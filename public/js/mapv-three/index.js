import { EventDispatcher } from "./EventDispatcher.js";
import { Texture } from "./Texture.js";
import { makeHeatmap3DClass } from "./Heatmap3D.js";
import { makeHeatmapClass } from "./Heatmap.js";
import {
  publicField,
  merge,
  clone,
  createElement,
  createCanvasEl,
} from "./utils/index.js";
import { Vector2, Vector3, Vector4 } from "./Vector.js";
import { Matrix3 } from "./Matrix.js";
import { Quaternion } from "./Quaternion.js";

import { Pe } from "./utils/other.js";
import { Source } from "./Source.js";
import { Material } from "./Material.js";
import { ShaderMaterial } from "./ShaderMaterial.js";
import { makeSimplePoint } from './SimplePoint.js'

import {
  r,
  a,
  o,
  l,
  h,
  c,
  u,
  d,
  p,
  f,
  m,
  g,
  _,
  v,
  A,
  y,
  x,
  b,
  E,
  S,
  C,
  M,
  w,
  T,
  I,
  R,
  P,
  D,
  L,
  F,
  N,
  B,
  k,
  O,
  U,
  z,
  G,
  V,
  Q,
  H,
  j,
  W,
  q,
  X,
  Y,
  K,
  Z,
  J,
  $,
  ee,
  te,
  ie,
  ne,
  se,
  re,
  ae,
  oe,
  le,
  he,
  ce,
  ue,
  de,
  pe,
  fe,
  me,
  ge,
  _e,
  ve,
  Ae,
  ye,
  xe,
  be,
  Ee,
  Se,
  Ce,
} from "./utils/other.js";

const t = "mapv";
var exports = {};

function i(e, t) {
  if (void 0 === e.className) e.className = t;
  else if (e.className !== t) {
    const i = e.className.split(/ +/);
    -1 === i.indexOf(t) &&
      (i.push(t),
      (e.className = i.join(" ").replace(/^\s+/, "").replace(/\s+$/, "")));
  }
  return e;
}

function n(e, t) {
  if (t)
    if (e.className === t) e.removeAttribute("class");
    else {
      const i = e.className.split(/ +/),
        n = i.indexOf(t);
      -1 !== n && (i.splice(n, 1), (e.className = i.join(" ")));
    }
  else e.className = void 0;
  return e;
}

const s = {};

let Te = 1234567;

const Ie = Math.PI / 180,
  Re = 180 / Math.PI;

function De(e, t, i) {
  return Math.max(t, Math.min(i, e));
}

function Le(e, t) {
  return ((e % t) + t) % t;
}

function Fe(e, t, i) {
  return (1 - i) * e + i * t;
}

function Ne(e) {
  return 0 == (e & (e - 1)) && 0 !== e;
}

function Be(e) {
  return Math.pow(2, Math.ceil(Math.log(e) / Math.LN2));
}

function ke(e) {
  return Math.pow(2, Math.floor(Math.log(e) / Math.LN2));
}

function Oe(e, t) {
  switch (t.constructor) {
    case Float32Array:
      return e;
    case Uint32Array:
      return e / 4294967295;
    case Uint16Array:
      return e / 65535;
    case Uint8Array:
      return e / 255;
    case Int32Array:
      return Math.max(e / 2147483647, -1);
    case Int16Array:
      return Math.max(e / 32767, -1);
    case Int8Array:
      return Math.max(e / 127, -1);
    default:
      throw new Error("Invalid component type.");
  }
}

function Ue(e, t) {
  switch (t.constructor) {
    case Float32Array:
      return e;
    case Uint32Array:
      return Math.round(4294967295 * e);
    case Uint16Array:
      return Math.round(65535 * e);
    case Uint8Array:
      return Math.round(255 * e);
    case Int32Array:
      return Math.round(2147483647 * e);
    case Int16Array:
      return Math.round(32767 * e);
    case Int8Array:
      return Math.round(127 * e);
    default:
      throw new Error("Invalid component type.");
  }
}

const ze = {
  DEG2RAD: Ie,
  RAD2DEG: Re,
  generateUUID: Pe,
  clamp: De,
  euclideanModulo: Le,
  mapLinear: function (e, t, i, n, s) {
    return n + ((e - t) * (s - n)) / (i - t);
  },
  inverseLerp: function (e, t, i) {
    return e !== t ? (i - e) / (t - e) : 0;
  },
  lerp: Fe,
  damp: function (e, t, i, n) {
    return Fe(e, t, 1 - Math.exp(-i * n));
  },
  pingpong: function (e, t = 1) {
    return t - Math.abs(Le(e, 2 * t) - t);
  },
  smoothstep: function (e, t, i) {
    return e <= t ? 0 : e >= i ? 1 : (e = (e - t) / (i - t)) * e * (3 - 2 * e);
  },
  smootherstep: function (e, t, i) {
    return e <= t
      ? 0
      : e >= i
      ? 1
      : (e = (e - t) / (i - t)) * e * e * (e * (6 * e - 15) + 10);
  },
  randInt: function (e, t) {
    return e + Math.floor(Math.random() * (t - e + 1));
  },
  randFloat: function (e, t) {
    return e + Math.random() * (t - e);
  },
  randFloatSpread: function (e) {
    return e * (0.5 - Math.random());
  },
  seededRandom: function (e) {
    void 0 !== e && (Te = e);
    let t = (Te += 1831565813);
    return (
      (t = Math.imul(t ^ (t >>> 15), 1 | t)),
      (t ^= t + Math.imul(t ^ (t >>> 7), 61 | t)),
      ((t ^ (t >>> 14)) >>> 0) / 4294967296
    );
  },
  degToRad: function (e) {
    return e * Ie;
  },
  radToDeg: function (e) {
    return e * Re;
  },
  isPowerOfTwo: Ne,
  ceilPowerOfTwo: Be,
  floorPowerOfTwo: ke,
  setQuaternionFromProperEuler: function (e, t, i, n, s) {
    const r = Math.cos,
      a = Math.sin,
      o = r(i / 2),
      l = a(i / 2),
      h = r((t + n) / 2),
      c = a((t + n) / 2),
      u = r((t - n) / 2),
      d = a((t - n) / 2),
      p = r((n - t) / 2),
      f = a((n - t) / 2);
    switch (s) {
      case "XYX":
        e.set(o * c, l * u, l * d, o * h);
        break;
      case "YZY":
        e.set(l * d, o * c, l * u, o * h);
        break;
      case "ZXZ":
        e.set(l * u, l * d, o * c, o * h);
        break;
      case "XZX":
        e.set(o * c, l * f, l * p, o * h);
        break;
      case "YXY":
        e.set(l * p, o * c, l * f, o * h);
        break;
      case "ZYZ":
        e.set(l * f, l * p, o * c, o * h);
        break;
      default:
        console.warn(
          "THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " +
            s
        );
    }
  },
  normalize: Ue,
  denormalize: Oe,
};

const Qe = new Matrix3();

function He(e) {
  for (let t = e.length - 1; t >= 0; --t) if (e[t] >= 65535) return !0;
  return !1;
}

const qe = {};
function Xe(e) {
  e in qe || ((qe[e] = !0), console.warn(e));
}

function Ye(e) {
  return e < 0.04045
    ? 0.0773993808 * e
    : Math.pow(0.9478672986 * e + 0.0521327014, 2.4);
}

function Ke(e) {
  return e < 0.0031308 ? 12.92 * e : 1.055 * Math.pow(e, 0.41666) - 0.055;
}
const Ze = new Matrix3().fromArray([
  0.8224621, 0.0331941, 0.0170827, 0.177538, 0.9668058, 0.0723974, -1e-7, 1e-7,
  0.9105199,
]);

const Je = new Matrix3().fromArray([
  1.2249401, -0.0420569, -0.0196376, -0.2249404, 1.0420571, -0.0786361, 1e-7, 0,
  1.0982735,
]);

const $e = {
  [ge]: (e) => e,
  [me]: (e) => e.convertSRGBToLinear(),
  [_e]: function (e) {
    return e.convertSRGBToLinear().applyMatrix3(Je);
  },
};
const et = {
  [ge]: (e) => e,
  [me]: (e) => e.convertLinearToSRGB(),
  [_e]: function (e) {
    return e.applyMatrix3(Ze).convertLinearToSRGB();
  },
};
const tt = {
  enabled: !0,
  get legacyMode() {
    return (
      console.warn(
        "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
      ),
      !this.enabled
    );
  },
  set legacyMode(e) {
    console.warn(
      "THREE.ColorManagement: .legacyMode=false renamed to .enabled=true in r150."
    ),
      (this.enabled = !e);
  },
  get workingColorSpace() {
    return ge;
  },
  set workingColorSpace(e) {
    console.warn("THREE.ColorManagement: .workingColorSpace is readonly.");
  },
  convert: function (e, t, i) {
    if (!1 === this.enabled || t === i || !t || !i) return e;
    const n = $e[t],
      s = et[i];
    if (void 0 === n || void 0 === s)
      throw new Error(`Unsupported color space conversion, "${t}" to "${i}".`);
    return s(n(e));
  },
  fromWorkingColorSpace: function (e, t) {
    return this.convert(e, this.workingColorSpace, t);
  },
  toWorkingColorSpace: function (e, t) {
    return this.convert(e, t, this.workingColorSpace);
  },
};
let it;

class nt {
  static getDataURL(e) {
    if (/^data:/i.test(e.src)) return e.src;
    if ("undefined" == typeof HTMLCanvasElement) return e.src;
    let t;
    if (e instanceof HTMLCanvasElement) t = e;
    else {
      void 0 === it && (it = createElement("canvas")),
        (it.width = e.width),
        (it.height = e.height);
      const i = it.getContext("2d");
      e instanceof ImageData
        ? i.putImageData(e, 0, 0)
        : i.drawImage(e, 0, 0, e.width, e.height),
        (t = it);
    }
    return t.width > 2048 || t.height > 2048
      ? (console.warn(
          "THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons",
          e
        ),
        t.toDataURL("image/jpeg", 0.6))
      : t.toDataURL("image/png");
  }
  static sRGBToLinear(e) {
    if (
      ("undefined" != typeof HTMLImageElement &&
        e instanceof HTMLImageElement) ||
      ("undefined" != typeof HTMLCanvasElement &&
        e instanceof HTMLCanvasElement) ||
      ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
    ) {
      const t = createElement("canvas");
      (t.width = e.width), (t.height = e.height);
      const i = t.getContext("2d");
      i.drawImage(e, 0, 0, e.width, e.height);
      const n = i.getImageData(0, 0, e.width, e.height),
        s = n.data;
      for (let e = 0; e < s.length; e++) s[e] = 255 * Ye(s[e] / 255);
      return i.putImageData(n, 0, 0), t;
    }
    if (e.data) {
      const t = e.data.slice(0);
      for (let e = 0; e < t.length; e++)
        t instanceof Uint8Array || t instanceof Uint8ClampedArray
          ? (t[e] = Math.floor(255 * Ye(t[e] / 255)))
          : (t[e] = Ye(t[e]));
      return { data: t, width: e.width, height: e.height };
    }
    return (
      console.warn(
        "THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."
      ),
      e
    );
  }
}

class RenderTarget extends EventDispatcher {
  constructor(e = 1, t = 1, i = {}) {
    super(),
      (this.isRenderTarget = !0),
      (this.width = e),
      (this.height = t),
      (this.depth = 1),
      (this.scissor = new Vector4(0, 0, e, t)),
      (this.scissorTest = !1),
      (this.viewport = new Vector4(0, 0, e, t));
    const n = { width: e, height: t, depth: 1 };
    void 0 !== i.encoding &&
      (Xe(
        "THREE.WebGLRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (i.colorSpace = i.encoding === pe ? me : fe)),
      (this.texture = new Texture(
        n,
        i.mapping,
        i.wrapS,
        i.wrapT,
        i.magFilter,
        i.minFilter,
        i.format,
        i.type,
        i.anisotropy,
        i.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.flipY = !1),
      (this.texture.generateMipmaps =
        void 0 !== i.generateMipmaps && i.generateMipmaps),
      (this.texture.internalFormat =
        void 0 !== i.internalFormat ? i.internalFormat : null),
      (this.texture.minFilter = void 0 !== i.minFilter ? i.minFilter : L),
      (this.depthBuffer = void 0 === i.depthBuffer || i.depthBuffer),
      (this.stencilBuffer = void 0 !== i.stencilBuffer && i.stencilBuffer),
      (this.depthTexture = void 0 !== i.depthTexture ? i.depthTexture : null),
      (this.samples = void 0 !== i.samples ? i.samples : 0);
  }
  setSize(e, t, i = 1) {
    (this.width === e && this.height === t && this.depth === i) ||
      ((this.width = e),
      (this.height = t),
      (this.depth = i),
      (this.texture.image.width = e),
      (this.texture.image.height = t),
      (this.texture.image.depth = i),
      this.dispose()),
      this.viewport.set(0, 0, e, t),
      this.scissor.set(0, 0, e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.texture = e.texture.clone()),
      (this.texture.isRenderTargetTexture = !0);
    const t = Object.assign({}, e.texture.image);
    return (
      (this.texture.source = new Source(t)),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
      (this.samples = e.samples),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class ut extends RenderTarget {
  constructor(e = 1, t = 1, i = {}) {
    super(e, t, i), (this.isWebGLRenderTarget = !0);
  }
}
class dt extends Texture {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null),
      (this.isDataArrayTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: n }),
      (this.magFilter = R),
      (this.minFilter = R),
      (this.wrapR = T),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class pt extends Texture {
  constructor(e = null, t = 1, i = 1, n = 1) {
    super(null),
      (this.isData3DTexture = !0),
      (this.image = { data: e, width: t, height: i, depth: n }),
      (this.magFilter = R),
      (this.minFilter = R),
      (this.wrapR = T),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
class ft extends ut {
  constructor(e = 1, t = 1, i = 1, n = {}) {
    super(e, t, n), (this.isWebGLMultipleRenderTargets = !0);
    const s = this.texture;
    this.texture = [];
    for (let r = 0; r < i; r++)
      (this.texture[r] = s.clone()),
        (this.texture[r].isRenderTargetTexture = !0);
  }
  setSize(e, t, i = 1) {
    if (this.width !== e || this.height !== t || this.depth !== i) {
      (this.width = e), (this.height = t), (this.depth = i);
      for (let n = 0, s = this.texture.length; n < s; n++)
        (this.texture[n].image.width = e),
          (this.texture[n].image.height = t),
          (this.texture[n].image.depth = i);
      this.dispose();
    }
    this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t);
  }
  copy(e) {
    this.dispose(),
      (this.width = e.width),
      (this.height = e.height),
      (this.depth = e.depth),
      this.scissor.copy(e.scissor),
      (this.scissorTest = e.scissorTest),
      this.viewport.copy(e.viewport),
      (this.depthBuffer = e.depthBuffer),
      (this.stencilBuffer = e.stencilBuffer),
      null !== e.depthTexture && (this.depthTexture = e.depthTexture.clone()),
      (this.texture.length = 0);
    for (let t = 0, i = e.texture.length; t < i; t++)
      (this.texture[t] = e.texture[t].clone()),
        (this.texture[t].isRenderTargetTexture = !0);
    return this;
  }
}

class Box3 {
  constructor(
    e = new Vector3(1 / 0, 1 / 0, 1 / 0),
    t = new Vector3(-1 / 0, -1 / 0, -1 / 0)
  ) {
    (this.isBox3 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromArray(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t += 3)
      this.expandByPoint(xt.fromArray(e, t));
    return this;
  }
  setFromBufferAttribute(e) {
    this.makeEmpty();
    for (let t = 0, i = e.count; t < i; t++)
      this.expandByPoint(xt.fromBufferAttribute(e, t));
    return this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = xt.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  setFromObject(e, t = !1) {
    return this.makeEmpty(), this.expandByObject(e, t);
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = this.min.z = 1 / 0),
      (this.max.x = this.max.y = this.max.z = -1 / 0),
      this
    );
  }
  isEmpty() {
    return (
      this.max.x < this.min.x ||
      this.max.y < this.min.y ||
      this.max.z < this.min.z
    );
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  expandByObject(e, t = !1) {
    if ((e.updateWorldMatrix(!1, !1), void 0 !== e.boundingBox))
      null === e.boundingBox && e.computeBoundingBox(),
        bt.copy(e.boundingBox),
        bt.applyMatrix4(e.matrixWorld),
        this.union(bt);
    else {
      const i = e.geometry;
      if (void 0 !== i)
        if (t && void 0 !== i.attributes && void 0 !== i.attributes.position) {
          const t = i.attributes.position;
          for (let i = 0, n = t.count; i < n; i++)
            xt.fromBufferAttribute(t, i).applyMatrix4(e.matrixWorld),
              this.expandByPoint(xt);
        } else
          null === i.boundingBox && i.computeBoundingBox(),
            bt.copy(i.boundingBox),
            bt.applyMatrix4(e.matrixWorld),
            this.union(bt);
    }
    const i = e.children;
    for (let n = 0, s = i.length; n < s; n++) this.expandByObject(i[n], t);
    return this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y ||
      e.z < this.min.z ||
      e.z > this.max.z
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y &&
      this.min.z <= e.min.z &&
      e.max.z <= this.max.z
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y),
      (e.z - this.min.z) / (this.max.z - this.min.z)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y ||
      e.max.z < this.min.z ||
      e.min.z > this.max.z
    );
  }
  intersectsSphere(e) {
    return (
      this.clampPoint(e.center, xt),
      xt.distanceToSquared(e.center) <= e.radius * e.radius
    );
  }
  intersectsPlane(e) {
    let t, i;
    return (
      e.normal.x > 0
        ? ((t = e.normal.x * this.min.x), (i = e.normal.x * this.max.x))
        : ((t = e.normal.x * this.max.x), (i = e.normal.x * this.min.x)),
      e.normal.y > 0
        ? ((t += e.normal.y * this.min.y), (i += e.normal.y * this.max.y))
        : ((t += e.normal.y * this.max.y), (i += e.normal.y * this.min.y)),
      e.normal.z > 0
        ? ((t += e.normal.z * this.min.z), (i += e.normal.z * this.max.z))
        : ((t += e.normal.z * this.max.z), (i += e.normal.z * this.min.z)),
      t <= -e.constant && i >= -e.constant
    );
  }
  intersectsTriangle(e) {
    if (this.isEmpty()) return !1;
    this.getCenter(It),
      Rt.subVectors(this.max, It),
      Et.subVectors(e.a, It),
      St.subVectors(e.b, It),
      Ct.subVectors(e.c, It),
      Mt.subVectors(St, Et),
      wt.subVectors(Ct, St),
      Tt.subVectors(Et, Ct);
    let t = [
      0,
      -Mt.z,
      Mt.y,
      0,
      -wt.z,
      wt.y,
      0,
      -Tt.z,
      Tt.y,
      Mt.z,
      0,
      -Mt.x,
      wt.z,
      0,
      -wt.x,
      Tt.z,
      0,
      -Tt.x,
      -Mt.y,
      Mt.x,
      0,
      -wt.y,
      wt.x,
      0,
      -Tt.y,
      Tt.x,
      0,
    ];
    return (
      !!Lt(t, Et, St, Ct, Rt) &&
      ((t = [1, 0, 0, 0, 1, 0, 0, 0, 1]),
      !!Lt(t, Et, St, Ct, Rt) &&
        (Pt.crossVectors(Mt, wt),
        (t = [Pt.x, Pt.y, Pt.z]),
        Lt(t, Et, St, Ct, Rt)))
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, xt).distanceTo(e);
  }
  getBoundingSphere(e) {
    return (
      this.isEmpty()
        ? e.makeEmpty()
        : (this.getCenter(e.center),
          (e.radius = 0.5 * this.getSize(xt).length())),
      e
    );
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  applyMatrix4(e) {
    return (
      this.isEmpty() ||
        (yt[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        yt[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        yt[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        yt[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        yt[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        yt[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        yt[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        yt[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(yt)),
      this
    );
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const yt = [
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
    new Vector3(),
  ],
  xt = new Vector3(),
  bt = new Box3(),
  Et = new Vector3(),
  St = new Vector3(),
  Ct = new Vector3(),
  Mt = new Vector3(),
  wt = new Vector3(),
  Tt = new Vector3(),
  It = new Vector3(),
  Rt = new Vector3(),
  Pt = new Vector3(),
  Dt = new Vector3();

function Lt(e, t, i, n, s) {
  for (let r = 0, a = e.length - 3; r <= a; r += 3) {
    Dt.fromArray(e, r);
    const a =
        s.x * Math.abs(Dt.x) + s.y * Math.abs(Dt.y) + s.z * Math.abs(Dt.z),
      o = t.dot(Dt),
      l = i.dot(Dt),
      h = n.dot(Dt);
    if (Math.max(-Math.max(o, l, h), Math.min(o, l, h)) > a) return !1;
  }
  return !0;
}

const Ft = new Box3(),
  Nt = new Vector3(),
  Bt = new Vector3();
class kt {
  constructor(e = new Vector3(), t = -1) {
    (this.center = e), (this.radius = t);
  }
  set(e, t) {
    return this.center.copy(e), (this.radius = t), this;
  }
  setFromPoints(e, t) {
    const i = this.center;
    void 0 !== t ? i.copy(t) : Ft.setFromPoints(e).getCenter(i);
    let n = 0;
    for (let s = 0, r = e.length; s < r; s++)
      n = Math.max(n, i.distanceToSquared(e[s]));
    return (this.radius = Math.sqrt(n)), this;
  }
  copy(e) {
    return this.center.copy(e.center), (this.radius = e.radius), this;
  }
  isEmpty() {
    return this.radius < 0;
  }
  makeEmpty() {
    return this.center.set(0, 0, 0), (this.radius = -1), this;
  }
  containsPoint(e) {
    return e.distanceToSquared(this.center) <= this.radius * this.radius;
  }
  distanceToPoint(e) {
    return e.distanceTo(this.center) - this.radius;
  }
  intersectsSphere(e) {
    const t = this.radius + e.radius;
    return e.center.distanceToSquared(this.center) <= t * t;
  }
  intersectsBox(e) {
    return e.intersectsSphere(this);
  }
  intersectsPlane(e) {
    return Math.abs(e.distanceToPoint(this.center)) <= this.radius;
  }
  clampPoint(e, t) {
    const i = this.center.distanceToSquared(e);
    return (
      t.copy(e),
      i > this.radius * this.radius &&
        (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
      t
    );
  }
  getBoundingBox(e) {
    return this.isEmpty()
      ? (e.makeEmpty(), e)
      : (e.set(this.center, this.center), e.expandByScalar(this.radius), e);
  }
  applyMatrix4(e) {
    return (
      this.center.applyMatrix4(e),
      (this.radius = this.radius * e.getMaxScaleOnAxis()),
      this
    );
  }
  translate(e) {
    return this.center.add(e), this;
  }
  expandByPoint(e) {
    if (this.isEmpty()) return this.center.copy(e), (this.radius = 0), this;
    Nt.subVectors(e, this.center);
    const t = Nt.lengthSq();
    if (t > this.radius * this.radius) {
      const e = Math.sqrt(t),
        i = 0.5 * (e - this.radius);
      this.center.addScaledVector(Nt, i / e), (this.radius += i);
    }
    return this;
  }
  union(e) {
    return e.isEmpty()
      ? this
      : this.isEmpty()
      ? (this.copy(e), this)
      : (!0 === this.center.equals(e.center)
          ? (this.radius = Math.max(this.radius, e.radius))
          : (Bt.subVectors(e.center, this.center).setLength(e.radius),
            this.expandByPoint(Nt.copy(e.center).add(Bt)),
            this.expandByPoint(Nt.copy(e.center).sub(Bt))),
        this);
  }
  equals(e) {
    return e.center.equals(this.center) && e.radius === this.radius;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Ot = new Vector3(),
  Ut = new Vector3(),
  zt = new Vector3(),
  Gt = new Vector3(),
  Vt = new Vector3(),
  Qt = new Vector3(),
  Ht = new Vector3();
class jt {
  constructor(e = new Vector3(), t = new Vector3(0, 0, -1)) {
    (this.origin = e), (this.direction = t);
  }
  set(e, t) {
    return this.origin.copy(e), this.direction.copy(t), this;
  }
  copy(e) {
    return this.origin.copy(e.origin), this.direction.copy(e.direction), this;
  }
  at(e, t) {
    return t.copy(this.origin).addScaledVector(this.direction, e);
  }
  lookAt(e) {
    return this.direction.copy(e).sub(this.origin).normalize(), this;
  }
  recast(e) {
    return this.origin.copy(this.at(e, Ot)), this;
  }
  closestPointToPoint(e, t) {
    t.subVectors(e, this.origin);
    const i = t.dot(this.direction);
    return i < 0
      ? t.copy(this.origin)
      : t.copy(this.origin).addScaledVector(this.direction, i);
  }
  distanceToPoint(e) {
    return Math.sqrt(this.distanceSqToPoint(e));
  }
  distanceSqToPoint(e) {
    const t = Ot.subVectors(e, this.origin).dot(this.direction);
    return t < 0
      ? this.origin.distanceToSquared(e)
      : (Ot.copy(this.origin).addScaledVector(this.direction, t),
        Ot.distanceToSquared(e));
  }
  distanceSqToSegment(e, t, i, n) {
    Ut.copy(e).add(t).multiplyScalar(0.5),
      zt.copy(t).sub(e).normalize(),
      Gt.copy(this.origin).sub(Ut);
    const s = 0.5 * e.distanceTo(t),
      r = -this.direction.dot(zt),
      a = Gt.dot(this.direction),
      o = -Gt.dot(zt),
      l = Gt.lengthSq(),
      h = Math.abs(1 - r * r);
    let c, u, d, p;
    if (h > 0)
      if (((c = r * o - a), (u = r * a - o), (p = s * h), c >= 0))
        if (u >= -p)
          if (u <= p) {
            const e = 1 / h;
            (c *= e),
              (u *= e),
              (d = c * (c + r * u + 2 * a) + u * (r * c + u + 2 * o) + l);
          } else
            (u = s),
              (c = Math.max(0, -(r * u + a))),
              (d = -c * c + u * (u + 2 * o) + l);
        else
          (u = -s),
            (c = Math.max(0, -(r * u + a))),
            (d = -c * c + u * (u + 2 * o) + l);
      else
        u <= -p
          ? ((c = Math.max(0, -(-r * s + a))),
            (u = c > 0 ? -s : Math.min(Math.max(-s, -o), s)),
            (d = -c * c + u * (u + 2 * o) + l))
          : u <= p
          ? ((c = 0),
            (u = Math.min(Math.max(-s, -o), s)),
            (d = u * (u + 2 * o) + l))
          : ((c = Math.max(0, -(r * s + a))),
            (u = c > 0 ? s : Math.min(Math.max(-s, -o), s)),
            (d = -c * c + u * (u + 2 * o) + l));
    else
      (u = r > 0 ? -s : s),
        (c = Math.max(0, -(r * u + a))),
        (d = -c * c + u * (u + 2 * o) + l);
    return (
      i && i.copy(this.origin).addScaledVector(this.direction, c),
      n && n.copy(Ut).addScaledVector(zt, u),
      d
    );
  }
  intersectSphere(e, t) {
    Ot.subVectors(e.center, this.origin);
    const i = Ot.dot(this.direction),
      n = Ot.dot(Ot) - i * i,
      s = e.radius * e.radius;
    if (n > s) return null;
    const r = Math.sqrt(s - n),
      a = i - r,
      o = i + r;
    return o < 0 ? null : a < 0 ? this.at(o, t) : this.at(a, t);
  }
  intersectsSphere(e) {
    return this.distanceSqToPoint(e.center) <= e.radius * e.radius;
  }
  distanceToPlane(e) {
    const t = e.normal.dot(this.direction);
    if (0 === t) return 0 === e.distanceToPoint(this.origin) ? 0 : null;
    const i = -(this.origin.dot(e.normal) + e.constant) / t;
    return i >= 0 ? i : null;
  }
  intersectPlane(e, t) {
    const i = this.distanceToPlane(e);
    return null === i ? null : this.at(i, t);
  }
  intersectsPlane(e) {
    const t = e.distanceToPoint(this.origin);
    if (0 === t) return !0;
    return e.normal.dot(this.direction) * t < 0;
  }
  intersectBox(e, t) {
    let i, n, s, r, a, o;
    const l = 1 / this.direction.x,
      h = 1 / this.direction.y,
      c = 1 / this.direction.z,
      u = this.origin;
    return (
      l >= 0
        ? ((i = (e.min.x - u.x) * l), (n = (e.max.x - u.x) * l))
        : ((i = (e.max.x - u.x) * l), (n = (e.min.x - u.x) * l)),
      h >= 0
        ? ((s = (e.min.y - u.y) * h), (r = (e.max.y - u.y) * h))
        : ((s = (e.max.y - u.y) * h), (r = (e.min.y - u.y) * h)),
      i > r || s > n
        ? null
        : ((s > i || isNaN(i)) && (i = s),
          (r < n || isNaN(n)) && (n = r),
          c >= 0
            ? ((a = (e.min.z - u.z) * c), (o = (e.max.z - u.z) * c))
            : ((a = (e.max.z - u.z) * c), (o = (e.min.z - u.z) * c)),
          i > o || a > n
            ? null
            : ((a > i || i != i) && (i = a),
              (o < n || n != n) && (n = o),
              n < 0 ? null : this.at(i >= 0 ? i : n, t)))
    );
  }
  intersectsBox(e) {
    return null !== this.intersectBox(e, Ot);
  }
  intersectTriangle(e, t, i, n, s) {
    Vt.subVectors(t, e), Qt.subVectors(i, e), Ht.crossVectors(Vt, Qt);
    let r,
      a = this.direction.dot(Ht);
    if (a > 0) {
      if (n) return null;
      r = 1;
    } else {
      if (!(a < 0)) return null;
      (r = -1), (a = -a);
    }
    Gt.subVectors(this.origin, e);
    const o = r * this.direction.dot(Qt.crossVectors(Gt, Qt));
    if (o < 0) return null;
    const l = r * this.direction.dot(Vt.cross(Gt));
    if (l < 0) return null;
    if (o + l > a) return null;
    const h = -r * Gt.dot(Ht);
    return h < 0 ? null : this.at(h / a, s);
  }
  applyMatrix4(e) {
    return (
      this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    );
  }
  equals(e) {
    return e.origin.equals(this.origin) && e.direction.equals(this.direction);
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Matrix4 {
  constructor(e, t, i, n, s, r, a, o, l, h, c, u, d, p, f, m) {
    (Matrix4.prototype.isMatrix4 = !0),
      (this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]),
      void 0 !== e && this.set(e, t, i, n, s, r, a, o, l, h, c, u, d, p, f, m);
  }
  set(e, t, i, n, s, r, a, o, l, h, c, u, d, p, f, m) {
    const g = this.elements;
    return (
      (g[0] = e),
      (g[4] = t),
      (g[8] = i),
      (g[12] = n),
      (g[1] = s),
      (g[5] = r),
      (g[9] = a),
      (g[13] = o),
      (g[2] = l),
      (g[6] = h),
      (g[10] = c),
      (g[14] = u),
      (g[3] = d),
      (g[7] = p),
      (g[11] = f),
      (g[15] = m),
      this
    );
  }
  identity() {
    return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  clone() {
    return new Matrix4().fromArray(this.elements);
  }
  copy(e) {
    const t = this.elements,
      i = e.elements;
    return (
      (t[0] = i[0]),
      (t[1] = i[1]),
      (t[2] = i[2]),
      (t[3] = i[3]),
      (t[4] = i[4]),
      (t[5] = i[5]),
      (t[6] = i[6]),
      (t[7] = i[7]),
      (t[8] = i[8]),
      (t[9] = i[9]),
      (t[10] = i[10]),
      (t[11] = i[11]),
      (t[12] = i[12]),
      (t[13] = i[13]),
      (t[14] = i[14]),
      (t[15] = i[15]),
      this
    );
  }
  copyPosition(e) {
    const t = this.elements,
      i = e.elements;
    return (t[12] = i[12]), (t[13] = i[13]), (t[14] = i[14]), this;
  }
  setFromMatrix3(e) {
    const t = e.elements;
    return (
      this.set(
        t[0],
        t[3],
        t[6],
        0,
        t[1],
        t[4],
        t[7],
        0,
        t[2],
        t[5],
        t[8],
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractBasis(e, t, i) {
    return (
      e.setFromMatrixColumn(this, 0),
      t.setFromMatrixColumn(this, 1),
      i.setFromMatrixColumn(this, 2),
      this
    );
  }
  makeBasis(e, t, i) {
    return (
      this.set(
        e.x,
        t.x,
        i.x,
        0,
        e.y,
        t.y,
        i.y,
        0,
        e.z,
        t.z,
        i.z,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  extractRotation(e) {
    const t = this.elements,
      i = e.elements,
      n = 1 / qt.setFromMatrixColumn(e, 0).length(),
      s = 1 / qt.setFromMatrixColumn(e, 1).length(),
      r = 1 / qt.setFromMatrixColumn(e, 2).length();
    return (
      (t[0] = i[0] * n),
      (t[1] = i[1] * n),
      (t[2] = i[2] * n),
      (t[3] = 0),
      (t[4] = i[4] * s),
      (t[5] = i[5] * s),
      (t[6] = i[6] * s),
      (t[7] = 0),
      (t[8] = i[8] * r),
      (t[9] = i[9] * r),
      (t[10] = i[10] * r),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromEuler(e) {
    const t = this.elements,
      i = e.x,
      n = e.y,
      s = e.z,
      r = Math.cos(i),
      a = Math.sin(i),
      o = Math.cos(n),
      l = Math.sin(n),
      h = Math.cos(s),
      c = Math.sin(s);
    if ("XYZ" === e.order) {
      const e = r * h,
        i = r * c,
        n = a * h,
        s = a * c;
      (t[0] = o * h),
        (t[4] = -o * c),
        (t[8] = l),
        (t[1] = i + n * l),
        (t[5] = e - s * l),
        (t[9] = -a * o),
        (t[2] = s - e * l),
        (t[6] = n + i * l),
        (t[10] = r * o);
    } else if ("YXZ" === e.order) {
      const e = o * h,
        i = o * c,
        n = l * h,
        s = l * c;
      (t[0] = e + s * a),
        (t[4] = n * a - i),
        (t[8] = r * l),
        (t[1] = r * c),
        (t[5] = r * h),
        (t[9] = -a),
        (t[2] = i * a - n),
        (t[6] = s + e * a),
        (t[10] = r * o);
    } else if ("ZXY" === e.order) {
      const e = o * h,
        i = o * c,
        n = l * h,
        s = l * c;
      (t[0] = e - s * a),
        (t[4] = -r * c),
        (t[8] = n + i * a),
        (t[1] = i + n * a),
        (t[5] = r * h),
        (t[9] = s - e * a),
        (t[2] = -r * l),
        (t[6] = a),
        (t[10] = r * o);
    } else if ("ZYX" === e.order) {
      const e = r * h,
        i = r * c,
        n = a * h,
        s = a * c;
      (t[0] = o * h),
        (t[4] = n * l - i),
        (t[8] = e * l + s),
        (t[1] = o * c),
        (t[5] = s * l + e),
        (t[9] = i * l - n),
        (t[2] = -l),
        (t[6] = a * o),
        (t[10] = r * o);
    } else if ("YZX" === e.order) {
      const e = r * o,
        i = r * l,
        n = a * o,
        s = a * l;
      (t[0] = o * h),
        (t[4] = s - e * c),
        (t[8] = n * c + i),
        (t[1] = c),
        (t[5] = r * h),
        (t[9] = -a * h),
        (t[2] = -l * h),
        (t[6] = i * c + n),
        (t[10] = e - s * c);
    } else if ("XZY" === e.order) {
      const e = r * o,
        i = r * l,
        n = a * o,
        s = a * l;
      (t[0] = o * h),
        (t[4] = -c),
        (t[8] = l * h),
        (t[1] = e * c + s),
        (t[5] = r * h),
        (t[9] = i * c - n),
        (t[2] = n * c - i),
        (t[6] = a * h),
        (t[10] = s * c + e);
    }
    return (
      (t[3] = 0),
      (t[7] = 0),
      (t[11] = 0),
      (t[12] = 0),
      (t[13] = 0),
      (t[14] = 0),
      (t[15] = 1),
      this
    );
  }
  makeRotationFromQuaternion(e) {
    return this.compose(Yt, e, Kt);
  }
  lookAt(e, t, i) {
    const n = this.elements;
    return (
      $t.subVectors(e, t),
      0 === $t.lengthSq() && ($t.z = 1),
      $t.normalize(),
      Zt.crossVectors(i, $t),
      0 === Zt.lengthSq() &&
        (1 === Math.abs(i.z) ? ($t.x += 1e-4) : ($t.z += 1e-4),
        $t.normalize(),
        Zt.crossVectors(i, $t)),
      Zt.normalize(),
      Jt.crossVectors($t, Zt),
      (n[0] = Zt.x),
      (n[4] = Jt.x),
      (n[8] = $t.x),
      (n[1] = Zt.y),
      (n[5] = Jt.y),
      (n[9] = $t.y),
      (n[2] = Zt.z),
      (n[6] = Jt.z),
      (n[10] = $t.z),
      this
    );
  }
  multiply(e) {
    return this.multiplyMatrices(this, e);
  }
  premultiply(e) {
    return this.multiplyMatrices(e, this);
  }
  multiplyMatrices(e, t) {
    const i = e.elements,
      n = t.elements,
      s = this.elements,
      r = i[0],
      a = i[4],
      o = i[8],
      l = i[12],
      h = i[1],
      c = i[5],
      u = i[9],
      d = i[13],
      p = i[2],
      f = i[6],
      m = i[10],
      g = i[14],
      _ = i[3],
      v = i[7],
      A = i[11],
      y = i[15],
      x = n[0],
      b = n[4],
      E = n[8],
      S = n[12],
      C = n[1],
      M = n[5],
      w = n[9],
      T = n[13],
      I = n[2],
      R = n[6],
      P = n[10],
      D = n[14],
      L = n[3],
      F = n[7],
      N = n[11],
      B = n[15];
    return (
      (s[0] = r * x + a * C + o * I + l * L),
      (s[4] = r * b + a * M + o * R + l * F),
      (s[8] = r * E + a * w + o * P + l * N),
      (s[12] = r * S + a * T + o * D + l * B),
      (s[1] = h * x + c * C + u * I + d * L),
      (s[5] = h * b + c * M + u * R + d * F),
      (s[9] = h * E + c * w + u * P + d * N),
      (s[13] = h * S + c * T + u * D + d * B),
      (s[2] = p * x + f * C + m * I + g * L),
      (s[6] = p * b + f * M + m * R + g * F),
      (s[10] = p * E + f * w + m * P + g * N),
      (s[14] = p * S + f * T + m * D + g * B),
      (s[3] = _ * x + v * C + A * I + y * L),
      (s[7] = _ * b + v * M + A * R + y * F),
      (s[11] = _ * E + v * w + A * P + y * N),
      (s[15] = _ * S + v * T + A * D + y * B),
      this
    );
  }
  multiplyScalar(e) {
    const t = this.elements;
    return (
      (t[0] *= e),
      (t[4] *= e),
      (t[8] *= e),
      (t[12] *= e),
      (t[1] *= e),
      (t[5] *= e),
      (t[9] *= e),
      (t[13] *= e),
      (t[2] *= e),
      (t[6] *= e),
      (t[10] *= e),
      (t[14] *= e),
      (t[3] *= e),
      (t[7] *= e),
      (t[11] *= e),
      (t[15] *= e),
      this
    );
  }
  determinant() {
    const e = this.elements,
      t = e[0],
      i = e[4],
      n = e[8],
      s = e[12],
      r = e[1],
      a = e[5],
      o = e[9],
      l = e[13],
      h = e[2],
      c = e[6],
      u = e[10],
      d = e[14];
    return (
      e[3] *
        (+s * o * c -
          n * l * c -
          s * a * u +
          i * l * u +
          n * a * d -
          i * o * d) +
      e[7] *
        (+t * o * d -
          t * l * u +
          s * r * u -
          n * r * d +
          n * l * h -
          s * o * h) +
      e[11] *
        (+t * l * c -
          t * a * d -
          s * r * c +
          i * r * d +
          s * a * h -
          i * l * h) +
      e[15] *
        (-n * a * h - t * o * c + t * a * u + n * r * c - i * r * u + i * o * h)
    );
  }
  transpose() {
    const e = this.elements;
    let t;
    return (
      (t = e[1]),
      (e[1] = e[4]),
      (e[4] = t),
      (t = e[2]),
      (e[2] = e[8]),
      (e[8] = t),
      (t = e[6]),
      (e[6] = e[9]),
      (e[9] = t),
      (t = e[3]),
      (e[3] = e[12]),
      (e[12] = t),
      (t = e[7]),
      (e[7] = e[13]),
      (e[13] = t),
      (t = e[11]),
      (e[11] = e[14]),
      (e[14] = t),
      this
    );
  }
  setPosition(e, t, i) {
    const n = this.elements;
    return (
      e.isVector3
        ? ((n[12] = e.x), (n[13] = e.y), (n[14] = e.z))
        : ((n[12] = e), (n[13] = t), (n[14] = i)),
      this
    );
  }
  invert() {
    const e = this.elements,
      t = e[0],
      i = e[1],
      n = e[2],
      s = e[3],
      r = e[4],
      a = e[5],
      o = e[6],
      l = e[7],
      h = e[8],
      c = e[9],
      u = e[10],
      d = e[11],
      p = e[12],
      f = e[13],
      m = e[14],
      g = e[15],
      _ = c * m * l - f * u * l + f * o * d - a * m * d - c * o * g + a * u * g,
      v = p * u * l - h * m * l - p * o * d + r * m * d + h * o * g - r * u * g,
      A = h * f * l - p * c * l + p * a * d - r * f * d - h * a * g + r * c * g,
      y = p * c * o - h * f * o - p * a * u + r * f * u + h * a * m - r * c * m,
      x = t * _ + i * v + n * A + s * y;
    if (0 === x)
      return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
    const b = 1 / x;
    return (
      (e[0] = _ * b),
      (e[1] =
        (f * u * s -
          c * m * s -
          f * n * d +
          i * m * d +
          c * n * g -
          i * u * g) *
        b),
      (e[2] =
        (a * m * s -
          f * o * s +
          f * n * l -
          i * m * l -
          a * n * g +
          i * o * g) *
        b),
      (e[3] =
        (c * o * s -
          a * u * s -
          c * n * l +
          i * u * l +
          a * n * d -
          i * o * d) *
        b),
      (e[4] = v * b),
      (e[5] =
        (h * m * s -
          p * u * s +
          p * n * d -
          t * m * d -
          h * n * g +
          t * u * g) *
        b),
      (e[6] =
        (p * o * s -
          r * m * s -
          p * n * l +
          t * m * l +
          r * n * g -
          t * o * g) *
        b),
      (e[7] =
        (r * u * s -
          h * o * s +
          h * n * l -
          t * u * l -
          r * n * d +
          t * o * d) *
        b),
      (e[8] = A * b),
      (e[9] =
        (p * c * s -
          h * f * s -
          p * i * d +
          t * f * d +
          h * i * g -
          t * c * g) *
        b),
      (e[10] =
        (r * f * s -
          p * a * s +
          p * i * l -
          t * f * l -
          r * i * g +
          t * a * g) *
        b),
      (e[11] =
        (h * a * s -
          r * c * s -
          h * i * l +
          t * c * l +
          r * i * d -
          t * a * d) *
        b),
      (e[12] = y * b),
      (e[13] =
        (h * f * n -
          p * c * n +
          p * i * u -
          t * f * u -
          h * i * m +
          t * c * m) *
        b),
      (e[14] =
        (p * a * n -
          r * f * n -
          p * i * o +
          t * f * o +
          r * i * m -
          t * a * m) *
        b),
      (e[15] =
        (r * c * n -
          h * a * n +
          h * i * o -
          t * c * o -
          r * i * u +
          t * a * u) *
        b),
      this
    );
  }
  scale(e) {
    const t = this.elements,
      i = e.x,
      n = e.y,
      s = e.z;
    return (
      (t[0] *= i),
      (t[4] *= n),
      (t[8] *= s),
      (t[1] *= i),
      (t[5] *= n),
      (t[9] *= s),
      (t[2] *= i),
      (t[6] *= n),
      (t[10] *= s),
      (t[3] *= i),
      (t[7] *= n),
      (t[11] *= s),
      this
    );
  }
  getMaxScaleOnAxis() {
    const e = this.elements,
      t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
      i = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
      n = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
    return Math.sqrt(Math.max(t, i, n));
  }
  makeTranslation(e, t, i) {
    return (
      e.isVector3
        ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1)
        : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, i, 0, 0, 0, 1),
      this
    );
  }
  makeRotationX(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(1, 0, 0, 0, 0, t, -i, 0, 0, i, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationY(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, 0, i, 0, 0, 1, 0, 0, -i, 0, t, 0, 0, 0, 0, 1), this;
  }
  makeRotationZ(e) {
    const t = Math.cos(e),
      i = Math.sin(e);
    return this.set(t, -i, 0, 0, i, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this;
  }
  makeRotationAxis(e, t) {
    const i = Math.cos(t),
      n = Math.sin(t),
      s = 1 - i,
      r = e.x,
      a = e.y,
      o = e.z,
      l = s * r,
      h = s * a;
    return (
      this.set(
        l * r + i,
        l * a - n * o,
        l * o + n * a,
        0,
        l * a + n * o,
        h * a + i,
        h * o - n * r,
        0,
        l * o - n * a,
        h * o + n * r,
        s * o * o + i,
        0,
        0,
        0,
        0,
        1
      ),
      this
    );
  }
  makeScale(e, t, i) {
    return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, i, 0, 0, 0, 0, 1), this;
  }
  makeShear(e, t, i, n, s, r) {
    return this.set(1, i, s, 0, e, 1, r, 0, t, n, 1, 0, 0, 0, 0, 1), this;
  }
  compose(e, t, i) {
    const n = this.elements,
      s = t._x,
      r = t._y,
      a = t._z,
      o = t._w,
      l = s + s,
      h = r + r,
      c = a + a,
      u = s * l,
      d = s * h,
      p = s * c,
      f = r * h,
      m = r * c,
      g = a * c,
      _ = o * l,
      v = o * h,
      A = o * c,
      y = i.x,
      x = i.y,
      b = i.z;
    return (
      (n[0] = (1 - (f + g)) * y),
      (n[1] = (d + A) * y),
      (n[2] = (p - v) * y),
      (n[3] = 0),
      (n[4] = (d - A) * x),
      (n[5] = (1 - (u + g)) * x),
      (n[6] = (m + _) * x),
      (n[7] = 0),
      (n[8] = (p + v) * b),
      (n[9] = (m - _) * b),
      (n[10] = (1 - (u + f)) * b),
      (n[11] = 0),
      (n[12] = e.x),
      (n[13] = e.y),
      (n[14] = e.z),
      (n[15] = 1),
      this
    );
  }
  decompose(e, t, i) {
    const n = this.elements;
    let s = qt.set(n[0], n[1], n[2]).length();
    const r = qt.set(n[4], n[5], n[6]).length(),
      a = qt.set(n[8], n[9], n[10]).length();
    this.determinant() < 0 && (s = -s),
      (e.x = n[12]),
      (e.y = n[13]),
      (e.z = n[14]),
      Xt.copy(this);
    const o = 1 / s,
      l = 1 / r,
      h = 1 / a;
    return (
      (Xt.elements[0] *= o),
      (Xt.elements[1] *= o),
      (Xt.elements[2] *= o),
      (Xt.elements[4] *= l),
      (Xt.elements[5] *= l),
      (Xt.elements[6] *= l),
      (Xt.elements[8] *= h),
      (Xt.elements[9] *= h),
      (Xt.elements[10] *= h),
      t.setFromRotationMatrix(Xt),
      (i.x = s),
      (i.y = r),
      (i.z = a),
      this
    );
  }
  makePerspective(e, t, i, n, s, r, a = 2e3) {
    const o = this.elements,
      l = (2 * s) / (t - e),
      h = (2 * s) / (i - n),
      c = (t + e) / (t - e),
      u = (i + n) / (i - n);
    let d, p;
    if (a === Se) (d = -(r + s) / (r - s)), (p = (-2 * r * s) / (r - s));
    else {
      if (a !== Ce)
        throw new Error(
          "THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a
        );
      (d = -r / (r - s)), (p = (-r * s) / (r - s));
    }
    return (
      (o[0] = l),
      (o[4] = 0),
      (o[8] = c),
      (o[12] = 0),
      (o[1] = 0),
      (o[5] = h),
      (o[9] = u),
      (o[13] = 0),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = d),
      (o[14] = p),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = -1),
      (o[15] = 0),
      this
    );
  }
  makeOrthographic(e, t, i, n, s, r, a = 2e3) {
    const o = this.elements,
      l = 1 / (t - e),
      h = 1 / (i - n),
      c = 1 / (r - s),
      u = (t + e) * l,
      d = (i + n) * h;
    let p, f;
    if (a === Se) (p = (r + s) * c), (f = -2 * c);
    else {
      if (a !== Ce)
        throw new Error(
          "THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a
        );
      (p = s * c), (f = -1 * c);
    }
    return (
      (o[0] = 2 * l),
      (o[4] = 0),
      (o[8] = 0),
      (o[12] = -u),
      (o[1] = 0),
      (o[5] = 2 * h),
      (o[9] = 0),
      (o[13] = -d),
      (o[2] = 0),
      (o[6] = 0),
      (o[10] = f),
      (o[14] = -p),
      (o[3] = 0),
      (o[7] = 0),
      (o[11] = 0),
      (o[15] = 1),
      this
    );
  }
  equals(e) {
    const t = this.elements,
      i = e.elements;
    for (let n = 0; n < 16; n++) if (t[n] !== i[n]) return !1;
    return !0;
  }
  fromArray(e, t = 0) {
    for (let i = 0; i < 16; i++) this.elements[i] = e[i + t];
    return this;
  }
  toArray(e = [], t = 0) {
    const i = this.elements;
    return (
      (e[t] = i[0]),
      (e[t + 1] = i[1]),
      (e[t + 2] = i[2]),
      (e[t + 3] = i[3]),
      (e[t + 4] = i[4]),
      (e[t + 5] = i[5]),
      (e[t + 6] = i[6]),
      (e[t + 7] = i[7]),
      (e[t + 8] = i[8]),
      (e[t + 9] = i[9]),
      (e[t + 10] = i[10]),
      (e[t + 11] = i[11]),
      (e[t + 12] = i[12]),
      (e[t + 13] = i[13]),
      (e[t + 14] = i[14]),
      (e[t + 15] = i[15]),
      e
    );
  }
}
const qt = new Vector3(),
  Xt = new Matrix4(),
  Yt = new Vector3(0, 0, 0),
  Kt = new Vector3(1, 1, 1),
  Zt = new Vector3(),
  Jt = new Vector3(),
  $t = new Vector3(),
  ei = new Matrix4(),
  ti = new Quaternion();
class ii {
  constructor(e = 0, t = 0, i = 0, n = ii.DEFAULT_ORDER) {
    (this.isEuler = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = n);
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get order() {
    return this._order;
  }
  set order(e) {
    (this._order = e), this._onChangeCallback();
  }
  set(e, t, i, n = this._order) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._order = n),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._order);
  }
  copy(e) {
    return (
      (this._x = e._x),
      (this._y = e._y),
      (this._z = e._z),
      (this._order = e._order),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e, t = this._order, i = !0) {
    const n = e.elements,
      s = n[0],
      r = n[4],
      a = n[8],
      o = n[1],
      l = n[5],
      h = n[9],
      c = n[2],
      u = n[6],
      d = n[10];
    switch (t) {
      case "XYZ":
        (this._y = Math.asin(De(a, -1, 1))),
          Math.abs(a) < 0.9999999
            ? ((this._x = Math.atan2(-h, d)), (this._z = Math.atan2(-r, s)))
            : ((this._x = Math.atan2(u, l)), (this._z = 0));
        break;
      case "YXZ":
        (this._x = Math.asin(-De(h, -1, 1))),
          Math.abs(h) < 0.9999999
            ? ((this._y = Math.atan2(a, d)), (this._z = Math.atan2(o, l)))
            : ((this._y = Math.atan2(-c, s)), (this._z = 0));
        break;
      case "ZXY":
        (this._x = Math.asin(De(u, -1, 1))),
          Math.abs(u) < 0.9999999
            ? ((this._y = Math.atan2(-c, d)), (this._z = Math.atan2(-r, l)))
            : ((this._y = 0), (this._z = Math.atan2(o, s)));
        break;
      case "ZYX":
        (this._y = Math.asin(-De(c, -1, 1))),
          Math.abs(c) < 0.9999999
            ? ((this._x = Math.atan2(u, d)), (this._z = Math.atan2(o, s)))
            : ((this._x = 0), (this._z = Math.atan2(-r, l)));
        break;
      case "YZX":
        (this._z = Math.asin(De(o, -1, 1))),
          Math.abs(o) < 0.9999999
            ? ((this._x = Math.atan2(-h, l)), (this._y = Math.atan2(-c, s)))
            : ((this._x = 0), (this._y = Math.atan2(a, d)));
        break;
      case "XZY":
        (this._z = Math.asin(-De(r, -1, 1))),
          Math.abs(r) < 0.9999999
            ? ((this._x = Math.atan2(u, l)), (this._y = Math.atan2(a, s)))
            : ((this._x = Math.atan2(-h, d)), (this._y = 0));
        break;
      default:
        console.warn(
          "THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " +
            t
        );
    }
    return (this._order = t), !0 === i && this._onChangeCallback(), this;
  }
  setFromQuaternion(e, t, i) {
    return (
      ei.makeRotationFromQuaternion(e), this.setFromRotationMatrix(ei, t, i)
    );
  }
  setFromVector3(e, t = this._order) {
    return this.set(e.x, e.y, e.z, t);
  }
  reorder(e) {
    return ti.setFromEuler(this), this.setFromQuaternion(ti, e);
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._order === this._order
    );
  }
  fromArray(e) {
    return (
      (this._x = e[0]),
      (this._y = e[1]),
      (this._z = e[2]),
      void 0 !== e[3] && (this._order = e[3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._order),
      e
    );
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._order;
  }
}
ii.DEFAULT_ORDER = "XYZ";
class ni {
  constructor() {
    this.mask = 1;
  }
  set(e) {
    this.mask = ((1 << e) | 0) >>> 0;
  }
  enable(e) {
    this.mask |= (1 << e) | 0;
  }
  enableAll() {
    this.mask = -1;
  }
  toggle(e) {
    this.mask ^= (1 << e) | 0;
  }
  disable(e) {
    this.mask &= ~((1 << e) | 0);
  }
  disableAll() {
    this.mask = 0;
  }
  test(e) {
    return 0 != (this.mask & e.mask);
  }
  isEnabled(e) {
    return 0 != (this.mask & ((1 << e) | 0));
  }
}
let si = 0;
const ri = new Vector3(),
  ai = new Quaternion(),
  oi = new Matrix4(),
  li = new Vector3(),
  hi = new Vector3(),
  ci = new Vector3(),
  ui = new Quaternion(),
  di = new Vector3(1, 0, 0),
  pi = new Vector3(0, 1, 0),
  fi = new Vector3(0, 0, 1),
  mi = { type: "added" },
  gi = { type: "removed" };

class Object3D extends EventDispatcher {
  constructor() {
    super(),
      (this.isObject3D = !0),
      Object.defineProperty(this, "id", { value: si++ }),
      (this.uuid = Pe()),
      (this.name = ""),
      (this.type = "Object3D"),
      (this.parent = null),
      (this.children = []),
      (this.up = Object3D.DEFAULT_UP.clone());
    const e = new Vector3(),
      t = new ii(),
      i = new Quaternion(),
      n = new Vector3(1, 1, 1);
    t._onChange(function () {
      i.setFromEuler(t, !1);
    }),
      i._onChange(function () {
        t.setFromQuaternion(i, void 0, !1);
      }),
      Object.defineProperties(this, {
        position: { configurable: !0, enumerable: !0, value: e },
        rotation: { configurable: !0, enumerable: !0, value: t },
        quaternion: { configurable: !0, enumerable: !0, value: i },
        scale: { configurable: !0, enumerable: !0, value: n },
        modelViewMatrix: { value: new Matrix4() },
        normalMatrix: { value: new Matrix3() },
      }),
      (this.matrix = new Matrix4()),
      (this.matrixWorld = new Matrix4()),
      (this.matrixAutoUpdate = Object3D.DEFAULT_MATRIX_AUTO_UPDATE),
      (this.matrixWorldNeedsUpdate = !1),
      (this.matrixWorldAutoUpdate = Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE),
      (this.layers = new ni()),
      (this.visible = !0),
      (this.castShadow = !1),
      (this.receiveShadow = !1),
      (this.frustumCulled = !0),
      (this.renderOrder = 0),
      (this.animations = []),
      (this.userData = {});
  }
  onBeforeRender() {}
  onAfterRender() {}
  applyMatrix4(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      this.matrix.premultiply(e),
      this.matrix.decompose(this.position, this.quaternion, this.scale);
  }
  applyQuaternion(e) {
    return this.quaternion.premultiply(e), this;
  }
  setRotationFromAxisAngle(e, t) {
    this.quaternion.setFromAxisAngle(e, t);
  }
  setRotationFromEuler(e) {
    this.quaternion.setFromEuler(e, !0);
  }
  setRotationFromMatrix(e) {
    this.quaternion.setFromRotationMatrix(e);
  }
  setRotationFromQuaternion(e) {
    this.quaternion.copy(e);
  }
  rotateOnAxis(e, t) {
    return ai.setFromAxisAngle(e, t), this.quaternion.multiply(ai), this;
  }
  rotateOnWorldAxis(e, t) {
    return ai.setFromAxisAngle(e, t), this.quaternion.premultiply(ai), this;
  }
  rotateX(e) {
    return this.rotateOnAxis(di, e);
  }
  rotateY(e) {
    return this.rotateOnAxis(pi, e);
  }
  rotateZ(e) {
    return this.rotateOnAxis(fi, e);
  }
  translateOnAxis(e, t) {
    return (
      ri.copy(e).applyQuaternion(this.quaternion),
      this.position.add(ri.multiplyScalar(t)),
      this
    );
  }
  translateX(e) {
    return this.translateOnAxis(di, e);
  }
  translateY(e) {
    return this.translateOnAxis(pi, e);
  }
  translateZ(e) {
    return this.translateOnAxis(fi, e);
  }
  localToWorld(e) {
    return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld);
  }
  worldToLocal(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      e.applyMatrix4(oi.copy(this.matrixWorld).invert())
    );
  }
  lookAt(e, t, i) {
    e.isVector3 ? li.copy(e) : li.set(e, t, i);
    const n = this.parent;
    this.updateWorldMatrix(!0, !1),
      hi.setFromMatrixPosition(this.matrixWorld),
      this.isCamera || this.isLight
        ? oi.lookAt(hi, li, this.up)
        : oi.lookAt(li, hi, this.up),
      this.quaternion.setFromRotationMatrix(oi),
      n &&
        (oi.extractRotation(n.matrixWorld),
        ai.setFromRotationMatrix(oi),
        this.quaternion.premultiply(ai.invert()));
  }
  add(e) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.add(arguments[e]);
      return this;
    }
    return e === this
      ? (console.error(
          "THREE.Object3D.add: object can't be added as a child of itself.",
          e
        ),
        this)
      : (e && e.isObject3D
          ? (null !== e.parent && e.parent.remove(e),
            (e.parent = this),
            this.children.push(e),
            e.dispatchEvent(mi))
          : console.error(
              "THREE.Object3D.add: object not an instance of THREE.Object3D.",
              e
            ),
        this);
  }
  remove(e) {
    if (arguments.length > 1) {
      for (let e = 0; e < arguments.length; e++) this.remove(arguments[e]);
      return this;
    }
    const t = this.children.indexOf(e);
    return (
      -1 !== t &&
        ((e.parent = null), this.children.splice(t, 1), e.dispatchEvent(gi)),
      this
    );
  }
  removeFromParent() {
    const e = this.parent;
    return null !== e && e.remove(this), this;
  }
  clear() {
    return this.remove(...this.children);
  }
  attach(e) {
    return (
      this.updateWorldMatrix(!0, !1),
      oi.copy(this.matrixWorld).invert(),
      null !== e.parent &&
        (e.parent.updateWorldMatrix(!0, !1), oi.multiply(e.parent.matrixWorld)),
      e.applyMatrix4(oi),
      this.add(e),
      e.updateWorldMatrix(!1, !0),
      this
    );
  }
  getObjectById(e) {
    return this.getObjectByProperty("id", e);
  }
  getObjectByName(e) {
    return this.getObjectByProperty("name", e);
  }
  getObjectByProperty(e, t) {
    if (this[e] === t) return this;
    for (let i = 0, n = this.children.length; i < n; i++) {
      const n = this.children[i].getObjectByProperty(e, t);
      if (void 0 !== n) return n;
    }
  }
  getObjectsByProperty(e, t) {
    let i = [];
    this[e] === t && i.push(this);
    for (let n = 0, s = this.children.length; n < s; n++) {
      const s = this.children[n].getObjectsByProperty(e, t);
      s.length > 0 && (i = i.concat(s));
    }
    return i;
  }
  getWorldPosition(e) {
    return (
      this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    );
  }
  getWorldQuaternion(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hi, e, ci), e
    );
  }
  getWorldScale(e) {
    return (
      this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(hi, ui, e), e
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(t[8], t[9], t[10]).normalize();
  }
  raycast() {}
  traverse(e) {
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].traverse(e);
  }
  traverseVisible(e) {
    if (!1 === this.visible) return;
    e(this);
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) t[i].traverseVisible(e);
  }
  traverseAncestors(e) {
    const t = this.parent;
    null !== t && (e(t), t.traverseAncestors(e));
  }
  updateMatrix() {
    this.matrix.compose(this.position, this.quaternion, this.scale),
      (this.matrixWorldNeedsUpdate = !0);
  }
  updateMatrixWorld(e) {
    this.matrixAutoUpdate && this.updateMatrix(),
      (this.matrixWorldNeedsUpdate || e) &&
        (null === this.parent
          ? this.matrixWorld.copy(this.matrix)
          : this.matrixWorld.multiplyMatrices(
              this.parent.matrixWorld,
              this.matrix
            ),
        (this.matrixWorldNeedsUpdate = !1),
        (e = !0));
    const t = this.children;
    for (let i = 0, n = t.length; i < n; i++) {
      const n = t[i];
      (!0 !== n.matrixWorldAutoUpdate && !0 !== e) || n.updateMatrixWorld(e);
    }
  }
  updateWorldMatrix(e, t) {
    const i = this.parent;
    if (
      (!0 === e &&
        null !== i &&
        !0 === i.matrixWorldAutoUpdate &&
        i.updateWorldMatrix(!0, !1),
      this.matrixAutoUpdate && this.updateMatrix(),
      null === this.parent
        ? this.matrixWorld.copy(this.matrix)
        : this.matrixWorld.multiplyMatrices(
            this.parent.matrixWorld,
            this.matrix
          ),
      !0 === t)
    ) {
      const e = this.children;
      for (let t = 0, i = e.length; t < i; t++) {
        const i = e[t];
        !0 === i.matrixWorldAutoUpdate && i.updateWorldMatrix(!1, !0);
      }
    }
  }
  toJSON(e) {
    const t = void 0 === e || "string" == typeof e,
      i = {};
    t &&
      ((e = {
        geometries: {},
        materials: {},
        textures: {},
        images: {},
        shapes: {},
        skeletons: {},
        animations: {},
        nodes: {},
      }),
      (i.metadata = {
        version: 4.6,
        type: "Object",
        generator: "Object3D.toJSON",
      }));
    const n = {};
    function s(t, i) {
      return void 0 === t[i.uuid] && (t[i.uuid] = i.toJSON(e)), i.uuid;
    }
    if (
      ((n.uuid = this.uuid),
      (n.type = this.type),
      "" !== this.name && (n.name = this.name),
      !0 === this.castShadow && (n.castShadow = !0),
      !0 === this.receiveShadow && (n.receiveShadow = !0),
      !1 === this.visible && (n.visible = !1),
      !1 === this.frustumCulled && (n.frustumCulled = !1),
      0 !== this.renderOrder && (n.renderOrder = this.renderOrder),
      Object.keys(this.userData).length > 0 && (n.userData = this.userData),
      (n.layers = this.layers.mask),
      (n.matrix = this.matrix.toArray()),
      (n.up = this.up.toArray()),
      !1 === this.matrixAutoUpdate && (n.matrixAutoUpdate = !1),
      this.isInstancedMesh &&
        ((n.type = "InstancedMesh"),
        (n.count = this.count),
        (n.instanceMatrix = this.instanceMatrix.toJSON()),
        null !== this.instanceColor &&
          (n.instanceColor = this.instanceColor.toJSON())),
      this.isScene)
    )
      this.background &&
        (this.background.isColor
          ? (n.background = this.background.toJSON())
          : this.background.isTexture &&
            (n.background = this.background.toJSON(e).uuid)),
        this.environment &&
          this.environment.isTexture &&
          !0 !== this.environment.isRenderTargetTexture &&
          (n.environment = this.environment.toJSON(e).uuid);
    else if (this.isMesh || this.isLine || this.isPoints) {
      n.geometry = s(e.geometries, this.geometry);
      const t = this.geometry.parameters;
      if (void 0 !== t && void 0 !== t.shapes) {
        const i = t.shapes;
        if (Array.isArray(i))
          for (let t = 0, n = i.length; t < n; t++) {
            const n = i[t];
            s(e.shapes, n);
          }
        else s(e.shapes, i);
      }
    }
    if (
      (this.isSkinnedMesh &&
        ((n.bindMode = this.bindMode),
        (n.bindMatrix = this.bindMatrix.toArray()),
        void 0 !== this.skeleton &&
          (s(e.skeletons, this.skeleton), (n.skeleton = this.skeleton.uuid))),
      void 0 !== this.material)
    )
      if (Array.isArray(this.material)) {
        const t = [];
        for (let i = 0, n = this.material.length; i < n; i++)
          t.push(s(e.materials, this.material[i]));
        n.material = t;
      } else n.material = s(e.materials, this.material);
    if (this.children.length > 0) {
      n.children = [];
      for (let t = 0; t < this.children.length; t++)
        n.children.push(this.children[t].toJSON(e).object);
    }
    if (this.animations.length > 0) {
      n.animations = [];
      for (let t = 0; t < this.animations.length; t++) {
        const i = this.animations[t];
        n.animations.push(s(e.animations, i));
      }
    }
    if (t) {
      const t = r(e.geometries),
        n = r(e.materials),
        s = r(e.textures),
        a = r(e.images),
        o = r(e.shapes),
        l = r(e.skeletons),
        h = r(e.animations),
        c = r(e.nodes);
      t.length > 0 && (i.geometries = t),
        n.length > 0 && (i.materials = n),
        s.length > 0 && (i.textures = s),
        a.length > 0 && (i.images = a),
        o.length > 0 && (i.shapes = o),
        l.length > 0 && (i.skeletons = l),
        h.length > 0 && (i.animations = h),
        c.length > 0 && (i.nodes = c);
    }
    return (i.object = n), i;
    function r(e) {
      const t = [];
      for (const i in e) {
        const n = e[i];
        delete n.metadata, t.push(n);
      }
      return t;
    }
  }
  clone(e) {
    return new this.constructor().copy(this, e);
  }
  copy(e, t = !0) {
    if (
      ((this.name = e.name),
      this.up.copy(e.up),
      this.position.copy(e.position),
      (this.rotation.order = e.rotation.order),
      this.quaternion.copy(e.quaternion),
      this.scale.copy(e.scale),
      this.matrix.copy(e.matrix),
      this.matrixWorld.copy(e.matrixWorld),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      (this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate),
      (this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate),
      (this.layers.mask = e.layers.mask),
      (this.visible = e.visible),
      (this.castShadow = e.castShadow),
      (this.receiveShadow = e.receiveShadow),
      (this.frustumCulled = e.frustumCulled),
      (this.renderOrder = e.renderOrder),
      (this.animations = e.animations.slice()),
      (this.userData = JSON.parse(JSON.stringify(e.userData))),
      !0 === t)
    )
      for (let i = 0; i < e.children.length; i++) {
        const t = e.children[i];
        this.add(t.clone());
      }
    return this;
  }
}

(Object3D.DEFAULT_UP = new Vector3(0, 1, 0)),
  (Object3D.DEFAULT_MATRIX_AUTO_UPDATE = !0),
  (Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0);
const vi = new Vector3(),
  Ai = new Vector3(),
  yi = new Vector3(),
  xi = new Vector3(),
  bi = new Vector3(),
  Ei = new Vector3(),
  Si = new Vector3(),
  Ci = new Vector3(),
  Mi = new Vector3(),
  wi = new Vector3();
let Ti = !1;
class Ii {
  constructor(e = new Vector3(), t = new Vector3(), i = new Vector3()) {
    (this.a = e), (this.b = t), (this.c = i);
  }
  static getNormal(e, t, i, n) {
    n.subVectors(i, t), vi.subVectors(e, t), n.cross(vi);
    const s = n.lengthSq();
    return s > 0 ? n.multiplyScalar(1 / Math.sqrt(s)) : n.set(0, 0, 0);
  }
  static getBarycoord(e, t, i, n, s) {
    vi.subVectors(n, t), Ai.subVectors(i, t), yi.subVectors(e, t);
    const r = vi.dot(vi),
      a = vi.dot(Ai),
      o = vi.dot(yi),
      l = Ai.dot(Ai),
      h = Ai.dot(yi),
      c = r * l - a * a;
    if (0 === c) return s.set(-2, -1, -1);
    const u = 1 / c,
      d = (l * o - a * h) * u,
      p = (r * h - a * o) * u;
    return s.set(1 - d - p, p, d);
  }
  static containsPoint(e, t, i, n) {
    return (
      this.getBarycoord(e, t, i, n, xi),
      xi.x >= 0 && xi.y >= 0 && xi.x + xi.y <= 1
    );
  }
  static getUV(e, t, i, n, s, r, a, o) {
    return (
      !1 === Ti &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Ti = !0)),
      this.getInterpolation(e, t, i, n, s, r, a, o)
    );
  }
  static getInterpolation(e, t, i, n, s, r, a, o) {
    return (
      this.getBarycoord(e, t, i, n, xi),
      o.setScalar(0),
      o.addScaledVector(s, xi.x),
      o.addScaledVector(r, xi.y),
      o.addScaledVector(a, xi.z),
      o
    );
  }
  static isFrontFacing(e, t, i, n) {
    return vi.subVectors(i, t), Ai.subVectors(e, t), vi.cross(Ai).dot(n) < 0;
  }
  set(e, t, i) {
    return this.a.copy(e), this.b.copy(t), this.c.copy(i), this;
  }
  setFromPointsAndIndices(e, t, i, n) {
    return this.a.copy(e[t]), this.b.copy(e[i]), this.c.copy(e[n]), this;
  }
  setFromAttributeAndIndices(e, t, i, n) {
    return (
      this.a.fromBufferAttribute(e, t),
      this.b.fromBufferAttribute(e, i),
      this.c.fromBufferAttribute(e, n),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this;
  }
  getArea() {
    return (
      vi.subVectors(this.c, this.b),
      Ai.subVectors(this.a, this.b),
      0.5 * vi.cross(Ai).length()
    );
  }
  getMidpoint(e) {
    return e
      .addVectors(this.a, this.b)
      .add(this.c)
      .multiplyScalar(1 / 3);
  }
  getNormal(e) {
    return Ii.getNormal(this.a, this.b, this.c, e);
  }
  getPlane(e) {
    return e.setFromCoplanarPoints(this.a, this.b, this.c);
  }
  getBarycoord(e, t) {
    return Ii.getBarycoord(e, this.a, this.b, this.c, t);
  }
  getUV(e, t, i, n, s) {
    return (
      !1 === Ti &&
        (console.warn(
          "THREE.Triangle.getUV() has been renamed to THREE.Triangle.getInterpolation()."
        ),
        (Ti = !0)),
      Ii.getInterpolation(e, this.a, this.b, this.c, t, i, n, s)
    );
  }
  getInterpolation(e, t, i, n, s) {
    return Ii.getInterpolation(e, this.a, this.b, this.c, t, i, n, s);
  }
  containsPoint(e) {
    return Ii.containsPoint(e, this.a, this.b, this.c);
  }
  isFrontFacing(e) {
    return Ii.isFrontFacing(this.a, this.b, this.c, e);
  }
  intersectsBox(e) {
    return e.intersectsTriangle(this);
  }
  closestPointToPoint(e, t) {
    const i = this.a,
      n = this.b,
      s = this.c;
    let r, a;
    bi.subVectors(n, i), Ei.subVectors(s, i), Ci.subVectors(e, i);
    const o = bi.dot(Ci),
      l = Ei.dot(Ci);
    if (o <= 0 && l <= 0) return t.copy(i);
    Mi.subVectors(e, n);
    const h = bi.dot(Mi),
      c = Ei.dot(Mi);
    if (h >= 0 && c <= h) return t.copy(n);
    const u = o * c - h * l;
    if (u <= 0 && o >= 0 && h <= 0)
      return (r = o / (o - h)), t.copy(i).addScaledVector(bi, r);
    wi.subVectors(e, s);
    const d = bi.dot(wi),
      p = Ei.dot(wi);
    if (p >= 0 && d <= p) return t.copy(s);
    const f = d * l - o * p;
    if (f <= 0 && l >= 0 && p <= 0)
      return (a = l / (l - p)), t.copy(i).addScaledVector(Ei, a);
    const m = h * p - d * c;
    if (m <= 0 && c - h >= 0 && d - p >= 0)
      return (
        Si.subVectors(s, n),
        (a = (c - h) / (c - h + (d - p))),
        t.copy(n).addScaledVector(Si, a)
      );
    const g = 1 / (m + f + u);
    return (
      (r = f * g),
      (a = u * g),
      t.copy(i).addScaledVector(bi, r).addScaledVector(Ei, a)
    );
  }
  equals(e) {
    return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c);
  }
}

const Di = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074,
  },
  Li = { h: 0, s: 0, l: 0 },
  Fi = { h: 0, s: 0, l: 0 };
function Ni(e, t, i) {
  return (
    i < 0 && (i += 1),
    i > 1 && (i -= 1),
    i < 1 / 6
      ? e + 6 * (t - e) * i
      : i < 0.5
      ? t
      : i < 2 / 3
      ? e + 6 * (t - e) * (2 / 3 - i)
      : e
  );
}
class Color {
  constructor(e, t, i) {
    return (
      (this.isColor = !0),
      (this.r = 1),
      (this.g = 1),
      (this.b = 1),
      this.set(e, t, i)
    );
  }
  set(e, t, i) {
    if (void 0 === t && void 0 === i) {
      const t = e;
      t && t.isColor
        ? this.copy(t)
        : "number" == typeof t
        ? this.setHex(t)
        : "string" == typeof t && this.setStyle(t);
    } else this.setRGB(e, t, i);
    return this;
  }
  setScalar(e) {
    return (this.r = e), (this.g = e), (this.b = e), this;
  }
  setHex(e, t = me) {
    return (
      (e = Math.floor(e)),
      (this.r = ((e >> 16) & 255) / 255),
      (this.g = ((e >> 8) & 255) / 255),
      (this.b = (255 & e) / 255),
      tt.toWorkingColorSpace(this, t),
      this
    );
  }
  setRGB(e, t, i, n = tt.workingColorSpace) {
    return (
      (this.r = e),
      (this.g = t),
      (this.b = i),
      tt.toWorkingColorSpace(this, n),
      this
    );
  }
  setHSL(e, t, i, n = tt.workingColorSpace) {
    if (((e = Le(e, 1)), (t = De(t, 0, 1)), (i = De(i, 0, 1)), 0 === t))
      this.r = this.g = this.b = i;
    else {
      const n = i <= 0.5 ? i * (1 + t) : i + t - i * t,
        s = 2 * i - n;
      (this.r = Ni(s, n, e + 1 / 3)),
        (this.g = Ni(s, n, e)),
        (this.b = Ni(s, n, e - 1 / 3));
    }
    return tt.toWorkingColorSpace(this, n), this;
  }
  setStyle(e, t = me) {
    function i(t) {
      void 0 !== t &&
        parseFloat(t) < 1 &&
        console.warn(
          "THREE.Color: Alpha component of " + e + " will be ignored."
        );
    }
    let n;
    if ((n = /^(\w+)\(([^\)]*)\)/.exec(e))) {
      let s;
      const r = n[1],
        a = n[2];
      switch (r) {
        case "rgb":
        case "rgba":
          if (
            (s =
              /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(255, parseInt(s[1], 10)) / 255,
                Math.min(255, parseInt(s[2], 10)) / 255,
                Math.min(255, parseInt(s[3], 10)) / 255,
                t
              )
            );
          if (
            (s =
              /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setRGB(
                Math.min(100, parseInt(s[1], 10)) / 100,
                Math.min(100, parseInt(s[2], 10)) / 100,
                Math.min(100, parseInt(s[3], 10)) / 100,
                t
              )
            );
          break;
        case "hsl":
        case "hsla":
          if (
            (s =
              /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(
                a
              ))
          )
            return (
              i(s[4]),
              this.setHSL(
                parseFloat(s[1]) / 360,
                parseFloat(s[2]) / 100,
                parseFloat(s[3]) / 100,
                t
              )
            );
          break;
        default:
          console.warn("THREE.Color: Unknown color model " + e);
      }
    } else if ((n = /^\#([A-Fa-f\d]+)$/.exec(e))) {
      const i = n[1],
        s = i.length;
      if (3 === s)
        return this.setRGB(
          parseInt(i.charAt(0), 16) / 15,
          parseInt(i.charAt(1), 16) / 15,
          parseInt(i.charAt(2), 16) / 15,
          t
        );
      if (6 === s) return this.setHex(parseInt(i, 16), t);
      console.warn("THREE.Color: Invalid hex color " + e);
    } else if (e && e.length > 0) return this.setColorName(e, t);
    return this;
  }
  setColorName(e, t = me) {
    const i = Di[e.toLowerCase()];
    return (
      void 0 !== i
        ? this.setHex(i, t)
        : console.warn("THREE.Color: Unknown color " + e),
      this
    );
  }
  clone() {
    return new this.constructor(this.r, this.g, this.b);
  }
  copy(e) {
    return (this.r = e.r), (this.g = e.g), (this.b = e.b), this;
  }
  copySRGBToLinear(e) {
    return (this.r = Ye(e.r)), (this.g = Ye(e.g)), (this.b = Ye(e.b)), this;
  }
  copyLinearToSRGB(e) {
    return (this.r = Ke(e.r)), (this.g = Ke(e.g)), (this.b = Ke(e.b)), this;
  }
  convertSRGBToLinear() {
    return this.copySRGBToLinear(this), this;
  }
  convertLinearToSRGB() {
    return this.copyLinearToSRGB(this), this;
  }
  getHex(e = me) {
    return (
      tt.fromWorkingColorSpace(ki.copy(this), e),
      65536 * Math.round(De(255 * ki.r, 0, 255)) +
        256 * Math.round(De(255 * ki.g, 0, 255)) +
        Math.round(De(255 * ki.b, 0, 255))
    );
  }
  getHexString(e = me) {
    return ("000000" + this.getHex(e).toString(16)).slice(-6);
  }
  getHSL(e, t = tt.workingColorSpace) {
    tt.fromWorkingColorSpace(ki.copy(this), t);
    const i = ki.r,
      n = ki.g,
      s = ki.b,
      r = Math.max(i, n, s),
      a = Math.min(i, n, s);
    let o, l;
    const h = (a + r) / 2;
    if (a === r) (o = 0), (l = 0);
    else {
      const e = r - a;
      switch (((l = h <= 0.5 ? e / (r + a) : e / (2 - r - a)), r)) {
        case i:
          o = (n - s) / e + (n < s ? 6 : 0);
          break;
        case n:
          o = (s - i) / e + 2;
          break;
        case s:
          o = (i - n) / e + 4;
      }
      o /= 6;
    }
    return (e.h = o), (e.s = l), (e.l = h), e;
  }
  getRGB(e, t = tt.workingColorSpace) {
    return (
      tt.fromWorkingColorSpace(ki.copy(this), t),
      (e.r = ki.r),
      (e.g = ki.g),
      (e.b = ki.b),
      e
    );
  }
  getStyle(e = me) {
    tt.fromWorkingColorSpace(ki.copy(this), e);
    const t = ki.r,
      i = ki.g,
      n = ki.b;
    return e !== me
      ? `color(${e} ${t.toFixed(3)} ${i.toFixed(3)} ${n.toFixed(3)})`
      : `rgb(${Math.round(255 * t)},${Math.round(255 * i)},${Math.round(
          255 * n
        )})`;
  }
  offsetHSL(e, t, i) {
    return (
      this.getHSL(Li),
      (Li.h += e),
      (Li.s += t),
      (Li.l += i),
      this.setHSL(Li.h, Li.s, Li.l),
      this
    );
  }
  add(e) {
    return (this.r += e.r), (this.g += e.g), (this.b += e.b), this;
  }
  addColors(e, t) {
    return (
      (this.r = e.r + t.r), (this.g = e.g + t.g), (this.b = e.b + t.b), this
    );
  }
  addScalar(e) {
    return (this.r += e), (this.g += e), (this.b += e), this;
  }
  sub(e) {
    return (
      (this.r = Math.max(0, this.r - e.r)),
      (this.g = Math.max(0, this.g - e.g)),
      (this.b = Math.max(0, this.b - e.b)),
      this
    );
  }
  multiply(e) {
    return (this.r *= e.r), (this.g *= e.g), (this.b *= e.b), this;
  }
  multiplyScalar(e) {
    return (this.r *= e), (this.g *= e), (this.b *= e), this;
  }
  lerp(e, t) {
    return (
      (this.r += (e.r - this.r) * t),
      (this.g += (e.g - this.g) * t),
      (this.b += (e.b - this.b) * t),
      this
    );
  }
  lerpColors(e, t, i) {
    return (
      (this.r = e.r + (t.r - e.r) * i),
      (this.g = e.g + (t.g - e.g) * i),
      (this.b = e.b + (t.b - e.b) * i),
      this
    );
  }
  lerpHSL(e, t) {
    this.getHSL(Li), e.getHSL(Fi);
    const i = Fe(Li.h, Fi.h, t),
      n = Fe(Li.s, Fi.s, t),
      s = Fe(Li.l, Fi.l, t);
    return this.setHSL(i, n, s), this;
  }
  setFromVector3(e) {
    return (this.r = e.x), (this.g = e.y), (this.b = e.z), this;
  }
  applyMatrix3(e) {
    const t = this.r,
      i = this.g,
      n = this.b,
      s = e.elements;
    return (
      (this.r = s[0] * t + s[3] * i + s[6] * n),
      (this.g = s[1] * t + s[4] * i + s[7] * n),
      (this.b = s[2] * t + s[5] * i + s[8] * n),
      this
    );
  }
  equals(e) {
    return e.r === this.r && e.g === this.g && e.b === this.b;
  }
  fromArray(e, t = 0) {
    return (this.r = e[t]), (this.g = e[t + 1]), (this.b = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.r), (e[t + 1] = this.g), (e[t + 2] = this.b), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.r = e.getX(t)), (this.g = e.getY(t)), (this.b = e.getZ(t)), this
    );
  }
  toJSON() {
    return this.getHex();
  }
  *[Symbol.iterator]() {
    yield this.r, yield this.g, yield this.b;
  }
}
const ki = new Color();
Color.NAMES = Di;
class Oi extends Material {
  constructor(e) {
    super(),
      (this.isMeshBasicMaterial = !0),
      (this.type = "MeshBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.specularMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.combine = f),
      (this.reflectivity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      (this.specularMap = e.specularMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.combine = e.combine),
      (this.reflectivity = e.reflectivity),
      (this.refractionRatio = e.refractionRatio),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const Ui = zi();
function zi() {
  const e = new ArrayBuffer(4),
    t = new Float32Array(e),
    i = new Uint32Array(e),
    n = new Uint32Array(512),
    s = new Uint32Array(512);
  for (let l = 0; l < 256; ++l) {
    const e = l - 127;
    e < -27
      ? ((n[l] = 0), (n[256 | l] = 32768), (s[l] = 24), (s[256 | l] = 24))
      : e < -14
      ? ((n[l] = 1024 >> (-e - 14)),
        (n[256 | l] = (1024 >> (-e - 14)) | 32768),
        (s[l] = -e - 1),
        (s[256 | l] = -e - 1))
      : e <= 15
      ? ((n[l] = (e + 15) << 10),
        (n[256 | l] = ((e + 15) << 10) | 32768),
        (s[l] = 13),
        (s[256 | l] = 13))
      : e < 128
      ? ((n[l] = 31744), (n[256 | l] = 64512), (s[l] = 24), (s[256 | l] = 24))
      : ((n[l] = 31744), (n[256 | l] = 64512), (s[l] = 13), (s[256 | l] = 13));
  }
  const r = new Uint32Array(2048),
    a = new Uint32Array(64),
    o = new Uint32Array(64);
  for (let l = 1; l < 1024; ++l) {
    let e = l << 13,
      t = 0;
    for (; 0 == (8388608 & e); ) (e <<= 1), (t -= 8388608);
    (e &= -8388609), (t += 947912704), (r[l] = e | t);
  }
  for (let l = 1024; l < 2048; ++l) r[l] = 939524096 + ((l - 1024) << 13);
  for (let l = 1; l < 31; ++l) a[l] = l << 23;
  (a[31] = 1199570944), (a[32] = 2147483648);
  for (let l = 33; l < 63; ++l) a[l] = 2147483648 + ((l - 32) << 23);
  a[63] = 3347054592;
  for (let l = 1; l < 64; ++l) 32 !== l && (o[l] = 1024);
  return {
    floatView: t,
    uint32View: i,
    baseTable: n,
    shiftTable: s,
    mantissaTable: r,
    exponentTable: a,
    offsetTable: o,
  };
}
function Gi(e) {
  Math.abs(e) > 65504 &&
    console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    (e = De(e, -65504, 65504)),
    (Ui.floatView[0] = e);
  const t = Ui.uint32View[0],
    i = (t >> 23) & 511;
  return Ui.baseTable[i] + ((8388607 & t) >> Ui.shiftTable[i]);
}
function Vi(e) {
  const t = e >> 10;
  return (
    (Ui.uint32View[0] =
      Ui.mantissaTable[Ui.offsetTable[t] + (1023 & e)] + Ui.exponentTable[t]),
    Ui.floatView[0]
  );
}
const Qi = { toHalfFloat: Gi, fromHalfFloat: Vi },
  Hi = new Vector3(),
  ji = new Vector2();
class Wi {
  constructor(e, t, i = !1) {
    if (Array.isArray(e))
      throw new TypeError(
        "THREE.BufferAttribute: array should be a Typed Array."
      );
    (this.isBufferAttribute = !0),
      (this.name = ""),
      (this.array = e),
      (this.itemSize = t),
      (this.count = void 0 !== e ? e.length / t : 0),
      (this.normalized = i),
      (this.usage = ye),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.gpuType = z),
      (this.version = 0);
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.name = e.name),
      (this.array = new e.array.constructor(e.array)),
      (this.itemSize = e.itemSize),
      (this.count = e.count),
      (this.normalized = e.normalized),
      (this.usage = e.usage),
      (this.gpuType = e.gpuType),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.itemSize), (i *= t.itemSize);
    for (let n = 0, s = this.itemSize; n < s; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  copyArray(e) {
    return this.array.set(e), this;
  }
  applyMatrix3(e) {
    if (2 === this.itemSize)
      for (let t = 0, i = this.count; t < i; t++)
        ji.fromBufferAttribute(this, t),
          ji.applyMatrix3(e),
          this.setXY(t, ji.x, ji.y);
    else if (3 === this.itemSize)
      for (let t = 0, i = this.count; t < i; t++)
        Hi.fromBufferAttribute(this, t),
          Hi.applyMatrix3(e),
          this.setXYZ(t, Hi.x, Hi.y, Hi.z);
    return this;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Hi.fromBufferAttribute(this, t),
        Hi.applyMatrix4(e),
        this.setXYZ(t, Hi.x, Hi.y, Hi.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Hi.fromBufferAttribute(this, t),
        Hi.applyNormalMatrix(e),
        this.setXYZ(t, Hi.x, Hi.y, Hi.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Hi.fromBufferAttribute(this, t),
        Hi.transformDirection(e),
        this.setXYZ(t, Hi.x, Hi.y, Hi.z);
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  getComponent(e, t) {
    let i = this.array[e * this.itemSize + t];
    return this.normalized && (i = Oe(i, this.array)), i;
  }
  setComponent(e, t, i) {
    return (
      this.normalized && (i = Ue(i, this.array)),
      (this.array[e * this.itemSize + t] = i),
      this
    );
  }
  getX(e) {
    let t = this.array[e * this.itemSize];
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.array[e * this.itemSize] = t),
      this
    );
  }
  getY(e) {
    let t = this.array[e * this.itemSize + 1];
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.array[e * this.itemSize + 1] = t),
      this
    );
  }
  getZ(e) {
    let t = this.array[e * this.itemSize + 2];
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.array[e * this.itemSize + 2] = t),
      this
    );
  }
  getW(e) {
    let t = this.array[e * this.itemSize + 3];
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.array[e * this.itemSize + 3] = t),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Ue(t, this.array)), (i = Ue(i, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, n) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ue(t, this.array)),
        (i = Ue(i, this.array)),
        (n = Ue(n, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = n),
      this
    );
  }
  setXYZW(e, t, i, n, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ue(t, this.array)),
        (i = Ue(i, this.array)),
        (n = Ue(n, this.array)),
        (s = Ue(s, this.array))),
      (this.array[e + 0] = t),
      (this.array[e + 1] = i),
      (this.array[e + 2] = n),
      (this.array[e + 3] = s),
      this
    );
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  clone() {
    return new this.constructor(this.array, this.itemSize).copy(this);
  }
  toJSON() {
    const e = {
      itemSize: this.itemSize,
      type: this.array.constructor.name,
      array: Array.from(this.array),
      normalized: this.normalized,
    };
    return (
      "" !== this.name && (e.name = this.name),
      this.usage !== ye && (e.usage = this.usage),
      (0 === this.updateRange.offset && -1 === this.updateRange.count) ||
        (e.updateRange = this.updateRange),
      e
    );
  }
}
class qi extends Wi {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i);
  }
}
class Xi extends Wi {
  constructor(e, t, i) {
    super(new Uint32Array(e), t, i);
  }
}
class Yi extends Wi {
  constructor(e, t, i) {
    super(new Uint16Array(e), t, i), (this.isFloat16BufferAttribute = !0);
  }
  getX(e) {
    let t = Vi(this.array[e * this.itemSize]);
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.array[e * this.itemSize] = Gi(t)),
      this
    );
  }
  getY(e) {
    let t = Vi(this.array[e * this.itemSize + 1]);
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  setY(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.array[e * this.itemSize + 1] = Gi(t)),
      this
    );
  }
  getZ(e) {
    let t = Vi(this.array[e * this.itemSize + 2]);
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.array[e * this.itemSize + 2] = Gi(t)),
      this
    );
  }
  getW(e) {
    let t = Vi(this.array[e * this.itemSize + 3]);
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  setW(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.array[e * this.itemSize + 3] = Gi(t)),
      this
    );
  }
  setXY(e, t, i) {
    return (
      (e *= this.itemSize),
      this.normalized && ((t = Ue(t, this.array)), (i = Ue(i, this.array))),
      (this.array[e + 0] = Gi(t)),
      (this.array[e + 1] = Gi(i)),
      this
    );
  }
  setXYZ(e, t, i, n) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ue(t, this.array)),
        (i = Ue(i, this.array)),
        (n = Ue(n, this.array))),
      (this.array[e + 0] = Gi(t)),
      (this.array[e + 1] = Gi(i)),
      (this.array[e + 2] = Gi(n)),
      this
    );
  }
  setXYZW(e, t, i, n, s) {
    return (
      (e *= this.itemSize),
      this.normalized &&
        ((t = Ue(t, this.array)),
        (i = Ue(i, this.array)),
        (n = Ue(n, this.array)),
        (s = Ue(s, this.array))),
      (this.array[e + 0] = Gi(t)),
      (this.array[e + 1] = Gi(i)),
      (this.array[e + 2] = Gi(n)),
      (this.array[e + 3] = Gi(s)),
      this
    );
  }
}
class Ki extends Wi {
  constructor(e, t, i) {
    super(new Float32Array(e), t, i);
  }
}
let Zi = 0;
const Ji = new Matrix4(),
  $i = new Object3D(),
  en = new Vector3(),
  tn = new Box3(),
  nn = new Box3(),
  sn = new Vector3();
class rn extends EventDispatcher {
  constructor() {
    super(),
      (this.isBufferGeometry = !0),
      Object.defineProperty(this, "id", { value: Zi++ }),
      (this.uuid = Pe()),
      (this.name = ""),
      (this.type = "BufferGeometry"),
      (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.morphTargetsRelative = !1),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null),
      (this.drawRange = { start: 0, count: 1 / 0 }),
      (this.userData = {});
  }
  getIndex() {
    return this.index;
  }
  setIndex(e) {
    return (
      Array.isArray(e)
        ? (this.index = new (He(e) ? Xi : qi)(e, 1))
        : (this.index = e),
      this
    );
  }
  getAttribute(e) {
    return this.attributes[e];
  }
  setAttribute(e, t) {
    return (this.attributes[e] = t), this;
  }
  deleteAttribute(e) {
    return delete this.attributes[e], this;
  }
  hasAttribute(e) {
    return void 0 !== this.attributes[e];
  }
  addGroup(e, t, i = 0) {
    this.groups.push({ start: e, count: t, materialIndex: i });
  }
  clearGroups() {
    this.groups = [];
  }
  setDrawRange(e, t) {
    (this.drawRange.start = e), (this.drawRange.count = t);
  }
  applyMatrix4(e) {
    const t = this.attributes.position;
    void 0 !== t && (t.applyMatrix4(e), (t.needsUpdate = !0));
    const i = this.attributes.normal;
    if (void 0 !== i) {
      const t = new Matrix3().getNormalMatrix(e);
      i.applyNormalMatrix(t), (i.needsUpdate = !0);
    }
    const n = this.attributes.tangent;
    return (
      void 0 !== n && (n.transformDirection(e), (n.needsUpdate = !0)),
      null !== this.boundingBox && this.computeBoundingBox(),
      null !== this.boundingSphere && this.computeBoundingSphere(),
      this
    );
  }
  applyQuaternion(e) {
    return Ji.makeRotationFromQuaternion(e), this.applyMatrix4(Ji), this;
  }
  rotateX(e) {
    return Ji.makeRotationX(e), this.applyMatrix4(Ji), this;
  }
  rotateY(e) {
    return Ji.makeRotationY(e), this.applyMatrix4(Ji), this;
  }
  rotateZ(e) {
    return Ji.makeRotationZ(e), this.applyMatrix4(Ji), this;
  }
  translate(e, t, i) {
    return Ji.makeTranslation(e, t, i), this.applyMatrix4(Ji), this;
  }
  scale(e, t, i) {
    return Ji.makeScale(e, t, i), this.applyMatrix4(Ji), this;
  }
  lookAt(e) {
    return $i.lookAt(e), $i.updateMatrix(), this.applyMatrix4($i.matrix), this;
  }
  center() {
    return (
      this.computeBoundingBox(),
      this.boundingBox.getCenter(en).negate(),
      this.translate(en.x, en.y, en.z),
      this
    );
  }
  setFromPoints(e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const n = e[i];
      t.push(n.x, n.y, n.z || 0);
    }
    return this.setAttribute("position", new Ki(t, 3)), this;
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new Box3());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute)
      return (
        console.error(
          'THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
        void this.boundingBox.set(
          new Vector3(-1 / 0, -1 / 0, -1 / 0),
          new Vector3(1 / 0, 1 / 0, 1 / 0)
        )
      );
    if (void 0 !== e) {
      if ((this.boundingBox.setFromBufferAttribute(e), t))
        for (let i = 0, n = t.length; i < n; i++) {
          const e = t[i];
          tn.setFromBufferAttribute(e),
            this.morphTargetsRelative
              ? (sn.addVectors(this.boundingBox.min, tn.min),
                this.boundingBox.expandByPoint(sn),
                sn.addVectors(this.boundingBox.max, tn.max),
                this.boundingBox.expandByPoint(sn))
              : (this.boundingBox.expandByPoint(tn.min),
                this.boundingBox.expandByPoint(tn.max));
        }
    } else this.boundingBox.makeEmpty();
    (isNaN(this.boundingBox.min.x) ||
      isNaN(this.boundingBox.min.y) ||
      isNaN(this.boundingBox.min.z)) &&
      console.error(
        'THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',
        this
      );
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new kt());
    const e = this.attributes.position,
      t = this.morphAttributes.position;
    if (e && e.isGLBufferAttribute)
      return (
        console.error(
          'THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere. Alternatively set "mesh.frustumCulled" to "false".',
          this
        ),
        void this.boundingSphere.set(new Vector3(), 1 / 0)
      );
    if (e) {
      const i = this.boundingSphere.center;
      if ((tn.setFromBufferAttribute(e), t))
        for (let e = 0, s = t.length; e < s; e++) {
          const i = t[e];
          nn.setFromBufferAttribute(i),
            this.morphTargetsRelative
              ? (sn.addVectors(tn.min, nn.min),
                tn.expandByPoint(sn),
                sn.addVectors(tn.max, nn.max),
                tn.expandByPoint(sn))
              : (tn.expandByPoint(nn.min), tn.expandByPoint(nn.max));
        }
      tn.getCenter(i);
      let n = 0;
      for (let t = 0, s = e.count; t < s; t++)
        sn.fromBufferAttribute(e, t),
          (n = Math.max(n, i.distanceToSquared(sn)));
      if (t)
        for (let s = 0, r = t.length; s < r; s++) {
          const r = t[s],
            a = this.morphTargetsRelative;
          for (let t = 0, s = r.count; t < s; t++)
            sn.fromBufferAttribute(r, t),
              a && (en.fromBufferAttribute(e, t), sn.add(en)),
              (n = Math.max(n, i.distanceToSquared(sn)));
        }
      (this.boundingSphere.radius = Math.sqrt(n)),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  computeTangents() {
    const e = this.index,
      t = this.attributes;
    if (
      null === e ||
      void 0 === t.position ||
      void 0 === t.normal ||
      void 0 === t.uv
    )
      return void console.error(
        "THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)"
      );
    const i = e.array,
      n = t.position.array,
      s = t.normal.array,
      r = t.uv.array,
      a = n.length / 3;
    !1 === this.hasAttribute("tangent") &&
      this.setAttribute("tangent", new Wi(new Float32Array(4 * a), 4));
    const o = this.getAttribute("tangent").array,
      l = [],
      h = [];
    for (let C = 0; C < a; C++) (l[C] = new Vector3()), (h[C] = new Vector3());
    const c = new Vector3(),
      u = new Vector3(),
      d = new Vector3(),
      p = new Vector2(),
      f = new Vector2(),
      m = new Vector2(),
      g = new Vector3(),
      _ = new Vector3();
    function v(e, t, i) {
      c.fromArray(n, 3 * e),
        u.fromArray(n, 3 * t),
        d.fromArray(n, 3 * i),
        p.fromArray(r, 2 * e),
        f.fromArray(r, 2 * t),
        m.fromArray(r, 2 * i),
        u.sub(c),
        d.sub(c),
        f.sub(p),
        m.sub(p);
      const s = 1 / (f.x * m.y - m.x * f.y);
      isFinite(s) &&
        (g
          .copy(u)
          .multiplyScalar(m.y)
          .addScaledVector(d, -f.y)
          .multiplyScalar(s),
        _.copy(d)
          .multiplyScalar(f.x)
          .addScaledVector(u, -m.x)
          .multiplyScalar(s),
        l[e].add(g),
        l[t].add(g),
        l[i].add(g),
        h[e].add(_),
        h[t].add(_),
        h[i].add(_));
    }
    let A = this.groups;
    0 === A.length && (A = [{ start: 0, count: i.length }]);
    for (let C = 0, M = A.length; C < M; ++C) {
      const e = A[C],
        t = e.start;
      for (let n = t, s = t + e.count; n < s; n += 3)
        v(i[n + 0], i[n + 1], i[n + 2]);
    }
    const y = new Vector3(),
      x = new Vector3(),
      b = new Vector3(),
      E = new Vector3();
    function S(e) {
      b.fromArray(s, 3 * e), E.copy(b);
      const t = l[e];
      y.copy(t),
        y.sub(b.multiplyScalar(b.dot(t))).normalize(),
        x.crossVectors(E, t);
      const i = x.dot(h[e]) < 0 ? -1 : 1;
      (o[4 * e] = y.x),
        (o[4 * e + 1] = y.y),
        (o[4 * e + 2] = y.z),
        (o[4 * e + 3] = i);
    }
    for (let C = 0, M = A.length; C < M; ++C) {
      const e = A[C],
        t = e.start;
      for (let n = t, s = t + e.count; n < s; n += 3)
        S(i[n + 0]), S(i[n + 1]), S(i[n + 2]);
    }
  }
  computeVertexNormals() {
    const e = this.index,
      t = this.getAttribute("position");
    if (void 0 !== t) {
      let i = this.getAttribute("normal");
      if (void 0 === i)
        (i = new Wi(new Float32Array(3 * t.count), 3)),
          this.setAttribute("normal", i);
      else for (let e = 0, t = i.count; e < t; e++) i.setXYZ(e, 0, 0, 0);
      const n = new Vector3(),
        s = new Vector3(),
        r = new Vector3(),
        a = new Vector3(),
        o = new Vector3(),
        l = new Vector3(),
        h = new Vector3(),
        c = new Vector3();
      if (e)
        for (let u = 0, d = e.count; u < d; u += 3) {
          const d = e.getX(u + 0),
            p = e.getX(u + 1),
            f = e.getX(u + 2);
          n.fromBufferAttribute(t, d),
            s.fromBufferAttribute(t, p),
            r.fromBufferAttribute(t, f),
            h.subVectors(r, s),
            c.subVectors(n, s),
            h.cross(c),
            a.fromBufferAttribute(i, d),
            o.fromBufferAttribute(i, p),
            l.fromBufferAttribute(i, f),
            a.add(h),
            o.add(h),
            l.add(h),
            i.setXYZ(d, a.x, a.y, a.z),
            i.setXYZ(p, o.x, o.y, o.z),
            i.setXYZ(f, l.x, l.y, l.z);
        }
      else
        for (let e = 0, u = t.count; e < u; e += 3)
          n.fromBufferAttribute(t, e + 0),
            s.fromBufferAttribute(t, e + 1),
            r.fromBufferAttribute(t, e + 2),
            h.subVectors(r, s),
            c.subVectors(n, s),
            h.cross(c),
            i.setXYZ(e + 0, h.x, h.y, h.z),
            i.setXYZ(e + 1, h.x, h.y, h.z),
            i.setXYZ(e + 2, h.x, h.y, h.z);
      this.normalizeNormals(), (i.needsUpdate = !0);
    }
  }
  normalizeNormals() {
    const e = this.attributes.normal;
    for (let t = 0, i = e.count; t < i; t++)
      sn.fromBufferAttribute(e, t),
        sn.normalize(),
        e.setXYZ(t, sn.x, sn.y, sn.z);
  }
  toNonIndexed() {
    function e(e, t) {
      const i = e.array,
        n = e.itemSize,
        s = e.normalized,
        r = new i.constructor(t.length * n);
      let a = 0,
        o = 0;
      for (let l = 0, h = t.length; l < h; l++) {
        a = e.isInterleavedBufferAttribute
          ? t[l] * e.data.stride + e.offset
          : t[l] * n;
        for (let e = 0; e < n; e++) r[o++] = i[a++];
      }
      return new Wi(r, n, s);
    }
    if (null === this.index)
      return (
        console.warn(
          "THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."
        ),
        this
      );
    const t = new rn(),
      i = this.index.array,
      n = this.attributes;
    for (const a in n) {
      const s = e(n[a], i);
      t.setAttribute(a, s);
    }
    const s = this.morphAttributes;
    for (const a in s) {
      const n = [],
        r = s[a];
      for (let t = 0, s = r.length; t < s; t++) {
        const s = e(r[t], i);
        n.push(s);
      }
      t.morphAttributes[a] = n;
    }
    t.morphTargetsRelative = this.morphTargetsRelative;
    const r = this.groups;
    for (let a = 0, o = r.length; a < o; a++) {
      const e = r[a];
      t.addGroup(e.start, e.count, e.materialIndex);
    }
    return t;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "BufferGeometry",
        generator: "BufferGeometry.toJSON",
      },
    };
    if (
      ((e.uuid = this.uuid),
      (e.type = this.type),
      "" !== this.name && (e.name = this.name),
      Object.keys(this.userData).length > 0 && (e.userData = this.userData),
      void 0 !== this.parameters)
    ) {
      const t = this.parameters;
      for (const i in t) void 0 !== t[i] && (e[i] = t[i]);
      return e;
    }
    e.data = { attributes: {} };
    const t = this.index;
    null !== t &&
      (e.data.index = {
        type: t.array.constructor.name,
        array: Array.prototype.slice.call(t.array),
      });
    const i = this.attributes;
    for (const o in i) {
      const t = i[o];
      e.data.attributes[o] = t.toJSON(e.data);
    }
    const n = {};
    let s = !1;
    for (const o in this.morphAttributes) {
      const t = this.morphAttributes[o],
        i = [];
      for (let n = 0, s = t.length; n < s; n++) {
        const s = t[n];
        i.push(s.toJSON(e.data));
      }
      i.length > 0 && ((n[o] = i), (s = !0));
    }
    s &&
      ((e.data.morphAttributes = n),
      (e.data.morphTargetsRelative = this.morphTargetsRelative));
    const r = this.groups;
    r.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(r)));
    const a = this.boundingSphere;
    return (
      null !== a &&
        (e.data.boundingSphere = {
          center: a.center.toArray(),
          radius: a.radius,
        }),
      e
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    (this.index = null),
      (this.attributes = {}),
      (this.morphAttributes = {}),
      (this.groups = []),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    const t = {};
    this.name = e.name;
    const i = e.index;
    null !== i && this.setIndex(i.clone(t));
    const n = e.attributes;
    for (const l in n) {
      const e = n[l];
      this.setAttribute(l, e.clone(t));
    }
    const s = e.morphAttributes;
    for (const l in s) {
      const e = [],
        i = s[l];
      for (let n = 0, s = i.length; n < s; n++) e.push(i[n].clone(t));
      this.morphAttributes[l] = e;
    }
    this.morphTargetsRelative = e.morphTargetsRelative;
    const r = e.groups;
    for (let l = 0, h = r.length; l < h; l++) {
      const e = r[l];
      this.addGroup(e.start, e.count, e.materialIndex);
    }
    const a = e.boundingBox;
    null !== a && (this.boundingBox = a.clone());
    const o = e.boundingSphere;
    return (
      null !== o && (this.boundingSphere = o.clone()),
      (this.drawRange.start = e.drawRange.start),
      (this.drawRange.count = e.drawRange.count),
      (this.userData = e.userData),
      this
    );
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
const an = new Matrix4(),
  on = new jt(),
  ln = new kt(),
  hn = new Vector3(),
  cn = new Vector3(),
  un = new Vector3(),
  dn = new Vector3(),
  pn = new Vector3(),
  fn = new Vector3(),
  mn = new Vector2(),
  gn = new Vector2(),
  _n = new Vector2(),
  vn = new Vector3(),
  An = new Vector3(),
  yn = new Vector3(),
  xn = new Vector3(),
  bn = new Vector3();
class En extends Object3D {
  constructor(e = new rn(), t = new Oi()) {
    super(),
      (this.isMesh = !0),
      (this.type = "Mesh"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      void 0 !== e.morphTargetInfluences &&
        (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
      void 0 !== e.morphTargetDictionary &&
        (this.morphTargetDictionary = Object.assign(
          {},
          e.morphTargetDictionary
        )),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      t = Object.keys(e);
    if (t.length > 0) {
      const i = e[t[0]];
      if (void 0 !== i) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let e = 0, t = i.length; e < t; e++) {
          const t = i[e].name || String(e);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[t] = e);
        }
      }
    }
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      n = i.attributes.position,
      s = i.morphAttributes.position,
      r = i.morphTargetsRelative;
    t.fromBufferAttribute(n, e);
    const a = this.morphTargetInfluences;
    if (s && a) {
      fn.set(0, 0, 0);
      for (let i = 0, n = s.length; i < n; i++) {
        const n = a[i],
          o = s[i];
        0 !== n &&
          (pn.fromBufferAttribute(o, e),
          r ? fn.addScaledVector(pn, n) : fn.addScaledVector(pn.sub(t), n));
      }
      t.add(fn);
    }
    return t;
  }
  raycast(e, t) {
    const i = this.geometry,
      n = this.material,
      s = this.matrixWorld;
    if (void 0 !== n) {
      if (
        (null === i.boundingSphere && i.computeBoundingSphere(),
        ln.copy(i.boundingSphere),
        ln.applyMatrix4(s),
        on.copy(e.ray).recast(e.near),
        !1 === ln.containsPoint(on.origin))
      ) {
        if (null === on.intersectSphere(ln, hn)) return;
        if (on.origin.distanceToSquared(hn) > (e.far - e.near) ** 2) return;
      }
      an.copy(s).invert(),
        on.copy(e.ray).applyMatrix4(an),
        (null !== i.boundingBox && !1 === on.intersectsBox(i.boundingBox)) ||
          this._computeIntersections(e, t, on);
    }
  }
  _computeIntersections(e, t, i) {
    let n;
    const s = this.geometry,
      r = this.material,
      a = s.index,
      o = s.attributes.position,
      l = s.attributes.uv,
      h = s.attributes.uv1,
      c = s.attributes.normal,
      u = s.groups,
      d = s.drawRange;
    if (null !== a)
      if (Array.isArray(r))
        for (let p = 0, f = u.length; p < f; p++) {
          const s = u[p],
            o = r[s.materialIndex];
          for (
            let r = Math.max(s.start, d.start),
              u = Math.min(
                a.count,
                Math.min(s.start + s.count, d.start + d.count)
              );
            r < u;
            r += 3
          ) {
            (n = Sn(
              this,
              o,
              e,
              i,
              l,
              h,
              c,
              a.getX(r),
              a.getX(r + 1),
              a.getX(r + 2)
            )),
              n &&
                ((n.faceIndex = Math.floor(r / 3)),
                (n.face.materialIndex = s.materialIndex),
                t.push(n));
          }
        }
      else {
        for (
          let s = Math.max(0, d.start),
            o = Math.min(a.count, d.start + d.count);
          s < o;
          s += 3
        ) {
          (n = Sn(
            this,
            r,
            e,
            i,
            l,
            h,
            c,
            a.getX(s),
            a.getX(s + 1),
            a.getX(s + 2)
          )),
            n && ((n.faceIndex = Math.floor(s / 3)), t.push(n));
        }
      }
    else if (void 0 !== o)
      if (Array.isArray(r))
        for (let p = 0, f = u.length; p < f; p++) {
          const s = u[p],
            a = r[s.materialIndex];
          for (
            let r = Math.max(s.start, d.start),
              u = Math.min(
                o.count,
                Math.min(s.start + s.count, d.start + d.count)
              );
            r < u;
            r += 3
          ) {
            (n = Sn(this, a, e, i, l, h, c, r, r + 1, r + 2)),
              n &&
                ((n.faceIndex = Math.floor(r / 3)),
                (n.face.materialIndex = s.materialIndex),
                t.push(n));
          }
        }
      else {
        for (
          let s = Math.max(0, d.start),
            a = Math.min(o.count, d.start + d.count);
          s < a;
          s += 3
        ) {
          (n = Sn(this, r, e, i, l, h, c, s, s + 1, s + 2)),
            n && ((n.faceIndex = Math.floor(s / 3)), t.push(n));
        }
      }
  }
}
function Sn(e, t, i, n, s, r, a, o, l, u) {
  e.getVertexPosition(o, cn),
    e.getVertexPosition(l, un),
    e.getVertexPosition(u, dn);
  const d = (function (e, t, i, n, s, r, a, o) {
    let l;
    if (
      ((l =
        t.side === c
          ? n.intersectTriangle(a, r, s, !0, o)
          : n.intersectTriangle(s, r, a, t.side === h, o)),
      null === l)
    )
      return null;
    bn.copy(o), bn.applyMatrix4(e.matrixWorld);
    const u = i.ray.origin.distanceTo(bn);
    return u < i.near || u > i.far
      ? null
      : { distance: u, point: bn.clone(), object: e };
  })(e, t, i, n, cn, un, dn, xn);
  if (d) {
    s &&
      (mn.fromBufferAttribute(s, o),
      gn.fromBufferAttribute(s, l),
      _n.fromBufferAttribute(s, u),
      (d.uv = Ii.getInterpolation(xn, cn, un, dn, mn, gn, _n, new Vector2()))),
      r &&
        (mn.fromBufferAttribute(r, o),
        gn.fromBufferAttribute(r, l),
        _n.fromBufferAttribute(r, u),
        (d.uv1 = Ii.getInterpolation(
          xn,
          cn,
          un,
          dn,
          mn,
          gn,
          _n,
          new Vector2()
        )),
        (d.uv2 = d.uv1)),
      a &&
        (vn.fromBufferAttribute(a, o),
        An.fromBufferAttribute(a, l),
        yn.fromBufferAttribute(a, u),
        (d.normal = Ii.getInterpolation(
          xn,
          cn,
          un,
          dn,
          vn,
          An,
          yn,
          new Vector3()
        )),
        d.normal.dot(n.direction) > 0 && d.normal.multiplyScalar(-1));
    const e = { a: o, b: l, c: u, normal: new Vector3(), materialIndex: 0 };
    Ii.getNormal(cn, un, dn, e.normal), (d.face = e);
  }
  return d;
}
class Cn extends rn {
  constructor(e = 1, t = 1, i = 1, n = 1, s = 1, r = 1) {
    super(),
      (this.type = "BoxGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        depth: i,
        widthSegments: n,
        heightSegments: s,
        depthSegments: r,
      });
    const a = this;
    (n = Math.floor(n)), (s = Math.floor(s)), (r = Math.floor(r));
    const o = [],
      l = [],
      h = [],
      c = [];
    let u = 0,
      d = 0;
    function p(e, t, i, n, s, r, p, f, m, g, _) {
      const v = r / m,
        A = p / g,
        y = r / 2,
        x = p / 2,
        b = f / 2,
        E = m + 1,
        S = g + 1;
      let C = 0,
        M = 0;
      const w = new Vector3();
      for (let a = 0; a < S; a++) {
        const r = a * A - x;
        for (let o = 0; o < E; o++) {
          const u = o * v - y;
          (w[e] = u * n),
            (w[t] = r * s),
            (w[i] = b),
            l.push(w.x, w.y, w.z),
            (w[e] = 0),
            (w[t] = 0),
            (w[i] = f > 0 ? 1 : -1),
            h.push(w.x, w.y, w.z),
            c.push(o / m),
            c.push(1 - a / g),
            (C += 1);
        }
      }
      for (let a = 0; a < g; a++)
        for (let e = 0; e < m; e++) {
          const t = u + e + E * a,
            i = u + e + E * (a + 1),
            n = u + (e + 1) + E * (a + 1),
            s = u + (e + 1) + E * a;
          o.push(t, i, s), o.push(i, n, s), (M += 6);
        }
      a.addGroup(d, M, _), (d += M), (u += C);
    }
    p("z", "y", "x", -1, -1, i, t, e, r, s, 0),
      p("z", "y", "x", 1, -1, i, t, -e, r, s, 1),
      p("x", "z", "y", 1, 1, e, i, t, n, r, 2),
      p("x", "z", "y", 1, -1, e, i, -t, n, r, 3),
      p("x", "y", "z", 1, -1, e, t, i, n, s, 4),
      p("x", "y", "z", -1, -1, e, t, -i, n, s, 5),
      this.setIndex(o),
      this.setAttribute("position", new Ki(l, 3)),
      this.setAttribute("normal", new Ki(h, 3)),
      this.setAttribute("uv", new Ki(c, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Cn(
      e.width,
      e.height,
      e.depth,
      e.widthSegments,
      e.heightSegments,
      e.depthSegments
    );
  }
}

function Tn(e) {
  return null === e.getRenderTarget() ? e.outputColorSpace : ge;
}
const In = { clone: clone, merge: merge };

class Pn extends Object3D {
  constructor() {
    super(),
      (this.isCamera = !0),
      (this.type = "Camera"),
      (this.matrixWorldInverse = new Matrix4()),
      (this.projectionMatrix = new Matrix4()),
      (this.projectionMatrixInverse = new Matrix4()),
      (this.coordinateSystem = Se);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.matrixWorldInverse.copy(e.matrixWorldInverse),
      this.projectionMatrix.copy(e.projectionMatrix),
      this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
      (this.coordinateSystem = e.coordinateSystem),
      this
    );
  }
  getWorldDirection(e) {
    this.updateWorldMatrix(!0, !1);
    const t = this.matrixWorld.elements;
    return e.set(-t[8], -t[9], -t[10]).normalize();
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  updateWorldMatrix(e, t) {
    super.updateWorldMatrix(e, t),
      this.matrixWorldInverse.copy(this.matrixWorld).invert();
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
class Dn extends Pn {
  constructor(e = 50, t = 1, i = 0.1, n = 2e3) {
    super(),
      (this.isPerspectiveCamera = !0),
      (this.type = "PerspectiveCamera"),
      (this.fov = e),
      (this.zoom = 1),
      (this.near = i),
      (this.far = n),
      (this.focus = 10),
      (this.aspect = t),
      (this.view = null),
      (this.filmGauge = 35),
      (this.filmOffset = 0),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.fov = e.fov),
      (this.zoom = e.zoom),
      (this.near = e.near),
      (this.far = e.far),
      (this.focus = e.focus),
      (this.aspect = e.aspect),
      (this.view = null === e.view ? null : Object.assign({}, e.view)),
      (this.filmGauge = e.filmGauge),
      (this.filmOffset = e.filmOffset),
      this
    );
  }
  setFocalLength(e) {
    const t = (0.5 * this.getFilmHeight()) / e;
    (this.fov = 2 * Re * Math.atan(t)), this.updateProjectionMatrix();
  }
  getFocalLength() {
    const e = Math.tan(0.5 * Ie * this.fov);
    return (0.5 * this.getFilmHeight()) / e;
  }
  getEffectiveFOV() {
    return 2 * Re * Math.atan(Math.tan(0.5 * Ie * this.fov) / this.zoom);
  }
  getFilmWidth() {
    return this.filmGauge * Math.min(this.aspect, 1);
  }
  getFilmHeight() {
    return this.filmGauge / Math.max(this.aspect, 1);
  }
  setViewOffset(e, t, i, n, s, r) {
    (this.aspect = e / t),
      null === this.view &&
        (this.view = {
          enabled: !0,
          fullWidth: 1,
          fullHeight: 1,
          offsetX: 0,
          offsetY: 0,
          width: 1,
          height: 1,
        }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = n),
      (this.view.width = s),
      (this.view.height = r),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = this.near;
    let t = (e * Math.tan(0.5 * Ie * this.fov)) / this.zoom,
      i = 2 * t,
      n = this.aspect * i,
      s = -0.5 * n;
    const r = this.view;
    if (null !== this.view && this.view.enabled) {
      const e = r.fullWidth,
        a = r.fullHeight;
      (s += (r.offsetX * n) / e),
        (t -= (r.offsetY * i) / a),
        (n *= r.width / e),
        (i *= r.height / a);
    }
    const a = this.filmOffset;
    0 !== a && (s += (e * a) / this.getFilmWidth()),
      this.projectionMatrix.makePerspective(
        s,
        s + n,
        t,
        t - i,
        e,
        this.far,
        this.coordinateSystem
      ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.fov = this.fov),
      (t.object.zoom = this.zoom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      (t.object.focus = this.focus),
      (t.object.aspect = this.aspect),
      null !== this.view && (t.object.view = Object.assign({}, this.view)),
      (t.object.filmGauge = this.filmGauge),
      (t.object.filmOffset = this.filmOffset),
      t
    );
  }
}
const Ln = -90;
class Fn extends Object3D {
  constructor(e, t, i) {
    super(),
      (this.type = "CubeCamera"),
      (this.renderTarget = i),
      (this.coordinateSystem = null);
    const n = new Dn(Ln, 1, e, t);
    (n.layers = this.layers), this.add(n);
    const s = new Dn(Ln, 1, e, t);
    (s.layers = this.layers), this.add(s);
    const r = new Dn(Ln, 1, e, t);
    (r.layers = this.layers), this.add(r);
    const a = new Dn(Ln, 1, e, t);
    (a.layers = this.layers), this.add(a);
    const o = new Dn(Ln, 1, e, t);
    (o.layers = this.layers), this.add(o);
    const l = new Dn(Ln, 1, e, t);
    (l.layers = this.layers), this.add(l);
  }
  updateCoordinateSystem() {
    const e = this.coordinateSystem,
      t = this.children.concat(),
      [i, n, s, r, a, o] = t;
    for (const l of t) this.remove(l);
    if (e === Se)
      i.up.set(0, 1, 0),
        i.lookAt(1, 0, 0),
        n.up.set(0, 1, 0),
        n.lookAt(-1, 0, 0),
        s.up.set(0, 0, -1),
        s.lookAt(0, 1, 0),
        r.up.set(0, 0, 1),
        r.lookAt(0, -1, 0),
        a.up.set(0, 1, 0),
        a.lookAt(0, 0, 1),
        o.up.set(0, 1, 0),
        o.lookAt(0, 0, -1);
    else {
      if (e !== Ce)
        throw new Error(
          "THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " +
            e
        );
      i.up.set(0, -1, 0),
        i.lookAt(-1, 0, 0),
        n.up.set(0, -1, 0),
        n.lookAt(1, 0, 0),
        s.up.set(0, 0, 1),
        s.lookAt(0, 1, 0),
        r.up.set(0, 0, -1),
        r.lookAt(0, -1, 0),
        a.up.set(0, -1, 0),
        a.lookAt(0, 0, 1),
        o.up.set(0, -1, 0),
        o.lookAt(0, 0, -1);
    }
    for (const l of t) this.add(l), l.updateMatrixWorld();
  }
  update(e, t) {
    null === this.parent && this.updateMatrixWorld();
    const i = this.renderTarget;
    this.coordinateSystem !== e.coordinateSystem &&
      ((this.coordinateSystem = e.coordinateSystem),
      this.updateCoordinateSystem());
    const [n, s, r, a, o, l] = this.children,
      h = e.getRenderTarget(),
      c = e.xr.enabled;
    e.xr.enabled = !1;
    const u = i.texture.generateMipmaps;
    (i.texture.generateMipmaps = !1),
      e.setRenderTarget(i, 0),
      e.render(t, n),
      e.setRenderTarget(i, 1),
      e.render(t, s),
      e.setRenderTarget(i, 2),
      e.render(t, r),
      e.setRenderTarget(i, 3),
      e.render(t, a),
      e.setRenderTarget(i, 4),
      e.render(t, o),
      (i.texture.generateMipmaps = u),
      e.setRenderTarget(i, 5),
      e.render(t, l),
      e.setRenderTarget(h),
      (e.xr.enabled = c),
      (i.texture.needsPMREMUpdate = !0);
  }
}
class Nn extends Texture {
  constructor(e, t, i, n, s, r, a, o, l, h) {
    super(
      (e = void 0 !== e ? e : []),
      (t = void 0 !== t ? t : E),
      i,
      n,
      s,
      r,
      a,
      o,
      l,
      h
    ),
      (this.isCubeTexture = !0),
      (this.flipY = !1);
  }
  get images() {
    return this.image;
  }
  set images(e) {
    this.image = e;
  }
}
class Bn extends ut {
  constructor(e = 1, t = {}) {
    super(e, e, t), (this.isWebGLCubeRenderTarget = !0);
    const i = { width: e, height: e, depth: 1 },
      n = [i, i, i, i, i, i];
    void 0 !== t.encoding &&
      (Xe(
        "THREE.WebGLCubeRenderTarget: option.encoding has been replaced by option.colorSpace."
      ),
      (t.colorSpace = t.encoding === pe ? me : fe)),
      (this.texture = new Nn(
        n,
        t.mapping,
        t.wrapS,
        t.wrapT,
        t.magFilter,
        t.minFilter,
        t.format,
        t.type,
        t.anisotropy,
        t.colorSpace
      )),
      (this.texture.isRenderTargetTexture = !0),
      (this.texture.generateMipmaps =
        void 0 !== t.generateMipmaps && t.generateMipmaps),
      (this.texture.minFilter = void 0 !== t.minFilter ? t.minFilter : L);
  }
  fromEquirectangularTexture(e, t) {
    (this.texture.type = t.type),
      (this.texture.colorSpace = t.colorSpace),
      (this.texture.generateMipmaps = t.generateMipmaps),
      (this.texture.minFilter = t.minFilter),
      (this.texture.magFilter = t.magFilter);
    const i = {
        uniforms: { tEquirect: { value: null } },
        vertexShader:
          "\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\tvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\n\t\t\t\t\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvWorldDirection = transformDirection( position, modelMatrix );\n\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t}\n\t\t\t",
        fragmentShader:
          "\n\n\t\t\t\tuniform sampler2D tEquirect;\n\n\t\t\t\tvarying vec3 vWorldDirection;\n\n\t\t\t\t#include <common>\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tvec3 direction = normalize( vWorldDirection );\n\n\t\t\t\t\tvec2 sampleUV = equirectUv( direction );\n\n\t\t\t\t\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\n\t\t\t\t}\n\t\t\t",
      },
      n = new Cn(5, 5, 5),
      s = new ShaderMaterial({
        name: "CubemapFromEquirect",
        uniforms: clone(i.uniforms),
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        side: c,
        blending: 0,
      });
    s.uniforms.tEquirect.value = t;
    const r = new En(n, s),
      a = t.minFilter;
    t.minFilter === N && (t.minFilter = L);
    return (
      new Fn(1, 10, this).update(e, r),
      (t.minFilter = a),
      r.geometry.dispose(),
      r.material.dispose(),
      this
    );
  }
  clear(e, t, i, n) {
    const s = e.getRenderTarget();
    for (let r = 0; r < 6; r++) e.setRenderTarget(this, r), e.clear(t, i, n);
    e.setRenderTarget(s);
  }
}
const kn = new Vector3(),
  On = new Vector3(),
  Un = new Matrix3();
class zn {
  constructor(e = new Vector3(1, 0, 0), t = 0) {
    (this.isPlane = !0), (this.normal = e), (this.constant = t);
  }
  set(e, t) {
    return this.normal.copy(e), (this.constant = t), this;
  }
  setComponents(e, t, i, n) {
    return this.normal.set(e, t, i), (this.constant = n), this;
  }
  setFromNormalAndCoplanarPoint(e, t) {
    return this.normal.copy(e), (this.constant = -t.dot(this.normal)), this;
  }
  setFromCoplanarPoints(e, t, i) {
    const n = kn.subVectors(i, t).cross(On.subVectors(e, t)).normalize();
    return this.setFromNormalAndCoplanarPoint(n, e), this;
  }
  copy(e) {
    return this.normal.copy(e.normal), (this.constant = e.constant), this;
  }
  normalize() {
    const e = 1 / this.normal.length();
    return this.normal.multiplyScalar(e), (this.constant *= e), this;
  }
  negate() {
    return (this.constant *= -1), this.normal.negate(), this;
  }
  distanceToPoint(e) {
    return this.normal.dot(e) + this.constant;
  }
  distanceToSphere(e) {
    return this.distanceToPoint(e.center) - e.radius;
  }
  projectPoint(e, t) {
    return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e));
  }
  intersectLine(e, t) {
    const i = e.delta(kn),
      n = this.normal.dot(i);
    if (0 === n)
      return 0 === this.distanceToPoint(e.start) ? t.copy(e.start) : null;
    const s = -(e.start.dot(this.normal) + this.constant) / n;
    return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(i, s);
  }
  intersectsLine(e) {
    const t = this.distanceToPoint(e.start),
      i = this.distanceToPoint(e.end);
    return (t < 0 && i > 0) || (i < 0 && t > 0);
  }
  intersectsBox(e) {
    return e.intersectsPlane(this);
  }
  intersectsSphere(e) {
    return e.intersectsPlane(this);
  }
  coplanarPoint(e) {
    return e.copy(this.normal).multiplyScalar(-this.constant);
  }
  applyMatrix4(e, t) {
    const i = t || Un.getNormalMatrix(e),
      n = this.coplanarPoint(kn).applyMatrix4(e),
      s = this.normal.applyMatrix3(i).normalize();
    return (this.constant = -n.dot(s)), this;
  }
  translate(e) {
    return (this.constant -= e.dot(this.normal)), this;
  }
  equals(e) {
    return e.normal.equals(this.normal) && e.constant === this.constant;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
const Gn = new kt(),
  Vn = new Vector3();
class Frustum {
  constructor(
    e = new zn(),
    t = new zn(),
    i = new zn(),
    n = new zn(),
    s = new zn(),
    r = new zn()
  ) {
    this.planes = [e, t, i, n, s, r];
  }
  set(e, t, i, n, s, r) {
    const a = this.planes;
    return (
      a[0].copy(e),
      a[1].copy(t),
      a[2].copy(i),
      a[3].copy(n),
      a[4].copy(s),
      a[5].copy(r),
      this
    );
  }
  copy(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) t[i].copy(e.planes[i]);
    return this;
  }
  setFromProjectionMatrix(e, t = 2e3) {
    const i = this.planes,
      n = e.elements,
      s = n[0],
      r = n[1],
      a = n[2],
      o = n[3],
      l = n[4],
      h = n[5],
      c = n[6],
      u = n[7],
      d = n[8],
      p = n[9],
      f = n[10],
      m = n[11],
      g = n[12],
      _ = n[13],
      v = n[14],
      A = n[15];
    if (
      (i[0].setComponents(o - s, u - l, m - d, A - g).normalize(),
      i[1].setComponents(o + s, u + l, m + d, A + g).normalize(),
      i[2].setComponents(o + r, u + h, m + p, A + _).normalize(),
      i[3].setComponents(o - r, u - h, m - p, A - _).normalize(),
      i[4].setComponents(o - a, u - c, m - f, A - v).normalize(),
      t === Se)
    )
      i[5].setComponents(o + a, u + c, m + f, A + v).normalize();
    else {
      if (t !== Ce)
        throw new Error(
          "THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " +
            t
        );
      i[5].setComponents(a, c, f, v).normalize();
    }
    return this;
  }
  intersectsObject(e) {
    if (void 0 !== e.boundingSphere)
      null === e.boundingSphere && e.computeBoundingSphere(),
        Gn.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
    else {
      const t = e.geometry;
      null === t.boundingSphere && t.computeBoundingSphere(),
        Gn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld);
    }
    return this.intersectsSphere(Gn);
  }
  intersectsSprite(e) {
    return (
      Gn.center.set(0, 0, 0),
      (Gn.radius = 0.7071067811865476),
      Gn.applyMatrix4(e.matrixWorld),
      this.intersectsSphere(Gn)
    );
  }
  intersectsSphere(e) {
    const t = this.planes,
      i = e.center,
      n = -e.radius;
    for (let s = 0; s < 6; s++) {
      if (t[s].distanceToPoint(i) < n) return !1;
    }
    return !0;
  }
  intersectsBox(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) {
      const n = t[i];
      if (
        ((Vn.x = n.normal.x > 0 ? e.max.x : e.min.x),
        (Vn.y = n.normal.y > 0 ? e.max.y : e.min.y),
        (Vn.z = n.normal.z > 0 ? e.max.z : e.min.z),
        n.distanceToPoint(Vn) < 0)
      )
        return !1;
    }
    return !0;
  }
  containsPoint(e) {
    const t = this.planes;
    for (let i = 0; i < 6; i++) if (t[i].distanceToPoint(e) < 0) return !1;
    return !0;
  }
  clone() {
    return new this.constructor().copy(this);
  }
}
function Hn() {
  let e = null,
    t = !1,
    i = null,
    n = null;
  function s(t, r) {
    i(t, r), (n = e.requestAnimationFrame(s));
  }
  return {
    start: function () {
      !0 !== t && null !== i && ((n = e.requestAnimationFrame(s)), (t = !0));
    },
    stop: function () {
      e.cancelAnimationFrame(n), (t = !1);
    },
    setAnimationLoop: function (e) {
      i = e;
    },
    setContext: function (t) {
      e = t;
    },
  };
}
function jn(e, t) {
  const i = t.isWebGL2,
    n = new WeakMap();
  return {
    get: function (e) {
      return e.isInterleavedBufferAttribute && (e = e.data), n.get(e);
    },
    remove: function (t) {
      t.isInterleavedBufferAttribute && (t = t.data);
      const i = n.get(t);
      i && (e.deleteBuffer(i.buffer), n.delete(t));
    },
    update: function (t, s) {
      if (t.isGLBufferAttribute) {
        const e = n.get(t);
        return void (
          (!e || e.version < t.version) &&
          n.set(t, {
            buffer: t.buffer,
            type: t.type,
            bytesPerElement: t.elementSize,
            version: t.version,
          })
        );
      }
      t.isInterleavedBufferAttribute && (t = t.data);
      const r = n.get(t);
      void 0 === r
        ? n.set(
            t,
            (function (t, n) {
              const s = t.array,
                r = t.usage,
                a = e.createBuffer();
              let o;
              if (
                (e.bindBuffer(n, a),
                e.bufferData(n, s, r),
                t.onUploadCallback(),
                s instanceof Float32Array)
              )
                o = e.FLOAT;
              else if (s instanceof Uint16Array)
                if (t.isFloat16BufferAttribute) {
                  if (!i)
                    throw new Error(
                      "THREE.WebGLAttributes: Usage of Float16BufferAttribute requires WebGL2."
                    );
                  o = e.HALF_FLOAT;
                } else o = e.UNSIGNED_SHORT;
              else if (s instanceof Int16Array) o = e.SHORT;
              else if (s instanceof Uint32Array) o = e.UNSIGNED_INT;
              else if (s instanceof Int32Array) o = e.INT;
              else if (s instanceof Int8Array) o = e.BYTE;
              else if (s instanceof Uint8Array) o = e.UNSIGNED_BYTE;
              else {
                if (!(s instanceof Uint8ClampedArray))
                  throw new Error(
                    "THREE.WebGLAttributes: Unsupported buffer data format: " +
                      s
                  );
                o = e.UNSIGNED_BYTE;
              }
              return {
                buffer: a,
                type: o,
                bytesPerElement: s.BYTES_PER_ELEMENT,
                version: t.version,
              };
            })(t, s)
          )
        : r.version < t.version &&
          (!(function (t, n, s) {
            const r = n.array,
              a = n.updateRange;
            e.bindBuffer(s, t),
              -1 === a.count
                ? e.bufferSubData(s, 0, r)
                : (i
                    ? e.bufferSubData(
                        s,
                        a.offset * r.BYTES_PER_ELEMENT,
                        r,
                        a.offset,
                        a.count
                      )
                    : e.bufferSubData(
                        s,
                        a.offset * r.BYTES_PER_ELEMENT,
                        r.subarray(a.offset, a.offset + a.count)
                      ),
                  (a.count = -1)),
              n.onUploadCallback();
          })(r.buffer, t, s),
          (r.version = t.version));
    },
  };
}
class PlaneGeometry extends rn {
  constructor(e = 1, t = 1, i = 1, n = 1) {
    super(),
      (this.type = "PlaneGeometry"),
      (this.parameters = {
        width: e,
        height: t,
        widthSegments: i,
        heightSegments: n,
      });
    const s = e / 2,
      r = t / 2,
      a = Math.floor(i),
      o = Math.floor(n),
      l = a + 1,
      h = o + 1,
      c = e / a,
      u = t / o,
      d = [],
      p = [],
      f = [],
      m = [];
    for (let g = 0; g < h; g++) {
      const e = g * u - r;
      for (let t = 0; t < l; t++) {
        const i = t * c - s;
        p.push(i, -e, 0), f.push(0, 0, 1), m.push(t / a), m.push(1 - g / o);
      }
    }
    for (let g = 0; g < o; g++)
      for (let e = 0; e < a; e++) {
        const t = e + l * g,
          i = e + l * (g + 1),
          n = e + 1 + l * (g + 1),
          s = e + 1 + l * g;
        d.push(t, i, s), d.push(i, n, s);
      }
    this.setIndex(d),
      this.setAttribute("position", new Ki(p, 3)),
      this.setAttribute("normal", new Ki(f, 3)),
      this.setAttribute("uv", new Ki(m, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new PlaneGeometry(
      e.width,
      e.height,
      e.widthSegments,
      e.heightSegments
    );
  }
}
const qn = {
    alphahash_fragment:
      "#ifdef USE_ALPHAHASH\n\tif ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;\n#endif",
    alphahash_pars_fragment:
      "#ifdef USE_ALPHAHASH\n\tconst float ALPHA_HASH_SCALE = 0.05;\n\tfloat hash2D( vec2 value ) {\n\t\treturn fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );\n\t}\n\tfloat hash3D( vec3 value ) {\n\t\treturn hash2D( vec2( hash2D( value.xy ), value.z ) );\n\t}\n\tfloat getAlphaHashThreshold( vec3 position ) {\n\t\tfloat maxDeriv = max(\n\t\t\tlength( dFdx( position.xyz ) ),\n\t\t\tlength( dFdy( position.xyz ) )\n\t\t);\n\t\tfloat pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );\n\t\tvec2 pixScales = vec2(\n\t\t\texp2( floor( log2( pixScale ) ) ),\n\t\t\texp2( ceil( log2( pixScale ) ) )\n\t\t);\n\t\tvec2 alpha = vec2(\n\t\t\thash3D( floor( pixScales.x * position.xyz ) ),\n\t\t\thash3D( floor( pixScales.y * position.xyz ) )\n\t\t);\n\t\tfloat lerpFactor = fract( log2( pixScale ) );\n\t\tfloat x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;\n\t\tfloat a = min( lerpFactor, 1.0 - lerpFactor );\n\t\tvec3 cases = vec3(\n\t\t\tx * x / ( 2.0 * a * ( 1.0 - a ) ),\n\t\t\t( x - 0.5 * a ) / ( 1.0 - a ),\n\t\t\t1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )\n\t\t);\n\t\tfloat threshold = ( x < ( 1.0 - a ) )\n\t\t\t? ( ( x < a ) ? cases.x : cases.y )\n\t\t\t: cases.z;\n\t\treturn clamp( threshold , 1.0e-6, 1.0 );\n\t}\n#endif",
    alphamap_fragment:
      "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;\n#endif",
    alphamap_pars_fragment:
      "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    alphatest_fragment:
      "#ifdef USE_ALPHATEST\n\tif ( diffuseColor.a < alphaTest ) discard;\n#endif",
    alphatest_pars_fragment:
      "#ifdef USE_ALPHATEST\n\tuniform float alphaTest;\n#endif",
    aomap_fragment:
      "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( STANDARD )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );\n\t#endif\n#endif",
    aomap_pars_fragment:
      "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif",
    begin_vertex:
      "vec3 transformed = vec3( position );\n#ifdef USE_ALPHAHASH\n\tvPosition = vec3( position );\n#endif",
    beginnormal_vertex:
      "vec3 objectNormal = vec3( normal );\n#ifdef USE_TANGENT\n\tvec3 objectTangent = vec3( tangent.xyz );\n#endif",
    bsdfs:
      "float G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, 1.0, dotVH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n} // validated",
    iridescence_fragment:
      "#ifdef USE_IRIDESCENCE\n\tconst mat3 XYZ_TO_REC709 = mat3(\n\t\t 3.2404542, -0.9692660,  0.0556434,\n\t\t-1.5371385,  1.8760108, -0.2040259,\n\t\t-0.4985314,  0.0415560,  1.0572252\n\t);\n\tvec3 Fresnel0ToIor( vec3 fresnel0 ) {\n\t\tvec3 sqrtF0 = sqrt( fresnel0 );\n\t\treturn ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );\n\t}\n\tvec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );\n\t}\n\tfloat IorToFresnel0( float transmittedIor, float incidentIor ) {\n\t\treturn pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));\n\t}\n\tvec3 evalSensitivity( float OPD, vec3 shift ) {\n\t\tfloat phase = 2.0 * PI * OPD * 1.0e-9;\n\t\tvec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );\n\t\tvec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );\n\t\tvec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );\n\t\tvec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );\n\t\txyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );\n\t\txyz /= 1.0685e-7;\n\t\tvec3 rgb = XYZ_TO_REC709 * xyz;\n\t\treturn rgb;\n\t}\n\tvec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {\n\t\tvec3 I;\n\t\tfloat iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );\n\t\tfloat sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );\n\t\tfloat cosTheta2Sq = 1.0 - sinTheta2Sq;\n\t\tif ( cosTheta2Sq < 0.0 ) {\n\t\t\treturn vec3( 1.0 );\n\t\t}\n\t\tfloat cosTheta2 = sqrt( cosTheta2Sq );\n\t\tfloat R0 = IorToFresnel0( iridescenceIOR, outsideIOR );\n\t\tfloat R12 = F_Schlick( R0, 1.0, cosTheta1 );\n\t\tfloat T121 = 1.0 - R12;\n\t\tfloat phi12 = 0.0;\n\t\tif ( iridescenceIOR < outsideIOR ) phi12 = PI;\n\t\tfloat phi21 = PI - phi12;\n\t\tvec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );\t\tvec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );\n\t\tvec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );\n\t\tvec3 phi23 = vec3( 0.0 );\n\t\tif ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;\n\t\tif ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;\n\t\tif ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;\n\t\tfloat OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;\n\t\tvec3 phi = vec3( phi21 ) + phi23;\n\t\tvec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );\n\t\tvec3 r123 = sqrt( R123 );\n\t\tvec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );\n\t\tvec3 C0 = R12 + Rs;\n\t\tI = C0;\n\t\tvec3 Cm = Rs - T121;\n\t\tfor ( int m = 1; m <= 2; ++ m ) {\n\t\t\tCm *= r123;\n\t\t\tvec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );\n\t\t\tI += Cm * Sm;\n\t\t}\n\t\treturn max( I, vec3( 0.0 ) );\n\t}\n#endif",
    bumpmap_pars_fragment:
      "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vBumpMapUv );\n\t\tvec2 dSTdy = dFdy( vBumpMapUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos.xyz );\n\t\tvec3 vSigmaY = dFdy( surf_pos.xyz );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 ) * faceDirection;\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif",
    clipping_planes_fragment:
      "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#pragma unroll_loop_end\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t\tif ( clipped ) discard;\n\t#endif\n#endif",
    clipping_planes_pars_fragment:
      "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif",
    clipping_planes_pars_vertex:
      "#if NUM_CLIPPING_PLANES > 0\n\tvarying vec3 vClipPosition;\n#endif",
    clipping_planes_vertex:
      "#if NUM_CLIPPING_PLANES > 0\n\tvClipPosition = - mvPosition.xyz;\n#endif",
    color_fragment:
      "#if defined( USE_COLOR_ALPHA )\n\tdiffuseColor *= vColor;\n#elif defined( USE_COLOR )\n\tdiffuseColor.rgb *= vColor;\n#endif",
    color_pars_fragment:
      "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_pars_vertex:
      "#if defined( USE_COLOR_ALPHA )\n\tvarying vec4 vColor;\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvarying vec3 vColor;\n#endif",
    color_vertex:
      "#if defined( USE_COLOR_ALPHA )\n\tvColor = vec4( 1.0 );\n#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR )\n\tvColor = vec3( 1.0 );\n#endif\n#ifdef USE_COLOR\n\tvColor *= color;\n#endif\n#ifdef USE_INSTANCING_COLOR\n\tvColor.xyz *= instanceColor.xyz;\n#endif",
    common:
      "#define PI 3.141592653589793\n#define PI2 6.283185307179586\n#define PI_HALF 1.5707963267948966\n#define RECIPROCAL_PI 0.3183098861837907\n#define RECIPROCAL_PI2 0.15915494309189535\n#define EPSILON 1e-6\n#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\n#define whiteComplement( a ) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nvec3 pow2( const in vec3 x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }\nfloat average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract( sin( sn ) * c );\n}\n#ifdef HIGH_PRECISION\n\tfloat precisionSafeLength( vec3 v ) { return length( v ); }\n#else\n\tfloat precisionSafeLength( vec3 v ) {\n\t\tfloat maxComponent = max3( abs( v ) );\n\t\treturn length( v / maxComponent ) * maxComponent;\n\t}\n#endif\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal;\n#endif\n};\n#ifdef USE_ALPHAHASH\n\tvarying vec3 vPosition;\n#endif\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat luminance( const in vec3 rgb ) {\n\tconst vec3 weights = vec3( 0.2126729, 0.7151522, 0.0721750 );\n\treturn dot( weights, rgb );\n}\nbool isPerspectiveMatrix( mat4 m ) {\n\treturn m[ 2 ][ 3 ] == - 1.0;\n}\nvec2 equirectUv( in vec3 dir ) {\n\tfloat u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;\n\tfloat v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\treturn vec2( u, v );\n}\nvec3 BRDF_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n}\nfloat F_Schlick( const in float f0, const in float f90, const in float dotVH ) {\n\tfloat fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );\n\treturn f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );\n} // validated",
    cube_uv_reflection_fragment:
      "#ifdef ENVMAP_TYPE_CUBE_UV\n\t#define cubeUV_minMipLevel 4.0\n\t#define cubeUV_minTileSize 16.0\n\tfloat getFace( vec3 direction ) {\n\t\tvec3 absDirection = abs( direction );\n\t\tfloat face = - 1.0;\n\t\tif ( absDirection.x > absDirection.z ) {\n\t\t\tif ( absDirection.x > absDirection.y )\n\t\t\t\tface = direction.x > 0.0 ? 0.0 : 3.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t} else {\n\t\t\tif ( absDirection.z > absDirection.y )\n\t\t\t\tface = direction.z > 0.0 ? 2.0 : 5.0;\n\t\t\telse\n\t\t\t\tface = direction.y > 0.0 ? 1.0 : 4.0;\n\t\t}\n\t\treturn face;\n\t}\n\tvec2 getUV( vec3 direction, float face ) {\n\t\tvec2 uv;\n\t\tif ( face == 0.0 ) {\n\t\t\tuv = vec2( direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 1.0 ) {\n\t\t\tuv = vec2( - direction.x, - direction.z ) / abs( direction.y );\n\t\t} else if ( face == 2.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.y ) / abs( direction.z );\n\t\t} else if ( face == 3.0 ) {\n\t\t\tuv = vec2( - direction.z, direction.y ) / abs( direction.x );\n\t\t} else if ( face == 4.0 ) {\n\t\t\tuv = vec2( - direction.x, direction.z ) / abs( direction.y );\n\t\t} else {\n\t\t\tuv = vec2( direction.x, direction.y ) / abs( direction.z );\n\t\t}\n\t\treturn 0.5 * ( uv + 1.0 );\n\t}\n\tvec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {\n\t\tfloat face = getFace( direction );\n\t\tfloat filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );\n\t\tmipInt = max( mipInt, cubeUV_minMipLevel );\n\t\tfloat faceSize = exp2( mipInt );\n\t\thighp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;\n\t\tif ( face > 2.0 ) {\n\t\t\tuv.y += faceSize;\n\t\t\tface -= 3.0;\n\t\t}\n\t\tuv.x += face * faceSize;\n\t\tuv.x += filterInt * 3.0 * cubeUV_minTileSize;\n\t\tuv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );\n\t\tuv.x *= CUBEUV_TEXEL_WIDTH;\n\t\tuv.y *= CUBEUV_TEXEL_HEIGHT;\n\t\t#ifdef texture2DGradEXT\n\t\t\treturn texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;\n\t\t#else\n\t\t\treturn texture2D( envMap, uv ).rgb;\n\t\t#endif\n\t}\n\t#define cubeUV_r0 1.0\n\t#define cubeUV_v0 0.339\n\t#define cubeUV_m0 - 2.0\n\t#define cubeUV_r1 0.8\n\t#define cubeUV_v1 0.276\n\t#define cubeUV_m1 - 1.0\n\t#define cubeUV_r4 0.4\n\t#define cubeUV_v4 0.046\n\t#define cubeUV_m4 2.0\n\t#define cubeUV_r5 0.305\n\t#define cubeUV_v5 0.016\n\t#define cubeUV_m5 3.0\n\t#define cubeUV_r6 0.21\n\t#define cubeUV_v6 0.0038\n\t#define cubeUV_m6 4.0\n\tfloat roughnessToMip( float roughness ) {\n\t\tfloat mip = 0.0;\n\t\tif ( roughness >= cubeUV_r1 ) {\n\t\t\tmip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;\n\t\t} else if ( roughness >= cubeUV_r4 ) {\n\t\t\tmip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;\n\t\t} else if ( roughness >= cubeUV_r5 ) {\n\t\t\tmip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;\n\t\t} else if ( roughness >= cubeUV_r6 ) {\n\t\t\tmip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;\n\t\t} else {\n\t\t\tmip = - 2.0 * log2( 1.16 * roughness );\t\t}\n\t\treturn mip;\n\t}\n\tvec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {\n\t\tfloat mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );\n\t\tfloat mipF = fract( mip );\n\t\tfloat mipInt = floor( mip );\n\t\tvec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );\n\t\tif ( mipF == 0.0 ) {\n\t\t\treturn vec4( color0, 1.0 );\n\t\t} else {\n\t\t\tvec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );\n\t\t\treturn vec4( mix( color0, color1, mipF ), 1.0 );\n\t\t}\n\t}\n#endif",
    defaultnormal_vertex:
      "vec3 transformedNormal = objectNormal;\n#ifdef USE_INSTANCING\n\tmat3 m = mat3( instanceMatrix );\n\ttransformedNormal /= vec3( dot( m[ 0 ], m[ 0 ] ), dot( m[ 1 ], m[ 1 ] ), dot( m[ 2 ], m[ 2 ] ) );\n\ttransformedNormal = m * transformedNormal;\n#endif\ntransformedNormal = normalMatrix * transformedNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif\n#ifdef USE_TANGENT\n\tvec3 transformedTangent = ( modelViewMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#ifdef FLIP_SIDED\n\t\ttransformedTangent = - transformedTangent;\n\t#endif\n#endif",
    displacementmap_pars_vertex:
      "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif",
    displacementmap_vertex:
      "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );\n#endif",
    emissivemap_fragment:
      "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif",
    emissivemap_pars_fragment:
      "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif",
    colorspace_fragment: "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    colorspace_pars_fragment:
      "vec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}",
    envmap_fragment:
      "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvec3 cameraToFrag;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToFrag = normalize( vWorldPosition - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToFrag, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif",
    envmap_common_pars_fragment:
      "#ifdef USE_ENVMAP\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\t\n#endif",
    envmap_pars_fragment:
      "#ifdef USE_ENVMAP\n\tuniform float reflectivity;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\tvarying vec3 vWorldPosition;\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif",
    envmap_pars_vertex:
      "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )\n\t\t#define ENV_WORLDPOS\n\t#endif\n\t#ifdef ENV_WORLDPOS\n\t\t\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif",
    envmap_physical_pars_fragment:
      "#ifdef USE_ENVMAP\n\tvec3 getIBLIrradiance( const in vec3 normal ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, worldNormal, 1.0 );\n\t\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\tvec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {\n\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\tvec3 reflectVec = reflect( - viewDir, normal );\n\t\t\treflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );\n\t\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, reflectVec, roughness );\n\t\t\treturn envMapColor.rgb * envMapIntensity;\n\t\t#else\n\t\t\treturn vec3( 0.0 );\n\t\t#endif\n\t}\n\t#ifdef USE_ANISOTROPY\n\t\tvec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {\n\t\t\t#ifdef ENVMAP_TYPE_CUBE_UV\n\t\t\t\tvec3 bentNormal = cross( bitangent, viewDir );\n\t\t\t\tbentNormal = normalize( cross( bentNormal, bitangent ) );\n\t\t\t\tbentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );\n\t\t\t\treturn getIBLRadiance( viewDir, bentNormal, roughness );\n\t\t\t#else\n\t\t\t\treturn vec3( 0.0 );\n\t\t\t#endif\n\t\t}\n\t#endif\n#endif",
    envmap_vertex:
      "#ifdef USE_ENVMAP\n\t#ifdef ENV_WORLDPOS\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex;\n\t\tif ( isOrthographic ) {\n\t\t\tcameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );\n\t\t} else {\n\t\t\tcameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\t}\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif",
    fog_vertex: "#ifdef USE_FOG\n\tvFogDepth = - mvPosition.z;\n#endif",
    fog_pars_vertex: "#ifdef USE_FOG\n\tvarying float vFogDepth;\n#endif",
    fog_fragment:
      "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, vFogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif",
    fog_pars_fragment:
      "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float vFogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif",
    gradientmap_pars_fragment:
      "#ifdef USE_GRADIENTMAP\n\tuniform sampler2D gradientMap;\n#endif\nvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\tfloat dotNL = dot( normal, lightDirection );\n\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t#ifdef USE_GRADIENTMAP\n\t\treturn vec3( texture2D( gradientMap, coord ).r );\n\t#else\n\t\tvec2 fw = fwidth( coord ) * 0.5;\n\t\treturn mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );\n\t#endif\n}",
    lightmap_fragment:
      "#ifdef USE_LIGHTMAP\n\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\treflectedLight.indirectDiffuse += lightMapIrradiance;\n#endif",
    lightmap_pars_fragment:
      "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif",
    lights_lambert_fragment:
      "LambertMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularStrength = specularStrength;",
    lights_lambert_pars_fragment:
      "varying vec3 vViewPosition;\nstruct LambertMaterial {\n\tvec3 diffuseColor;\n\tfloat specularStrength;\n};\nvoid RE_Direct_Lambert( const in IncidentLight directLight, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in GeometricContext geometry, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Lambert\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Lambert",
    lights_pars_begin:
      "uniform bool receiveShadow;\nuniform vec3 ambientLightColor;\nuniform vec3 lightProbe[ 9 ];\nvec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {\n\tfloat x = normal.x, y = normal.y, z = normal.z;\n\tvec3 result = shCoefficients[ 0 ] * 0.886227;\n\tresult += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;\n\tresult += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;\n\tresult += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;\n\tresult += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;\n\tresult += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;\n\tresult += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );\n\tresult += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;\n\tresult += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );\n\treturn result;\n}\nvec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {\n\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\tvec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );\n\treturn irradiance;\n}\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\treturn irradiance;\n}\nfloat getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t#if defined ( LEGACY_LIGHTS )\n\t\tif ( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\t\treturn pow( saturate( - lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t\t}\n\t\treturn 1.0;\n\t#else\n\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\tif ( cutoffDistance > 0.0 ) {\n\t\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t}\n\t\treturn distanceFalloff;\n\t#endif\n}\nfloat getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {\n\treturn smoothstep( coneCosine, penumbraCosine, angleCosine );\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalLightInfo( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tlight.color = directionalLight.color;\n\t\tlight.direction = directionalLight.direction;\n\t\tlight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointLightInfo( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tlight.color = pointLight.color;\n\t\tlight.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );\n\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotLightInfo( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight light ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tlight.direction = normalize( lVector );\n\t\tfloat angleCos = dot( light.direction, spotLight.direction );\n\t\tfloat spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\tif ( spotAttenuation > 0.0 ) {\n\t\t\tfloat lightDistance = length( lVector );\n\t\t\tlight.color = spotLight.color * spotAttenuation;\n\t\t\tlight.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tlight.visible = ( light.color != vec3( 0.0 ) );\n\t\t} else {\n\t\t\tlight.color = vec3( 0.0 );\n\t\t\tlight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {\n\t\tfloat dotNL = dot( normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\treturn irradiance;\n\t}\n#endif",
    lights_toon_fragment:
      "ToonMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;",
    lights_toon_pars_fragment:
      "varying vec3 vViewPosition;\nstruct ToonMaterial {\n\tvec3 diffuseColor;\n};\nvoid RE_Direct_Toon( const in IncidentLight directLight, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in GeometricContext geometry, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_Toon\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Toon",
    lights_phong_fragment:
      "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;",
    lights_phong_pars_fragment:
      "varying vec3 vViewPosition;\nstruct BlinnPhongMaterial {\n\tvec3 diffuseColor;\n\tvec3 specularColor;\n\tfloat specularShininess;\n\tfloat specularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometry.viewDir, geometry.normal, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong",
    lights_physical_fragment:
      "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nvec3 dxy = max( abs( dFdx( geometryNormal ) ), abs( dFdy( geometryNormal ) ) );\nfloat geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );\nmaterial.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;\nmaterial.roughness = min( material.roughness, 1.0 );\n#ifdef IOR\n\tmaterial.ior = ior;\n\t#ifdef USE_SPECULAR\n\t\tfloat specularIntensityFactor = specularIntensity;\n\t\tvec3 specularColorFactor = specularColor;\n\t\t#ifdef USE_SPECULAR_COLORMAP\n\t\t\tspecularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;\n\t\t#endif\n\t\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\t\tspecularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;\n\t\t#endif\n\t\tmaterial.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );\n\t#else\n\t\tfloat specularIntensityFactor = 1.0;\n\t\tvec3 specularColorFactor = vec3( 1.0 );\n\t\tmaterial.specularF90 = 1.0;\n\t#endif\n\tmaterial.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.specularF90 = 1.0;\n#endif\n#ifdef USE_CLEARCOAT\n\tmaterial.clearcoat = clearcoat;\n\tmaterial.clearcoatRoughness = clearcoatRoughness;\n\tmaterial.clearcoatF0 = vec3( 0.04 );\n\tmaterial.clearcoatF90 = 1.0;\n\t#ifdef USE_CLEARCOATMAP\n\t\tmaterial.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;\n\t#endif\n\t#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\t\tmaterial.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;\n\t#endif\n\tmaterial.clearcoat = saturate( material.clearcoat );\tmaterial.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );\n\tmaterial.clearcoatRoughness += geometryRoughness;\n\tmaterial.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );\n#endif\n#ifdef USE_IRIDESCENCE\n\tmaterial.iridescence = iridescence;\n\tmaterial.iridescenceIOR = iridescenceIOR;\n\t#ifdef USE_IRIDESCENCEMAP\n\t\tmaterial.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;\n\t#endif\n\t#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\t\tmaterial.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;\n\t#else\n\t\tmaterial.iridescenceThickness = iridescenceThicknessMaximum;\n\t#endif\n#endif\n#ifdef USE_SHEEN\n\tmaterial.sheenColor = sheenColor;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tmaterial.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;\n\t#endif\n\tmaterial.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tmaterial.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\t#ifdef USE_ANISOTROPYMAP\n\t\tmat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );\n\t\tvec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;\n\t\tvec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;\n\t#else\n\t\tvec2 anisotropyV = anisotropyVector;\n\t#endif\n\tmaterial.anisotropy = length( anisotropyV );\n\tanisotropyV /= material.anisotropy;\n\tmaterial.anisotropy = saturate( material.anisotropy );\n\tmaterial.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );\n\tmaterial.anisotropyT = tbn[ 0 ] * anisotropyV.x - tbn[ 1 ] * anisotropyV.y;\n\tmaterial.anisotropyB = tbn[ 1 ] * anisotropyV.x + tbn[ 0 ] * anisotropyV.y;\n#endif",
    lights_physical_pars_fragment:
      "struct PhysicalMaterial {\n\tvec3 diffuseColor;\n\tfloat roughness;\n\tvec3 specularColor;\n\tfloat specularF90;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat clearcoat;\n\t\tfloat clearcoatRoughness;\n\t\tvec3 clearcoatF0;\n\t\tfloat clearcoatF90;\n\t#endif\n\t#ifdef USE_IRIDESCENCE\n\t\tfloat iridescence;\n\t\tfloat iridescenceIOR;\n\t\tfloat iridescenceThickness;\n\t\tvec3 iridescenceFresnel;\n\t\tvec3 iridescenceF0;\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tvec3 sheenColor;\n\t\tfloat sheenRoughness;\n\t#endif\n\t#ifdef IOR\n\t\tfloat ior;\n\t#endif\n\t#ifdef USE_TRANSMISSION\n\t\tfloat transmission;\n\t\tfloat transmissionAlpha;\n\t\tfloat thickness;\n\t\tfloat attenuationDistance;\n\t\tvec3 attenuationColor;\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat anisotropy;\n\t\tfloat alphaT;\n\t\tvec3 anisotropyT;\n\t\tvec3 anisotropyB;\n\t#endif\n};\nvec3 clearcoatSpecular = vec3( 0.0 );\nvec3 sheenSpecular = vec3( 0.0 );\nvec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {\n    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );\n    float x2 = x * x;\n    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );\n    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );\n}\nfloat V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\n#ifdef USE_ANISOTROPY\n\tfloat V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {\n\t\tfloat gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );\n\t\tfloat gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );\n\t\tfloat v = 0.5 / ( gv + gl );\n\t\treturn saturate(v);\n\t}\n\tfloat D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {\n\t\tfloat a2 = alphaT * alphaB;\n\t\thighp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );\n\t\thighp float v2 = dot( v, v );\n\t\tfloat w2 = a2 / v2;\n\t\treturn RECIPROCAL_PI * a2 * pow2 ( w2 );\n\t}\n#endif\n#ifdef USE_CLEARCOAT\n\tvec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {\n\t\tvec3 f0 = material.clearcoatF0;\n\t\tfloat f90 = material.clearcoatF90;\n\t\tfloat roughness = material.clearcoatRoughness;\n\t\tfloat alpha = pow2( roughness );\n\t\tvec3 halfDir = normalize( lightDir + viewDir );\n\t\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\t\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\t\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\t\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\t\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t\treturn F * ( V * D );\n\t}\n#endif\nvec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {\n\tvec3 f0 = material.specularColor;\n\tfloat f90 = material.specularF90;\n\tfloat roughness = material.roughness;\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat dotVH = saturate( dot( viewDir, halfDir ) );\n\tvec3 F = F_Schlick( f0, f90, dotVH );\n\t#ifdef USE_IRIDESCENCE\n\t\tF = mix( F, material.iridescenceFresnel, material.iridescence );\n\t#endif\n\t#ifdef USE_ANISOTROPY\n\t\tfloat dotTL = dot( material.anisotropyT, lightDir );\n\t\tfloat dotTV = dot( material.anisotropyT, viewDir );\n\t\tfloat dotTH = dot( material.anisotropyT, halfDir );\n\t\tfloat dotBL = dot( material.anisotropyB, lightDir );\n\t\tfloat dotBV = dot( material.anisotropyB, viewDir );\n\t\tfloat dotBH = dot( material.anisotropyB, halfDir );\n\t\tfloat V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );\n\t\tfloat D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );\n\t#else\n\t\tfloat V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\t\tfloat D = D_GGX( alpha, dotNH );\n\t#endif\n\treturn F * ( V * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\n#if defined( USE_SHEEN )\nfloat D_Charlie( float roughness, float dotNH ) {\n\tfloat alpha = pow2( roughness );\n\tfloat invAlpha = 1.0 / alpha;\n\tfloat cos2h = dotNH * dotNH;\n\tfloat sin2h = max( 1.0 - cos2h, 0.0078125 );\n\treturn ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );\n}\nfloat V_Neubelt( float dotNV, float dotNL ) {\n\treturn saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );\n}\nvec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {\n\tvec3 halfDir = normalize( lightDir + viewDir );\n\tfloat dotNL = saturate( dot( normal, lightDir ) );\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat dotNH = saturate( dot( normal, halfDir ) );\n\tfloat D = D_Charlie( sheenRoughness, dotNH );\n\tfloat V = V_Neubelt( dotNV, dotNL );\n\treturn sheenColor * ( D * V );\n}\n#endif\nfloat IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tfloat r2 = roughness * roughness;\n\tfloat a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;\n\tfloat b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;\n\tfloat DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );\n\treturn saturate( DG * RECIPROCAL_PI );\n}\nvec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {\n\tfloat dotNV = saturate( dot( normal, viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;\n\treturn fab;\n}\nvec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\treturn specularColor * fab.x + specularF90 * fab.y;\n}\n#ifdef USE_IRIDESCENCE\nvoid computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#else\nvoid computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n#endif\n\tvec2 fab = DFGApprox( normal, viewDir, roughness );\n\t#ifdef USE_IRIDESCENCE\n\t\tvec3 Fr = mix( specularColor, iridescenceF0, iridescence );\n\t#else\n\t\tvec3 Fr = specularColor;\n\t#endif\n\tvec3 FssEss = Fr * fab.x + specularF90 * fab.y;\n\tfloat Ess = fab.x + fab.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.roughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNLcc = saturate( dot( geometry.clearcoatNormal, directLight.direction ) );\n\t\tvec3 ccIrradiance = dotNLcc * directLight.color;\n\t\tclearcoatSpecular += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometry.viewDir, geometry.clearcoatNormal, material );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * BRDF_Sheen( directLight.direction, geometry.viewDir, geometry.normal, material.sheenColor, material.sheenRoughness );\n\t#endif\n\treflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometry.viewDir, geometry.normal, material );\n\treflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatSpecular += clearcoatRadiance * EnvironmentBRDF( geometry.clearcoatNormal, geometry.viewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );\n\t#endif\n\t#ifdef USE_SHEEN\n\t\tsheenSpecular += irradiance * material.sheenColor * IBLSheenBRDF( geometry.normal, geometry.viewDir, material.sheenRoughness );\n\t#endif\n\tvec3 singleScattering = vec3( 0.0 );\n\tvec3 multiScattering = vec3( 0.0 );\n\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t#ifdef USE_IRIDESCENCE\n\t\tcomputeMultiscatteringIridescence( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );\n\t#else\n\t\tcomputeMultiscattering( geometry.normal, geometry.viewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );\n\t#endif\n\tvec3 totalScattering = singleScattering + multiScattering;\n\tvec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );\n\treflectedLight.indirectSpecular += radiance * singleScattering;\n\treflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;\n\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}",
    lights_fragment_begin:
      "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );\n#ifdef USE_CLEARCOAT\n\tgeometry.clearcoatNormal = clearcoatNormal;\n#endif\n#ifdef USE_IRIDESCENCE\n\tfloat dotNVi = saturate( dot( normal, geometry.viewDir ) );\n\tif ( material.iridescenceThickness == 0.0 ) {\n\t\tmaterial.iridescence = 0.0;\n\t} else {\n\t\tmaterial.iridescence = saturate( material.iridescence );\n\t}\n\tif ( material.iridescence > 0.0 ) {\n\t\tmaterial.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );\n\t\tmaterial.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );\n\t}\n#endif\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointLightInfo( pointLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )\n\t\tpointLightShadow = pointLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tvec4 spotColor;\n\tvec3 spotLightCoord;\n\tbool inSpotLightMap;\n\t#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotLightInfo( spotLight, geometry, directLight );\n\t\t#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX\n\t\t#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS\n\t\t#else\n\t\t#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )\n\t\t#endif\n\t\t#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )\n\t\t\tspotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;\n\t\t\tinSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );\n\t\t\tspotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );\n\t\t\tdirectLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;\n\t\t#endif\n\t\t#undef SPOT_LIGHT_MAP_INDEX\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\tspotLightShadow = spotLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLightShadow;\n\t#endif\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalLightInfo( directionalLight, geometry, directLight );\n\t\t#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )\n\t\tdirectionalLightShadow = directionalLightShadows[ i ];\n\t\tdirectLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n\t#pragma unroll_loop_end\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 iblIrradiance = vec3( 0.0 );\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\tirradiance += getLightProbeIrradiance( lightProbe, geometry.normal );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry.normal );\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearcoatRadiance = vec3( 0.0 );\n#endif",
    lights_fragment_maps:
      "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\tvec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tiblIrradiance += getIBLIrradiance( geometry.normal );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\t#ifdef USE_ANISOTROPY\n\t\tradiance += getIBLAnisotropyRadiance( geometry.viewDir, geometry.normal, material.roughness, material.anisotropyB, material.anisotropy );\n\t#else\n\t\tradiance += getIBLRadiance( geometry.viewDir, geometry.normal, material.roughness );\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tclearcoatRadiance += getIBLRadiance( geometry.viewDir, geometry.clearcoatNormal, material.clearcoatRoughness );\n\t#endif\n#endif",
    lights_fragment_end:
      "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometry, material, reflectedLight );\n#endif",
    logdepthbuf_fragment:
      "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif",
    logdepthbuf_pars_fragment:
      "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n\tvarying float vIsPerspective;\n#endif",
    logdepthbuf_pars_vertex:
      "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t\tvarying float vIsPerspective;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif",
    logdepthbuf_vertex:
      "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t\tvIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );\n\t#else\n\t\tif ( isPerspectiveMatrix( projectionMatrix ) ) {\n\t\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\t\tgl_Position.z *= gl_Position.w;\n\t\t}\n\t#endif\n#endif",
    map_fragment:
      "#ifdef USE_MAP\n\tvec4 sampledDiffuseColor = texture2D( map, vMapUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\tsampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\t\n\t#endif\n\tdiffuseColor *= sampledDiffuseColor;\n#endif",
    map_pars_fragment: "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif",
    map_particle_fragment:
      "#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t#if defined( USE_POINTS_UV )\n\t\tvec2 uv = vUv;\n\t#else\n\t\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tdiffuseColor *= texture2D( map, uv );\n#endif\n#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, uv ).g;\n#endif",
    map_particle_pars_fragment:
      "#if defined( USE_POINTS_UV )\n\tvarying vec2 vUv;\n#else\n\t#if defined( USE_MAP ) || defined( USE_ALPHAMAP )\n\t\tuniform mat3 uvTransform;\n\t#endif\n#endif\n#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif",
    metalnessmap_fragment:
      "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif",
    metalnessmap_pars_fragment:
      "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif",
    morphcolor_vertex:
      "#if defined( USE_MORPHCOLORS ) && defined( MORPHTARGETS_TEXTURE )\n\tvColor *= morphTargetBaseInfluence;\n\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t#if defined( USE_COLOR_ALPHA )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];\n\t\t#elif defined( USE_COLOR )\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];\n\t\t#endif\n\t}\n#endif",
    morphnormal_vertex:
      "#ifdef USE_MORPHNORMALS\n\tobjectNormal *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\tobjectNormal += morphNormal0 * morphTargetInfluences[ 0 ];\n\t\tobjectNormal += morphNormal1 * morphTargetInfluences[ 1 ];\n\t\tobjectNormal += morphNormal2 * morphTargetInfluences[ 2 ];\n\t\tobjectNormal += morphNormal3 * morphTargetInfluences[ 3 ];\n\t#endif\n#endif",
    morphtarget_pars_vertex:
      "#ifdef USE_MORPHTARGETS\n\tuniform float morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tuniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];\n\t\tuniform sampler2DArray morphTargetsTexture;\n\t\tuniform ivec2 morphTargetsTextureSize;\n\t\tvec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {\n\t\t\tint texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;\n\t\t\tint y = texelIndex / morphTargetsTextureSize.x;\n\t\t\tint x = texelIndex - y * morphTargetsTextureSize.x;\n\t\t\tivec3 morphUV = ivec3( x, y, morphTargetIndex );\n\t\t\treturn texelFetch( morphTargetsTexture, morphUV, 0 );\n\t\t}\n\t#else\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\tuniform float morphTargetInfluences[ 8 ];\n\t\t#else\n\t\t\tuniform float morphTargetInfluences[ 4 ];\n\t\t#endif\n\t#endif\n#endif",
    morphtarget_vertex:
      "#ifdef USE_MORPHTARGETS\n\ttransformed *= morphTargetBaseInfluence;\n\t#ifdef MORPHTARGETS_TEXTURE\n\t\tfor ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {\n\t\t\tif ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];\n\t\t}\n\t#else\n\t\ttransformed += morphTarget0 * morphTargetInfluences[ 0 ];\n\t\ttransformed += morphTarget1 * morphTargetInfluences[ 1 ];\n\t\ttransformed += morphTarget2 * morphTargetInfluences[ 2 ];\n\t\ttransformed += morphTarget3 * morphTargetInfluences[ 3 ];\n\t\t#ifndef USE_MORPHNORMALS\n\t\t\ttransformed += morphTarget4 * morphTargetInfluences[ 4 ];\n\t\t\ttransformed += morphTarget5 * morphTargetInfluences[ 5 ];\n\t\t\ttransformed += morphTarget6 * morphTargetInfluences[ 6 ];\n\t\t\ttransformed += morphTarget7 * morphTargetInfluences[ 7 ];\n\t\t#endif\n\t#endif\n#endif",
    normal_fragment_begin:
      "float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;\n#ifdef FLAT_SHADED\n\tvec3 fdx = dFdx( vViewPosition );\n\tvec3 fdy = dFdy( vViewPosition );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal *= faceDirection;\n\t#endif\n#endif\n#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn = getTangentFrame( - vViewPosition, normal,\n\t\t#if defined( USE_NORMALMAP )\n\t\t\tvNormalMapUv\n\t\t#elif defined( USE_CLEARCOAT_NORMALMAP )\n\t\t\tvClearcoatNormalMapUv\n\t\t#else\n\t\t\tvUv\n\t\t#endif\n\t\t);\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn[0] *= faceDirection;\n\t\ttbn[1] *= faceDirection;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\t#ifdef USE_TANGENT\n\t\tmat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );\n\t#else\n\t\tmat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );\n\t#endif\n\t#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )\n\t\ttbn2[0] *= faceDirection;\n\t\ttbn2[1] *= faceDirection;\n\t#endif\n#endif\nvec3 geometryNormal = normal;",
    normal_fragment_maps:
      "#ifdef USE_NORMALMAP_OBJECTSPACE\n\tnormal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\t#ifdef FLIP_SIDED\n\t\tnormal = - normal;\n\t#endif\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * faceDirection;\n\t#endif\n\tnormal = normalize( normalMatrix * normal );\n#elif defined( USE_NORMALMAP_TANGENTSPACE )\n\tvec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;\n\tmapN.xy *= normalScale;\n\tnormal = normalize( tbn * mapN );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n#endif",
    normal_pars_fragment:
      "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    normal_pars_vertex:
      "#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n\t#ifdef USE_TANGENT\n\t\tvarying vec3 vTangent;\n\t\tvarying vec3 vBitangent;\n\t#endif\n#endif",
    normal_vertex:
      "#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n\t#ifdef USE_TANGENT\n\t\tvTangent = normalize( transformedTangent );\n\t\tvBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );\n\t#endif\n#endif",
    normalmap_pars_fragment:
      "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n#endif\n#ifdef USE_NORMALMAP_OBJECTSPACE\n\tuniform mat3 normalMatrix;\n#endif\n#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )\n\tmat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( uv.st );\n\t\tvec2 st1 = dFdy( uv.st );\n\t\tvec3 N = surf_norm;\n\t\tvec3 q1perp = cross( q1, N );\n\t\tvec3 q0perp = cross( N, q0 );\n\t\tvec3 T = q1perp * st0.x + q0perp * st1.x;\n\t\tvec3 B = q1perp * st0.y + q0perp * st1.y;\n\t\tfloat det = max( dot( T, T ), dot( B, B ) );\n\t\tfloat scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );\n\t\treturn mat3( T * scale, B * scale, N );\n\t}\n#endif",
    clearcoat_normal_fragment_begin:
      "#ifdef USE_CLEARCOAT\n\tvec3 clearcoatNormal = geometryNormal;\n#endif",
    clearcoat_normal_fragment_maps:
      "#ifdef USE_CLEARCOAT_NORMALMAP\n\tvec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;\n\tclearcoatMapN.xy *= clearcoatNormalScale;\n\tclearcoatNormal = normalize( tbn2 * clearcoatMapN );\n#endif",
    clearcoat_pars_fragment:
      "#ifdef USE_CLEARCOATMAP\n\tuniform sampler2D clearcoatMap;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform sampler2D clearcoatNormalMap;\n\tuniform vec2 clearcoatNormalScale;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform sampler2D clearcoatRoughnessMap;\n#endif",
    iridescence_pars_fragment:
      "#ifdef USE_IRIDESCENCEMAP\n\tuniform sampler2D iridescenceMap;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform sampler2D iridescenceThicknessMap;\n#endif",
    opaque_fragment:
      "#ifdef OPAQUE\ndiffuseColor.a = 1.0;\n#endif\n#ifdef USE_TRANSMISSION\ndiffuseColor.a *= material.transmissionAlpha;\n#endif\ngl_FragColor = vec4( outgoingLight, diffuseColor.a );",
    packing:
      "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256., 256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nvec2 packDepthToRG( in highp float v ) {\n\treturn packDepthToRGBA( v ).yx;\n}\nfloat unpackRGToDepth( const in highp vec2 v ) {\n\treturn unpackRGBAToDepth( vec4( v.xy, 0.0, 0.0 ) );\n}\nvec4 pack2HalfToRGBA( vec2 v ) {\n\tvec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );\n\treturn vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );\n}\nvec2 unpackRGBATo2Half( vec4 v ) {\n\treturn vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn depth * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * depth - far );\n}",
    premultiplied_alpha_fragment:
      "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif",
    project_vertex:
      "vec4 mvPosition = vec4( transformed, 1.0 );\n#ifdef USE_INSTANCING\n\tmvPosition = instanceMatrix * mvPosition;\n#endif\nmvPosition = modelViewMatrix * mvPosition;\ngl_Position = projectionMatrix * mvPosition;",
    dithering_fragment:
      "#ifdef DITHERING\n\tgl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif",
    dithering_pars_fragment:
      "#ifdef DITHERING\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif",
    roughnessmap_fragment:
      "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );\n\troughnessFactor *= texelRoughness.g;\n#endif",
    roughnessmap_pars_fragment:
      "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif",
    shadowmap_pars_fragment:
      "#if NUM_SPOT_LIGHT_COORDS > 0\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#if NUM_SPOT_LIGHT_MAPS > 0\n\tuniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tvec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {\n\t\treturn unpackRGBATo2Half( texture2D( shadow, uv ) );\n\t}\n\tfloat VSMShadow (sampler2D shadow, vec2 uv, float compare ){\n\t\tfloat occlusion = 1.0;\n\t\tvec2 distribution = texture2DDistribution( shadow, uv );\n\t\tfloat hard_shadow = step( compare , distribution.x );\n\t\tif (hard_shadow != 1.0 ) {\n\t\t\tfloat distance = compare - distribution.x ;\n\t\t\tfloat variance = max( 0.00000, distribution.y * distribution.y );\n\t\t\tfloat softness_probability = variance / (variance + distance * distance );\t\t\tsoftness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );\t\t\tocclusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );\n\t\t}\n\t\treturn occlusion;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;\n\t\tbool frustumTest = inFrustum && shadowCoord.z <= 1.0;\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tfloat dx2 = dx0 / 2.0;\n\t\t\tfloat dy2 = dy0 / 2.0;\n\t\t\tfloat dx3 = dx1 / 2.0;\n\t\t\tfloat dy3 = dy1 / 2.0;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 17.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx = texelSize.x;\n\t\t\tfloat dy = texelSize.y;\n\t\t\tvec2 uv = shadowCoord.xy;\n\t\t\tvec2 f = fract( uv * shadowMapSize + 0.5 );\n\t\t\tuv -= f * texelSize;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, uv, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),\n\t\t\t\t\t f.x ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t f.y ) +\n\t\t\t\tmix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),\n\t\t\t\t\t\t  f.x ),\n\t\t\t\t\t f.y )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_VSM )\n\t\t\tshadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif",
    shadowmap_pars_vertex:
      "#if NUM_SPOT_LIGHT_COORDS > 0\n\tuniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];\n\tvarying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];\n#endif\n#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];\n\t\tstruct DirectionalLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\t\tstruct SpotLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t};\n\t\tuniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];\n\t\tstruct PointLightShadow {\n\t\t\tfloat shadowBias;\n\t\t\tfloat shadowNormalBias;\n\t\t\tfloat shadowRadius;\n\t\t\tvec2 shadowMapSize;\n\t\t\tfloat shadowCameraNear;\n\t\t\tfloat shadowCameraFar;\n\t\t};\n\t\tuniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];\n\t#endif\n#endif",
    shadowmap_vertex:
      "#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )\n\tvec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\tvec4 shadowWorldPosition;\n#endif\n#if defined( USE_SHADOWMAP )\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\t\t#pragma unroll_loop_start\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\t\tshadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );\n\t\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;\n\t\t}\n\t\t#pragma unroll_loop_end\n\t#endif\n#endif\n#if NUM_SPOT_LIGHT_COORDS > 0\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {\n\t\tshadowWorldPosition = worldPosition;\n\t\t#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )\n\t\t\tshadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;\n\t\t#endif\n\t\tvSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;\n\t}\n\t#pragma unroll_loop_end\n#endif",
    shadowmask_pars_fragment:
      "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHT_SHADOWS > 0\n\tDirectionalLightShadow directionalLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {\n\t\tdirectionalLight = directionalLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_SPOT_LIGHT_SHADOWS > 0\n\tSpotLightShadow spotLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {\n\t\tspotLight = spotLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#if NUM_POINT_LIGHT_SHADOWS > 0\n\tPointLightShadow pointLight;\n\t#pragma unroll_loop_start\n\tfor ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {\n\t\tpointLight = pointLightShadows[ i ];\n\t\tshadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#pragma unroll_loop_end\n\t#endif\n\t#endif\n\treturn shadow;\n}",
    skinbase_vertex:
      "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif",
    skinning_pars_vertex:
      "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\tuniform highp sampler2D boneTexture;\n\tuniform int boneTextureSize;\n\tmat4 getBoneMatrix( const in float i ) {\n\t\tfloat j = i * 4.0;\n\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\ty = dy * ( y + 0.5 );\n\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\treturn bone;\n\t}\n#endif",
    skinning_vertex:
      "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif",
    skinnormal_vertex:
      "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n\t#ifdef USE_TANGENT\n\t\tobjectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;\n\t#endif\n#endif",
    specularmap_fragment:
      "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif",
    specularmap_pars_fragment:
      "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif",
    tonemapping_fragment:
      "#if defined( TONE_MAPPING )\n\tgl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif",
    tonemapping_pars_fragment:
      "#ifndef saturate\n#define saturate( a ) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn saturate( toneMappingExposure * color );\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 RRTAndODTFit( vec3 v ) {\n\tvec3 a = v * ( v + 0.0245786 ) - 0.000090537;\n\tvec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;\n\treturn a / b;\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tconst mat3 ACESInputMat = mat3(\n\t\tvec3( 0.59719, 0.07600, 0.02840 ),\t\tvec3( 0.35458, 0.90834, 0.13383 ),\n\t\tvec3( 0.04823, 0.01566, 0.83777 )\n\t);\n\tconst mat3 ACESOutputMat = mat3(\n\t\tvec3(  1.60475, -0.10208, -0.00327 ),\t\tvec3( -0.53108,  1.10813, -0.07276 ),\n\t\tvec3( -0.07367, -0.00605,  1.07602 )\n\t);\n\tcolor *= toneMappingExposure / 0.6;\n\tcolor = ACESInputMat * color;\n\tcolor = RRTAndODTFit( color );\n\tcolor = ACESOutputMat * color;\n\treturn saturate( color );\n}\nvec3 CustomToneMapping( vec3 color ) { return color; }",
    transmission_fragment:
      "#ifdef USE_TRANSMISSION\n\tmaterial.transmission = transmission;\n\tmaterial.transmissionAlpha = 1.0;\n\tmaterial.thickness = thickness;\n\tmaterial.attenuationDistance = attenuationDistance;\n\tmaterial.attenuationColor = attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tmaterial.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tmaterial.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;\n\t#endif\n\tvec3 pos = vWorldPosition;\n\tvec3 v = normalize( cameraPosition - pos );\n\tvec3 n = inverseTransformDirection( normal, viewMatrix );\n\tvec4 transmitted = getIBLVolumeRefraction(\n\t\tn, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,\n\t\tpos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness,\n\t\tmaterial.attenuationColor, material.attenuationDistance );\n\tmaterial.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );\n\ttotalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );\n#endif",
    transmission_pars_fragment:
      "#ifdef USE_TRANSMISSION\n\tuniform float transmission;\n\tuniform float thickness;\n\tuniform float attenuationDistance;\n\tuniform vec3 attenuationColor;\n\t#ifdef USE_TRANSMISSIONMAP\n\t\tuniform sampler2D transmissionMap;\n\t#endif\n\t#ifdef USE_THICKNESSMAP\n\t\tuniform sampler2D thicknessMap;\n\t#endif\n\tuniform vec2 transmissionSamplerSize;\n\tuniform sampler2D transmissionSamplerMap;\n\tuniform mat4 modelMatrix;\n\tuniform mat4 projectionMatrix;\n\tvarying vec3 vWorldPosition;\n\tfloat w0( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );\n\t}\n\tfloat w1( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );\n\t}\n\tfloat w2( float a ){\n\t\treturn ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );\n\t}\n\tfloat w3( float a ) {\n\t\treturn ( 1.0 / 6.0 ) * ( a * a * a );\n\t}\n\tfloat g0( float a ) {\n\t\treturn w0( a ) + w1( a );\n\t}\n\tfloat g1( float a ) {\n\t\treturn w2( a ) + w3( a );\n\t}\n\tfloat h0( float a ) {\n\t\treturn - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );\n\t}\n\tfloat h1( float a ) {\n\t\treturn 1.0 + w3( a ) / ( w2( a ) + w3( a ) );\n\t}\n\tvec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {\n\t\tuv = uv * texelSize.zw + 0.5;\n\t\tvec2 iuv = floor( uv );\n\t\tvec2 fuv = fract( uv );\n\t\tfloat g0x = g0( fuv.x );\n\t\tfloat g1x = g1( fuv.x );\n\t\tfloat h0x = h0( fuv.x );\n\t\tfloat h1x = h1( fuv.x );\n\t\tfloat h0y = h0( fuv.y );\n\t\tfloat h1y = h1( fuv.y );\n\t\tvec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\tvec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;\n\t\treturn g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +\n\t\t\tg1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );\n\t}\n\tvec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {\n\t\tvec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );\n\t\tvec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );\n\t\tvec2 fLodSizeInv = 1.0 / fLodSize;\n\t\tvec2 cLodSizeInv = 1.0 / cLodSize;\n\t\tvec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );\n\t\tvec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );\n\t\treturn mix( fSample, cSample, fract( lod ) );\n\t}\n\tvec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {\n\t\tvec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );\n\t\tvec3 modelScale;\n\t\tmodelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );\n\t\tmodelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );\n\t\tmodelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );\n\t\treturn normalize( refractionVector ) * thickness * modelScale;\n\t}\n\tfloat applyIorToRoughness( const in float roughness, const in float ior ) {\n\t\treturn roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );\n\t}\n\tvec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {\n\t\tfloat lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );\n\t\treturn textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );\n\t}\n\tvec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tif ( isinf( attenuationDistance ) ) {\n\t\t\treturn vec3( 1.0 );\n\t\t} else {\n\t\t\tvec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;\n\t\t\tvec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );\t\t\treturn transmittance;\n\t\t}\n\t}\n\tvec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,\n\t\tconst in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,\n\t\tconst in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,\n\t\tconst in vec3 attenuationColor, const in float attenuationDistance ) {\n\t\tvec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );\n\t\tvec3 refractedRayExit = position + transmissionRay;\n\t\tvec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );\n\t\tvec2 refractionCoords = ndcPos.xy / ndcPos.w;\n\t\trefractionCoords += 1.0;\n\t\trefractionCoords /= 2.0;\n\t\tvec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );\n\t\tvec3 transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );\n\t\tvec3 attenuatedColor = transmittance * transmittedLight.rgb;\n\t\tvec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );\n\t\tfloat transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;\n\t\treturn vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );\n\t}\n#endif",
    uv_pars_fragment:
      "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
    uv_pars_vertex:
      "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvarying vec2 vUv;\n#endif\n#ifdef USE_MAP\n\tuniform mat3 mapTransform;\n\tvarying vec2 vMapUv;\n#endif\n#ifdef USE_ALPHAMAP\n\tuniform mat3 alphaMapTransform;\n\tvarying vec2 vAlphaMapUv;\n#endif\n#ifdef USE_LIGHTMAP\n\tuniform mat3 lightMapTransform;\n\tvarying vec2 vLightMapUv;\n#endif\n#ifdef USE_AOMAP\n\tuniform mat3 aoMapTransform;\n\tvarying vec2 vAoMapUv;\n#endif\n#ifdef USE_BUMPMAP\n\tuniform mat3 bumpMapTransform;\n\tvarying vec2 vBumpMapUv;\n#endif\n#ifdef USE_NORMALMAP\n\tuniform mat3 normalMapTransform;\n\tvarying vec2 vNormalMapUv;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tuniform mat3 displacementMapTransform;\n\tvarying vec2 vDisplacementMapUv;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tuniform mat3 emissiveMapTransform;\n\tvarying vec2 vEmissiveMapUv;\n#endif\n#ifdef USE_METALNESSMAP\n\tuniform mat3 metalnessMapTransform;\n\tvarying vec2 vMetalnessMapUv;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tuniform mat3 roughnessMapTransform;\n\tvarying vec2 vRoughnessMapUv;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tuniform mat3 anisotropyMapTransform;\n\tvarying vec2 vAnisotropyMapUv;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tuniform mat3 clearcoatMapTransform;\n\tvarying vec2 vClearcoatMapUv;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tuniform mat3 clearcoatNormalMapTransform;\n\tvarying vec2 vClearcoatNormalMapUv;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tuniform mat3 clearcoatRoughnessMapTransform;\n\tvarying vec2 vClearcoatRoughnessMapUv;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tuniform mat3 sheenColorMapTransform;\n\tvarying vec2 vSheenColorMapUv;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tuniform mat3 sheenRoughnessMapTransform;\n\tvarying vec2 vSheenRoughnessMapUv;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tuniform mat3 iridescenceMapTransform;\n\tvarying vec2 vIridescenceMapUv;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tuniform mat3 iridescenceThicknessMapTransform;\n\tvarying vec2 vIridescenceThicknessMapUv;\n#endif\n#ifdef USE_SPECULARMAP\n\tuniform mat3 specularMapTransform;\n\tvarying vec2 vSpecularMapUv;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tuniform mat3 specularColorMapTransform;\n\tvarying vec2 vSpecularColorMapUv;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tuniform mat3 specularIntensityMapTransform;\n\tvarying vec2 vSpecularIntensityMapUv;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tuniform mat3 transmissionMapTransform;\n\tvarying vec2 vTransmissionMapUv;\n#endif\n#ifdef USE_THICKNESSMAP\n\tuniform mat3 thicknessMapTransform;\n\tvarying vec2 vThicknessMapUv;\n#endif",
    uv_vertex:
      "#if defined( USE_UV ) || defined( USE_ANISOTROPY )\n\tvUv = vec3( uv, 1 ).xy;\n#endif\n#ifdef USE_MAP\n\tvMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ALPHAMAP\n\tvAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_LIGHTMAP\n\tvLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_AOMAP\n\tvAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_BUMPMAP\n\tvBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_NORMALMAP\n\tvNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_DISPLACEMENTMAP\n\tvDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_EMISSIVEMAP\n\tvEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_METALNESSMAP\n\tvMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ROUGHNESSMAP\n\tvRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_ANISOTROPYMAP\n\tvAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOATMAP\n\tvClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_NORMALMAP\n\tvClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_CLEARCOAT_ROUGHNESSMAP\n\tvClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCEMAP\n\tvIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_IRIDESCENCE_THICKNESSMAP\n\tvIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_COLORMAP\n\tvSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SHEEN_ROUGHNESSMAP\n\tvSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULARMAP\n\tvSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_COLORMAP\n\tvSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_SPECULAR_INTENSITYMAP\n\tvSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_TRANSMISSIONMAP\n\tvTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;\n#endif\n#ifdef USE_THICKNESSMAP\n\tvThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;\n#endif",
    worldpos_vertex:
      "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0\n\tvec4 worldPosition = vec4( transformed, 1.0 );\n\t#ifdef USE_INSTANCING\n\t\tworldPosition = instanceMatrix * worldPosition;\n\t#endif\n\tworldPosition = modelMatrix * worldPosition;\n#endif",
    background_vert:
      "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}",
    background_frag:
      "uniform sampler2D t2D;\nuniform float backgroundIntensity;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\t#ifdef DECODE_VIDEO_TEXTURE\n\t\ttexColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    backgroundCube_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    backgroundCube_frag:
      "#ifdef ENVMAP_TYPE_CUBE\n\tuniform samplerCube envMap;\n#elif defined( ENVMAP_TYPE_CUBE_UV )\n\tuniform sampler2D envMap;\n#endif\nuniform float flipEnvMap;\nuniform float backgroundBlurriness;\nuniform float backgroundIntensity;\nvarying vec3 vWorldDirection;\n#include <cube_uv_reflection_fragment>\nvoid main() {\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 texColor = textureCube( envMap, vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );\n\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec4 texColor = textureCubeUV( envMap, vWorldDirection, backgroundBlurriness );\n\t#else\n\t\tvec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t#endif\n\ttexColor.rgb *= backgroundIntensity;\n\tgl_FragColor = texColor;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    cube_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}",
    cube_frag:
      "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = texColor;\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    depth_vert:
      "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvHighPrecisionZW = gl_Position.zw;\n}",
    depth_frag:
      "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvarying vec2 vHighPrecisionZW;\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <logdepthbuf_fragment>\n\tfloat fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( fragCoordZ );\n\t#endif\n}",
    distanceRGBA_vert:
      "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}",
    distanceRGBA_frag:
      "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}",
    equirect_vert:
      "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}",
    equirect_frag:
      "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV = equirectUv( direction );\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}",
    linedashed_vert:
      "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\tvLineDistance = scale * lineDistance;\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    linedashed_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    meshbasic_vert:
      "#include <common>\n#include <uv_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinbase_vertex>\n\t\t#include <skinnormal_vertex>\n\t\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}",
    meshbasic_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\tvec4 lightMapTexel = texture2D( lightMap, vLightMapUv );\n\t\treflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshlambert_vert:
      "#define LAMBERT\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshlambert_frag:
      "#define LAMBERT\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_lambert_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_lambert_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshmatcap_vert:
      "#define MATCAP\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <color_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}",
    meshmatcap_frag:
      "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#include <common>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t#else\n\t\tvec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshnormal_vert:
      "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}",
    meshnormal_frag:
      "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )\n\tvarying vec3 vViewPosition;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <normal_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#ifdef OPAQUE\n\t\tgl_FragColor.a = 1.0;\n\t#endif\n}",
    meshphong_vert:
      "#define PHONG\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshphong_frag:
      "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshphysical_vert:
      "#define STANDARD\nvarying vec3 vViewPosition;\n#ifdef USE_TRANSMISSION\n\tvarying vec3 vWorldPosition;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n#ifdef USE_TRANSMISSION\n\tvWorldPosition = worldPosition.xyz;\n#endif\n}",
    meshphysical_frag:
      "#define STANDARD\n#ifdef PHYSICAL\n\t#define IOR\n\t#define USE_SPECULAR\n#endif\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifdef IOR\n\tuniform float ior;\n#endif\n#ifdef USE_SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\t#ifdef USE_SPECULAR_COLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n\t#ifdef USE_SPECULAR_INTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n#endif\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n#ifdef USE_IRIDESCENCE\n\tuniform float iridescence;\n\tuniform float iridescenceIOR;\n\tuniform float iridescenceThicknessMinimum;\n\tuniform float iridescenceThicknessMaximum;\n#endif\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\t#ifdef USE_SHEEN_COLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\t#ifdef USE_SHEEN_ROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n#ifdef USE_ANISOTROPY\n\tuniform vec2 anisotropyVector;\n\t#ifdef USE_ANISOTROPYMAP\n\t\tuniform sampler2D anisotropyMap;\n\t#endif\n#endif\nvarying vec3 vViewPosition;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <iridescence_fragment>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <iridescence_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\t#include <transmission_fragment>\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\t#ifdef USE_SHEEN\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\t#endif\n\t#ifdef USE_CLEARCOAT\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\t#endif\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    meshtoon_vert:
      "#define TOON\nvarying vec3 vViewPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    meshtoon_frag:
      "#define TOON\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_toon_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_toon_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}",
    points_vert:
      "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n#ifdef USE_POINTS_UV\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif\nvoid main() {\n\t#ifdef USE_POINTS_UV\n\t\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\t#endif\n\t#include <color_vertex>\n\t#include <morphcolor_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}",
    points_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n}",
    shadow_vert:
      "#include <common>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}",
    shadow_frag:
      "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <logdepthbuf_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
    sprite_vert:
      "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = isPerspectiveMatrix( projectionMatrix );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}",
    sprite_frag:
      "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <alphahash_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <alphahash_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n}",
  },
  Xn = {
    common: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
    specularmap: {
      specularMap: { value: null },
      specularMapTransform: { value: new Matrix3() },
    },
    envmap: {
      envMap: { value: null },
      flipEnvMap: { value: -1 },
      reflectivity: { value: 1 },
      ior: { value: 1.5 },
      refractionRatio: { value: 0.98 },
    },
    aomap: {
      aoMap: { value: null },
      aoMapIntensity: { value: 1 },
      aoMapTransform: { value: new Matrix3() },
    },
    lightmap: {
      lightMap: { value: null },
      lightMapIntensity: { value: 1 },
      lightMapTransform: { value: new Matrix3() },
    },
    bumpmap: {
      bumpMap: { value: null },
      bumpMapTransform: { value: new Matrix3() },
      bumpScale: { value: 1 },
    },
    normalmap: {
      normalMap: { value: null },
      normalMapTransform: { value: new Matrix3() },
      normalScale: { value: new Vector2(1, 1) },
    },
    displacementmap: {
      displacementMap: { value: null },
      displacementMapTransform: { value: new Matrix3() },
      displacementScale: { value: 1 },
      displacementBias: { value: 0 },
    },
    emissivemap: {
      emissiveMap: { value: null },
      emissiveMapTransform: { value: new Matrix3() },
    },
    metalnessmap: {
      metalnessMap: { value: null },
      metalnessMapTransform: { value: new Matrix3() },
    },
    roughnessmap: {
      roughnessMap: { value: null },
      roughnessMapTransform: { value: new Matrix3() },
    },
    gradientmap: { gradientMap: { value: null } },
    fog: {
      fogDensity: { value: 25e-5 },
      fogNear: { value: 1 },
      fogFar: { value: 2e3 },
      fogColor: { value: new Color(16777215) },
    },
    lights: {
      ambientLightColor: { value: [] },
      lightProbe: { value: [] },
      directionalLights: {
        value: [],
        properties: { direction: {}, color: {} },
      },
      directionalLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      directionalShadowMap: { value: [] },
      directionalShadowMatrix: { value: [] },
      spotLights: {
        value: [],
        properties: {
          color: {},
          position: {},
          direction: {},
          distance: {},
          coneCos: {},
          penumbraCos: {},
          decay: {},
        },
      },
      spotLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
        },
      },
      spotLightMap: { value: [] },
      spotShadowMap: { value: [] },
      spotLightMatrix: { value: [] },
      pointLights: {
        value: [],
        properties: { color: {}, position: {}, decay: {}, distance: {} },
      },
      pointLightShadows: {
        value: [],
        properties: {
          shadowBias: {},
          shadowNormalBias: {},
          shadowRadius: {},
          shadowMapSize: {},
          shadowCameraNear: {},
          shadowCameraFar: {},
        },
      },
      pointShadowMap: { value: [] },
      pointShadowMatrix: { value: [] },
      hemisphereLights: {
        value: [],
        properties: { direction: {}, skyColor: {}, groundColor: {} },
      },
      rectAreaLights: {
        value: [],
        properties: { color: {}, position: {}, width: {}, height: {} },
      },
      ltc_1: { value: null },
      ltc_2: { value: null },
    },
    points: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      size: { value: 1 },
      scale: { value: 1 },
      map: { value: null },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
      uvTransform: { value: new Matrix3() },
    },
    sprite: {
      diffuse: { value: new Color(16777215) },
      opacity: { value: 1 },
      center: { value: new Vector2(0.5, 0.5) },
      rotation: { value: 0 },
      map: { value: null },
      mapTransform: { value: new Matrix3() },
      alphaMap: { value: null },
      alphaMapTransform: { value: new Matrix3() },
      alphaTest: { value: 0 },
    },
  },
  Yn = {
    basic: {
      uniforms: merge([
        Xn.common,
        Xn.specularmap,
        Xn.envmap,
        Xn.aomap,
        Xn.lightmap,
        Xn.fog,
      ]),
      vertexShader: qn.meshbasic_vert,
      fragmentShader: qn.meshbasic_frag,
    },
    lambert: {
      uniforms: merge([
        Xn.common,
        Xn.specularmap,
        Xn.envmap,
        Xn.aomap,
        Xn.lightmap,
        Xn.emissivemap,
        Xn.bumpmap,
        Xn.normalmap,
        Xn.displacementmap,
        Xn.fog,
        Xn.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: qn.meshlambert_vert,
      fragmentShader: qn.meshlambert_frag,
    },
    phong: {
      uniforms: merge([
        Xn.common,
        Xn.specularmap,
        Xn.envmap,
        Xn.aomap,
        Xn.lightmap,
        Xn.emissivemap,
        Xn.bumpmap,
        Xn.normalmap,
        Xn.displacementmap,
        Xn.fog,
        Xn.lights,
        {
          emissive: { value: new Color(0) },
          specular: { value: new Color(1118481) },
          shininess: { value: 30 },
        },
      ]),
      vertexShader: qn.meshphong_vert,
      fragmentShader: qn.meshphong_frag,
    },
    standard: {
      uniforms: merge([
        Xn.common,
        Xn.envmap,
        Xn.aomap,
        Xn.lightmap,
        Xn.emissivemap,
        Xn.bumpmap,
        Xn.normalmap,
        Xn.displacementmap,
        Xn.roughnessmap,
        Xn.metalnessmap,
        Xn.fog,
        Xn.lights,
        {
          emissive: { value: new Color(0) },
          roughness: { value: 1 },
          metalness: { value: 0 },
          envMapIntensity: { value: 1 },
        },
      ]),
      vertexShader: qn.meshphysical_vert,
      fragmentShader: qn.meshphysical_frag,
    },
    toon: {
      uniforms: merge([
        Xn.common,
        Xn.aomap,
        Xn.lightmap,
        Xn.emissivemap,
        Xn.bumpmap,
        Xn.normalmap,
        Xn.displacementmap,
        Xn.gradientmap,
        Xn.fog,
        Xn.lights,
        { emissive: { value: new Color(0) } },
      ]),
      vertexShader: qn.meshtoon_vert,
      fragmentShader: qn.meshtoon_frag,
    },
    matcap: {
      uniforms: merge([
        Xn.common,
        Xn.bumpmap,
        Xn.normalmap,
        Xn.displacementmap,
        Xn.fog,
        { matcap: { value: null } },
      ]),
      vertexShader: qn.meshmatcap_vert,
      fragmentShader: qn.meshmatcap_frag,
    },
    points: {
      uniforms: merge([Xn.points, Xn.fog]),
      vertexShader: qn.points_vert,
      fragmentShader: qn.points_frag,
    },
    dashed: {
      uniforms: merge([
        Xn.common,
        Xn.fog,
        {
          scale: { value: 1 },
          dashSize: { value: 1 },
          totalSize: { value: 2 },
        },
      ]),
      vertexShader: qn.linedashed_vert,
      fragmentShader: qn.linedashed_frag,
    },
    depth: {
      uniforms: merge([Xn.common, Xn.displacementmap]),
      vertexShader: qn.depth_vert,
      fragmentShader: qn.depth_frag,
    },
    normal: {
      uniforms: merge([
        Xn.common,
        Xn.bumpmap,
        Xn.normalmap,
        Xn.displacementmap,
        { opacity: { value: 1 } },
      ]),
      vertexShader: qn.meshnormal_vert,
      fragmentShader: qn.meshnormal_frag,
    },
    sprite: {
      uniforms: merge([Xn.sprite, Xn.fog]),
      vertexShader: qn.sprite_vert,
      fragmentShader: qn.sprite_frag,
    },
    background: {
      uniforms: {
        uvTransform: { value: new Matrix3() },
        t2D: { value: null },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: qn.background_vert,
      fragmentShader: qn.background_frag,
    },
    backgroundCube: {
      uniforms: {
        envMap: { value: null },
        flipEnvMap: { value: -1 },
        backgroundBlurriness: { value: 0 },
        backgroundIntensity: { value: 1 },
      },
      vertexShader: qn.backgroundCube_vert,
      fragmentShader: qn.backgroundCube_frag,
    },
    cube: {
      uniforms: {
        tCube: { value: null },
        tFlip: { value: -1 },
        opacity: { value: 1 },
      },
      vertexShader: qn.cube_vert,
      fragmentShader: qn.cube_frag,
    },
    equirect: {
      uniforms: { tEquirect: { value: null } },
      vertexShader: qn.equirect_vert,
      fragmentShader: qn.equirect_frag,
    },
    distanceRGBA: {
      uniforms: merge([
        Xn.common,
        Xn.displacementmap,
        {
          referencePosition: { value: new Vector3() },
          nearDistance: { value: 1 },
          farDistance: { value: 1e3 },
        },
      ]),
      vertexShader: qn.distanceRGBA_vert,
      fragmentShader: qn.distanceRGBA_frag,
    },
    shadow: {
      uniforms: merge([
        Xn.lights,
        Xn.fog,
        { color: { value: new Color(0) }, opacity: { value: 1 } },
      ]),
      vertexShader: qn.shadow_vert,
      fragmentShader: qn.shadow_frag,
    },
  };
Yn.physical = {
  uniforms: merge([
    Yn.standard.uniforms,
    {
      clearcoat: { value: 0 },
      clearcoatMap: { value: null },
      clearcoatMapTransform: { value: new Matrix3() },
      clearcoatNormalMap: { value: null },
      clearcoatNormalMapTransform: { value: new Matrix3() },
      clearcoatNormalScale: { value: new Vector2(1, 1) },
      clearcoatRoughness: { value: 0 },
      clearcoatRoughnessMap: { value: null },
      clearcoatRoughnessMapTransform: { value: new Matrix3() },
      iridescence: { value: 0 },
      iridescenceMap: { value: null },
      iridescenceMapTransform: { value: new Matrix3() },
      iridescenceIOR: { value: 1.3 },
      iridescenceThicknessMinimum: { value: 100 },
      iridescenceThicknessMaximum: { value: 400 },
      iridescenceThicknessMap: { value: null },
      iridescenceThicknessMapTransform: { value: new Matrix3() },
      sheen: { value: 0 },
      sheenColor: { value: new Color(0) },
      sheenColorMap: { value: null },
      sheenColorMapTransform: { value: new Matrix3() },
      sheenRoughness: { value: 1 },
      sheenRoughnessMap: { value: null },
      sheenRoughnessMapTransform: { value: new Matrix3() },
      transmission: { value: 0 },
      transmissionMap: { value: null },
      transmissionMapTransform: { value: new Matrix3() },
      transmissionSamplerSize: { value: new Vector2() },
      transmissionSamplerMap: { value: null },
      thickness: { value: 0 },
      thicknessMap: { value: null },
      thicknessMapTransform: { value: new Matrix3() },
      attenuationDistance: { value: 0 },
      attenuationColor: { value: new Color(0) },
      specularColor: { value: new Color(1, 1, 1) },
      specularColorMap: { value: null },
      specularColorMapTransform: { value: new Matrix3() },
      specularIntensity: { value: 1 },
      specularIntensityMap: { value: null },
      specularIntensityMapTransform: { value: new Matrix3() },
      anisotropyVector: { value: new Vector2() },
      anisotropyMap: { value: null },
      anisotropyMapTransform: { value: new Matrix3() },
    },
  ]),
  vertexShader: qn.meshphysical_vert,
  fragmentShader: qn.meshphysical_frag,
};
const Kn = { r: 0, b: 0, g: 0 };
function Zn(e, t, i, n, s, r, a) {
  const o = new Color(0);
  let l,
    u,
    d = !0 === r ? 0 : 1,
    p = null,
    f = 0,
    m = null;
  function g(t, i) {
    t.getRGB(Kn, Tn(e)), n.buffers.color.setClear(Kn.r, Kn.g, Kn.b, i, a);
  }
  return {
    getClearColor: function () {
      return o;
    },
    setClearColor: function (e, t = 1) {
      o.set(e), (d = t), g(o, d);
    },
    getClearAlpha: function () {
      return d;
    },
    setClearAlpha: function (e) {
      (d = e), g(o, d);
    },
    render: function (r, _) {
      let v = !1,
        A = !0 === _.isScene ? _.background : null;
      if (A && A.isTexture) {
        A = (_.backgroundBlurriness > 0 ? i : t).get(A);
      }
      null === A ? g(o, d) : A && A.isColor && (g(A, 1), (v = !0));
      const y = e.xr.getEnvironmentBlendMode();
      "additive" === y
        ? n.buffers.color.setClear(0, 0, 0, 1, a)
        : "alpha-blend" === y && n.buffers.color.setClear(0, 0, 0, 0, a),
        (e.autoClear || v) &&
          e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
        A && (A.isCubeTexture || A.mapping === M)
          ? (void 0 === u &&
              ((u = new En(
                new Cn(1, 1, 1),
                new ShaderMaterial({
                  name: "BackgroundCubeMaterial",
                  uniforms: clone(Yn.backgroundCube.uniforms),
                  vertexShader: Yn.backgroundCube.vertexShader,
                  fragmentShader: Yn.backgroundCube.fragmentShader,
                  side: c,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              u.geometry.deleteAttribute("normal"),
              u.geometry.deleteAttribute("uv"),
              (u.onBeforeRender = function (e, t, i) {
                this.matrixWorld.copyPosition(i.matrixWorld);
              }),
              Object.defineProperty(u.material, "envMap", {
                get: function () {
                  return this.uniforms.envMap.value;
                },
              }),
              s.update(u)),
            (u.material.uniforms.envMap.value = A),
            (u.material.uniforms.flipEnvMap.value =
              A.isCubeTexture && !1 === A.isRenderTargetTexture ? -1 : 1),
            (u.material.uniforms.backgroundBlurriness.value =
              _.backgroundBlurriness),
            (u.material.uniforms.backgroundIntensity.value =
              _.backgroundIntensity),
            (u.material.toneMapped = A.colorSpace !== me),
            (p === A && f === A.version && m === e.toneMapping) ||
              ((u.material.needsUpdate = !0),
              (p = A),
              (f = A.version),
              (m = e.toneMapping)),
            u.layers.enableAll(),
            r.unshift(u, u.geometry, u.material, 0, 0, null))
          : A &&
            A.isTexture &&
            (void 0 === l &&
              ((l = new En(
                new PlaneGeometry(2, 2),
                new ShaderMaterial({
                  name: "BackgroundMaterial",
                  uniforms: clone(Yn.background.uniforms),
                  vertexShader: Yn.background.vertexShader,
                  fragmentShader: Yn.background.fragmentShader,
                  side: h,
                  depthTest: !1,
                  depthWrite: !1,
                  fog: !1,
                })
              )),
              l.geometry.deleteAttribute("normal"),
              Object.defineProperty(l.material, "map", {
                get: function () {
                  return this.uniforms.t2D.value;
                },
              }),
              s.update(l)),
            (l.material.uniforms.t2D.value = A),
            (l.material.uniforms.backgroundIntensity.value =
              _.backgroundIntensity),
            (l.material.toneMapped = A.colorSpace !== me),
            !0 === A.matrixAutoUpdate && A.updateMatrix(),
            l.material.uniforms.uvTransform.value.copy(A.matrix),
            (p === A && f === A.version && m === e.toneMapping) ||
              ((l.material.needsUpdate = !0),
              (p = A),
              (f = A.version),
              (m = e.toneMapping)),
            l.layers.enableAll(),
            r.unshift(l, l.geometry, l.material, 0, 0, null));
    },
  };
}
function Jn(e, t, i, n) {
  const s = e.getParameter(e.MAX_VERTEX_ATTRIBS),
    r = n.isWebGL2 ? null : t.get("OES_vertex_array_object"),
    a = n.isWebGL2 || null !== r,
    o = {},
    l = p(null);
  let h = l,
    c = !1;
  function u(t) {
    return n.isWebGL2 ? e.bindVertexArray(t) : r.bindVertexArrayOES(t);
  }
  function d(t) {
    return n.isWebGL2 ? e.deleteVertexArray(t) : r.deleteVertexArrayOES(t);
  }
  function p(e) {
    const t = [],
      i = [],
      n = [];
    for (let r = 0; r < s; r++) (t[r] = 0), (i[r] = 0), (n[r] = 0);
    return {
      geometry: null,
      program: null,
      wireframe: !1,
      newAttributes: t,
      enabledAttributes: i,
      attributeDivisors: n,
      object: e,
      attributes: {},
      index: null,
    };
  }
  function f() {
    const e = h.newAttributes;
    for (let t = 0, i = e.length; t < i; t++) e[t] = 0;
  }
  function m(e) {
    g(e, 0);
  }
  function g(i, s) {
    const r = h.newAttributes,
      a = h.enabledAttributes,
      o = h.attributeDivisors;
    if (
      ((r[i] = 1),
      0 === a[i] && (e.enableVertexAttribArray(i), (a[i] = 1)),
      o[i] !== s)
    ) {
      (n.isWebGL2 ? e : t.get("ANGLE_instanced_arrays"))[
        n.isWebGL2 ? "vertexAttribDivisor" : "vertexAttribDivisorANGLE"
      ](i, s),
        (o[i] = s);
    }
  }
  function _() {
    const t = h.newAttributes,
      i = h.enabledAttributes;
    for (let n = 0, s = i.length; n < s; n++)
      i[n] !== t[n] && (e.disableVertexAttribArray(n), (i[n] = 0));
  }
  function v(t, i, n, s, r, a, o) {
    !0 === o
      ? e.vertexAttribIPointer(t, i, n, r, a)
      : e.vertexAttribPointer(t, i, n, s, r, a);
  }
  function A() {
    y(), (c = !0), h !== l && ((h = l), u(h.object));
  }
  function y() {
    (l.geometry = null), (l.program = null), (l.wireframe = !1);
  }
  return {
    setup: function (s, l, d, A, y) {
      let x = !1;
      if (a) {
        const t = (function (t, i, s) {
          const a = !0 === s.wireframe;
          let l = o[t.id];
          void 0 === l && ((l = {}), (o[t.id] = l));
          let h = l[i.id];
          void 0 === h && ((h = {}), (l[i.id] = h));
          let c = h[a];
          void 0 === c &&
            ((c = p(
              n.isWebGL2 ? e.createVertexArray() : r.createVertexArrayOES()
            )),
            (h[a] = c));
          return c;
        })(A, d, l);
        h !== t && ((h = t), u(h.object)),
          (x = (function (e, t, i, n) {
            const s = h.attributes,
              r = t.attributes;
            let a = 0;
            const o = i.getAttributes();
            for (const l in o) {
              if (o[l].location >= 0) {
                const t = s[l];
                let i = r[l];
                if (
                  (void 0 === i &&
                    ("instanceMatrix" === l &&
                      e.instanceMatrix &&
                      (i = e.instanceMatrix),
                    "instanceColor" === l &&
                      e.instanceColor &&
                      (i = e.instanceColor)),
                  void 0 === t)
                )
                  return !0;
                if (t.attribute !== i) return !0;
                if (i && t.data !== i.data) return !0;
                a++;
              }
            }
            return h.attributesNum !== a || h.index !== n;
          })(s, A, d, y)),
          x &&
            (function (e, t, i, n) {
              const s = {},
                r = t.attributes;
              let a = 0;
              const o = i.getAttributes();
              for (const l in o) {
                if (o[l].location >= 0) {
                  let t = r[l];
                  void 0 === t &&
                    ("instanceMatrix" === l &&
                      e.instanceMatrix &&
                      (t = e.instanceMatrix),
                    "instanceColor" === l &&
                      e.instanceColor &&
                      (t = e.instanceColor));
                  const i = {};
                  (i.attribute = t),
                    t && t.data && (i.data = t.data),
                    (s[l] = i),
                    a++;
                }
              }
              (h.attributes = s), (h.attributesNum = a), (h.index = n);
            })(s, A, d, y);
      } else {
        const e = !0 === l.wireframe;
        (h.geometry === A.id && h.program === d.id && h.wireframe === e) ||
          ((h.geometry = A.id),
          (h.program = d.id),
          (h.wireframe = e),
          (x = !0));
      }
      null !== y && i.update(y, e.ELEMENT_ARRAY_BUFFER),
        (x || c) &&
          ((c = !1),
          (function (s, r, a, o) {
            if (
              !1 === n.isWebGL2 &&
              (s.isInstancedMesh || o.isInstancedBufferGeometry) &&
              null === t.get("ANGLE_instanced_arrays")
            )
              return;
            f();
            const l = o.attributes,
              h = a.getAttributes(),
              c = r.defaultAttributeValues;
            for (const t in h) {
              const r = h[t];
              if (r.location >= 0) {
                let a = l[t];
                if (
                  (void 0 === a &&
                    ("instanceMatrix" === t &&
                      s.instanceMatrix &&
                      (a = s.instanceMatrix),
                    "instanceColor" === t &&
                      s.instanceColor &&
                      (a = s.instanceColor)),
                  void 0 !== a)
                ) {
                  const t = a.normalized,
                    l = a.itemSize,
                    h = i.get(a);
                  if (void 0 === h) continue;
                  const c = h.buffer,
                    u = h.type,
                    d = h.bytesPerElement,
                    p =
                      !0 === n.isWebGL2 &&
                      (u === e.INT || u === e.UNSIGNED_INT || a.gpuType === O);
                  if (a.isInterleavedBufferAttribute) {
                    const i = a.data,
                      n = i.stride,
                      h = a.offset;
                    if (i.isInstancedInterleavedBuffer) {
                      for (let e = 0; e < r.locationSize; e++)
                        g(r.location + e, i.meshPerAttribute);
                      !0 !== s.isInstancedMesh &&
                        void 0 === o._maxInstanceCount &&
                        (o._maxInstanceCount = i.meshPerAttribute * i.count);
                    } else
                      for (let e = 0; e < r.locationSize; e++)
                        m(r.location + e);
                    e.bindBuffer(e.ARRAY_BUFFER, c);
                    for (let e = 0; e < r.locationSize; e++)
                      v(
                        r.location + e,
                        l / r.locationSize,
                        u,
                        t,
                        n * d,
                        (h + (l / r.locationSize) * e) * d,
                        p
                      );
                  } else {
                    if (a.isInstancedBufferAttribute) {
                      for (let e = 0; e < r.locationSize; e++)
                        g(r.location + e, a.meshPerAttribute);
                      !0 !== s.isInstancedMesh &&
                        void 0 === o._maxInstanceCount &&
                        (o._maxInstanceCount = a.meshPerAttribute * a.count);
                    } else
                      for (let e = 0; e < r.locationSize; e++)
                        m(r.location + e);
                    e.bindBuffer(e.ARRAY_BUFFER, c);
                    for (let e = 0; e < r.locationSize; e++)
                      v(
                        r.location + e,
                        l / r.locationSize,
                        u,
                        t,
                        l * d,
                        (l / r.locationSize) * e * d,
                        p
                      );
                  }
                } else if (void 0 !== c) {
                  const i = c[t];
                  if (void 0 !== i)
                    switch (i.length) {
                      case 2:
                        e.vertexAttrib2fv(r.location, i);
                        break;
                      case 3:
                        e.vertexAttrib3fv(r.location, i);
                        break;
                      case 4:
                        e.vertexAttrib4fv(r.location, i);
                        break;
                      default:
                        e.vertexAttrib1fv(r.location, i);
                    }
                }
              }
            }
            _();
          })(s, l, d, A),
          null !== y && e.bindBuffer(e.ELEMENT_ARRAY_BUFFER, i.get(y).buffer));
    },
    reset: A,
    resetDefaultState: y,
    dispose: function () {
      A();
      for (const e in o) {
        const t = o[e];
        for (const e in t) {
          const i = t[e];
          for (const e in i) d(i[e].object), delete i[e];
          delete t[e];
        }
        delete o[e];
      }
    },
    releaseStatesOfGeometry: function (e) {
      if (void 0 === o[e.id]) return;
      const t = o[e.id];
      for (const i in t) {
        const e = t[i];
        for (const t in e) d(e[t].object), delete e[t];
        delete t[i];
      }
      delete o[e.id];
    },
    releaseStatesOfProgram: function (e) {
      for (const t in o) {
        const i = o[t];
        if (void 0 === i[e.id]) continue;
        const n = i[e.id];
        for (const e in n) d(n[e].object), delete n[e];
        delete i[e.id];
      }
    },
    initAttributes: f,
    enableAttribute: m,
    disableUnusedAttributes: _,
  };
}
function $n(e, t, i, n) {
  const s = n.isWebGL2;
  let r;
  (this.setMode = function (e) {
    r = e;
  }),
    (this.render = function (t, n) {
      e.drawArrays(r, t, n), i.update(n, r, 1);
    }),
    (this.renderInstances = function (n, a, o) {
      if (0 === o) return;
      let l, h;
      if (s) (l = e), (h = "drawArraysInstanced");
      else if (
        ((l = t.get("ANGLE_instanced_arrays")),
        (h = "drawArraysInstancedANGLE"),
        null === l)
      )
        return void console.error(
          "THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
      l[h](r, n, a, o), i.update(a, r, o);
    });
}
function es(e, t, i) {
  let n;
  function s(t) {
    if ("highp" === t) {
      if (
        e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.HIGH_FLOAT).precision >
          0 &&
        e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision >
          0
      )
        return "highp";
      t = "mediump";
    }
    return "mediump" === t &&
      e.getShaderPrecisionFormat(e.VERTEX_SHADER, e.MEDIUM_FLOAT).precision >
        0 &&
      e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.MEDIUM_FLOAT).precision >
        0
      ? "mediump"
      : "lowp";
  }
  const r =
    "undefined" != typeof WebGL2RenderingContext &&
    "WebGL2RenderingContext" === e.constructor.name;
  let a = void 0 !== i.precision ? i.precision : "highp";
  const o = s(a);
  o !== a &&
    (console.warn(
      "THREE.WebGLRenderer:",
      a,
      "not supported, using",
      o,
      "instead."
    ),
    (a = o));
  const l = r || t.has("WEBGL_draw_buffers"),
    h = !0 === i.logarithmicDepthBuffer,
    c = e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS),
    u = e.getParameter(e.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
    d = e.getParameter(e.MAX_TEXTURE_SIZE),
    p = e.getParameter(e.MAX_CUBE_MAP_TEXTURE_SIZE),
    f = e.getParameter(e.MAX_VERTEX_ATTRIBS),
    m = e.getParameter(e.MAX_VERTEX_UNIFORM_VECTORS),
    g = e.getParameter(e.MAX_VARYING_VECTORS),
    _ = e.getParameter(e.MAX_FRAGMENT_UNIFORM_VECTORS),
    v = u > 0,
    A = r || t.has("OES_texture_float");
  return {
    isWebGL2: r,
    drawBuffers: l,
    getMaxAnisotropy: function () {
      if (void 0 !== n) return n;
      if (!0 === t.has("EXT_texture_filter_anisotropic")) {
        const i = t.get("EXT_texture_filter_anisotropic");
        n = e.getParameter(i.MAX_TEXTURE_MAX_ANISOTROPY_EXT);
      } else n = 0;
      return n;
    },
    getMaxPrecision: s,
    precision: a,
    logarithmicDepthBuffer: h,
    maxTextures: c,
    maxVertexTextures: u,
    maxTextureSize: d,
    maxCubemapSize: p,
    maxAttributes: f,
    maxVertexUniforms: m,
    maxVaryings: g,
    maxFragmentUniforms: _,
    vertexTextures: v,
    floatFragmentTextures: A,
    floatVertexTextures: v && A,
    maxSamples: r ? e.getParameter(e.MAX_SAMPLES) : 0,
  };
}
function ts(e) {
  const t = this;
  let i = null,
    n = 0,
    s = !1,
    r = !1;
  const a = new zn(),
    o = new Matrix3(),
    l = { value: null, needsUpdate: !1 };
  function h(e, i, n, s) {
    const r = null !== e ? e.length : 0;
    let h = null;
    if (0 !== r) {
      if (((h = l.value), !0 !== s || null === h)) {
        const t = n + 4 * r,
          s = i.matrixWorldInverse;
        o.getNormalMatrix(s),
          (null === h || h.length < t) && (h = new Float32Array(t));
        for (let i = 0, l = n; i !== r; ++i, l += 4)
          a.copy(e[i]).applyMatrix4(s, o),
            a.normal.toArray(h, l),
            (h[l + 3] = a.constant);
      }
      (l.value = h), (l.needsUpdate = !0);
    }
    return (t.numPlanes = r), (t.numIntersection = 0), h;
  }
  (this.uniform = l),
    (this.numPlanes = 0),
    (this.numIntersection = 0),
    (this.init = function (e, t) {
      const i = 0 !== e.length || t || 0 !== n || s;
      return (s = t), (n = e.length), i;
    }),
    (this.beginShadows = function () {
      (r = !0), h(null);
    }),
    (this.endShadows = function () {
      r = !1;
    }),
    (this.setGlobalState = function (e, t) {
      i = h(e, t, 0);
    }),
    (this.setState = function (a, o, c) {
      const u = a.clippingPlanes,
        d = a.clipIntersection,
        p = a.clipShadows,
        f = e.get(a);
      if (!s || null === u || 0 === u.length || (r && !p))
        r
          ? h(null)
          : (function () {
              l.value !== i && ((l.value = i), (l.needsUpdate = n > 0));
              (t.numPlanes = n), (t.numIntersection = 0);
            })();
      else {
        const e = r ? 0 : n,
          t = 4 * e;
        let s = f.clippingState || null;
        (l.value = s), (s = h(u, o, t, c));
        for (let n = 0; n !== t; ++n) s[n] = i[n];
        (f.clippingState = s),
          (this.numIntersection = d ? this.numPlanes : 0),
          (this.numPlanes += e);
      }
    });
}
function is(e) {
  let t = new WeakMap();
  function i(e, t) {
    return t === C ? (e.mapping = E) : 304 === t && (e.mapping = S), e;
  }
  function n(e) {
    const i = e.target;
    i.removeEventListener("dispose", n);
    const s = t.get(i);
    void 0 !== s && (t.delete(i), s.dispose());
  }
  return {
    get: function (s) {
      if (s && s.isTexture && !1 === s.isRenderTargetTexture) {
        const r = s.mapping;
        if (r === C || 304 === r) {
          if (t.has(s)) {
            return i(t.get(s).texture, s.mapping);
          }
          {
            const r = s.image;
            if (r && r.height > 0) {
              const a = new Bn(r.height / 2);
              return (
                a.fromEquirectangularTexture(e, s),
                t.set(s, a),
                s.addEventListener("dispose", n),
                i(a.texture, s.mapping)
              );
            }
            return null;
          }
        }
      }
      return s;
    },
    dispose: function () {
      t = new WeakMap();
    },
  };
}
class ns extends Pn {
  constructor(e = -1, t = 1, i = 1, n = -1, s = 0.1, r = 2e3) {
    super(),
      (this.isOrthographicCamera = !0),
      (this.type = "OrthographicCamera"),
      (this.zoom = 1),
      (this.view = null),
      (this.left = e),
      (this.right = t),
      (this.top = i),
      (this.bottom = n),
      (this.near = s),
      (this.far = r),
      this.updateProjectionMatrix();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.left = e.left),
      (this.right = e.right),
      (this.top = e.top),
      (this.bottom = e.bottom),
      (this.near = e.near),
      (this.far = e.far),
      (this.zoom = e.zoom),
      (this.view = null === e.view ? null : Object.assign({}, e.view)),
      this
    );
  }
  setViewOffset(e, t, i, n, s, r) {
    null === this.view &&
      (this.view = {
        enabled: !0,
        fullWidth: 1,
        fullHeight: 1,
        offsetX: 0,
        offsetY: 0,
        width: 1,
        height: 1,
      }),
      (this.view.enabled = !0),
      (this.view.fullWidth = e),
      (this.view.fullHeight = t),
      (this.view.offsetX = i),
      (this.view.offsetY = n),
      (this.view.width = s),
      (this.view.height = r),
      this.updateProjectionMatrix();
  }
  clearViewOffset() {
    null !== this.view && (this.view.enabled = !1),
      this.updateProjectionMatrix();
  }
  updateProjectionMatrix() {
    const e = (this.right - this.left) / (2 * this.zoom),
      t = (this.top - this.bottom) / (2 * this.zoom),
      i = (this.right + this.left) / 2,
      n = (this.top + this.bottom) / 2;
    let s = i - e,
      r = i + e,
      a = n + t,
      o = n - t;
    if (null !== this.view && this.view.enabled) {
      const e = (this.right - this.left) / this.view.fullWidth / this.zoom,
        t = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
      (s += e * this.view.offsetX),
        (r = s + e * this.view.width),
        (a -= t * this.view.offsetY),
        (o = a - t * this.view.height);
    }
    this.projectionMatrix.makeOrthographic(
      s,
      r,
      a,
      o,
      this.near,
      this.far,
      this.coordinateSystem
    ),
      this.projectionMatrixInverse.copy(this.projectionMatrix).invert();
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.zoom = this.zoom),
      (t.object.left = this.left),
      (t.object.right = this.right),
      (t.object.top = this.top),
      (t.object.bottom = this.bottom),
      (t.object.near = this.near),
      (t.object.far = this.far),
      null !== this.view && (t.object.view = Object.assign({}, this.view)),
      t
    );
  }
}
const ss = [0.125, 0.215, 0.35, 0.446, 0.526, 0.582],
  rs = 20,
  as = new ns(),
  os = new Color();
let ls = null;
const hs = (1 + Math.sqrt(5)) / 2,
  cs = 1 / hs,
  us = [
    new Vector3(1, 1, 1),
    new Vector3(-1, 1, 1),
    new Vector3(1, 1, -1),
    new Vector3(-1, 1, -1),
    new Vector3(0, hs, cs),
    new Vector3(0, hs, -cs),
    new Vector3(cs, 0, hs),
    new Vector3(-cs, 0, hs),
    new Vector3(hs, cs, 0),
    new Vector3(-hs, cs, 0),
  ];
class ds {
  constructor(e) {
    (this._renderer = e),
      (this._pingPongRenderTarget = null),
      (this._lodMax = 0),
      (this._cubeSize = 0),
      (this._lodPlanes = []),
      (this._sizeLods = []),
      (this._sigmas = []),
      (this._blurMaterial = null),
      (this._cubemapMaterial = null),
      (this._equirectMaterial = null),
      this._compileMaterial(this._blurMaterial);
  }
  fromScene(e, t = 0, i = 0.1, n = 100, s = null, r = null) {
    return (
      (ls = this._renderer.getRenderTarget()),
      this._setSize(256),
      (s.depthBuffer = !0),
      s || (s = this._allocateTargets()),
      r && (this._pingPongRenderTarget = r),
      this._sceneToCubeUV(e, i, n, s),
      t > 0 && this._blur(s, 0, 0, t),
      this._applyPMREM(s),
      this._cleanup(s),
      s
    );
  }
  prepareForRenderTarget(e, t = null, i = 256) {
    this._setSize(i);
    const { _lodMax: n } = this;
    ({
      sizeLods: this._sizeLods,
      lodPlanes: this._lodPlanes,
      sigmas: this._sigmas,
    } = ps(n));
    const s = 3 * Math.max(this._cubeSize, 112),
      r = 4 * this._cubeSize;
    (this._blurMaterial = gs(n, s, r)), e.setSize(s, r), t && t.setSize(s, r);
  }
  fromSceneToRenderTarget(e, t, i, n = 0, s = 0.1, r = 100) {
    return (
      (ls = this._renderer.getRenderTarget()),
      (this._pingPongRenderTarget = i),
      this._sceneToCubeUV(e, s, r, t),
      n > 0 && this._blur(t, 0, 0, n),
      this._applyPMREM(t),
      this._renderer.setRenderTarget(ls),
      (t.scissorTest = !1),
      ms(t, 0, 0, t.width, t.height),
      t
    );
  }
  fromEquirectangular(e, t = null) {
    return this._fromTexture(e, t);
  }
  fromCubemap(e, t = null) {
    return this._fromTexture(e, t);
  }
  compileCubemapShader() {
    null === this._cubemapMaterial &&
      ((this._cubemapMaterial = vs()),
      this._compileMaterial(this._cubemapMaterial));
  }
  compileEquirectangularShader() {
    null === this._equirectMaterial &&
      ((this._equirectMaterial = _s()),
      this._compileMaterial(this._equirectMaterial));
  }
  dispose() {
    this._dispose(),
      null !== this._cubemapMaterial && this._cubemapMaterial.dispose(),
      null !== this._equirectMaterial && this._equirectMaterial.dispose();
  }
  _setSize(e) {
    (this._lodMax = Math.floor(Math.log2(e))),
      (this._cubeSize = Math.pow(2, this._lodMax));
  }
  _dispose() {
    null !== this._blurMaterial && this._blurMaterial.dispose(),
      null !== this._pingPongRenderTarget &&
        this._pingPongRenderTarget.dispose();
    for (let e = 0; e < this._lodPlanes.length; e++)
      this._lodPlanes[e].dispose();
  }
  _cleanup(e) {
    this._renderer.setRenderTarget(ls),
      (e.scissorTest = !1),
      ms(e, 0, 0, e.width, e.height);
  }
  _fromTexture(e, t) {
    e.mapping === E || e.mapping === S
      ? this._setSize(
          0 === e.image.length ? 16 : e.image[0].width || e.image[0].image.width
        )
      : this._setSize(e.image.width / 4),
      (ls = this._renderer.getRenderTarget());
    const i = t || this._allocateTargets();
    return (
      this._textureToCubeUV(e, i), this._applyPMREM(i), this._cleanup(i), i
    );
  }
  _allocateTargets() {
    const e = 3 * Math.max(this._cubeSize, 112),
      t = 4 * this._cubeSize,
      i = {
        magFilter: L,
        minFilter: L,
        generateMipmaps: !1,
        type: G,
        format: Q,
        colorSpace: ge,
        depthBuffer: !1,
      },
      n = fs(e, t, i);
    if (
      null === this._pingPongRenderTarget ||
      this._pingPongRenderTarget.width !== e ||
      this._pingPongRenderTarget.height !== t
    ) {
      null !== this._pingPongRenderTarget && this._dispose(),
        (this._pingPongRenderTarget = fs(e, t, i));
      const { _lodMax: n } = this;
      ({
        sizeLods: this._sizeLods,
        lodPlanes: this._lodPlanes,
        sigmas: this._sigmas,
      } = ps(n)),
        (this._blurMaterial = gs(n, e, t));
    }
    return n;
  }
  _compileMaterial(e) {
    const t = new En(this._lodPlanes[0], e);
    this._renderer.compile(t, as);
  }
  _sceneToCubeUV(e, t, i, n) {
    const s = new Dn(90, 1, t, i),
      r = [1, -1, 1, 1, 1, 1],
      a = [1, 1, 1, -1, -1, -1],
      o = this._renderer,
      l = o.autoClear,
      h = o.toneMapping;
    o.getClearColor(os), (o.toneMapping = _), (o.autoClear = !1);
    const u = new Oi({
        name: "PMREM.Background",
        side: c,
        depthWrite: !1,
        depthTest: !1,
      }),
      d = new En(new Cn(), u);
    let p = !1;
    const f = e.background;
    f
      ? f.isColor && (u.color.copy(f), (e.background = null), (p = !0))
      : (u.color.copy(os), (p = !0));
    for (let c = 0; c < 6; c++) {
      const t = c % 3;
      0 === t
        ? (s.up.set(0, r[c], 0), s.lookAt(a[c], 0, 0))
        : 1 === t
        ? (s.up.set(0, 0, r[c]), s.lookAt(0, a[c], 0))
        : (s.up.set(0, r[c], 0), s.lookAt(0, 0, a[c]));
      const i = this._cubeSize;
      ms(n, t * i, c > 2 ? i : 0, i, i),
        o.setRenderTarget(n),
        p && o.render(d, s),
        o.render(e, s);
    }
    d.geometry.dispose(),
      d.material.dispose(),
      (o.toneMapping = h),
      (o.autoClear = l),
      (e.background = f);
  }
  _textureToCubeUV(e, t) {
    const i = this._renderer,
      n = e.mapping === E || e.mapping === S;
    n
      ? (null === this._cubemapMaterial && (this._cubemapMaterial = vs()),
        (this._cubemapMaterial.uniforms.flipEnvMap.value =
          !1 === e.isRenderTargetTexture ? -1 : 1))
      : null === this._equirectMaterial && (this._equirectMaterial = _s());
    const s = n ? this._cubemapMaterial : this._equirectMaterial,
      r = new En(this._lodPlanes[0], s);
    s.uniforms.envMap.value = e;
    const a = this._cubeSize;
    ms(t, 0, 0, 3 * a, 2 * a), i.setRenderTarget(t), i.render(r, as);
  }
  _applyPMREM(e) {
    const t = this._renderer,
      i = t.autoClear;
    t.autoClear = !1;
    for (let n = 1; n < this._lodPlanes.length; n++) {
      const t = Math.sqrt(
          this._sigmas[n] * this._sigmas[n] -
            this._sigmas[n - 1] * this._sigmas[n - 1]
        ),
        i = us[(n - 1) % us.length];
      this._blur(e, n - 1, n, t, i);
    }
    t.autoClear = i;
  }
  _blur(e, t, i, n, s) {
    const r = this._pingPongRenderTarget;
    this._halfBlur(e, r, t, i, n, "latitudinal", s),
      this._halfBlur(r, e, i, i, n, "longitudinal", s);
  }
  _halfBlur(e, t, i, n, s, r, a) {
    const o = this._renderer,
      l = this._blurMaterial;
    "latitudinal" !== r &&
      "longitudinal" !== r &&
      console.error(
        "blur direction must be either latitudinal or longitudinal!"
      );
    const h = new En(this._lodPlanes[n], l),
      c = l.uniforms,
      u = this._sizeLods[i] - 1,
      d = isFinite(s) ? Math.PI / (2 * u) : (2 * Math.PI) / 39,
      p = s / d,
      f = isFinite(s) ? 1 + Math.floor(3 * p) : rs;
    f > rs &&
      console.warn(
        `sigmaRadians, ${s}, is too large and will clip, as it requested ${f} samples when the maximum is set to 20`
      );
    const m = [];
    let g = 0;
    for (let A = 0; A < rs; ++A) {
      const e = A / p,
        t = Math.exp((-e * e) / 2);
      m.push(t), 0 === A ? (g += t) : A < f && (g += 2 * t);
    }
    for (let A = 0; A < m.length; A++) m[A] = m[A] / g;
    (c.envMap.value = e.texture),
      (c.samples.value = f),
      (c.weights.value = m),
      (c.latitudinal.value = "latitudinal" === r),
      a && (c.poleAxis.value = a);
    const { _lodMax: _ } = this;
    (c.dTheta.value = d), (c.mipInt.value = _ - i);
    const v = this._sizeLods[n];
    ms(
      t,
      3 * v * (n > _ - 4 ? n - _ + 4 : 0),
      4 * (this._cubeSize - v),
      3 * v,
      2 * v
    ),
      o.setRenderTarget(t),
      o.render(h, as);
  }
}
function ps(e) {
  const t = [],
    i = [],
    n = [];
  let s = e;
  const r = e - 4 + 1 + ss.length;
  for (let a = 0; a < r; a++) {
    const r = Math.pow(2, s);
    i.push(r);
    let o = 1 / r;
    a > e - 4 ? (o = ss[a - e + 4 - 1]) : 0 === a && (o = 0), n.push(o);
    const l = 1 / (r - 2),
      h = -l,
      c = 1 + l,
      u = [h, h, c, h, c, c, h, h, c, c, h, c],
      d = 6,
      p = 6,
      f = 3,
      m = 2,
      g = 1,
      _ = new Float32Array(f * p * d),
      v = new Float32Array(m * p * d),
      A = new Float32Array(g * p * d);
    for (let e = 0; e < d; e++) {
      const t = ((e % 3) * 2) / 3 - 1,
        i = e > 2 ? 0 : -1,
        n = [
          t,
          i,
          0,
          t + 2 / 3,
          i,
          0,
          t + 2 / 3,
          i + 1,
          0,
          t,
          i,
          0,
          t + 2 / 3,
          i + 1,
          0,
          t,
          i + 1,
          0,
        ];
      _.set(n, f * p * e), v.set(u, m * p * e);
      const s = [e, e, e, e, e, e];
      A.set(s, g * p * e);
    }
    const y = new rn();
    y.setAttribute("position", new Wi(_, f)),
      y.setAttribute("uv", new Wi(v, m)),
      y.setAttribute("faceIndex", new Wi(A, g)),
      t.push(y),
      s > 4 && s--;
  }
  return { lodPlanes: t, sizeLods: i, sigmas: n };
}
function fs(e, t, i) {
  const n = new ut(e, t, i);
  return (
    (n.texture.mapping = M),
    (n.texture.name = "PMREM.cubeUv"),
    (n.scissorTest = !0),
    n
  );
}
function ms(e, t, i, n, s) {
  e.viewport.set(t, i, n, s), e.scissor.set(t, i, n, s);
}
function gs(e, t, i) {
  const n = new Float32Array(rs),
    s = new Vector3(0, 1, 0);
  return new ShaderMaterial({
    name: "SphericalGaussianBlur",
    defines: {
      n: rs,
      CUBEUV_TEXEL_WIDTH: 1 / t,
      CUBEUV_TEXEL_HEIGHT: 1 / i,
      CUBEUV_MAX_MIP: `${e}.0`,
    },
    uniforms: {
      envMap: { value: null },
      samples: { value: 1 },
      weights: { value: n },
      latitudinal: { value: !1 },
      dTheta: { value: 0 },
      mipInt: { value: 0 },
      poleAxis: { value: s },
    },
    vertexShader: As(),
    fragmentShader:
      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\t\t\tuniform int samples;\n\t\t\tuniform float weights[ n ];\n\t\t\tuniform bool latitudinal;\n\t\t\tuniform float dTheta;\n\t\t\tuniform float mipInt;\n\t\t\tuniform vec3 poleAxis;\n\n\t\t\t#define ENVMAP_TYPE_CUBE_UV\n\t\t\t#include <cube_uv_reflection_fragment>\n\n\t\t\tvec3 getSample( float theta, vec3 axis ) {\n\n\t\t\t\tfloat cosTheta = cos( theta );\n\t\t\t\t// Rodrigues' axis-angle rotation\n\t\t\t\tvec3 sampleDirection = vOutputDirection * cosTheta\n\t\t\t\t\t+ cross( axis, vOutputDirection ) * sin( theta )\n\t\t\t\t\t+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );\n\n\t\t\t\treturn bilinearCubeUV( envMap, sampleDirection, mipInt );\n\n\t\t\t}\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );\n\n\t\t\t\tif ( all( equal( axis, vec3( 0.0 ) ) ) ) {\n\n\t\t\t\t\taxis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );\n\n\t\t\t\t}\n\n\t\t\t\taxis = normalize( axis );\n\n\t\t\t\tgl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );\n\t\t\t\tgl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );\n\n\t\t\t\tfor ( int i = 1; i < n; i++ ) {\n\n\t\t\t\t\tif ( i >= samples ) {\n\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tfloat theta = dTheta * float( i );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );\n\t\t\t\t\tgl_FragColor.rgb += weights[ i ] * getSample( theta, axis );\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t",
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function _s() {
  return new ShaderMaterial({
    name: "EquirectangularToCubeUV",
    uniforms: { envMap: { value: null } },
    vertexShader: As(),
    fragmentShader:
      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform sampler2D envMap;\n\n\t\t\t#include <common>\n\n\t\t\tvoid main() {\n\n\t\t\t\tvec3 outputDirection = normalize( vOutputDirection );\n\t\t\t\tvec2 uv = equirectUv( outputDirection );\n\n\t\t\t\tgl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );\n\n\t\t\t}\n\t\t",
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function vs() {
  return new ShaderMaterial({
    name: "CubemapToCubeUV",
    uniforms: { envMap: { value: null }, flipEnvMap: { value: -1 } },
    vertexShader: As(),
    fragmentShader:
      "\n\n\t\t\tprecision mediump float;\n\t\t\tprecision mediump int;\n\n\t\t\tuniform float flipEnvMap;\n\n\t\t\tvarying vec3 vOutputDirection;\n\n\t\t\tuniform samplerCube envMap;\n\n\t\t\tvoid main() {\n\n\t\t\t\tgl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );\n\n\t\t\t}\n\t\t",
    blending: 0,
    depthTest: !1,
    depthWrite: !1,
  });
}
function As() {
  return "\n\n\t\tprecision mediump float;\n\t\tprecision mediump int;\n\n\t\tattribute float faceIndex;\n\n\t\tvarying vec3 vOutputDirection;\n\n\t\tmat3 getRotationMatrix(vec3 axis, float angle) {\n\t\t\taxis = normalize(axis);\n\t\t\tfloat s = sin(angle);\n\t\t\tfloat c = cos(angle);\n\t\t\tfloat oc = 1.0 - c;\n\t\t\n\t\t\treturn mat3(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,\n\t\t\t\t\t\toc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,\n\t\t\t\t\t\toc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c);\n\t\t}\n\t\t// RH coordinate system; PMREM face-indexing convention\n\t\tvec3 getDirection( vec2 uv, float face ) {\n\n\t\t\tuv = 2.0 * uv - 1.0;\n\n\t\t\tvec3 direction = vec3( uv, 1.0 );\n\n\t\t\tif ( face == 0.0 ) {\n\n\t\t\t\tdirection = direction.zyx; // ( 1, v, u ) pos x\n\n\t\t\t} else if ( face == 1.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xz *= -1.0; // ( -u, 1, -v ) pos y\n\n\t\t\t} else if ( face == 2.0 ) {\n\n\t\t\t\tdirection.x *= -1.0; // ( -u, v, 1 ) pos z\n\n\t\t\t} else if ( face == 3.0 ) {\n\n\t\t\t\tdirection = direction.zyx;\n\t\t\t\tdirection.xz *= -1.0; // ( -1, v, -u ) neg x\n\n\t\t\t} else if ( face == 4.0 ) {\n\n\t\t\t\tdirection = direction.xzy;\n\t\t\t\tdirection.xy *= -1.0; // ( -u, -1, v ) neg y\n\n\t\t\t} else if ( face == 5.0 ) {\n\n\t\t\t\tdirection.z *= -1.0; // ( u, v, -1 ) neg z\n\n\t\t\t}\n\n\t\t\tmat3 rotationMatrix = getRotationMatrix(vec3(1.0, 0.0, 0.0), 1.57);\n\t\t\tdirection = rotationMatrix * direction;\n\t\t\treturn direction;\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\tvOutputDirection = getDirection( uv, faceIndex );\n\t\t\tgl_Position = vec4( position, 1.0 );\n\n\t\t}\n\t";
}
function ys(e) {
  let t = new WeakMap(),
    i = null;
  function n(e) {
    const i = e.target;
    i.removeEventListener("dispose", n);
    const s = t.get(i);
    void 0 !== s && (t.delete(i), s.dispose());
  }
  return {
    get: function (s) {
      if (s && s.isTexture) {
        const r = s.mapping,
          a = r === C || 304 === r,
          o = r === E || r === S;
        if (a || o) {
          if (s.isRenderTargetTexture && !0 === s.needsPMREMUpdate) {
            s.needsPMREMUpdate = !1;
            let n = t.get(s);
            return (
              null === i && (i = new ds(e)),
              (n = a ? i.fromEquirectangular(s, n) : i.fromCubemap(s, n)),
              t.set(s, n),
              n.texture
            );
          }
          if (t.has(s)) return t.get(s).texture;
          {
            const r = s.image;
            if (
              (a && r && r.height > 0) ||
              (o &&
                r &&
                (function (e) {
                  let t = 0;
                  const i = 6;
                  for (let n = 0; n < i; n++) void 0 !== e[n] && t++;
                  return t === i;
                })(r))
            ) {
              null === i && (i = new ds(e));
              const r = a ? i.fromEquirectangular(s) : i.fromCubemap(s);
              return t.set(s, r), s.addEventListener("dispose", n), r.texture;
            }
            return null;
          }
        }
      }
      return s;
    },
    dispose: function () {
      (t = new WeakMap()), null !== i && (i.dispose(), (i = null));
    },
  };
}
function xs(e) {
  const t = {};
  function i(i) {
    if (void 0 !== t[i]) return t[i];
    let n;
    switch (i) {
      case "WEBGL_depth_texture":
        n =
          e.getExtension("WEBGL_depth_texture") ||
          e.getExtension("MOZ_WEBGL_depth_texture") ||
          e.getExtension("WEBKIT_WEBGL_depth_texture");
        break;
      case "EXT_texture_filter_anisotropic":
        n =
          e.getExtension("EXT_texture_filter_anisotropic") ||
          e.getExtension("MOZ_EXT_texture_filter_anisotropic") ||
          e.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
        break;
      case "WEBGL_compressed_texture_s3tc":
        n =
          e.getExtension("WEBGL_compressed_texture_s3tc") ||
          e.getExtension("MOZ_WEBGL_compressed_texture_s3tc") ||
          e.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        break;
      case "WEBGL_compressed_texture_pvrtc":
        n =
          e.getExtension("WEBGL_compressed_texture_pvrtc") ||
          e.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
        break;
      default:
        n = e.getExtension(i);
    }
    return (t[i] = n), n;
  }
  return {
    has: function (e) {
      return null !== i(e);
    },
    init: function (e) {
      e.isWebGL2
        ? i("EXT_color_buffer_float")
        : (i("WEBGL_depth_texture"),
          i("OES_texture_float"),
          i("OES_texture_half_float"),
          i("OES_texture_half_float_linear"),
          i("OES_standard_derivatives"),
          i("OES_element_index_uint"),
          i("OES_vertex_array_object"),
          i("ANGLE_instanced_arrays")),
        i("OES_texture_float_linear"),
        i("EXT_color_buffer_half_float"),
        i("WEBGL_multisampled_render_to_texture");
    },
    get: function (e) {
      const t = i(e);
      return (
        null === t &&
          console.warn(
            "THREE.WebGLRenderer: " + e + " extension not supported."
          ),
        t
      );
    },
  };
}
function bs(e, t, i, n) {
  const s = {},
    r = new WeakMap();
  function a(e) {
    const o = e.target;
    null !== o.index && t.remove(o.index);
    for (const i in o.attributes) t.remove(o.attributes[i]);
    for (const i in o.morphAttributes) {
      const e = o.morphAttributes[i];
      for (let i = 0, n = e.length; i < n; i++) t.remove(e[i]);
    }
    o.removeEventListener("dispose", a), delete s[o.id];
    const l = r.get(o);
    l && (t.remove(l), r.delete(o)),
      n.releaseStatesOfGeometry(o),
      !0 === o.isInstancedBufferGeometry && delete o._maxInstanceCount,
      i.memory.geometries--;
  }
  function o(e) {
    const i = [],
      n = e.index,
      s = e.attributes.position;
    let a = 0;
    if (null !== n) {
      const e = n.array;
      a = n.version;
      for (let t = 0, n = e.length; t < n; t += 3) {
        const n = e[t + 0],
          s = e[t + 1],
          r = e[t + 2];
        i.push(n, s, s, r, r, n);
      }
    } else {
      if (void 0 === s) return;
      {
        const e = s.array;
        a = s.version;
        for (let t = 0, n = e.length / 3 - 1; t < n; t += 3) {
          const e = t + 0,
            n = t + 1,
            s = t + 2;
          i.push(e, n, n, s, s, e);
        }
      }
    }
    const o = new (He(i) ? Xi : qi)(i, 1);
    o.version = a;
    const l = r.get(e);
    l && t.remove(l), r.set(e, o);
  }
  return {
    get: function (e, t) {
      return (
        !0 === s[t.id] ||
          (t.addEventListener("dispose", a),
          (s[t.id] = !0),
          i.memory.geometries++),
        t
      );
    },
    update: function (i) {
      const n = i.attributes;
      for (const r in n) t.update(n[r], e.ARRAY_BUFFER);
      const s = i.morphAttributes;
      for (const r in s) {
        const i = s[r];
        for (let n = 0, s = i.length; n < s; n++)
          t.update(i[n], e.ARRAY_BUFFER);
      }
    },
    getWireframeAttribute: function (e) {
      const t = r.get(e);
      if (t) {
        const i = e.index;
        null !== i && t.version < i.version && o(e);
      } else o(e);
      return r.get(e);
    },
  };
}
function Es(e, t, i, n) {
  const s = n.isWebGL2;
  let r, a, o;
  (this.setMode = function (e) {
    r = e;
  }),
    (this.setIndex = function (e) {
      (a = e.type), (o = e.bytesPerElement);
    }),
    (this.render = function (t, n) {
      e.drawElements(r, n, a, t * o), i.update(n, r, 1);
    }),
    (this.renderInstances = function (n, l, h) {
      if (0 === h) return;
      let c, u;
      if (s) (c = e), (u = "drawElementsInstanced");
      else if (
        ((c = t.get("ANGLE_instanced_arrays")),
        (u = "drawElementsInstancedANGLE"),
        null === c)
      )
        return void console.error(
          "THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays."
        );
      c[u](r, l, a, n * o, h), i.update(l, r, h);
    });
}
function Ss(e) {
  const t = { frame: 0, calls: 0, triangles: 0, points: 0, lines: 0 };
  return {
    memory: { geometries: 0, textures: 0 },
    render: t,
    programs: null,
    autoReset: !0,
    reset: function () {
      (t.calls = 0), (t.triangles = 0), (t.points = 0), (t.lines = 0);
    },
    update: function (i, n, s) {
      switch ((t.calls++, n)) {
        case e.TRIANGLES:
          t.triangles += s * (i / 3);
          break;
        case e.LINES:
          t.lines += s * (i / 2);
          break;
        case e.LINE_STRIP:
          t.lines += s * (i - 1);
          break;
        case e.LINE_LOOP:
          t.lines += s * i;
          break;
        case e.POINTS:
          t.points += s * i;
          break;
        default:
          console.error("THREE.WebGLInfo: Unknown draw mode:", n);
      }
    },
  };
}
function Cs(e, t) {
  return e[0] - t[0];
}
function Ms(e, t) {
  return Math.abs(t[1]) - Math.abs(e[1]);
}
function ws(e, t, i) {
  const n = {},
    s = new Float32Array(8),
    r = new WeakMap(),
    a = new Vector4(),
    o = [];
  for (let l = 0; l < 8; l++) o[l] = [l, 0];
  return {
    update: function (l, h, c) {
      const u = l.morphTargetInfluences;
      if (!0 === t.isWebGL2) {
        const n =
            h.morphAttributes.position ||
            h.morphAttributes.normal ||
            h.morphAttributes.color,
          s = void 0 !== n ? n.length : 0;
        let o = r.get(h);
        if (void 0 === o || o.count !== s) {
          let e = function () {
            _.dispose(), r.delete(h), h.removeEventListener("dispose", e);
          };
          void 0 !== o && o.texture.dispose();
          const i = void 0 !== h.morphAttributes.position,
            n = void 0 !== h.morphAttributes.normal,
            l = void 0 !== h.morphAttributes.color,
            c = h.morphAttributes.position || [],
            u = h.morphAttributes.normal || [],
            d = h.morphAttributes.color || [];
          let p = 0;
          !0 === i && (p = 1), !0 === n && (p = 2), !0 === l && (p = 3);
          let f = h.attributes.position.count * p,
            m = 1;
          f > t.maxTextureSize &&
            ((m = Math.ceil(f / t.maxTextureSize)), (f = t.maxTextureSize));
          const g = new Float32Array(f * m * 4 * s),
            _ = new dt(g, f, m, s);
          (_.type = z), (_.needsUpdate = !0);
          const v = 4 * p;
          for (let t = 0; t < s; t++) {
            const e = c[t],
              s = u[t],
              r = d[t],
              o = f * m * 4 * t;
            for (let t = 0; t < e.count; t++) {
              const h = t * v;
              !0 === i &&
                (a.fromBufferAttribute(e, t),
                (g[o + h + 0] = a.x),
                (g[o + h + 1] = a.y),
                (g[o + h + 2] = a.z),
                (g[o + h + 3] = 0)),
                !0 === n &&
                  (a.fromBufferAttribute(s, t),
                  (g[o + h + 4] = a.x),
                  (g[o + h + 5] = a.y),
                  (g[o + h + 6] = a.z),
                  (g[o + h + 7] = 0)),
                !0 === l &&
                  (a.fromBufferAttribute(r, t),
                  (g[o + h + 8] = a.x),
                  (g[o + h + 9] = a.y),
                  (g[o + h + 10] = a.z),
                  (g[o + h + 11] = 4 === r.itemSize ? a.w : 1));
            }
          }
          (o = { count: s, texture: _, size: new Vector2(f, m) }),
            r.set(h, o),
            h.addEventListener("dispose", e);
        }
        let l = 0;
        for (let e = 0; e < u.length; e++) l += u[e];
        const d = h.morphTargetsRelative ? 1 : 1 - l;
        c.getUniforms().setValue(e, "morphTargetBaseInfluence", d),
          c.getUniforms().setValue(e, "morphTargetInfluences", u),
          c.getUniforms().setValue(e, "morphTargetsTexture", o.texture, i),
          c.getUniforms().setValue(e, "morphTargetsTextureSize", o.size);
      } else {
        const t = void 0 === u ? 0 : u.length;
        let i = n[h.id];
        if (void 0 === i || i.length !== t) {
          i = [];
          for (let e = 0; e < t; e++) i[e] = [e, 0];
          n[h.id] = i;
        }
        for (let e = 0; e < t; e++) {
          const t = i[e];
          (t[0] = e), (t[1] = u[e]);
        }
        i.sort(Ms);
        for (let e = 0; e < 8; e++)
          e < t && i[e][1]
            ? ((o[e][0] = i[e][0]), (o[e][1] = i[e][1]))
            : ((o[e][0] = Number.MAX_SAFE_INTEGER), (o[e][1] = 0));
        o.sort(Cs);
        const r = h.morphAttributes.position,
          a = h.morphAttributes.normal;
        let l = 0;
        for (let e = 0; e < 8; e++) {
          const t = o[e],
            i = t[0],
            n = t[1];
          i !== Number.MAX_SAFE_INTEGER && n
            ? (r &&
                h.getAttribute("morphTarget" + e) !== r[i] &&
                h.setAttribute("morphTarget" + e, r[i]),
              a &&
                h.getAttribute("morphNormal" + e) !== a[i] &&
                h.setAttribute("morphNormal" + e, a[i]),
              (s[e] = n),
              (l += n))
            : (r &&
                !0 === h.hasAttribute("morphTarget" + e) &&
                h.deleteAttribute("morphTarget" + e),
              a &&
                !0 === h.hasAttribute("morphNormal" + e) &&
                h.deleteAttribute("morphNormal" + e),
              (s[e] = 0));
        }
        const d = h.morphTargetsRelative ? 1 : 1 - l;
        c.getUniforms().setValue(e, "morphTargetBaseInfluence", d),
          c.getUniforms().setValue(e, "morphTargetInfluences", s);
      }
    },
  };
}
function Ts(e, t, i, n) {
  let s = new WeakMap();
  function r(e) {
    const t = e.target;
    t.removeEventListener("dispose", r),
      i.remove(t.instanceMatrix),
      null !== t.instanceColor && i.remove(t.instanceColor);
  }
  return {
    update: function (a) {
      const o = n.render.frame,
        l = a.geometry,
        h = t.get(a, l);
      if (
        (s.get(h) !== o && (t.update(h), s.set(h, o)),
        a.isInstancedMesh &&
          (!1 === a.hasEventListener("dispose", r) &&
            a.addEventListener("dispose", r),
          s.get(a) !== o &&
            (i.update(a.instanceMatrix, e.ARRAY_BUFFER),
            null !== a.instanceColor &&
              i.update(a.instanceColor, e.ARRAY_BUFFER),
            s.set(a, o))),
        a.isSkinnedMesh)
      ) {
        const e = a.skeleton;
        s.get(e) !== o && (e.update(), s.set(e, o));
      }
      return h;
    },
    dispose: function () {
      s = new WeakMap();
    },
  };
}
const Is = new Texture(),
  Rs = new dt(),
  Ps = new pt(),
  Ds = new Nn(),
  Ls = [],
  Fs = [],
  Ns = new Float32Array(16),
  Bs = new Float32Array(9),
  ks = new Float32Array(4);
function Os(e, t, i) {
  const n = e[0];
  if (n <= 0 || n > 0) return e;
  const s = t * i;
  let r = Ls[s];
  if ((void 0 === r && ((r = new Float32Array(s)), (Ls[s] = r)), 0 !== t)) {
    n.toArray(r, 0);
    for (let n = 1, s = 0; n !== t; ++n) (s += i), e[n].toArray(r, s);
  }
  return r;
}
function Us(e, t) {
  if (e.length !== t.length) return !1;
  for (let i = 0, n = e.length; i < n; i++) if (e[i] !== t[i]) return !1;
  return !0;
}
function zs(e, t) {
  for (let i = 0, n = t.length; i < n; i++) e[i] = t[i];
}
function Gs(e, t) {
  let i = Fs[t];
  void 0 === i && ((i = new Int32Array(t)), (Fs[t] = i));
  for (let n = 0; n !== t; ++n) i[n] = e.allocateTextureUnit();
  return i;
}
function Vs(e, t) {
  const i = this.cache;
  i[0] !== t && (e.uniform1f(this.addr, t), (i[0] = t));
}
function Qs(e, t) {
  const i = this.cache;
  if (void 0 !== t.x)
    (i[0] === t.x && i[1] === t.y) ||
      (e.uniform2f(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
  else {
    if (Us(i, t)) return;
    e.uniform2fv(this.addr, t), zs(i, t);
  }
}
function Hs(e, t) {
  const i = this.cache;
  if (void 0 !== t.x)
    (i[0] === t.x && i[1] === t.y && i[2] === t.z) ||
      (e.uniform3f(this.addr, t.x, t.y, t.z),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z));
  else if (void 0 !== t.r)
    (i[0] === t.r && i[1] === t.g && i[2] === t.b) ||
      (e.uniform3f(this.addr, t.r, t.g, t.b),
      (i[0] = t.r),
      (i[1] = t.g),
      (i[2] = t.b));
  else {
    if (Us(i, t)) return;
    e.uniform3fv(this.addr, t), zs(i, t);
  }
}
function js(e, t) {
  const i = this.cache;
  if (void 0 !== t.x)
    (i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w) ||
      (e.uniform4f(this.addr, t.x, t.y, t.z, t.w),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = t.w));
  else {
    if (Us(i, t)) return;
    e.uniform4fv(this.addr, t), zs(i, t);
  }
}
function Ws(e, t) {
  const i = this.cache,
    n = t.elements;
  if (void 0 === n) {
    if (Us(i, t)) return;
    e.uniformMatrix2fv(this.addr, !1, t), zs(i, t);
  } else {
    if (Us(i, n)) return;
    ks.set(n), e.uniformMatrix2fv(this.addr, !1, ks), zs(i, n);
  }
}
function qs(e, t) {
  const i = this.cache,
    n = t.elements;
  if (void 0 === n) {
    if (Us(i, t)) return;
    e.uniformMatrix3fv(this.addr, !1, t), zs(i, t);
  } else {
    if (Us(i, n)) return;
    Bs.set(n), e.uniformMatrix3fv(this.addr, !1, Bs), zs(i, n);
  }
}
function Xs(e, t) {
  const i = this.cache,
    n = t.elements;
  if (void 0 === n) {
    if (Us(i, t)) return;
    e.uniformMatrix4fv(this.addr, !1, t), zs(i, t);
  } else {
    if (Us(i, n)) return;
    Ns.set(n), e.uniformMatrix4fv(this.addr, !1, Ns), zs(i, n);
  }
}
function Ys(e, t) {
  const i = this.cache;
  i[0] !== t && (e.uniform1i(this.addr, t), (i[0] = t));
}
function Ks(e, t) {
  const i = this.cache;
  if (void 0 !== t.x)
    (i[0] === t.x && i[1] === t.y) ||
      (e.uniform2i(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
  else {
    if (Us(i, t)) return;
    e.uniform2iv(this.addr, t), zs(i, t);
  }
}
function Zs(e, t) {
  const i = this.cache;
  if (void 0 !== t.x)
    (i[0] === t.x && i[1] === t.y && i[2] === t.z) ||
      (e.uniform3i(this.addr, t.x, t.y, t.z),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z));
  else {
    if (Us(i, t)) return;
    e.uniform3iv(this.addr, t), zs(i, t);
  }
}
function Js(e, t) {
  const i = this.cache;
  if (void 0 !== t.x)
    (i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w) ||
      (e.uniform4i(this.addr, t.x, t.y, t.z, t.w),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = t.w));
  else {
    if (Us(i, t)) return;
    e.uniform4iv(this.addr, t), zs(i, t);
  }
}
function $s(e, t) {
  const i = this.cache;
  i[0] !== t && (e.uniform1ui(this.addr, t), (i[0] = t));
}
function er(e, t) {
  const i = this.cache;
  if (void 0 !== t.x)
    (i[0] === t.x && i[1] === t.y) ||
      (e.uniform2ui(this.addr, t.x, t.y), (i[0] = t.x), (i[1] = t.y));
  else {
    if (Us(i, t)) return;
    e.uniform2uiv(this.addr, t), zs(i, t);
  }
}
function tr(e, t) {
  const i = this.cache;
  if (void 0 !== t.x)
    (i[0] === t.x && i[1] === t.y && i[2] === t.z) ||
      (e.uniform3ui(this.addr, t.x, t.y, t.z),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z));
  else {
    if (Us(i, t)) return;
    e.uniform3uiv(this.addr, t), zs(i, t);
  }
}
function ir(e, t) {
  const i = this.cache;
  if (void 0 !== t.x)
    (i[0] === t.x && i[1] === t.y && i[2] === t.z && i[3] === t.w) ||
      (e.uniform4ui(this.addr, t.x, t.y, t.z, t.w),
      (i[0] = t.x),
      (i[1] = t.y),
      (i[2] = t.z),
      (i[3] = t.w));
  else {
    if (Us(i, t)) return;
    e.uniform4uiv(this.addr, t), zs(i, t);
  }
}
function nr(e, t, i) {
  const n = this.cache,
    s = i.allocateTextureUnit();
  n[0] !== s && (e.uniform1i(this.addr, s), (n[0] = s)),
    i.setTexture2D(t || Is, s);
}
function sr(e, t, i) {
  const n = this.cache,
    s = i.allocateTextureUnit();
  n[0] !== s && (e.uniform1i(this.addr, s), (n[0] = s)),
    i.setTexture3D(t || Ps, s);
}
function rr(e, t, i) {
  const n = this.cache,
    s = i.allocateTextureUnit();
  n[0] !== s && (e.uniform1i(this.addr, s), (n[0] = s)),
    i.setTextureCube(t || Ds, s);
}
function ar(e, t, i) {
  const n = this.cache,
    s = i.allocateTextureUnit();
  n[0] !== s && (e.uniform1i(this.addr, s), (n[0] = s)),
    i.setTexture2DArray(t || Rs, s);
}
function or(e, t) {
  e.uniform1fv(this.addr, t);
}
function lr(e, t) {
  const i = Os(t, this.size, 2);
  e.uniform2fv(this.addr, i);
}
function hr(e, t) {
  const i = Os(t, this.size, 3);
  e.uniform3fv(this.addr, i);
}
function cr(e, t) {
  const i = Os(t, this.size, 4);
  e.uniform4fv(this.addr, i);
}
function ur(e, t) {
  const i = Os(t, this.size, 4);
  e.uniformMatrix2fv(this.addr, !1, i);
}
function dr(e, t) {
  const i = Os(t, this.size, 9);
  e.uniformMatrix3fv(this.addr, !1, i);
}
function pr(e, t) {
  const i = Os(t, this.size, 16);
  e.uniformMatrix4fv(this.addr, !1, i);
}
function fr(e, t) {
  e.uniform1iv(this.addr, t);
}
function mr(e, t) {
  e.uniform2iv(this.addr, t);
}
function gr(e, t) {
  e.uniform3iv(this.addr, t);
}
function _r(e, t) {
  e.uniform4iv(this.addr, t);
}
function vr(e, t) {
  e.uniform1uiv(this.addr, t);
}
function Ar(e, t) {
  e.uniform2uiv(this.addr, t);
}
function yr(e, t) {
  e.uniform3uiv(this.addr, t);
}
function xr(e, t) {
  e.uniform4uiv(this.addr, t);
}
function br(e, t, i) {
  const n = this.cache,
    s = t.length,
    r = Gs(i, s);
  Us(n, r) || (e.uniform1iv(this.addr, r), zs(n, r));
  for (let a = 0; a !== s; ++a) i.setTexture2D(t[a] || Is, r[a]);
}
function Er(e, t, i) {
  const n = this.cache,
    s = t.length,
    r = Gs(i, s);
  Us(n, r) || (e.uniform1iv(this.addr, r), zs(n, r));
  for (let a = 0; a !== s; ++a) i.setTexture3D(t[a] || Ps, r[a]);
}
function Sr(e, t, i) {
  const n = this.cache,
    s = t.length,
    r = Gs(i, s);
  Us(n, r) || (e.uniform1iv(this.addr, r), zs(n, r));
  for (let a = 0; a !== s; ++a) i.setTextureCube(t[a] || Ds, r[a]);
}
function Cr(e, t, i) {
  const n = this.cache,
    s = t.length,
    r = Gs(i, s);
  Us(n, r) || (e.uniform1iv(this.addr, r), zs(n, r));
  for (let a = 0; a !== s; ++a) i.setTexture2DArray(t[a] || Rs, r[a]);
}
class Mr {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.setValue = (function (e) {
        switch (e) {
          case 5126:
            return Vs;
          case 35664:
            return Qs;
          case 35665:
            return Hs;
          case 35666:
            return js;
          case 35674:
            return Ws;
          case 35675:
            return qs;
          case 35676:
            return Xs;
          case 5124:
          case 35670:
            return Ys;
          case 35667:
          case 35671:
            return Ks;
          case 35668:
          case 35672:
            return Zs;
          case 35669:
          case 35673:
            return Js;
          case 5125:
            return $s;
          case 36294:
            return er;
          case 36295:
            return tr;
          case 36296:
            return ir;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return nr;
          case 35679:
          case 36299:
          case 36307:
            return sr;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return rr;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return ar;
        }
      })(t.type));
  }
}
class wr {
  constructor(e, t, i) {
    (this.id = e),
      (this.addr = i),
      (this.cache = []),
      (this.size = t.size),
      (this.setValue = (function (e) {
        switch (e) {
          case 5126:
            return or;
          case 35664:
            return lr;
          case 35665:
            return hr;
          case 35666:
            return cr;
          case 35674:
            return ur;
          case 35675:
            return dr;
          case 35676:
            return pr;
          case 5124:
          case 35670:
            return fr;
          case 35667:
          case 35671:
            return mr;
          case 35668:
          case 35672:
            return gr;
          case 35669:
          case 35673:
            return _r;
          case 5125:
            return vr;
          case 36294:
            return Ar;
          case 36295:
            return yr;
          case 36296:
            return xr;
          case 35678:
          case 36198:
          case 36298:
          case 36306:
          case 35682:
            return br;
          case 35679:
          case 36299:
          case 36307:
            return Er;
          case 35680:
          case 36300:
          case 36308:
          case 36293:
            return Sr;
          case 36289:
          case 36303:
          case 36311:
          case 36292:
            return Cr;
        }
      })(t.type));
  }
}
class Tr {
  constructor(e) {
    (this.id = e), (this.seq = []), (this.map = {});
  }
  setValue(e, t, i) {
    const n = this.seq;
    for (let s = 0, r = n.length; s !== r; ++s) {
      const r = n[s];
      r.setValue(e, t[r.id], i);
    }
  }
}
const Ir = /(\w+)(\])?(\[|\.)?/g;
function Rr(e, t) {
  e.seq.push(t), (e.map[t.id] = t);
}
function Pr(e, t, i) {
  const n = e.name,
    s = n.length;
  for (Ir.lastIndex = 0; ; ) {
    const r = Ir.exec(n),
      a = Ir.lastIndex;
    let o = r[1];
    const l = "]" === r[2],
      h = r[3];
    if ((l && (o |= 0), void 0 === h || ("[" === h && a + 2 === s))) {
      Rr(i, void 0 === h ? new Mr(o, e, t) : new wr(o, e, t));
      break;
    }
    {
      let e = i.map[o];
      void 0 === e && ((e = new Tr(o)), Rr(i, e)), (i = e);
    }
  }
}
class Dr {
  constructor(e, t) {
    (this.seq = []), (this.map = {});
    const i = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
    for (let n = 0; n < i; ++n) {
      const i = e.getActiveUniform(t, n);
      Pr(i, e.getUniformLocation(t, i.name), this);
    }
  }
  setValue(e, t, i, n) {
    const s = this.map[t];
    void 0 !== s && s.setValue(e, i, n);
  }
  setOptional(e, t, i) {
    const n = t[i];
    void 0 !== n && this.setValue(e, i, n);
  }
  static upload(e, t, i, n) {
    for (let s = 0, r = t.length; s !== r; ++s) {
      const r = t[s],
        a = i[r.id];
      !1 !== a.needsUpdate && r.setValue(e, a.value, n);
    }
  }
  static seqWithValue(e, t) {
    const i = [];
    for (let n = 0, s = e.length; n !== s; ++n) {
      const s = e[n];
      s.id in t && i.push(s);
    }
    return i;
  }
}
function Lr(e, t, i) {
  const n = e.createShader(t);
  return e.shaderSource(n, i), e.compileShader(n), n;
}
let Fr = 0;
function Nr(e, t, i) {
  const n = e.getShaderParameter(t, e.COMPILE_STATUS),
    s = e.getShaderInfoLog(t).trim();
  if (n && "" === s) return "";
  const r = /ERROR: 0:(\d+)/.exec(s);
  if (r) {
    const n = parseInt(r[1]);
    return (
      i.toUpperCase() +
      "\n\n" +
      s +
      "\n\n" +
      (function (e, t) {
        const i = e.split("\n"),
          n = [],
          s = Math.max(t - 6, 0),
          r = Math.min(t + 6, i.length);
        for (let a = s; a < r; a++) {
          const e = a + 1;
          n.push(`${e === t ? ">" : " "} ${e}: ${i[a]}`);
        }
        return n.join("\n");
      })(e.getShaderSource(t), n)
    );
  }
  return s;
}
function Br(e, t) {
  const i = (function (e) {
    switch (e) {
      case ge:
        return ["Linear", "( value )"];
      case me:
        return ["sRGB", "( value )"];
      default:
        return (
          console.warn("THREE.WebGLProgram: Unsupported color space:", e),
          ["Linear", "( value )"]
        );
    }
  })(t);
  return "vec4 " + e + "( vec4 value ) { return LinearTo" + i[0] + i[1] + "; }";
}
function kr(e, t) {
  let i;
  switch (t) {
    case v:
      i = "Linear";
      break;
    case A:
      i = "Reinhard";
      break;
    case y:
      i = "OptimizedCineon";
      break;
    case x:
      i = "ACESFilmic";
      break;
    case b:
      i = "Custom";
      break;
    default:
      console.warn("THREE.WebGLProgram: Unsupported toneMapping:", t),
        (i = "Linear");
  }
  return (
    "vec3 " + e + "( vec3 color ) { return " + i + "ToneMapping( color ); }"
  );
}
function Or(e) {
  return "" !== e;
}
function Ur(e, t) {
  const i =
    t.numSpotLightShadows + t.numSpotLightMaps - t.numSpotLightShadowsWithMaps;
  return e
    .replace(/NUM_DIR_LIGHTS/g, t.numDirLights)
    .replace(/NUM_SPOT_LIGHTS/g, t.numSpotLights)
    .replace(/NUM_SPOT_LIGHT_MAPS/g, t.numSpotLightMaps)
    .replace(/NUM_SPOT_LIGHT_COORDS/g, i)
    .replace(/NUM_RECT_AREA_LIGHTS/g, t.numRectAreaLights)
    .replace(/NUM_POINT_LIGHTS/g, t.numPointLights)
    .replace(/NUM_HEMI_LIGHTS/g, t.numHemiLights)
    .replace(/NUM_DIR_LIGHT_SHADOWS/g, t.numDirLightShadows)
    .replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, t.numSpotLightShadowsWithMaps)
    .replace(/NUM_SPOT_LIGHT_SHADOWS/g, t.numSpotLightShadows)
    .replace(/NUM_POINT_LIGHT_SHADOWS/g, t.numPointLightShadows);
}
function zr(e, t) {
  return e
    .replace(/NUM_CLIPPING_PLANES/g, t.numClippingPlanes)
    .replace(
      /UNION_CLIPPING_PLANES/g,
      t.numClippingPlanes - t.numClipIntersection
    );
}
const Gr = /^[ \t]*#include +<([\w\d./]+)>/gm;
function Vr(e) {
  return e.replace(Gr, Hr);
}
const Qr = new Map([
  ["encodings_fragment", "colorspace_fragment"],
  ["encodings_pars_fragment", "colorspace_pars_fragment"],
  ["output_fragment", "opaque_fragment"],
]);
function Hr(e, t) {
  let i = qn[t];
  if (void 0 === i) {
    const e = Qr.get(t);
    if (void 0 === e) throw new Error("Can not resolve #include <" + t + ">");
    (i = qn[e]),
      console.warn(
        'THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.',
        t,
        e
      );
  }
  return Vr(i);
}
const jr =
  /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Wr(e) {
  return e.replace(jr, qr);
}
function qr(e, t, i, n) {
  let s = "";
  for (let r = parseInt(t); r < parseInt(i); r++)
    s += n
      .replace(/\[\s*i\s*\]/g, "[ " + r + " ]")
      .replace(/UNROLLED_LOOP_INDEX/g, r);
  return s;
}
function Xr(e) {
  let t =
    "precision " + e.precision + " float;\nprecision " + e.precision + " int;";
  return (
    "highp" === e.precision
      ? (t += "\n#define HIGH_PRECISION")
      : "mediump" === e.precision
      ? (t += "\n#define MEDIUM_PRECISION")
      : "lowp" === e.precision && (t += "\n#define LOW_PRECISION"),
    t
  );
}
function Yr(e, t, i, n) {
  const s = e.getContext(),
    r = i.defines;
  let h = i.vertexShader,
    c = i.fragmentShader;
  const u = (function (e) {
      let t = "SHADOWMAP_TYPE_BASIC";
      return (
        e.shadowMapType === a
          ? (t = "SHADOWMAP_TYPE_PCF")
          : e.shadowMapType === o
          ? (t = "SHADOWMAP_TYPE_PCF_SOFT")
          : e.shadowMapType === l && (t = "SHADOWMAP_TYPE_VSM"),
        t
      );
    })(i),
    d = (function (e) {
      let t = "ENVMAP_TYPE_CUBE";
      if (e.envMap)
        switch (e.envMapMode) {
          case E:
          case S:
            t = "ENVMAP_TYPE_CUBE";
            break;
          case M:
            t = "ENVMAP_TYPE_CUBE_UV";
        }
      return t;
    })(i),
    p = (function (e) {
      let t = "ENVMAP_MODE_REFLECTION";
      e.envMap && e.envMapMode === S && (t = "ENVMAP_MODE_REFRACTION");
      return t;
    })(i),
    v = (function (e) {
      let t = "ENVMAP_BLENDING_NONE";
      if (e.envMap)
        switch (e.combine) {
          case f:
            t = "ENVMAP_BLENDING_MULTIPLY";
            break;
          case m:
            t = "ENVMAP_BLENDING_MIX";
            break;
          case g:
            t = "ENVMAP_BLENDING_ADD";
        }
      return t;
    })(i),
    A = (function (e) {
      const t = e.envMapCubeUVHeight;
      if (null === t) return null;
      const i = Math.log2(t) - 2,
        n = 1 / t;
      return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)),
        texelHeight: n,
        maxMip: i,
      };
    })(i),
    y = i.isWebGL2
      ? ""
      : (function (e) {
          return [
            e.extensionDerivatives ||
            e.envMapCubeUVHeight ||
            e.bumpMap ||
            e.normalMapTangentSpace ||
            e.clearcoatNormalMap ||
            e.flatShading ||
            "physical" === e.shaderID
              ? "#extension GL_OES_standard_derivatives : enable"
              : "",
            (e.extensionFragDepth || e.logarithmicDepthBuffer) &&
            e.rendererExtensionFragDepth
              ? "#extension GL_EXT_frag_depth : enable"
              : "",
            e.extensionDrawBuffers && e.rendererExtensionDrawBuffers
              ? "#extension GL_EXT_draw_buffers : require"
              : "",
            (e.extensionShaderTextureLOD || e.envMap || e.transmission) &&
            e.rendererExtensionShaderTextureLod
              ? "#extension GL_EXT_shader_texture_lod : enable"
              : "",
          ]
            .filter(Or)
            .join("\n");
        })(i),
    x = (function (e) {
      const t = [];
      for (const i in e) {
        const n = e[i];
        !1 !== n && t.push("#define " + i + " " + n);
      }
      return t.join("\n");
    })(r),
    b = s.createProgram();
  let C,
    w,
    T = i.glslVersion ? "#version " + i.glslVersion + "\n" : "";
  if (
    (i.isRawShaderMaterial
      ? ((C = [
          "#define SHADER_TYPE " + i.shaderType,
          "#define SHADER_NAME " + i.shaderName,
          x,
        ]
          .filter(Or)
          .join("\n")),
        C.length > 0 && (C += "\n"),
        (w = [
          y,
          "#define SHADER_TYPE " + i.shaderType,
          "#define SHADER_NAME " + i.shaderName,
          x,
        ]
          .filter(Or)
          .join("\n")),
        w.length > 0 && (w += "\n"))
      : ((C = [
          Xr(i),
          "#define SHADER_TYPE " + i.shaderType,
          "#define SHADER_NAME " + i.shaderName,
          x,
          i.instancing ? "#define USE_INSTANCING" : "",
          i.instancingColor ? "#define USE_INSTANCING_COLOR" : "",
          i.useFog && i.fog ? "#define USE_FOG" : "",
          i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
          i.map ? "#define USE_MAP" : "",
          i.envMap ? "#define USE_ENVMAP" : "",
          i.envMap ? "#define " + p : "",
          i.lightMap ? "#define USE_LIGHTMAP" : "",
          i.aoMap ? "#define USE_AOMAP" : "",
          i.bumpMap ? "#define USE_BUMPMAP" : "",
          i.normalMap ? "#define USE_NORMALMAP" : "",
          i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          i.displacementMap ? "#define USE_DISPLACEMENTMAP" : "",
          i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          i.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          i.specularMap ? "#define USE_SPECULARMAP" : "",
          i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          i.metalnessMap ? "#define USE_METALNESSMAP" : "",
          i.alphaMap ? "#define USE_ALPHAMAP" : "",
          i.alphaHash ? "#define USE_ALPHAHASH" : "",
          i.transmission ? "#define USE_TRANSMISSION" : "",
          i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          i.mapUv ? "#define MAP_UV " + i.mapUv : "",
          i.alphaMapUv ? "#define ALPHAMAP_UV " + i.alphaMapUv : "",
          i.lightMapUv ? "#define LIGHTMAP_UV " + i.lightMapUv : "",
          i.aoMapUv ? "#define AOMAP_UV " + i.aoMapUv : "",
          i.emissiveMapUv ? "#define EMISSIVEMAP_UV " + i.emissiveMapUv : "",
          i.bumpMapUv ? "#define BUMPMAP_UV " + i.bumpMapUv : "",
          i.normalMapUv ? "#define NORMALMAP_UV " + i.normalMapUv : "",
          i.displacementMapUv
            ? "#define DISPLACEMENTMAP_UV " + i.displacementMapUv
            : "",
          i.metalnessMapUv ? "#define METALNESSMAP_UV " + i.metalnessMapUv : "",
          i.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + i.roughnessMapUv : "",
          i.anisotropyMapUv
            ? "#define ANISOTROPYMAP_UV " + i.anisotropyMapUv
            : "",
          i.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + i.clearcoatMapUv : "",
          i.clearcoatNormalMapUv
            ? "#define CLEARCOAT_NORMALMAP_UV " + i.clearcoatNormalMapUv
            : "",
          i.clearcoatRoughnessMapUv
            ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + i.clearcoatRoughnessMapUv
            : "",
          i.iridescenceMapUv
            ? "#define IRIDESCENCEMAP_UV " + i.iridescenceMapUv
            : "",
          i.iridescenceThicknessMapUv
            ? "#define IRIDESCENCE_THICKNESSMAP_UV " +
              i.iridescenceThicknessMapUv
            : "",
          i.sheenColorMapUv
            ? "#define SHEEN_COLORMAP_UV " + i.sheenColorMapUv
            : "",
          i.sheenRoughnessMapUv
            ? "#define SHEEN_ROUGHNESSMAP_UV " + i.sheenRoughnessMapUv
            : "",
          i.specularMapUv ? "#define SPECULARMAP_UV " + i.specularMapUv : "",
          i.specularColorMapUv
            ? "#define SPECULAR_COLORMAP_UV " + i.specularColorMapUv
            : "",
          i.specularIntensityMapUv
            ? "#define SPECULAR_INTENSITYMAP_UV " + i.specularIntensityMapUv
            : "",
          i.transmissionMapUv
            ? "#define TRANSMISSIONMAP_UV " + i.transmissionMapUv
            : "",
          i.thicknessMapUv ? "#define THICKNESSMAP_UV " + i.thicknessMapUv : "",
          i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "",
          i.vertexColors ? "#define USE_COLOR" : "",
          i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          i.vertexUv1s ? "#define USE_UV1" : "",
          i.vertexUv2s ? "#define USE_UV2" : "",
          i.vertexUv3s ? "#define USE_UV3" : "",
          i.pointsUvs ? "#define USE_POINTS_UV" : "",
          i.flatShading ? "#define FLAT_SHADED" : "",
          i.skinning ? "#define USE_SKINNING" : "",
          i.morphTargets ? "#define USE_MORPHTARGETS" : "",
          i.morphNormals && !1 === i.flatShading
            ? "#define USE_MORPHNORMALS"
            : "",
          i.morphColors && i.isWebGL2 ? "#define USE_MORPHCOLORS" : "",
          i.morphTargetsCount > 0 && i.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE"
            : "",
          i.morphTargetsCount > 0 && i.isWebGL2
            ? "#define MORPHTARGETS_TEXTURE_STRIDE " + i.morphTextureStride
            : "",
          i.morphTargetsCount > 0 && i.isWebGL2
            ? "#define MORPHTARGETS_COUNT " + i.morphTargetsCount
            : "",
          i.doubleSided ? "#define DOUBLE_SIDED" : "",
          i.flipSided ? "#define FLIP_SIDED" : "",
          i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          i.shadowMapEnabled ? "#define " + u : "",
          i.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "",
          i.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 modelMatrix;",
          "uniform mat4 modelViewMatrix;",
          "uniform mat4 projectionMatrix;",
          "uniform mat4 viewMatrix;",
          "uniform mat3 normalMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          "#ifdef USE_INSTANCING",
          "\tattribute mat4 instanceMatrix;",
          "#endif",
          "#ifdef USE_INSTANCING_COLOR",
          "\tattribute vec3 instanceColor;",
          "#endif",
          "attribute vec3 position;",
          "attribute vec3 normal;",
          "attribute vec2 uv;",
          "#ifdef USE_UV1",
          "\tattribute vec2 uv1;",
          "#endif",
          "#ifdef USE_UV2",
          "\tattribute vec2 uv2;",
          "#endif",
          "#ifdef USE_UV3",
          "\tattribute vec2 uv3;",
          "#endif",
          "#ifdef USE_TANGENT",
          "\tattribute vec4 tangent;",
          "#endif",
          "#if defined( USE_COLOR_ALPHA )",
          "\tattribute vec4 color;",
          "#elif defined( USE_COLOR )",
          "\tattribute vec3 color;",
          "#endif",
          "#if ( defined( USE_MORPHTARGETS ) && ! defined( MORPHTARGETS_TEXTURE ) )",
          "\tattribute vec3 morphTarget0;",
          "\tattribute vec3 morphTarget1;",
          "\tattribute vec3 morphTarget2;",
          "\tattribute vec3 morphTarget3;",
          "\t#ifdef USE_MORPHNORMALS",
          "\t\tattribute vec3 morphNormal0;",
          "\t\tattribute vec3 morphNormal1;",
          "\t\tattribute vec3 morphNormal2;",
          "\t\tattribute vec3 morphNormal3;",
          "\t#else",
          "\t\tattribute vec3 morphTarget4;",
          "\t\tattribute vec3 morphTarget5;",
          "\t\tattribute vec3 morphTarget6;",
          "\t\tattribute vec3 morphTarget7;",
          "\t#endif",
          "#endif",
          "#ifdef USE_SKINNING",
          "\tattribute vec4 skinIndex;",
          "\tattribute vec4 skinWeight;",
          "#endif",
          "\n",
        ]
          .filter(Or)
          .join("\n")),
        (w = [
          y,
          Xr(i),
          "#define SHADER_TYPE " + i.shaderType,
          "#define SHADER_NAME " + i.shaderName,
          x,
          i.useFog && i.fog ? "#define USE_FOG" : "",
          i.useFog && i.fogExp2 ? "#define FOG_EXP2" : "",
          i.map ? "#define USE_MAP" : "",
          i.matcap ? "#define USE_MATCAP" : "",
          i.envMap ? "#define USE_ENVMAP" : "",
          i.envMap ? "#define " + d : "",
          i.envMap ? "#define " + p : "",
          i.envMap ? "#define " + v : "",
          A ? "#define CUBEUV_TEXEL_WIDTH " + A.texelWidth : "",
          A ? "#define CUBEUV_TEXEL_HEIGHT " + A.texelHeight : "",
          A ? "#define CUBEUV_MAX_MIP " + A.maxMip + ".0" : "",
          i.lightMap ? "#define USE_LIGHTMAP" : "",
          i.aoMap ? "#define USE_AOMAP" : "",
          i.bumpMap ? "#define USE_BUMPMAP" : "",
          i.normalMap ? "#define USE_NORMALMAP" : "",
          i.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "",
          i.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "",
          i.emissiveMap ? "#define USE_EMISSIVEMAP" : "",
          i.anisotropy ? "#define USE_ANISOTROPY" : "",
          i.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "",
          i.clearcoat ? "#define USE_CLEARCOAT" : "",
          i.clearcoatMap ? "#define USE_CLEARCOATMAP" : "",
          i.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "",
          i.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "",
          i.iridescence ? "#define USE_IRIDESCENCE" : "",
          i.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "",
          i.iridescenceThicknessMap
            ? "#define USE_IRIDESCENCE_THICKNESSMAP"
            : "",
          i.specularMap ? "#define USE_SPECULARMAP" : "",
          i.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "",
          i.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "",
          i.roughnessMap ? "#define USE_ROUGHNESSMAP" : "",
          i.metalnessMap ? "#define USE_METALNESSMAP" : "",
          i.alphaMap ? "#define USE_ALPHAMAP" : "",
          i.alphaTest ? "#define USE_ALPHATEST" : "",
          i.alphaHash ? "#define USE_ALPHAHASH" : "",
          i.sheen ? "#define USE_SHEEN" : "",
          i.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "",
          i.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "",
          i.transmission ? "#define USE_TRANSMISSION" : "",
          i.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "",
          i.thicknessMap ? "#define USE_THICKNESSMAP" : "",
          i.vertexTangents && !1 === i.flatShading ? "#define USE_TANGENT" : "",
          i.vertexColors || i.instancingColor ? "#define USE_COLOR" : "",
          i.vertexAlphas ? "#define USE_COLOR_ALPHA" : "",
          i.vertexUv1s ? "#define USE_UV1" : "",
          i.vertexUv2s ? "#define USE_UV2" : "",
          i.vertexUv3s ? "#define USE_UV3" : "",
          i.pointsUvs ? "#define USE_POINTS_UV" : "",
          i.gradientMap ? "#define USE_GRADIENTMAP" : "",
          i.flatShading ? "#define FLAT_SHADED" : "",
          i.doubleSided ? "#define DOUBLE_SIDED" : "",
          i.flipSided ? "#define FLIP_SIDED" : "",
          i.shadowMapEnabled ? "#define USE_SHADOWMAP" : "",
          i.shadowMapEnabled ? "#define " + u : "",
          i.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "",
          i.useLegacyLights ? "#define LEGACY_LIGHTS" : "",
          i.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "",
          i.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "",
          i.logarithmicDepthBuffer && i.rendererExtensionFragDepth
            ? "#define USE_LOGDEPTHBUF_EXT"
            : "",
          "uniform mat4 viewMatrix;",
          "uniform vec3 cameraPosition;",
          "uniform bool isOrthographic;",
          i.toneMapping !== _ ? "#define TONE_MAPPING" : "",
          i.toneMapping !== _ ? qn.tonemapping_pars_fragment : "",
          i.toneMapping !== _ ? kr("toneMapping", i.toneMapping) : "",
          i.dithering ? "#define DITHERING" : "",
          i.opaque ? "#define OPAQUE" : "",
          qn.colorspace_pars_fragment,
          Br("linearToOutputTexel", i.outputColorSpace),
          i.useDepthPacking ? "#define DEPTH_PACKING " + i.depthPacking : "",
          "\n",
        ]
          .filter(Or)
          .join("\n"))),
    e.onShaderBeforeResolve)
  ) {
    const t = e.onShaderBeforeResolve(h, c, i);
    (h = t.vertexShader), (c = t.fragmentShader);
  }
  (h = Vr(h)),
    (h = Ur(h, i)),
    (h = zr(h, i)),
    (c = Vr(c)),
    (c = Ur(c, i)),
    (c = zr(c, i)),
    (h = Wr(h)),
    (c = Wr(c)),
    i.isWebGL2 &&
      !0 !== i.isRawShaderMaterial &&
      ((T = "#version 300 es\n"),
      (C =
        [
          "precision mediump sampler2DArray;",
          "#define attribute in",
          "#define varying out",
          "#define texture2D texture",
        ].join("\n") +
        "\n" +
        C),
      (w =
        [
          "#define varying in",
          i.glslVersion === be
            ? ""
            : "layout(location = 0) out highp vec4 pc_fragColor;",
          i.glslVersion === be ? "" : "#define gl_FragColor pc_fragColor",
          "#define gl_FragDepthEXT gl_FragDepth",
          "#define texture2D texture",
          "#define textureCube texture",
          "#define texture2DProj textureProj",
          "#define texture2DLodEXT textureLod",
          "#define texture2DProjLodEXT textureProjLod",
          "#define textureCubeLodEXT textureLod",
          "#define texture2DGradEXT textureGrad",
          "#define texture2DProjGradEXT textureProjGrad",
          "#define textureCubeGradEXT textureGrad",
        ].join("\n") +
        "\n" +
        w));
  let I = T + C + h,
    R = T + w + c;
  if (e.onShaderBeforeCompile) {
    const t = e.onShaderBeforeCompile(I, R, i);
    (I = t.vertexShader), (R = t.fragmentShader);
  }
  const P = Lr(s, s.VERTEX_SHADER, I),
    D = Lr(s, s.FRAGMENT_SHADER, R);
  if (
    (s.attachShader(b, P),
    s.attachShader(b, D),
    void 0 !== i.index0AttributeName
      ? s.bindAttribLocation(b, 0, i.index0AttributeName)
      : !0 === i.morphTargets && s.bindAttribLocation(b, 0, "position"),
    s.linkProgram(b),
    e.debug.checkShaderErrors)
  ) {
    const t = s.getProgramInfoLog(b).trim(),
      i = s.getShaderInfoLog(P).trim(),
      n = s.getShaderInfoLog(D).trim();
    let r = !0,
      a = !0;
    if (!1 === s.getProgramParameter(b, s.LINK_STATUS))
      if (((r = !1), "function" == typeof e.debug.onShaderError))
        e.debug.onShaderError(s, b, P, D);
      else {
        const e = Nr(s, P, "vertex"),
          i = Nr(s, D, "fragment");
        console.error(
          "THREE.WebGLProgram: Shader Error " +
            s.getError() +
            " - VALIDATE_STATUS " +
            s.getProgramParameter(b, s.VALIDATE_STATUS) +
            "\n\nProgram Info Log: " +
            t +
            "\n" +
            e +
            "\n" +
            i
        );
      }
    else
      "" !== t
        ? console.warn("THREE.WebGLProgram: Program Info Log:", t)
        : ("" !== i && "" !== n) || (a = !1);
    a &&
      (this.diagnostics = {
        runnable: r,
        programLog: t,
        vertexShader: { log: i, prefix: C },
        fragmentShader: { log: n, prefix: w },
      });
  }
  let L, F;
  return (
    s.deleteShader(P),
    s.deleteShader(D),
    (this.getUniforms = function () {
      return void 0 === L && (L = new Dr(s, b)), L;
    }),
    (this.getAttributes = function () {
      return (
        void 0 === F &&
          (F = (function (e, t) {
            const i = {},
              n = e.getProgramParameter(t, e.ACTIVE_ATTRIBUTES);
            for (let s = 0; s < n; s++) {
              const n = e.getActiveAttrib(t, s),
                r = n.name;
              let a = 1;
              n.type === e.FLOAT_MAT2 && (a = 2),
                n.type === e.FLOAT_MAT3 && (a = 3),
                n.type === e.FLOAT_MAT4 && (a = 4),
                (i[r] = {
                  type: n.type,
                  location: e.getAttribLocation(t, r),
                  locationSize: a,
                });
            }
            return i;
          })(s, b)),
        F
      );
    }),
    (this.destroy = function () {
      n.releaseStatesOfProgram(this),
        s.deleteProgram(b),
        (this.program = void 0);
    }),
    (this.type = i.shaderType),
    (this.name = i.shaderName),
    (this.id = Fr++),
    (this.cacheKey = t),
    (this.usedTimes = 1),
    (this.program = b),
    (this.vertexShader = P),
    (this.fragmentShader = D),
    this
  );
}
let Kr = 0;
class Zr {
  constructor() {
    (this.shaderCache = new Map()), (this.materialCache = new Map());
  }
  update(e) {
    const t = e.vertexShader,
      i = e.fragmentShader,
      n = this._getShaderStage(t),
      s = this._getShaderStage(i),
      r = this._getShaderCacheForMaterial(e);
    return (
      !1 === r.has(n) && (r.add(n), n.usedTimes++),
      !1 === r.has(s) && (r.add(s), s.usedTimes++),
      this
    );
  }
  remove(e) {
    const t = this.materialCache.get(e);
    for (const i of t)
      i.usedTimes--, 0 === i.usedTimes && this.shaderCache.delete(i.code);
    return this.materialCache.delete(e), this;
  }
  getVertexShaderID(e) {
    return this._getShaderStage(e.vertexShader).id;
  }
  getFragmentShaderID(e) {
    return this._getShaderStage(e.fragmentShader).id;
  }
  dispose() {
    this.shaderCache.clear(), this.materialCache.clear();
  }
  _getShaderCacheForMaterial(e) {
    const t = this.materialCache;
    let i = t.get(e);
    return void 0 === i && ((i = new Set()), t.set(e, i)), i;
  }
  _getShaderStage(e) {
    const t = this.shaderCache;
    let i = t.get(e);
    return void 0 === i && ((i = new Jr(e)), t.set(e, i)), i;
  }
}
class Jr {
  constructor(e) {
    (this.id = Kr++), (this.code = e), (this.usedTimes = 0);
  }
}
function $r(e, t, i, n, s, r, a) {
  const o = new ni(),
    l = new Zr(),
    h = [],
    u = s.isWebGL2,
    d = s.logarithmicDepthBuffer,
    p = s.vertexTextures;
  let f = s.precision;
  const m = {
    MeshDepthMaterial: "depth",
    MeshDistanceMaterial: "distanceRGBA",
    MeshNormalMaterial: "normal",
    MeshBasicMaterial: "basic",
    MeshLambertMaterial: "lambert",
    MeshPhongMaterial: "phong",
    MeshToonMaterial: "toon",
    MeshStandardMaterial: "physical",
    MeshPhysicalMaterial: "physical",
    MeshMatcapMaterial: "matcap",
    LineBasicMaterial: "basic",
    LineDashedMaterial: "dashed",
    PointsMaterial: "points",
    ShadowMaterial: "shadow",
    SpriteMaterial: "sprite",
  };
  function g(e) {
    return 0 === e ? "uv" : `uv${e}`;
  }
  return {
    getParameters: function (r, o, h, v, A) {
      const y = v.fog,
        x = A.geometry,
        b = r.isMeshStandardMaterial ? v.environment : null,
        E = (r.isMeshStandardMaterial ? i : t).get(r.envMap || b),
        S = E && E.mapping === M ? E.image.height : null,
        C = m[r.type];
      null !== r.precision &&
        ((f = s.getMaxPrecision(r.precision)),
        f !== r.precision &&
          console.warn(
            "THREE.WebGLProgram.getParameters:",
            r.precision,
            "not supported, using",
            f,
            "instead."
          ));
      const w =
          x.morphAttributes.position ||
          x.morphAttributes.normal ||
          x.morphAttributes.color,
        T = void 0 !== w ? w.length : 0;
      let I,
        R,
        P,
        D,
        L = 0;
      if (
        (void 0 !== x.morphAttributes.position && (L = 1),
        void 0 !== x.morphAttributes.normal && (L = 2),
        void 0 !== x.morphAttributes.color && (L = 3),
        C)
      ) {
        const e = Yn[C];
        (I = e.vertexShader), (R = e.fragmentShader);
      } else
        (I = r.vertexShader),
          (R = r.fragmentShader),
          l.update(r),
          (P = l.getVertexShaderID(r)),
          (D = l.getFragmentShaderID(r));
      const F = e.getRenderTarget(),
        N = !0 === A.isInstancedMesh,
        B = !!r.map,
        k = !!r.matcap,
        O = !!E,
        U = !!r.aoMap,
        z = !!r.lightMap,
        G = !!r.bumpMap,
        V = !!r.normalMap,
        Q = !!r.displacementMap,
        H = !!r.emissiveMap,
        j = !!r.metalnessMap,
        W = !!r.roughnessMap,
        q = r.anisotropy > 0,
        X = r.clearcoat > 0,
        Y = r.iridescence > 0,
        K = r.sheen > 0,
        Z = r.transmission > 0,
        J = q && !!r.anisotropyMap,
        $ = X && !!r.clearcoatMap,
        ee = X && !!r.clearcoatNormalMap,
        te = X && !!r.clearcoatRoughnessMap,
        ie = Y && !!r.iridescenceMap,
        ne = Y && !!r.iridescenceThicknessMap,
        se = K && !!r.sheenColorMap,
        re = K && !!r.sheenRoughnessMap,
        ae = !!r.specularMap,
        oe = !!r.specularColorMap,
        le = !!r.specularIntensityMap,
        he = Z && !!r.transmissionMap,
        ce = Z && !!r.thicknessMap,
        ue = !!r.gradientMap,
        de = !!r.alphaMap,
        pe = r.alphaTest > 0,
        fe = !!r.alphaHash,
        _e = !!r.extensions,
        ve = !!x.attributes.uv1,
        Ae = !!x.attributes.uv2,
        ye = !!x.attributes.uv3;
      let xe = _;
      return (
        r.toneMapped &&
          ((null !== F && !0 !== F.isXRRenderTarget) || (xe = e.toneMapping)),
        {
          isWebGL2: u,
          shaderID: C,
          shaderType: r.type,
          shaderName: r.name,
          vertexShader: I,
          fragmentShader: R,
          defines: r.defines,
          customVertexShaderID: P,
          customFragmentShaderID: D,
          isRawShaderMaterial: !0 === r.isRawShaderMaterial,
          glslVersion: r.glslVersion,
          precision: f,
          instancing: N,
          instancingColor: N && null !== A.instanceColor,
          supportsVertexTextures: p,
          outputColorSpace:
            null === F
              ? e.outputColorSpace
              : !0 === F.isXRRenderTarget
              ? F.texture.colorSpace
              : ge,
          map: B,
          matcap: k,
          envMap: O,
          envMapMode: O && E.mapping,
          envMapCubeUVHeight: S,
          aoMap: U,
          lightMap: z,
          bumpMap: G,
          normalMap: V,
          displacementMap: p && Q,
          emissiveMap: H,
          normalMapObjectSpace: V && 1 === r.normalMapType,
          normalMapTangentSpace: V && 0 === r.normalMapType,
          metalnessMap: j,
          roughnessMap: W,
          anisotropy: q,
          anisotropyMap: J,
          clearcoat: X,
          clearcoatMap: $,
          clearcoatNormalMap: ee,
          clearcoatRoughnessMap: te,
          iridescence: Y,
          iridescenceMap: ie,
          iridescenceThicknessMap: ne,
          sheen: K,
          sheenColorMap: se,
          sheenRoughnessMap: re,
          specularMap: ae,
          specularColorMap: oe,
          specularIntensityMap: le,
          transmission: Z,
          transmissionMap: he,
          thicknessMap: ce,
          gradientMap: ue,
          opaque: !1 === r.transparent && 1 === r.blending,
          alphaMap: de,
          alphaTest: pe,
          alphaHash: fe,
          combine: r.combine,
          mapUv: B && g(r.map.channel),
          aoMapUv: U && g(r.aoMap.channel),
          lightMapUv: z && g(r.lightMap.channel),
          bumpMapUv: G && g(r.bumpMap.channel),
          normalMapUv: V && g(r.normalMap.channel),
          displacementMapUv: Q && g(r.displacementMap.channel),
          emissiveMapUv: H && g(r.emissiveMap.channel),
          metalnessMapUv: j && g(r.metalnessMap.channel),
          roughnessMapUv: W && g(r.roughnessMap.channel),
          anisotropyMapUv: J && g(r.anisotropyMap.channel),
          clearcoatMapUv: $ && g(r.clearcoatMap.channel),
          clearcoatNormalMapUv: ee && g(r.clearcoatNormalMap.channel),
          clearcoatRoughnessMapUv: te && g(r.clearcoatRoughnessMap.channel),
          iridescenceMapUv: ie && g(r.iridescenceMap.channel),
          iridescenceThicknessMapUv: ne && g(r.iridescenceThicknessMap.channel),
          sheenColorMapUv: se && g(r.sheenColorMap.channel),
          sheenRoughnessMapUv: re && g(r.sheenRoughnessMap.channel),
          specularMapUv: ae && g(r.specularMap.channel),
          specularColorMapUv: oe && g(r.specularColorMap.channel),
          specularIntensityMapUv: le && g(r.specularIntensityMap.channel),
          transmissionMapUv: he && g(r.transmissionMap.channel),
          thicknessMapUv: ce && g(r.thicknessMap.channel),
          alphaMapUv: de && g(r.alphaMap.channel),
          vertexTangents: !!x.attributes.tangent && (V || q),
          vertexColors: r.vertexColors,
          vertexAlphas:
            !0 === r.vertexColors &&
            !!x.attributes.color &&
            4 === x.attributes.color.itemSize,
          vertexUv1s: ve,
          vertexUv2s: Ae,
          vertexUv3s: ye,
          pointsUvs: !0 === A.isPoints && !!x.attributes.uv && (B || de),
          fog: !!y,
          useFog: !0 === r.fog,
          fogExp2: y && y.isFogExp2,
          flatShading: !0 === r.flatShading,
          sizeAttenuation: !0 === r.sizeAttenuation,
          logarithmicDepthBuffer: d,
          skinning: !0 === A.isSkinnedMesh,
          morphTargets: void 0 !== x.morphAttributes.position,
          morphNormals: void 0 !== x.morphAttributes.normal,
          morphColors: void 0 !== x.morphAttributes.color,
          morphTargetsCount: T,
          morphTextureStride: L,
          numDirLights: o.directional.length,
          numPointLights: o.point.length,
          numSpotLights: o.spot.length,
          numSpotLightMaps: o.spotLightMap.length,
          numRectAreaLights: o.rectArea.length,
          numHemiLights: o.hemi.length,
          numDirLightShadows: o.directionalShadowMap.length,
          numPointLightShadows: o.pointShadowMap.length,
          numSpotLightShadows: o.spotShadowMap.length,
          numSpotLightShadowsWithMaps: o.numSpotLightShadowsWithMaps,
          numClippingPlanes: a.numPlanes,
          numClipIntersection: a.numIntersection,
          dithering: r.dithering,
          shadowMapEnabled: e.shadowMap.enabled && h.length > 0,
          shadowMapType: e.shadowMap.type,
          toneMapping: xe,
          useLegacyLights: e._useLegacyLights,
          decodeVideoTexture:
            B && !0 === r.map.isVideoTexture && r.map.colorSpace === me,
          premultipliedAlpha: r.premultipliedAlpha,
          doubleSided: 2 === r.side,
          flipSided: r.side === c,
          useDepthPacking: r.depthPacking >= 0,
          depthPacking: r.depthPacking || 0,
          index0AttributeName: r.index0AttributeName,
          extensionDerivatives: _e && !0 === r.extensions.derivatives,
          extensionFragDepth: _e && !0 === r.extensions.fragDepth,
          extensionDrawBuffers: _e && !0 === r.extensions.drawBuffers,
          extensionShaderTextureLOD: _e && !0 === r.extensions.shaderTextureLOD,
          rendererExtensionFragDepth: u || n.has("EXT_frag_depth"),
          rendererExtensionDrawBuffers: u || n.has("WEBGL_draw_buffers"),
          rendererExtensionShaderTextureLod:
            u || n.has("EXT_shader_texture_lod"),
          customProgramCacheKey: r.customProgramCacheKey(),
          extraProgramCacheKey: e.extraProgramCacheKey,
        }
      );
    },
    getProgramCacheKey: function (t) {
      const i = [];
      if (
        (t.shaderID
          ? i.push(t.shaderID)
          : (i.push(t.customVertexShaderID), i.push(t.customFragmentShaderID)),
        void 0 !== t.defines)
      )
        for (const e in t.defines) i.push(e), i.push(t.defines[e]);
      return (
        !1 === t.isRawShaderMaterial &&
          (!(function (e, t) {
            e.push(t.precision),
              e.push(t.outputColorSpace),
              e.push(t.envMapMode),
              e.push(t.envMapCubeUVHeight),
              e.push(t.mapUv),
              e.push(t.alphaMapUv),
              e.push(t.lightMapUv),
              e.push(t.aoMapUv),
              e.push(t.bumpMapUv),
              e.push(t.normalMapUv),
              e.push(t.displacementMapUv),
              e.push(t.emissiveMapUv),
              e.push(t.metalnessMapUv),
              e.push(t.roughnessMapUv),
              e.push(t.anisotropyMapUv),
              e.push(t.clearcoatMapUv),
              e.push(t.clearcoatNormalMapUv),
              e.push(t.clearcoatRoughnessMapUv),
              e.push(t.iridescenceMapUv),
              e.push(t.iridescenceThicknessMapUv),
              e.push(t.sheenColorMapUv),
              e.push(t.sheenRoughnessMapUv),
              e.push(t.specularMapUv),
              e.push(t.specularColorMapUv),
              e.push(t.specularIntensityMapUv),
              e.push(t.transmissionMapUv),
              e.push(t.thicknessMapUv),
              e.push(t.combine),
              e.push(t.fogExp2),
              e.push(t.sizeAttenuation),
              e.push(t.morphTargetsCount),
              e.push(t.morphAttributeCount),
              e.push(t.numDirLights),
              e.push(t.numPointLights),
              e.push(t.numSpotLights),
              e.push(t.numSpotLightMaps),
              e.push(t.numHemiLights),
              e.push(t.numRectAreaLights),
              e.push(t.numDirLightShadows),
              e.push(t.numPointLightShadows),
              e.push(t.numSpotLightShadows),
              e.push(t.numSpotLightShadowsWithMaps),
              e.push(t.shadowMapType),
              e.push(t.toneMapping),
              e.push(t.numClippingPlanes),
              e.push(t.numClipIntersection),
              e.push(t.depthPacking);
          })(i, t),
          (function (e, t) {
            o.disableAll(), t.isWebGL2 && o.enable(0);
            t.supportsVertexTextures && o.enable(1);
            t.instancing && o.enable(2);
            t.instancingColor && o.enable(3);
            t.matcap && o.enable(4);
            t.envMap && o.enable(5);
            t.normalMapObjectSpace && o.enable(6);
            t.normalMapTangentSpace && o.enable(7);
            t.clearcoat && o.enable(8);
            t.iridescence && o.enable(9);
            t.alphaTest && o.enable(10);
            t.vertexColors && o.enable(11);
            t.vertexAlphas && o.enable(12);
            t.vertexUv1s && o.enable(13);
            t.vertexUv2s && o.enable(14);
            t.vertexUv3s && o.enable(15);
            t.vertexTangents && o.enable(16);
            t.anisotropy && o.enable(17);
            e.push(o.mask), o.disableAll(), t.fog && o.enable(0);
            t.useFog && o.enable(1);
            t.flatShading && o.enable(2);
            t.logarithmicDepthBuffer && o.enable(3);
            t.skinning && o.enable(4);
            t.morphTargets && o.enable(5);
            t.morphNormals && o.enable(6);
            t.morphColors && o.enable(7);
            t.premultipliedAlpha && o.enable(8);
            t.shadowMapEnabled && o.enable(9);
            t.useLegacyLights && o.enable(10);
            t.doubleSided && o.enable(11);
            t.flipSided && o.enable(12);
            t.useDepthPacking && o.enable(13);
            t.dithering && o.enable(14);
            t.transmission && o.enable(15);
            t.sheen && o.enable(16);
            t.opaque && o.enable(17);
            t.pointsUvs && o.enable(18);
            t.decodeVideoTexture && o.enable(19);
            e.push(o.mask);
          })(i, t),
          i.push(e.outputColorSpace)),
        i.push(t.customProgramCacheKey),
        e.extraProgramCacheKey && i.push(e.extraProgramCacheKey),
        i.join()
      );
    },
    getUniforms: function (e) {
      const t = m[e.type];
      let i;
      if (t) {
        const e = Yn[t];
        i = In.clone(e.uniforms);
      } else i = e.uniforms;
      return i;
    },
    acquireProgram: function (t, i) {
      let n;
      for (let e = 0, s = h.length; e < s; e++) {
        const t = h[e];
        if (t.cacheKey === i) {
          (n = t), ++n.usedTimes;
          break;
        }
      }
      return void 0 === n && ((n = new Yr(e, i, t, r)), h.push(n)), n;
    },
    releaseProgram: function (e) {
      if (0 == --e.usedTimes) {
        const t = h.indexOf(e);
        (h[t] = h[h.length - 1]), h.pop(), e.destroy();
      }
    },
    releaseShaderCache: function (e) {
      l.remove(e);
    },
    programs: h,
    dispose: function () {
      l.dispose();
    },
  };
}
function ea() {
  let e = new WeakMap();
  return {
    get: function (t) {
      let i = e.get(t);
      return void 0 === i && ((i = {}), e.set(t, i)), i;
    },
    remove: function (t) {
      e.delete(t);
    },
    update: function (t, i, n) {
      e.get(t)[i] = n;
    },
    dispose: function () {
      e = new WeakMap();
    },
  };
}
function ta(e, t) {
  return e.groupOrder !== t.groupOrder
    ? e.groupOrder - t.groupOrder
    : e.renderOrder !== t.renderOrder
    ? e.renderOrder - t.renderOrder
    : e.material.id !== t.material.id
    ? e.material.id - t.material.id
    : e.z !== t.z
    ? e.z - t.z
    : e.id - t.id;
}
function ia(e, t) {
  return e.groupOrder !== t.groupOrder
    ? e.groupOrder - t.groupOrder
    : e.renderOrder !== t.renderOrder
    ? e.renderOrder - t.renderOrder
    : e.z !== t.z
    ? t.z - e.z
    : e.id - t.id;
}
function na() {
  const e = [];
  let t = 0;
  const i = [],
    n = [],
    s = [];
  function r(i, n, s, r, a, o) {
    let l = e[t];
    return (
      void 0 === l
        ? ((l = {
            id: i.id,
            object: i,
            geometry: n,
            material: s,
            groupOrder: r,
            renderOrder: i.renderOrder,
            z: a,
            group: o,
          }),
          (e[t] = l))
        : ((l.id = i.id),
          (l.object = i),
          (l.geometry = n),
          (l.material = s),
          (l.groupOrder = r),
          (l.renderOrder = i.renderOrder),
          (l.z = a),
          (l.group = o)),
      t++,
      l
    );
  }
  return {
    opaque: i,
    transmissive: n,
    transparent: s,
    init: function () {
      (t = 0), (i.length = 0), (n.length = 0), (s.length = 0);
    },
    push: function (e, t, a, o, l, h) {
      const c = r(e, t, a, o, l, h);
      a.transmission > 0
        ? n.push(c)
        : !0 === a.transparent
        ? s.push(c)
        : i.push(c);
    },
    unshift: function (e, t, a, o, l, h) {
      const c = r(e, t, a, o, l, h);
      a.transmission > 0
        ? n.unshift(c)
        : !0 === a.transparent
        ? s.unshift(c)
        : i.unshift(c);
    },
    finish: function () {
      for (let i = t, n = e.length; i < n; i++) {
        const t = e[i];
        if (null === t.id) break;
        (t.id = null),
          (t.object = null),
          (t.geometry = null),
          (t.material = null),
          (t.group = null);
      }
    },
    sort: function (e, t) {
      i.length > 1 && i.sort(e || ta),
        n.length > 1 && n.sort(t || ia),
        s.length > 1 && s.sort(t || ia);
    },
  };
}
function sa() {
  let e = new WeakMap();
  return {
    get: function (t, i) {
      const n = e.get(t);
      let s;
      return (
        void 0 === n
          ? ((s = new na()), e.set(t, [s]))
          : i >= n.length
          ? ((s = new na()), n.push(s))
          : (s = n[i]),
        s
      );
    },
    dispose: function () {
      e = new WeakMap();
    },
  };
}
function ra() {
  const e = {};
  return {
    get: function (t) {
      if (void 0 !== e[t.id]) return e[t.id];
      let i;
      switch (t.type) {
        case "DirectionalLight":
          i = { direction: new Vector3(), color: new Color() };
          break;
        case "SpotLight":
          i = {
            position: new Vector3(),
            direction: new Vector3(),
            color: new Color(),
            distance: 0,
            coneCos: 0,
            penumbraCos: 0,
            decay: 0,
          };
          break;
        case "PointLight":
          i = {
            position: new Vector3(),
            color: new Color(),
            distance: 0,
            decay: 0,
          };
          break;
        case "HemisphereLight":
          i = {
            direction: new Vector3(),
            skyColor: new Color(),
            groundColor: new Color(),
          };
          break;
        case "RectAreaLight":
          i = {
            color: new Color(),
            position: new Vector3(),
            halfWidth: new Vector3(),
            halfHeight: new Vector3(),
          };
      }
      return (e[t.id] = i), i;
    },
  };
}
let aa = 0;
function oa(e, t) {
  return (
    (t.castShadow ? 2 : 0) -
    (e.castShadow ? 2 : 0) +
    (t.map ? 1 : 0) -
    (e.map ? 1 : 0)
  );
}
function la(e, t) {
  const i = new ra(),
    n = (function () {
      const e = {};
      return {
        get: function (t) {
          if (void 0 !== e[t.id]) return e[t.id];
          let i;
          switch (t.type) {
            case "DirectionalLight":
            case "SpotLight":
              i = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2(),
              };
              break;
            case "PointLight":
              i = {
                shadowBias: 0,
                shadowNormalBias: 0,
                shadowRadius: 1,
                shadowMapSize: new Vector2(),
                shadowCameraNear: 1,
                shadowCameraFar: 1e3,
              };
          }
          return (e[t.id] = i), i;
        },
      };
    })(),
    s = {
      version: 0,
      hash: {
        directionalLength: -1,
        pointLength: -1,
        spotLength: -1,
        rectAreaLength: -1,
        hemiLength: -1,
        numDirectionalShadows: -1,
        numPointShadows: -1,
        numSpotShadows: -1,
        numSpotMaps: -1,
      },
      ambient: [0, 0, 0],
      probe: [],
      directional: [],
      directionalShadow: [],
      directionalShadowMap: [],
      directionalShadowMatrix: [],
      spot: [],
      spotLightMap: [],
      spotShadow: [],
      spotShadowMap: [],
      spotLightMatrix: [],
      rectArea: [],
      rectAreaLTC1: null,
      rectAreaLTC2: null,
      point: [],
      pointShadow: [],
      pointShadowMap: [],
      pointShadowMatrix: [],
      hemi: [],
      numSpotLightShadowsWithMaps: 0,
    };
  for (let l = 0; l < 9; l++) s.probe.push(new Vector3());
  const r = new Vector3(),
    a = new Matrix4(),
    o = new Matrix4();
  return {
    setup: function (r, a) {
      let o = 0,
        l = 0,
        h = 0;
      for (let e = 0; e < 9; e++) s.probe[e].set(0, 0, 0);
      let c = 0,
        u = 0,
        d = 0,
        p = 0,
        f = 0,
        m = 0,
        g = 0,
        _ = 0,
        v = 0,
        A = 0;
      r.sort(oa);
      const y = !0 === a ? Math.PI : 1;
      for (let e = 0, t = r.length; e < t; e++) {
        const t = r[e],
          a = t.color,
          x = t.intensity,
          b = t.distance,
          E = t.shadow && t.shadow.map ? t.shadow.map.texture : null;
        if (t.isAmbientLight)
          (o += a.r * x * y), (l += a.g * x * y), (h += a.b * x * y);
        else if (t.isLightProbe)
          for (let e = 0; e < 9; e++)
            s.probe[e].addScaledVector(t.sh.coefficients[e], x);
        else if (t.isDirectionalLight) {
          const e = i.get(t);
          if (
            (e.color.copy(t.color).multiplyScalar(t.intensity * y),
            t.castShadow)
          ) {
            const e = t.shadow,
              i = n.get(t);
            (i.shadowBias = e.bias),
              (i.shadowNormalBias = e.normalBias),
              (i.shadowRadius = e.radius),
              (i.shadowMapSize = e.mapSize),
              (s.directionalShadow[c] = i),
              (s.directionalShadowMap[c] = E),
              (s.directionalShadowMatrix[c] = t.shadow.matrix),
              m++;
          }
          (s.directional[c] = e), c++;
        } else if (t.isSpotLight) {
          const e = i.get(t);
          e.position.setFromMatrixPosition(t.matrixWorld),
            e.color.copy(a).multiplyScalar(x * y),
            (e.distance = b),
            (e.coneCos = Math.cos(t.angle)),
            (e.penumbraCos = Math.cos(t.angle * (1 - t.penumbra))),
            (e.decay = t.decay),
            (s.spot[d] = e);
          const r = t.shadow;
          if (
            (t.map &&
              ((s.spotLightMap[v] = t.map),
              v++,
              r.updateMatrices(t),
              t.castShadow && A++),
            (s.spotLightMatrix[d] = r.matrix),
            t.castShadow)
          ) {
            const e = n.get(t);
            (e.shadowBias = r.bias),
              (e.shadowNormalBias = r.normalBias),
              (e.shadowRadius = r.radius),
              (e.shadowMapSize = r.mapSize),
              (s.spotShadow[d] = e),
              (s.spotShadowMap[d] = E),
              _++;
          }
          d++;
        } else if (t.isRectAreaLight) {
          const e = i.get(t);
          e.color.copy(a).multiplyScalar(x),
            e.halfWidth.set(0.5 * t.width, 0, 0),
            e.halfHeight.set(0, 0.5 * t.height, 0),
            (s.rectArea[p] = e),
            p++;
        } else if (t.isPointLight) {
          const e = i.get(t);
          if (
            (e.color.copy(t.color).multiplyScalar(t.intensity * y),
            (e.distance = t.distance),
            (e.decay = t.decay),
            t.castShadow)
          ) {
            const e = t.shadow,
              i = n.get(t);
            (i.shadowBias = e.bias),
              (i.shadowNormalBias = e.normalBias),
              (i.shadowRadius = e.radius),
              (i.shadowMapSize = e.mapSize),
              (i.shadowCameraNear = e.camera.near),
              (i.shadowCameraFar = e.camera.far),
              (s.pointShadow[u] = i),
              (s.pointShadowMap[u] = E),
              (s.pointShadowMatrix[u] = t.shadow.matrix),
              g++;
          }
          (s.point[u] = e), u++;
        } else if (t.isHemisphereLight) {
          const e = i.get(t);
          e.skyColor.copy(t.color).multiplyScalar(x * y),
            e.groundColor.copy(t.groundColor).multiplyScalar(x * y),
            (s.hemi[f] = e),
            f++;
        }
      }
      p > 0 &&
        (t.isWebGL2 || !0 === e.has("OES_texture_float_linear")
          ? ((s.rectAreaLTC1 = Xn.LTC_FLOAT_1),
            (s.rectAreaLTC2 = Xn.LTC_FLOAT_2))
          : !0 === e.has("OES_texture_half_float_linear")
          ? ((s.rectAreaLTC1 = Xn.LTC_HALF_1), (s.rectAreaLTC2 = Xn.LTC_HALF_2))
          : console.error(
              "THREE.WebGLRenderer: Unable to use RectAreaLight. Missing WebGL extensions."
            )),
        (s.ambient[0] = o),
        (s.ambient[1] = l),
        (s.ambient[2] = h);
      const x = s.hash;
      (x.directionalLength === c &&
        x.pointLength === u &&
        x.spotLength === d &&
        x.rectAreaLength === p &&
        x.hemiLength === f &&
        x.numDirectionalShadows === m &&
        x.numPointShadows === g &&
        x.numSpotShadows === _ &&
        x.numSpotMaps === v) ||
        ((s.directional.length = c),
        (s.spot.length = d),
        (s.rectArea.length = p),
        (s.point.length = u),
        (s.hemi.length = f),
        (s.directionalShadow.length = m),
        (s.directionalShadowMap.length = m),
        (s.pointShadow.length = g),
        (s.pointShadowMap.length = g),
        (s.spotShadow.length = _),
        (s.spotShadowMap.length = _),
        (s.directionalShadowMatrix.length = m),
        (s.pointShadowMatrix.length = g),
        (s.spotLightMatrix.length = _ + v - A),
        (s.spotLightMap.length = v),
        (s.numSpotLightShadowsWithMaps = A),
        (x.directionalLength = c),
        (x.pointLength = u),
        (x.spotLength = d),
        (x.rectAreaLength = p),
        (x.hemiLength = f),
        (x.numDirectionalShadows = m),
        (x.numPointShadows = g),
        (x.numSpotShadows = _),
        (x.numSpotMaps = v),
        (s.version = aa++));
    },
    setupView: function (e, t) {
      let i = 0,
        n = 0,
        l = 0,
        h = 0,
        c = 0;
      const u = t.matrixWorldInverse;
      for (let d = 0, p = e.length; d < p; d++) {
        const t = e[d];
        if (t.isDirectionalLight) {
          const e = s.directional[i];
          e.direction.setFromMatrixPosition(t.matrixWorld),
            r.setFromMatrixPosition(t.target.matrixWorld),
            e.direction.sub(r),
            e.direction.transformDirection(u),
            i++;
        } else if (t.isSpotLight) {
          const e = s.spot[l];
          e.position.setFromMatrixPosition(t.matrixWorld),
            e.position.applyMatrix4(u),
            e.direction.setFromMatrixPosition(t.matrixWorld),
            r.setFromMatrixPosition(t.target.matrixWorld),
            e.direction.sub(r),
            e.direction.transformDirection(u),
            l++;
        } else if (t.isRectAreaLight) {
          const e = s.rectArea[h];
          e.position.setFromMatrixPosition(t.matrixWorld),
            e.position.applyMatrix4(u),
            o.identity(),
            a.copy(t.matrixWorld),
            a.premultiply(u),
            o.extractRotation(a),
            e.halfWidth.set(0.5 * t.width, 0, 0),
            e.halfHeight.set(0, 0.5 * t.height, 0),
            e.halfWidth.applyMatrix4(o),
            e.halfHeight.applyMatrix4(o),
            h++;
        } else if (t.isPointLight) {
          const e = s.point[n];
          e.position.setFromMatrixPosition(t.matrixWorld),
            e.position.applyMatrix4(u),
            n++;
        } else if (t.isHemisphereLight) {
          const e = s.hemi[c];
          e.direction.setFromMatrixPosition(t.matrixWorld),
            e.direction.transformDirection(u),
            c++;
        }
      }
    },
    state: s,
  };
}
function ha(e, t) {
  const i = new la(e, t),
    n = [],
    s = [];
  return {
    init: function () {
      (n.length = 0), (s.length = 0);
    },
    state: { lightsArray: n, shadowsArray: s, lights: i },
    setupLights: function (e) {
      i.setup(n, e);
    },
    setupLightsView: function (e) {
      i.setupView(n, e);
    },
    pushLight: function (e) {
      n.push(e);
    },
    pushShadow: function (e) {
      s.push(e);
    },
  };
}
function ca(e, t) {
  let i = new WeakMap();
  return {
    get: function (n, s = 0) {
      const r = i.get(n);
      let a;
      return (
        void 0 === r
          ? ((a = new ha(e, t)), i.set(n, [a]))
          : s >= r.length
          ? ((a = new ha(e, t)), r.push(a))
          : (a = r[s]),
        a
      );
    },
    dispose: function () {
      i = new WeakMap();
    },
  };
}
class ua extends Material {
  constructor(e) {
    super(),
      (this.isMeshDepthMaterial = !0),
      (this.type = "MeshDepthMaterial"),
      (this.depthPacking = 3200),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.depthPacking = e.depthPacking),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      this
    );
  }
}
class da extends Material {
  constructor(e) {
    super(),
      (this.isMeshDistanceMaterial = !0),
      (this.type = "MeshDistanceMaterial"),
      (this.map = null),
      (this.alphaMap = null),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      this
    );
  }
}
function pa(e, t, i) {
  let n = new Frustum();
  const s = new Vector2(),
    r = new Vector2(),
    o = new Vector4(),
    u = new ua({ depthPacking: 3201 }),
    d = new da(),
    p = {},
    f = i.maxTextureSize,
    m = { [h]: c, [c]: h, 2: 2 },
    g = new ShaderMaterial({
      defines: { VSM_SAMPLES: 8 },
      uniforms: {
        shadow_pass: { value: null },
        resolution: { value: new Vector2() },
        radius: { value: 4 },
      },
      vertexShader: "void main() {\n\tgl_Position = vec4( position, 1.0 );\n}",
      fragmentShader:
        "uniform sampler2D shadow_pass;\nuniform vec2 resolution;\nuniform float radius;\n#include <packing>\nvoid main() {\n\tconst float samples = float( VSM_SAMPLES );\n\tfloat mean = 0.0;\n\tfloat squared_mean = 0.0;\n\tfloat uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );\n\tfloat uvStart = samples <= 1.0 ? 0.0 : - 1.0;\n\tfor ( float i = 0.0; i < samples; i ++ ) {\n\t\tfloat uvOffset = uvStart + i * uvStride;\n\t\t#ifdef HORIZONTAL_PASS\n\t\t\tvec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );\n\t\t\tmean += distribution.x;\n\t\t\tsquared_mean += distribution.y * distribution.y + distribution.x * distribution.x;\n\t\t#else\n\t\t\tfloat depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );\n\t\t\tmean += depth;\n\t\t\tsquared_mean += depth * depth;\n\t\t#endif\n\t}\n\tmean = mean / samples;\n\tsquared_mean = squared_mean / samples;\n\tfloat std_dev = sqrt( squared_mean - mean * mean );\n\tgl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );\n}",
    }),
    _ = g.clone();
  _.defines.HORIZONTAL_PASS = 1;
  const v = new rn();
  v.setAttribute(
    "position",
    new Wi(new Float32Array([-1, -1, 0.5, 3, -1, 0.5, -1, 3, 0.5]), 3)
  );
  const A = new En(v, g),
    y = this;
  (this.enabled = !1),
    (this.autoUpdate = !0),
    (this.needsUpdate = !1),
    (this.type = a);
  let x = this.type;
  function b(i, n) {
    const r = t.update(A);
    g.defines.VSM_SAMPLES !== i.blurSamples &&
      ((g.defines.VSM_SAMPLES = i.blurSamples),
      (_.defines.VSM_SAMPLES = i.blurSamples),
      (g.needsUpdate = !0),
      (_.needsUpdate = !0)),
      null === i.mapPass && (i.mapPass = new ut(s.x, s.y)),
      (g.uniforms.shadow_pass.value = i.map.texture),
      (g.uniforms.resolution.value = i.mapSize),
      (g.uniforms.radius.value = i.radius),
      e.setRenderTarget(i.mapPass),
      e.clear(),
      e.renderBufferDirect(n, null, r, g, A, null),
      (_.uniforms.shadow_pass.value = i.mapPass.texture),
      (_.uniforms.resolution.value = i.mapSize),
      (_.uniforms.radius.value = i.radius),
      e.setRenderTarget(i.map),
      e.clear(),
      e.renderBufferDirect(n, null, r, _, A, null);
  }
  function E(t, i, n, s) {
    let r = null;
    const a =
      !0 === n.isPointLight ? t.customDistanceMaterial : t.customDepthMaterial;
    if (void 0 !== a) r = a;
    else if (
      ((r = !0 === n.isPointLight ? d : u),
      (e.localClippingEnabled &&
        !0 === i.clipShadows &&
        Array.isArray(i.clippingPlanes) &&
        0 !== i.clippingPlanes.length) ||
        (i.displacementMap && 0 !== i.displacementScale) ||
        (i.alphaMap && i.alphaTest > 0) ||
        (i.map && i.alphaTest > 0))
    ) {
      const e = r.uuid,
        t = i.uuid;
      let n = p[e];
      void 0 === n && ((n = {}), (p[e] = n));
      let s = n[t];
      void 0 === s && ((s = r.clone()), (n[t] = s)), (r = s);
    }
    if (
      ((r.visible = i.visible),
      (r.wireframe = i.wireframe),
      (r.side =
        s === l
          ? null !== i.shadowSide
            ? i.shadowSide
            : i.side
          : null !== i.shadowSide
          ? i.shadowSide
          : m[i.side]),
      (r.alphaMap = i.alphaMap),
      (r.alphaTest = i.alphaTest),
      (r.map = i.map),
      (r.clipShadows = i.clipShadows),
      (r.clippingPlanes = i.clippingPlanes),
      (r.clipIntersection = i.clipIntersection),
      (r.displacementMap = i.displacementMap),
      (r.displacementScale = i.displacementScale),
      (r.displacementBias = i.displacementBias),
      (r.wireframeLinewidth = i.wireframeLinewidth),
      (r.linewidth = i.linewidth),
      !0 === n.isPointLight && !0 === r.isMeshDistanceMaterial)
    ) {
      e.properties.get(r).light = n;
    }
    return r;
  }
  function S(i, s, r, a, o) {
    if (!1 === i.visible) return;
    if (
      i.layers.test(s.layers) &&
      (i.isMesh || i.isLine || i.isPoints) &&
      (i.castShadow || (i.receiveShadow && o === l)) &&
      (!i.frustumCulled || n.intersectsObject(i))
    ) {
      i.modelViewMatrix.multiplyMatrices(r.matrixWorldInverse, i.matrixWorld);
      const n = t.update(i),
        s = i.material;
      if (Array.isArray(s)) {
        const t = n.groups;
        for (let l = 0, h = t.length; l < h; l++) {
          const h = t[l],
            c = s[h.materialIndex];
          if (c && c.visible) {
            const t = E(i, c, a, o);
            e.renderBufferDirect(r, null, n, t, i, h);
          }
        }
      } else if (s.visible) {
        const t = E(i, s, a, o);
        e.renderBufferDirect(r, null, n, t, i, null);
      }
    }
    const h = i.children;
    for (let e = 0, t = h.length; e < t; e++) S(h[e], s, r, a, o);
  }
  this.render = function (t, i, a) {
    if (!1 === y.enabled) return;
    if (!1 === y.autoUpdate && !1 === y.needsUpdate) return;
    if (0 === t.length) return;
    const h = e.getRenderTarget(),
      c = e.getActiveCubeFace(),
      u = e.getActiveMipmapLevel(),
      d = e.state;
    d.setBlending(0),
      d.buffers.color.setClear(1, 1, 1, 1),
      d.buffers.depth.setTest(!0),
      d.setScissorTest(!1);
    const p = x !== l && this.type === l,
      m = x === l && this.type !== l;
    for (let g = 0, _ = t.length; g < _; g++) {
      const h = t[g],
        c = h.shadow;
      if (void 0 === c) {
        console.warn("THREE.WebGLShadowMap:", h, "has no shadow.");
        continue;
      }
      if (!1 === c.autoUpdate && !1 === c.needsUpdate) continue;
      s.copy(c.mapSize);
      const u = c.getFrameExtents();
      if (
        (s.multiply(u),
        r.copy(c.mapSize),
        (s.x > f || s.y > f) &&
          (s.x > f &&
            ((r.x = Math.floor(f / u.x)),
            (s.x = r.x * u.x),
            (c.mapSize.x = r.x)),
          s.y > f &&
            ((r.y = Math.floor(f / u.y)),
            (s.y = r.y * u.y),
            (c.mapSize.y = r.y))),
        null === c.map || !0 === p || !0 === m)
      ) {
        const e = this.type !== l ? { minFilter: R, magFilter: R } : {};
        null !== c.map && c.map.dispose(),
          (c.map = new ut(s.x, s.y, e)),
          (c.map.texture.name = h.name + ".shadowMap"),
          c.camera.updateProjectionMatrix();
      }
      e.setRenderTarget(c.map), e.clear();
      const _ = c.getViewportCount();
      for (let e = 0; e < _; e++) {
        const t = c.getViewport(e);
        o.set(r.x * t.x, r.y * t.y, r.x * t.z, r.y * t.w),
          d.viewport(o),
          c.updateMatrices(h, e),
          (n = c.getFrustum()),
          S(i, a, c.camera, h, this.type);
      }
      !0 !== c.isPointLightShadow && this.type === l && b(c, a),
        (c.needsUpdate = !1);
    }
    (x = this.type), (y.needsUpdate = !1), e.setRenderTarget(h, c, u);
  };
}
function fa(e, t, i) {
  const n = i.isWebGL2;
  const s = new (function () {
      let t = !1;
      const i = new Vector4();
      let n = null;
      const s = new Vector4(0, 0, 0, 0);
      return {
        setMask: function (i) {
          n === i || t || (e.colorMask(i, i, i, i), (n = i));
        },
        setLocked: function (e) {
          t = e;
        },
        setClear: function (t, n, r, a, o) {
          !0 === o && ((t *= a), (n *= a), (r *= a)),
            i.set(t, n, r, a),
            !1 === s.equals(i) && (e.clearColor(t, n, r, a), s.copy(i));
        },
        reset: function () {
          (t = !1), (n = null), s.set(-1, 0, 0, 0);
        },
      };
    })(),
    r = new (function () {
      let t = !1,
        i = null,
        n = null,
        s = null;
      return {
        setTest: function (t) {
          t ? H(e.DEPTH_TEST) : j(e.DEPTH_TEST);
        },
        setMask: function (n) {
          i === n || t || (e.depthMask(n), (i = n));
        },
        setFunc: function (t) {
          if (n !== t) {
            switch (t) {
              case 0:
                e.depthFunc(e.NEVER);
                break;
              case 1:
                e.depthFunc(e.ALWAYS);
                break;
              case 2:
                e.depthFunc(e.LESS);
                break;
              case 3:
              default:
                e.depthFunc(e.LEQUAL);
                break;
              case 4:
                e.depthFunc(e.EQUAL);
                break;
              case 5:
                e.depthFunc(e.GEQUAL);
                break;
              case 6:
                e.depthFunc(e.GREATER);
                break;
              case 7:
                e.depthFunc(e.NOTEQUAL);
            }
            n = t;
          }
        },
        setLocked: function (e) {
          t = e;
        },
        setClear: function (t) {
          s !== t && (e.clearDepth(t), (s = t));
        },
        reset: function () {
          (t = !1), (i = null), (n = null), (s = null);
        },
      };
    })(),
    a = new (function () {
      let t = !1,
        i = null,
        n = null,
        s = null,
        r = null,
        a = null,
        o = null,
        l = null,
        h = null;
      return {
        setTest: function (i) {
          t || (i ? H(e.STENCIL_TEST) : j(e.STENCIL_TEST));
        },
        setMask: function (n) {
          i === n || t || (e.stencilMask(n), (i = n));
        },
        setFunc: function (t, i, a) {
          (n === t && s === i && r === a) ||
            (e.stencilFunc(t, i, a), (n = t), (s = i), (r = a));
        },
        setOp: function (t, i, n) {
          (a === t && o === i && l === n) ||
            (e.stencilOp(t, i, n), (a = t), (o = i), (l = n));
        },
        setLocked: function (e) {
          t = e;
        },
        setClear: function (t) {
          h !== t && (e.clearStencil(t), (h = t));
        },
        reset: function () {
          (t = !1),
            (i = null),
            (n = null),
            (s = null),
            (r = null),
            (a = null),
            (o = null),
            (l = null),
            (h = null);
        },
      };
    })(),
    o = new WeakMap(),
    l = new WeakMap();
  let h = {},
    f = {},
    m = new WeakMap(),
    g = [],
    _ = null,
    v = !1,
    A = null,
    y = null,
    x = null,
    b = null,
    E = null,
    S = null,
    C = null,
    M = !1,
    w = null,
    T = null,
    I = null,
    R = null,
    P = null;
  const D = e.getParameter(e.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
  let L = !1,
    F = 0;
  const N = e.getParameter(e.VERSION);
  -1 !== N.indexOf("WebGL")
    ? ((F = parseFloat(/^WebGL (\d)/.exec(N)[1])), (L = F >= 1))
    : -1 !== N.indexOf("OpenGL ES") &&
      ((F = parseFloat(/^OpenGL ES (\d)/.exec(N)[1])), (L = F >= 2));
  let B = null,
    k = {};
  const O = e.getParameter(e.SCISSOR_BOX),
    U = e.getParameter(e.VIEWPORT),
    z = new Vector4().fromArray(O),
    G = new Vector4().fromArray(U);
  function V(t, i, s, r) {
    const a = new Uint8Array(4),
      o = e.createTexture();
    e.bindTexture(t, o),
      e.texParameteri(t, e.TEXTURE_MIN_FILTER, e.NEAREST),
      e.texParameteri(t, e.TEXTURE_MAG_FILTER, e.NEAREST);
    for (let l = 0; l < s; l++)
      !n || (t !== e.TEXTURE_3D && t !== e.TEXTURE_2D_ARRAY)
        ? e.texImage2D(i + l, 0, e.RGBA, 1, 1, 0, e.RGBA, e.UNSIGNED_BYTE, a)
        : e.texImage3D(i, 0, e.RGBA, 1, 1, r, 0, e.RGBA, e.UNSIGNED_BYTE, a);
    return o;
  }
  const Q = {};
  function H(t) {
    !0 !== h[t] && (e.enable(t), (h[t] = !0));
  }
  function j(t) {
    !1 !== h[t] && (e.disable(t), (h[t] = !1));
  }
  (Q[e.TEXTURE_2D] = V(e.TEXTURE_2D, e.TEXTURE_2D, 1)),
    (Q[e.TEXTURE_CUBE_MAP] = V(
      e.TEXTURE_CUBE_MAP,
      e.TEXTURE_CUBE_MAP_POSITIVE_X,
      6
    )),
    n &&
      ((Q[e.TEXTURE_2D_ARRAY] = V(
        e.TEXTURE_2D_ARRAY,
        e.TEXTURE_2D_ARRAY,
        1,
        1
      )),
      (Q[e.TEXTURE_3D] = V(e.TEXTURE_3D, e.TEXTURE_3D, 1, 1))),
    s.setClear(0, 0, 0, 1),
    r.setClear(1),
    a.setClear(0),
    H(e.DEPTH_TEST),
    r.setFunc(3),
    Y(!1),
    K(1),
    H(e.CULL_FACE),
    X(0);
  const W = {
    [u]: e.FUNC_ADD,
    101: e.FUNC_SUBTRACT,
    102: e.FUNC_REVERSE_SUBTRACT,
  };
  if (n) (W[103] = e.MIN), (W[104] = e.MAX);
  else {
    const e = t.get("EXT_blend_minmax");
    null !== e && ((W[103] = e.MIN_EXT), (W[104] = e.MAX_EXT));
  }
  const q = {
    [d]: e.ZERO,
    [p]: e.ONE,
    202: e.SRC_COLOR,
    204: e.SRC_ALPHA,
    210: e.SRC_ALPHA_SATURATE,
    208: e.DST_COLOR,
    206: e.DST_ALPHA,
    203: e.ONE_MINUS_SRC_COLOR,
    205: e.ONE_MINUS_SRC_ALPHA,
    209: e.ONE_MINUS_DST_COLOR,
    207: e.ONE_MINUS_DST_ALPHA,
  };
  function X(t, i, n, s, r, a, o, l) {
    if (0 !== t) {
      if ((!1 === v && (H(e.BLEND), (v = !0)), 5 === t))
        (r = r || i),
          (a = a || n),
          (o = o || s),
          (i === y && r === E) ||
            (e.blendEquationSeparate(W[i], W[r]), (y = i), (E = r)),
          (n === x && s === b && a === S && o === C) ||
            (e.blendFuncSeparate(q[n], q[s], q[a], q[o]),
            (x = n),
            (b = s),
            (S = a),
            (C = o)),
          (A = t),
          (M = !1);
      else if (t !== A || l !== M) {
        if (
          ((y === u && E === u) ||
            (e.blendEquation(e.FUNC_ADD), (y = u), (E = u)),
          l)
        )
          switch (t) {
            case 1:
              e.blendFuncSeparate(
                e.ONE,
                e.ONE_MINUS_SRC_ALPHA,
                e.ONE,
                e.ONE_MINUS_SRC_ALPHA
              );
              break;
            case 2:
              e.blendFunc(e.ONE, e.ONE);
              break;
            case 3:
              e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
              break;
            case 4:
              e.blendFuncSeparate(e.ZERO, e.SRC_COLOR, e.ZERO, e.SRC_ALPHA);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", t);
          }
        else
          switch (t) {
            case 1:
              e.blendFuncSeparate(
                e.SRC_ALPHA,
                e.ONE_MINUS_SRC_ALPHA,
                e.ONE,
                e.ONE_MINUS_SRC_ALPHA
              );
              break;
            case 2:
              e.blendFunc(e.SRC_ALPHA, e.ONE);
              break;
            case 3:
              e.blendFuncSeparate(e.ZERO, e.ONE_MINUS_SRC_COLOR, e.ZERO, e.ONE);
              break;
            case 4:
              e.blendFunc(e.ZERO, e.SRC_COLOR);
              break;
            default:
              console.error("THREE.WebGLState: Invalid blending: ", t);
          }
        (x = null), (b = null), (S = null), (C = null), (A = t), (M = l);
      }
    } else !0 === v && (j(e.BLEND), (v = !1));
  }
  function Y(t) {
    w !== t && (t ? e.frontFace(e.CW) : e.frontFace(e.CCW), (w = t));
  }
  function K(t) {
    0 !== t
      ? (H(e.CULL_FACE),
        t !== T &&
          (1 === t
            ? e.cullFace(e.BACK)
            : 2 === t
            ? e.cullFace(e.FRONT)
            : e.cullFace(e.FRONT_AND_BACK)))
      : j(e.CULL_FACE),
      (T = t);
  }
  function Z(t, i, n) {
    t
      ? (H(e.POLYGON_OFFSET_FILL),
        (R === i && P === n) || (e.polygonOffset(i, n), (R = i), (P = n)))
      : j(e.POLYGON_OFFSET_FILL);
  }
  return {
    buffers: { color: s, depth: r, stencil: a },
    enable: H,
    disable: j,
    bindFramebuffer: function (t, i) {
      return (
        f[t] !== i &&
        (e.bindFramebuffer(t, i),
        (f[t] = i),
        n &&
          (t === e.DRAW_FRAMEBUFFER && (f[e.FRAMEBUFFER] = i),
          t === e.FRAMEBUFFER && (f[e.DRAW_FRAMEBUFFER] = i)),
        !0)
      );
    },
    drawBuffers: function (n, s) {
      let r = g,
        a = !1;
      if (n)
        if (
          ((r = m.get(s)),
          void 0 === r && ((r = []), m.set(s, r)),
          n.isWebGLMultipleRenderTargets)
        ) {
          const t = n.texture;
          if (r.length !== t.length || r[0] !== e.COLOR_ATTACHMENT0) {
            for (let i = 0, n = t.length; i < n; i++)
              r[i] = e.COLOR_ATTACHMENT0 + i;
            (r.length = t.length), (a = !0);
          }
        } else
          r[0] !== e.COLOR_ATTACHMENT0 &&
            ((r[0] = e.COLOR_ATTACHMENT0), (a = !0));
      else r[0] !== e.BACK && ((r[0] = e.BACK), (a = !0));
      a &&
        (i.isWebGL2
          ? e.drawBuffers(r)
          : t.get("WEBGL_draw_buffers").drawBuffersWEBGL(r));
    },
    useProgram: function (t) {
      return _ !== t && (e.useProgram(t), (_ = t), !0);
    },
    setBlending: X,
    setMaterial: function (t, i) {
      2 === t.side ? j(e.CULL_FACE) : H(e.CULL_FACE);
      let n = t.side === c;
      i && (n = !n),
        Y(n),
        1 === t.blending && !1 === t.transparent
          ? X(0)
          : X(
              t.blending,
              t.blendEquation,
              t.blendSrc,
              t.blendDst,
              t.blendEquationAlpha,
              t.blendSrcAlpha,
              t.blendDstAlpha,
              t.premultipliedAlpha
            ),
        r.setFunc(t.depthFunc),
        r.setTest(t.depthTest),
        r.setMask(t.depthWrite),
        s.setMask(t.colorWrite);
      const o = t.stencilWrite;
      a.setTest(o),
        o &&
          (a.setMask(t.stencilWriteMask),
          a.setFunc(t.stencilFunc, t.stencilRef, t.stencilFuncMask),
          a.setOp(t.stencilFail, t.stencilZFail, t.stencilZPass)),
        Z(t.polygonOffset, t.polygonOffsetFactor, t.polygonOffsetUnits),
        !0 === t.alphaToCoverage
          ? H(e.SAMPLE_ALPHA_TO_COVERAGE)
          : j(e.SAMPLE_ALPHA_TO_COVERAGE);
    },
    setFlipSided: Y,
    setCullFace: K,
    setLineWidth: function (t) {
      t !== I && (L && e.lineWidth(t), (I = t));
    },
    setPolygonOffset: Z,
    setScissorTest: function (t) {
      t ? H(e.SCISSOR_TEST) : j(e.SCISSOR_TEST);
    },
    activeTexture: function (t) {
      void 0 === t && (t = e.TEXTURE0 + D - 1),
        B !== t && (e.activeTexture(t), (B = t));
    },
    bindTexture: function (t, i, n) {
      void 0 === n && (n = null === B ? e.TEXTURE0 + D - 1 : B);
      let s = k[n];
      void 0 === s && ((s = { type: void 0, texture: void 0 }), (k[n] = s)),
        (s.type === t && s.texture === i) ||
          (B !== n && (e.activeTexture(n), (B = n)),
          e.bindTexture(t, i || Q[t]),
          (s.type = t),
          (s.texture = i));
    },
    unbindTexture: function () {
      const t = k[B];
      void 0 !== t &&
        void 0 !== t.type &&
        (e.bindTexture(t.type, null), (t.type = void 0), (t.texture = void 0));
    },
    compressedTexImage2D: function () {
      try {
        e.compressedTexImage2D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    compressedTexImage3D: function () {
      try {
        e.compressedTexImage3D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage2D: function () {
      try {
        e.texImage2D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texImage3D: function () {
      try {
        e.texImage3D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    updateUBOMapping: function (t, i) {
      let n = l.get(i);
      void 0 === n && ((n = new WeakMap()), l.set(i, n));
      let s = n.get(t);
      void 0 === s && ((s = e.getUniformBlockIndex(i, t.name)), n.set(t, s));
    },
    uniformBlockBinding: function (t, i) {
      const n = l.get(i).get(t);
      o.get(i) !== n &&
        (e.uniformBlockBinding(i, n, t.__bindingPointIndex), o.set(i, n));
    },
    texStorage2D: function () {
      try {
        e.texStorage2D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texStorage3D: function () {
      try {
        e.texStorage3D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texSubImage2D: function () {
      try {
        e.texSubImage2D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    texSubImage3D: function () {
      try {
        e.texSubImage3D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    compressedTexSubImage2D: function () {
      try {
        e.compressedTexSubImage2D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    compressedTexSubImage3D: function () {
      try {
        e.compressedTexSubImage3D.apply(e, arguments);
      } catch (t) {
        console.error("THREE.WebGLState:", t);
      }
    },
    scissor: function (t) {
      !1 === z.equals(t) && (e.scissor(t.x, t.y, t.z, t.w), z.copy(t));
    },
    viewport: function (t) {
      !1 === G.equals(t) && (e.viewport(t.x, t.y, t.z, t.w), G.copy(t));
    },
    reset: function () {
      e.disable(e.BLEND),
        e.disable(e.CULL_FACE),
        e.disable(e.DEPTH_TEST),
        e.disable(e.POLYGON_OFFSET_FILL),
        e.disable(e.SCISSOR_TEST),
        e.disable(e.STENCIL_TEST),
        e.disable(e.SAMPLE_ALPHA_TO_COVERAGE),
        e.blendEquation(e.FUNC_ADD),
        e.blendFunc(e.ONE, e.ZERO),
        e.blendFuncSeparate(e.ONE, e.ZERO, e.ONE, e.ZERO),
        e.colorMask(!0, !0, !0, !0),
        e.clearColor(0, 0, 0, 0),
        e.depthMask(!0),
        e.depthFunc(e.LESS),
        e.clearDepth(1),
        e.stencilMask(4294967295),
        e.stencilFunc(e.ALWAYS, 0, 4294967295),
        e.stencilOp(e.KEEP, e.KEEP, e.KEEP),
        e.clearStencil(0),
        e.cullFace(e.BACK),
        e.frontFace(e.CCW),
        e.polygonOffset(0, 0),
        e.activeTexture(e.TEXTURE0),
        e.bindFramebuffer(e.FRAMEBUFFER, null),
        !0 === n &&
          (e.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
          e.bindFramebuffer(e.READ_FRAMEBUFFER, null)),
        e.useProgram(null),
        e.lineWidth(1),
        e.scissor(0, 0, e.canvas.width, e.canvas.height),
        e.viewport(0, 0, e.canvas.width, e.canvas.height),
        (h = {}),
        (B = null),
        (k = {}),
        (f = {}),
        (m = new WeakMap()),
        (g = []),
        (_ = null),
        (v = !1),
        (A = null),
        (y = null),
        (x = null),
        (b = null),
        (E = null),
        (S = null),
        (C = null),
        (M = !1),
        (w = null),
        (T = null),
        (I = null),
        (R = null),
        (P = null),
        z.set(0, 0, e.canvas.width, e.canvas.height),
        G.set(0, 0, e.canvas.width, e.canvas.height),
        s.reset(),
        r.reset(),
        a.reset();
    },
  };
}
function ma(e, t, i, n, s, r, a) {
  const o = s.isWebGL2,
    l = s.maxTextures,
    h = s.maxCubemapSize,
    c = s.maxTextureSize,
    u = s.maxSamples,
    d = t.has("WEBGL_multisampled_render_to_texture")
      ? t.get("WEBGL_multisampled_render_to_texture")
      : null,
    p =
      "undefined" != typeof navigator &&
      /OculusBrowser/g.test(navigator.userAgent),
    f = new WeakMap();
  let m;
  const g = new WeakMap();
  let _ = !1;
  try {
    _ =
      "undefined" != typeof OffscreenCanvas &&
      null !== new OffscreenCanvas(1, 1).getContext("2d");
  } catch (oe) {}
  function v(e, t) {
    return _ ? new OffscreenCanvas(e, t) : createElement("canvas");
  }
  function A(e, t, i, n) {
    let s = 1;
    if (
      ((e.width > n || e.height > n) && (s = n / Math.max(e.width, e.height)),
      s < 1 || !0 === t)
    ) {
      if (
        ("undefined" != typeof HTMLImageElement &&
          e instanceof HTMLImageElement) ||
        ("undefined" != typeof HTMLCanvasElement &&
          e instanceof HTMLCanvasElement) ||
        ("undefined" != typeof ImageBitmap && e instanceof ImageBitmap)
      ) {
        const n = t ? ke : Math.floor,
          r = n(s * e.width),
          a = n(s * e.height);
        void 0 === m && (m = v(r, a));
        const o = i ? v(r, a) : m;
        (o.width = r), (o.height = a);
        return (
          o.getContext("2d").drawImage(e, 0, 0, r, a),
          console.warn(
            "THREE.WebGLRenderer: Texture has been resized from (" +
              e.width +
              "x" +
              e.height +
              ") to (" +
              r +
              "x" +
              a +
              ")."
          ),
          o
        );
      }
      return (
        "data" in e &&
          console.warn(
            "THREE.WebGLRenderer: Image in DataTexture is too big (" +
              e.width +
              "x" +
              e.height +
              ")."
          ),
        e
      );
    }
    return e;
  }
  function y(e) {
    return Ne(e.width) && Ne(e.height);
  }
  function x(e, t) {
    return e.generateMipmaps && t && e.minFilter !== R && e.minFilter !== L;
  }
  function b(t) {
    e.generateMipmap(t);
  }
  function E(i, n, s, r, a = !1) {
    if (!1 === o) return n;
    if (null !== i) {
      if (void 0 !== e[i]) return e[i];
      console.warn(
        "THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" +
          i +
          "'"
      );
    }
    let l = n;
    return (
      n === e.RED &&
        (s === e.FLOAT && (l = e.R32F),
        s === e.HALF_FLOAT && (l = e.R16F),
        s === e.UNSIGNED_BYTE && (l = e.R8)),
      n === e.RED_INTEGER &&
        (s === e.UNSIGNED_BYTE && (l = e.R8UI),
        s === e.UNSIGNED_SHORT && (l = e.R16UI),
        s === e.UNSIGNED_INT && (l = e.R32UI),
        s === e.BYTE && (l = e.R8I),
        s === e.SHORT && (l = e.R16I),
        s === e.INT && (l = e.R32I)),
      n === e.RG &&
        (s === e.FLOAT && (l = e.RG32F),
        s === e.HALF_FLOAT && (l = e.RG16F),
        s === e.UNSIGNED_BYTE && (l = e.RG8)),
      n === e.RGBA &&
        (s === e.FLOAT && (l = e.RGBA32F),
        s === e.HALF_FLOAT && (l = e.RGBA16F),
        s === e.UNSIGNED_BYTE &&
          (l = r === me && !1 === a ? e.SRGB8_ALPHA8 : e.RGBA8),
        s === e.UNSIGNED_SHORT_4_4_4_4 && (l = e.RGBA4),
        s === e.UNSIGNED_SHORT_5_5_5_1 && (l = e.RGB5_A1)),
      (l !== e.R16F &&
        l !== e.R32F &&
        l !== e.RG16F &&
        l !== e.RG32F &&
        l !== e.RGBA16F &&
        l !== e.RGBA32F) ||
        t.get("EXT_color_buffer_float"),
      l
    );
  }
  function S(e, t, i) {
    return !0 === x(e, i) ||
      (e.isFramebufferTexture && e.minFilter !== R && e.minFilter !== L)
      ? Math.log2(Math.max(t.width, t.height)) + 1
      : void 0 !== e.mipmaps && e.mipmaps.length > 0
      ? e.mipmaps.length
      : e.isCompressedTexture && Array.isArray(e.image)
      ? t.mipmaps.length
      : 1;
  }
  function C(t) {
    return t === R || t === P || t === D ? e.NEAREST : e.LINEAR;
  }
  function M(e) {
    const t = e.target;
    t.removeEventListener("dispose", M),
      (function (e) {
        const t = n.get(e);
        if (void 0 === t.__webglInit) return;
        const i = e.source,
          s = g.get(i);
        if (s) {
          const n = s[t.__cacheKey];
          n.usedTimes--,
            0 === n.usedTimes && W(e),
            0 === Object.keys(s).length && g.delete(i);
        }
        n.remove(e);
      })(t),
      t.isVideoTexture && f.delete(t);
  }
  function O(t) {
    const i = t.target;
    i.removeEventListener("dispose", O),
      (function (t) {
        const i = t.texture,
          s = n.get(t),
          r = n.get(i);
        void 0 !== r.__webglTexture &&
          (e.deleteTexture(r.__webglTexture), a.memory.textures--);
        t.depthTexture && t.depthTexture.dispose();
        if (t.isWebGLCubeRenderTarget)
          for (let n = 0; n < 6; n++) {
            if (Array.isArray(s.__webglFramebuffer[n]))
              for (let t = 0; t < s.__webglFramebuffer[n].length; t++)
                e.deleteFramebuffer(s.__webglFramebuffer[n][t]);
            else e.deleteFramebuffer(s.__webglFramebuffer[n]);
            s.__webglDepthbuffer &&
              e.deleteRenderbuffer(s.__webglDepthbuffer[n]);
          }
        else {
          if (Array.isArray(s.__webglFramebuffer))
            for (let t = 0; t < s.__webglFramebuffer.length; t++)
              e.deleteFramebuffer(s.__webglFramebuffer[t]);
          else e.deleteFramebuffer(s.__webglFramebuffer);
          if (
            (s.__webglDepthbuffer && e.deleteRenderbuffer(s.__webglDepthbuffer),
            s.__webglMultisampledFramebuffer &&
              e.deleteFramebuffer(s.__webglMultisampledFramebuffer),
            s.__webglColorRenderbuffer)
          )
            for (let t = 0; t < s.__webglColorRenderbuffer.length; t++)
              s.__webglColorRenderbuffer[t] &&
                e.deleteRenderbuffer(s.__webglColorRenderbuffer[t]);
          s.__webglDepthRenderbuffer &&
            e.deleteRenderbuffer(s.__webglDepthRenderbuffer);
        }
        if (t.isWebGLMultipleRenderTargets)
          for (let o = 0, l = i.length; o < l; o++) {
            const t = n.get(i[o]);
            t.__webglTexture &&
              (e.deleteTexture(t.__webglTexture), a.memory.textures--),
              n.remove(i[o]);
          }
        n.remove(i), n.remove(t);
      })(i);
  }
  function W(t) {
    const i = n.get(t);
    e.deleteTexture(i.__webglTexture);
    const s = t.source;
    delete g.get(s)[i.__cacheKey], a.memory.textures--;
  }
  let q = 0;
  function X(t, s) {
    const r = n.get(t);
    if (
      (t.isVideoTexture &&
        (function (e) {
          const t = a.render.frame;
          f.get(e) !== t && (f.set(e, t), e.update());
        })(t),
      !1 === t.isRenderTargetTexture &&
        t.version > 0 &&
        r.__version !== t.version)
    ) {
      const e = t.image;
      if (null === e)
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but no image data found."
        );
      else {
        if (!1 !== e.complete) return void ee(r, t, s);
        console.warn(
          "THREE.WebGLRenderer: Texture marked for update but image is incomplete"
        );
      }
    }
    i.bindTexture(e.TEXTURE_2D, r.__webglTexture, e.TEXTURE0 + s);
  }
  const Y = { [w]: e.REPEAT, [T]: e.CLAMP_TO_EDGE, [I]: e.MIRRORED_REPEAT },
    K = {
      [R]: e.NEAREST,
      [P]: e.NEAREST_MIPMAP_NEAREST,
      [D]: e.NEAREST_MIPMAP_LINEAR,
      [L]: e.LINEAR,
      [F]: e.LINEAR_MIPMAP_NEAREST,
      [N]: e.LINEAR_MIPMAP_LINEAR,
    },
    Z = {
      512: e.NEVER,
      519: e.ALWAYS,
      513: e.LESS,
      515: e.LEQUAL,
      514: e.EQUAL,
      518: e.GEQUAL,
      516: e.GREATER,
      517: e.NOTEQUAL,
    };
  function J(i, r, a) {
    if (
      (a
        ? (e.texParameteri(i, e.TEXTURE_WRAP_S, Y[r.wrapS]),
          e.texParameteri(i, e.TEXTURE_WRAP_T, Y[r.wrapT]),
          (i !== e.TEXTURE_3D && i !== e.TEXTURE_2D_ARRAY) ||
            e.texParameteri(i, e.TEXTURE_WRAP_R, Y[r.wrapR]),
          e.texParameteri(i, e.TEXTURE_MAG_FILTER, K[r.magFilter]),
          e.texParameteri(i, e.TEXTURE_MIN_FILTER, K[r.minFilter]))
        : (e.texParameteri(i, e.TEXTURE_WRAP_S, e.CLAMP_TO_EDGE),
          e.texParameteri(i, e.TEXTURE_WRAP_T, e.CLAMP_TO_EDGE),
          (i !== e.TEXTURE_3D && i !== e.TEXTURE_2D_ARRAY) ||
            e.texParameteri(i, e.TEXTURE_WRAP_R, e.CLAMP_TO_EDGE),
          (r.wrapS === T && r.wrapT === T) ||
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping."
            ),
          e.texParameteri(i, e.TEXTURE_MAG_FILTER, C(r.magFilter)),
          e.texParameteri(i, e.TEXTURE_MIN_FILTER, C(r.minFilter)),
          r.minFilter !== R &&
            r.minFilter !== L &&
            console.warn(
              "THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter."
            )),
      r.compareFunction &&
        (e.texParameteri(i, e.TEXTURE_COMPARE_MODE, e.COMPARE_REF_TO_TEXTURE),
        e.texParameteri(i, e.TEXTURE_COMPARE_FUNC, Z[r.compareFunction])),
      !0 === t.has("EXT_texture_filter_anisotropic"))
    ) {
      const a = t.get("EXT_texture_filter_anisotropic");
      if (r.magFilter === R) return;
      if (r.minFilter !== D && r.minFilter !== N) return;
      if (r.type === z && !1 === t.has("OES_texture_float_linear")) return;
      if (
        !1 === o &&
        r.type === G &&
        !1 === t.has("OES_texture_half_float_linear")
      )
        return;
      (r.anisotropy > 1 || n.get(r).__currentAnisotropy) &&
        (e.texParameterf(
          i,
          a.TEXTURE_MAX_ANISOTROPY_EXT,
          Math.min(r.anisotropy, s.getMaxAnisotropy())
        ),
        (n.get(r).__currentAnisotropy = r.anisotropy));
    }
  }
  function $(t, i) {
    let n = !1;
    void 0 === t.__webglInit &&
      ((t.__webglInit = !0), i.addEventListener("dispose", M));
    const s = i.source;
    let r = g.get(s);
    void 0 === r && ((r = {}), g.set(s, r));
    const o = (function (e) {
      const t = [];
      return (
        t.push(e.wrapS),
        t.push(e.wrapT),
        t.push(e.wrapR || 0),
        t.push(e.magFilter),
        t.push(e.minFilter),
        t.push(e.anisotropy),
        t.push(e.internalFormat),
        t.push(e.format),
        t.push(e.type),
        t.push(e.generateMipmaps),
        t.push(e.premultiplyAlpha),
        t.push(e.flipY),
        t.push(e.unpackAlignment),
        t.push(e.colorSpace),
        t.join()
      );
    })(i);
    if (o !== t.__cacheKey) {
      void 0 === r[o] &&
        ((r[o] = { texture: e.createTexture(), usedTimes: 0 }),
        a.memory.textures++,
        (n = !0)),
        r[o].usedTimes++;
      const s = r[t.__cacheKey];
      void 0 !== s && (r[t.__cacheKey].usedTimes--, 0 === s.usedTimes && W(i)),
        (t.__cacheKey = o),
        (t.__webglTexture = r[o].texture);
    }
    return n;
  }
  function ee(t, s, a) {
    let l = e.TEXTURE_2D;
    (s.isDataArrayTexture || s.isCompressedArrayTexture) &&
      (l = e.TEXTURE_2D_ARRAY),
      s.isData3DTexture && (l = e.TEXTURE_3D);
    const h = $(t, s),
      u = s.source;
    i.bindTexture(l, t.__webglTexture, e.TEXTURE0 + a);
    const d = n.get(u);
    if (u.version !== d.__version || !0 === h) {
      i.activeTexture(e.TEXTURE0 + a),
        e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
        e.pixelStorei(e.UNPACK_PREMULTIPLY_ALPHA_WEBGL, s.premultiplyAlpha),
        e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
        e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE);
      const t =
        (function (e) {
          return (
            !o &&
            (e.wrapS !== T ||
              e.wrapT !== T ||
              (e.minFilter !== R && e.minFilter !== L))
          );
        })(s) && !1 === y(s.image);
      let n = A(s.image, t, !1, c);
      n = ae(s, n);
      const p = y(n) || o,
        f = r.convert(s.format, s.colorSpace);
      let m,
        g = r.convert(s.type),
        _ = E(s.internalFormat, f, g, s.colorSpace, s.isVideoTexture);
      J(l, s, p);
      const v = s.mipmaps,
        C = o && !0 !== s.isVideoTexture,
        M = void 0 === d.__version || !0 === h,
        w = S(s, n, p);
      if (s.isDepthTexture)
        (_ = e.DEPTH_COMPONENT),
          o
            ? (_ =
                s.type === z
                  ? e.DEPTH_COMPONENT32F
                  : s.type === U
                  ? e.DEPTH_COMPONENT24
                  : s.type === V
                  ? e.DEPTH24_STENCIL8
                  : e.DEPTH_COMPONENT16)
            : s.type === z &&
              console.error(
                "WebGLRenderer: Floating point depth texture requires WebGL2."
              ),
          s.format === H &&
            _ === e.DEPTH_COMPONENT &&
            s.type !== k &&
            s.type !== U &&
            (console.warn(
              "THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture."
            ),
            (s.type = U),
            (g = r.convert(s.type))),
          s.format === j &&
            _ === e.DEPTH_COMPONENT &&
            ((_ = e.DEPTH_STENCIL),
            s.type !== V &&
              (console.warn(
                "THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture."
              ),
              (s.type = V),
              (g = r.convert(s.type)))),
          M &&
            (C
              ? i.texStorage2D(e.TEXTURE_2D, 1, _, n.width, n.height)
              : i.texImage2D(
                  e.TEXTURE_2D,
                  0,
                  _,
                  n.width,
                  n.height,
                  0,
                  f,
                  g,
                  null
                ));
      else if (s.isDataTexture)
        if (v.length > 0 && p) {
          C && M && i.texStorage2D(e.TEXTURE_2D, w, _, v[0].width, v[0].height);
          for (let t = 0, n = v.length; t < n; t++)
            (m = v[t]),
              C
                ? i.texSubImage2D(
                    e.TEXTURE_2D,
                    t,
                    0,
                    0,
                    m.width,
                    m.height,
                    f,
                    g,
                    m.data
                  )
                : i.texImage2D(
                    e.TEXTURE_2D,
                    t,
                    _,
                    m.width,
                    m.height,
                    0,
                    f,
                    g,
                    m.data
                  );
          s.generateMipmaps = !1;
        } else
          C
            ? (M && i.texStorage2D(e.TEXTURE_2D, w, _, n.width, n.height),
              i.texSubImage2D(
                e.TEXTURE_2D,
                0,
                0,
                0,
                n.width,
                n.height,
                f,
                g,
                n.data
              ))
            : i.texImage2D(
                e.TEXTURE_2D,
                0,
                _,
                n.width,
                n.height,
                0,
                f,
                g,
                n.data
              );
      else if (s.isCompressedTexture)
        if (s.isCompressedArrayTexture) {
          C &&
            M &&
            i.texStorage3D(
              e.TEXTURE_2D_ARRAY,
              w,
              _,
              v[0].width,
              v[0].height,
              n.depth
            );
          for (let t = 0, r = v.length; t < r; t++)
            (m = v[t]),
              s.format !== Q
                ? null !== f
                  ? C
                    ? i.compressedTexSubImage3D(
                        e.TEXTURE_2D_ARRAY,
                        t,
                        0,
                        0,
                        0,
                        m.width,
                        m.height,
                        n.depth,
                        f,
                        m.data,
                        0,
                        0
                      )
                    : i.compressedTexImage3D(
                        e.TEXTURE_2D_ARRAY,
                        t,
                        _,
                        m.width,
                        m.height,
                        n.depth,
                        0,
                        m.data,
                        0,
                        0
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : C
                ? i.texSubImage3D(
                    e.TEXTURE_2D_ARRAY,
                    t,
                    0,
                    0,
                    0,
                    m.width,
                    m.height,
                    n.depth,
                    f,
                    g,
                    m.data
                  )
                : i.texImage3D(
                    e.TEXTURE_2D_ARRAY,
                    t,
                    _,
                    m.width,
                    m.height,
                    n.depth,
                    0,
                    f,
                    g,
                    m.data
                  );
        } else {
          C && M && i.texStorage2D(e.TEXTURE_2D, w, _, v[0].width, v[0].height);
          for (let t = 0, n = v.length; t < n; t++)
            (m = v[t]),
              s.format !== Q
                ? null !== f
                  ? C
                    ? i.compressedTexSubImage2D(
                        e.TEXTURE_2D,
                        t,
                        0,
                        0,
                        m.width,
                        m.height,
                        f,
                        m.data
                      )
                    : i.compressedTexImage2D(
                        e.TEXTURE_2D,
                        t,
                        _,
                        m.width,
                        m.height,
                        0,
                        m.data
                      )
                  : console.warn(
                      "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()"
                    )
                : C
                ? i.texSubImage2D(
                    e.TEXTURE_2D,
                    t,
                    0,
                    0,
                    m.width,
                    m.height,
                    f,
                    g,
                    m.data
                  )
                : i.texImage2D(
                    e.TEXTURE_2D,
                    t,
                    _,
                    m.width,
                    m.height,
                    0,
                    f,
                    g,
                    m.data
                  );
        }
      else if (s.isDataArrayTexture)
        C
          ? (M &&
              i.texStorage3D(
                e.TEXTURE_2D_ARRAY,
                w,
                _,
                n.width,
                n.height,
                n.depth
              ),
            i.texSubImage3D(
              e.TEXTURE_2D_ARRAY,
              0,
              0,
              0,
              0,
              n.width,
              n.height,
              n.depth,
              f,
              g,
              n.data
            ))
          : i.texImage3D(
              e.TEXTURE_2D_ARRAY,
              0,
              _,
              n.width,
              n.height,
              n.depth,
              0,
              f,
              g,
              n.data
            );
      else if (s.isData3DTexture)
        C
          ? (M &&
              i.texStorage3D(e.TEXTURE_3D, w, _, n.width, n.height, n.depth),
            i.texSubImage3D(
              e.TEXTURE_3D,
              0,
              0,
              0,
              0,
              n.width,
              n.height,
              n.depth,
              f,
              g,
              n.data
            ))
          : i.texImage3D(
              e.TEXTURE_3D,
              0,
              _,
              n.width,
              n.height,
              n.depth,
              0,
              f,
              g,
              n.data
            );
      else if (s.isFramebufferTexture) {
        if (M)
          if (C) i.texStorage2D(e.TEXTURE_2D, w, _, n.width, n.height);
          else {
            let t = n.width,
              s = n.height;
            for (let n = 0; n < w; n++)
              i.texImage2D(e.TEXTURE_2D, n, _, t, s, 0, f, g, null),
                (t >>= 1),
                (s >>= 1);
          }
      } else if (v.length > 0 && p) {
        C && M && i.texStorage2D(e.TEXTURE_2D, w, _, v[0].width, v[0].height);
        for (let t = 0, n = v.length; t < n; t++)
          (m = v[t]),
            C
              ? i.texSubImage2D(e.TEXTURE_2D, t, 0, 0, f, g, m)
              : i.texImage2D(e.TEXTURE_2D, t, _, f, g, m);
        s.generateMipmaps = !1;
      } else
        C
          ? (M && i.texStorage2D(e.TEXTURE_2D, w, _, n.width, n.height),
            i.texSubImage2D(e.TEXTURE_2D, 0, 0, 0, f, g, n))
          : i.texImage2D(e.TEXTURE_2D, 0, _, f, g, n);
      x(s, p) && b(l), (d.__version = u.version), s.onUpdate && s.onUpdate(s);
    }
    t.__version = s.version;
  }
  function te(t, s, a, o, l, h) {
    const c = r.convert(a.format, a.colorSpace),
      u = r.convert(a.type),
      p = E(a.internalFormat, c, u, a.colorSpace);
    if (!n.get(s).__hasExternalTextures) {
      const t = Math.max(1, s.width >> h),
        n = Math.max(1, s.height >> h);
      l === e.TEXTURE_3D || l === e.TEXTURE_2D_ARRAY
        ? i.texImage3D(l, h, p, t, n, s.depth, 0, c, u, null)
        : i.texImage2D(l, h, p, t, n, 0, c, u, null);
    }
    i.bindFramebuffer(e.FRAMEBUFFER, t),
      re(s)
        ? d.framebufferTexture2DMultisampleEXT(
            e.FRAMEBUFFER,
            o,
            l,
            n.get(a).__webglTexture,
            0,
            se(s)
          )
        : (l === e.TEXTURE_2D ||
            (l >= e.TEXTURE_CUBE_MAP_POSITIVE_X &&
              l <= e.TEXTURE_CUBE_MAP_NEGATIVE_Z)) &&
          e.framebufferTexture2D(
            e.FRAMEBUFFER,
            o,
            l,
            n.get(a).__webglTexture,
            h
          ),
      i.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  function ie(t, i, n) {
    if (
      (e.bindRenderbuffer(e.RENDERBUFFER, t), i.depthBuffer && !i.stencilBuffer)
    ) {
      let s = e.DEPTH_COMPONENT16;
      if (n || re(i)) {
        const t = i.depthTexture;
        t &&
          t.isDepthTexture &&
          (t.type === z
            ? (s = e.DEPTH_COMPONENT32F)
            : t.type === U && (s = e.DEPTH_COMPONENT24));
        const n = se(i);
        re(i)
          ? d.renderbufferStorageMultisampleEXT(
              e.RENDERBUFFER,
              n,
              s,
              i.width,
              i.height
            )
          : e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              n,
              s,
              i.width,
              i.height
            );
      } else e.renderbufferStorage(e.RENDERBUFFER, s, i.width, i.height);
      e.framebufferRenderbuffer(
        e.FRAMEBUFFER,
        e.DEPTH_ATTACHMENT,
        e.RENDERBUFFER,
        t
      );
    } else if (i.depthBuffer && i.stencilBuffer) {
      const s = se(i);
      n && !1 === re(i)
        ? e.renderbufferStorageMultisample(
            e.RENDERBUFFER,
            s,
            e.DEPTH24_STENCIL8,
            i.width,
            i.height
          )
        : re(i)
        ? d.renderbufferStorageMultisampleEXT(
            e.RENDERBUFFER,
            s,
            e.DEPTH24_STENCIL8,
            i.width,
            i.height
          )
        : e.renderbufferStorage(
            e.RENDERBUFFER,
            e.DEPTH_STENCIL,
            i.width,
            i.height
          ),
        e.framebufferRenderbuffer(
          e.FRAMEBUFFER,
          e.DEPTH_STENCIL_ATTACHMENT,
          e.RENDERBUFFER,
          t
        );
    } else {
      const t = !0 === i.isWebGLMultipleRenderTargets ? i.texture : [i.texture];
      for (let s = 0; s < t.length; s++) {
        const a = t[s],
          o = r.convert(a.format, a.colorSpace),
          l = r.convert(a.type),
          h = E(a.internalFormat, o, l, a.colorSpace),
          c = se(i);
        n && !1 === re(i)
          ? e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              c,
              h,
              i.width,
              i.height
            )
          : re(i)
          ? d.renderbufferStorageMultisampleEXT(
              e.RENDERBUFFER,
              c,
              h,
              i.width,
              i.height
            )
          : e.renderbufferStorage(e.RENDERBUFFER, h, i.width, i.height);
      }
    }
    e.bindRenderbuffer(e.RENDERBUFFER, null);
  }
  function ne(t) {
    const s = n.get(t),
      r = !0 === t.isWebGLCubeRenderTarget;
    if (t.depthTexture && !s.__autoAllocateDepthBuffer) {
      if (r)
        throw new Error(
          "target.depthTexture not supported in Cube render targets"
        );
      !(function (t, s) {
        if (s && s.isWebGLCubeRenderTarget)
          throw new Error(
            "Depth Texture with cube render targets is not supported"
          );
        if (
          (i.bindFramebuffer(e.FRAMEBUFFER, t),
          !s.depthTexture || !s.depthTexture.isDepthTexture)
        )
          throw new Error(
            "renderTarget.depthTexture must be an instance of THREE.DepthTexture"
          );
        (n.get(s.depthTexture).__webglTexture &&
          s.depthTexture.image.width === s.width &&
          s.depthTexture.image.height === s.height) ||
          ((s.depthTexture.image.width = s.width),
          (s.depthTexture.image.height = s.height),
          (s.depthTexture.needsUpdate = !0)),
          X(s.depthTexture, 0);
        const r = n.get(s.depthTexture).__webglTexture,
          a = se(s);
        if (s.depthTexture.format === H)
          re(s)
            ? d.framebufferTexture2DMultisampleEXT(
                e.FRAMEBUFFER,
                e.DEPTH_ATTACHMENT,
                e.TEXTURE_2D,
                r,
                0,
                a
              )
            : e.framebufferTexture2D(
                e.FRAMEBUFFER,
                e.DEPTH_ATTACHMENT,
                e.TEXTURE_2D,
                r,
                0
              );
        else {
          if (s.depthTexture.format !== j)
            throw new Error("Unknown depthTexture format");
          re(s)
            ? d.framebufferTexture2DMultisampleEXT(
                e.FRAMEBUFFER,
                e.DEPTH_STENCIL_ATTACHMENT,
                e.TEXTURE_2D,
                r,
                0,
                a
              )
            : e.framebufferTexture2D(
                e.FRAMEBUFFER,
                e.DEPTH_STENCIL_ATTACHMENT,
                e.TEXTURE_2D,
                r,
                0
              );
        }
      })(s.__webglFramebuffer, t);
    } else if (r) {
      s.__webglDepthbuffer = [];
      for (let n = 0; n < 6; n++)
        i.bindFramebuffer(e.FRAMEBUFFER, s.__webglFramebuffer[n]),
          (s.__webglDepthbuffer[n] = e.createRenderbuffer()),
          ie(s.__webglDepthbuffer[n], t, !1);
    } else
      i.bindFramebuffer(e.FRAMEBUFFER, s.__webglFramebuffer),
        (s.__webglDepthbuffer = e.createRenderbuffer()),
        ie(s.__webglDepthbuffer, t, !1);
    i.bindFramebuffer(e.FRAMEBUFFER, null);
  }
  function se(e) {
    return Math.min(u, e.samples);
  }
  function re(e) {
    const i = n.get(e);
    return (
      o &&
      e.samples > 0 &&
      !0 === t.has("WEBGL_multisampled_render_to_texture") &&
      !1 !== i.__useRenderToTexture
    );
  }
  function ae(e, i) {
    const n = e.colorSpace,
      s = e.format,
      r = e.type;
    return (
      !0 === e.isCompressedTexture ||
        !0 === e.isVideoTexture ||
        e.format === Ee ||
        (n !== ge &&
          n !== fe &&
          (n === me || n === _e
            ? !1 === o
              ? !0 === t.has("EXT_sRGB") && s === Q
                ? ((e.format = Ee), (e.minFilter = L), (e.generateMipmaps = !1))
                : (i = nt.sRGBToLinear(i))
              : (s === Q && r === B) ||
                console.warn(
                  "THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType."
                )
            : console.error(
                "THREE.WebGLTextures: Unsupported texture color space:",
                n
              ))),
      i
    );
  }
  (this.allocateTextureUnit = function () {
    const e = q;
    return (
      e >= l &&
        console.warn(
          "THREE.WebGLTextures: Trying to use " +
            e +
            " texture units while this GPU supports only " +
            l
        ),
      (q += 1),
      e
    );
  }),
    (this.resetTextureUnits = function () {
      q = 0;
    }),
    (this.setTexture2D = X),
    (this.setTexture2DArray = function (t, s) {
      const r = n.get(t);
      t.version > 0 && r.__version !== t.version
        ? ee(r, t, s)
        : i.bindTexture(e.TEXTURE_2D_ARRAY, r.__webglTexture, e.TEXTURE0 + s);
    }),
    (this.setTexture3D = function (t, s) {
      const r = n.get(t);
      t.version > 0 && r.__version !== t.version
        ? ee(r, t, s)
        : i.bindTexture(e.TEXTURE_3D, r.__webglTexture, e.TEXTURE0 + s);
    }),
    (this.setTextureCube = function (t, s) {
      const a = n.get(t);
      t.version > 0 && a.__version !== t.version
        ? (function (t, s, a) {
            if (6 !== s.image.length) return;
            const l = $(t, s),
              c = s.source;
            i.bindTexture(e.TEXTURE_CUBE_MAP, t.__webglTexture, e.TEXTURE0 + a);
            const u = n.get(c);
            if (c.version !== u.__version || !0 === l) {
              i.activeTexture(e.TEXTURE0 + a),
                e.pixelStorei(e.UNPACK_FLIP_Y_WEBGL, s.flipY),
                e.pixelStorei(
                  e.UNPACK_PREMULTIPLY_ALPHA_WEBGL,
                  s.premultiplyAlpha
                ),
                e.pixelStorei(e.UNPACK_ALIGNMENT, s.unpackAlignment),
                e.pixelStorei(e.UNPACK_COLORSPACE_CONVERSION_WEBGL, e.NONE);
              const t = s.isCompressedTexture || s.image[0].isCompressedTexture,
                n = s.image[0] && s.image[0].isDataTexture,
                d = [];
              for (let e = 0; e < 6; e++)
                (d[e] =
                  t || n
                    ? n
                      ? s.image[e].image
                      : s.image[e]
                    : A(s.image[e], !1, !0, h)),
                  (d[e] = ae(s, d[e]));
              const p = d[0],
                f = y(p) || o,
                m = r.convert(s.format, s.colorSpace),
                g = r.convert(s.type),
                _ = E(s.internalFormat, m, g, s.colorSpace),
                v = o && !0 !== s.isVideoTexture,
                C = void 0 === u.__version || !0 === l;
              let M,
                w = S(s, p, f);
              if ((J(e.TEXTURE_CUBE_MAP, s, f), t)) {
                v &&
                  C &&
                  i.texStorage2D(e.TEXTURE_CUBE_MAP, w, _, p.width, p.height);
                for (let t = 0; t < 6; t++) {
                  M = d[t].mipmaps;
                  for (let n = 0; n < M.length; n++) {
                    const r = M[n];
                    s.format !== Q
                      ? null !== m
                        ? v
                          ? i.compressedTexSubImage2D(
                              e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                              n,
                              0,
                              0,
                              r.width,
                              r.height,
                              m,
                              r.data
                            )
                          : i.compressedTexImage2D(
                              e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                              n,
                              _,
                              r.width,
                              r.height,
                              0,
                              r.data
                            )
                        : console.warn(
                            "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()"
                          )
                      : v
                      ? i.texSubImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                          n,
                          0,
                          0,
                          r.width,
                          r.height,
                          m,
                          g,
                          r.data
                        )
                      : i.texImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                          n,
                          _,
                          r.width,
                          r.height,
                          0,
                          m,
                          g,
                          r.data
                        );
                  }
                }
              } else {
                (M = s.mipmaps),
                  v &&
                    C &&
                    (M.length > 0 && w++,
                    i.texStorage2D(
                      e.TEXTURE_CUBE_MAP,
                      w,
                      _,
                      d[0].width,
                      d[0].height
                    ));
                for (let t = 0; t < 6; t++)
                  if (n) {
                    v
                      ? i.texSubImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                          0,
                          0,
                          0,
                          d[t].width,
                          d[t].height,
                          m,
                          g,
                          d[t].data
                        )
                      : i.texImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                          0,
                          _,
                          d[t].width,
                          d[t].height,
                          0,
                          m,
                          g,
                          d[t].data
                        );
                    for (let n = 0; n < M.length; n++) {
                      const s = M[n].image[t].image;
                      v
                        ? i.texSubImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            n + 1,
                            0,
                            0,
                            s.width,
                            s.height,
                            m,
                            g,
                            s.data
                          )
                        : i.texImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            n + 1,
                            _,
                            s.width,
                            s.height,
                            0,
                            m,
                            g,
                            s.data
                          );
                    }
                  } else {
                    v
                      ? i.texSubImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                          0,
                          0,
                          0,
                          m,
                          g,
                          d[t]
                        )
                      : i.texImage2D(
                          e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                          0,
                          _,
                          m,
                          g,
                          d[t]
                        );
                    for (let n = 0; n < M.length; n++) {
                      const s = M[n];
                      v
                        ? i.texSubImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            n + 1,
                            0,
                            0,
                            m,
                            g,
                            s.image[t]
                          )
                        : i.texImage2D(
                            e.TEXTURE_CUBE_MAP_POSITIVE_X + t,
                            n + 1,
                            _,
                            m,
                            g,
                            s.image[t]
                          );
                    }
                  }
              }
              x(s, f) && b(e.TEXTURE_CUBE_MAP),
                (u.__version = c.version),
                s.onUpdate && s.onUpdate(s);
            }
            t.__version = s.version;
          })(a, t, s)
        : i.bindTexture(e.TEXTURE_CUBE_MAP, a.__webglTexture, e.TEXTURE0 + s);
    }),
    (this.rebindTextures = function (t, i, s) {
      const r = n.get(t);
      void 0 !== i &&
        te(
          r.__webglFramebuffer,
          t,
          t.texture,
          e.COLOR_ATTACHMENT0,
          e.TEXTURE_2D,
          0
        ),
        void 0 !== s && ne(t);
    }),
    (this.setupRenderTarget = function (t) {
      const l = t.texture,
        h = n.get(t),
        c = n.get(l);
      t.addEventListener("dispose", O),
        !0 !== t.isWebGLMultipleRenderTargets &&
          (void 0 === c.__webglTexture &&
            (c.__webglTexture = e.createTexture()),
          (c.__version = l.version),
          a.memory.textures++);
      const u = !0 === t.isWebGLCubeRenderTarget,
        d = !0 === t.isWebGLMultipleRenderTargets,
        p = y(t) || o;
      if (u) {
        h.__webglFramebuffer = [];
        for (let t = 0; t < 6; t++)
          if (o && l.mipmaps && l.mipmaps.length > 0) {
            h.__webglFramebuffer[t] = [];
            for (let i = 0; i < l.mipmaps.length; i++)
              h.__webglFramebuffer[t][i] = e.createFramebuffer();
          } else h.__webglFramebuffer[t] = e.createFramebuffer();
      } else {
        if (o && l.mipmaps && l.mipmaps.length > 0) {
          h.__webglFramebuffer = [];
          for (let t = 0; t < l.mipmaps.length; t++)
            h.__webglFramebuffer[t] = e.createFramebuffer();
        } else h.__webglFramebuffer = e.createFramebuffer();
        if (d)
          if (s.drawBuffers) {
            const i = t.texture;
            for (let t = 0, s = i.length; t < s; t++) {
              const s = n.get(i[t]);
              void 0 === s.__webglTexture &&
                ((s.__webglTexture = e.createTexture()), a.memory.textures++);
            }
          } else
            console.warn(
              "THREE.WebGLRenderer: WebGLMultipleRenderTargets can only be used with WebGL2 or WEBGL_draw_buffers extension."
            );
        if (o && t.samples > 0 && !1 === re(t)) {
          const n = d ? l : [l];
          (h.__webglMultisampledFramebuffer = e.createFramebuffer()),
            (h.__webglColorRenderbuffer = []),
            i.bindFramebuffer(e.FRAMEBUFFER, h.__webglMultisampledFramebuffer);
          for (let i = 0; i < n.length; i++) {
            const s = n[i];
            (h.__webglColorRenderbuffer[i] = e.createRenderbuffer()),
              e.bindRenderbuffer(e.RENDERBUFFER, h.__webglColorRenderbuffer[i]);
            const a = r.convert(s.format, s.colorSpace),
              o = r.convert(s.type),
              l = E(
                s.internalFormat,
                a,
                o,
                s.colorSpace,
                !0 === t.isXRRenderTarget
              ),
              c = se(t);
            e.renderbufferStorageMultisample(
              e.RENDERBUFFER,
              c,
              l,
              t.width,
              t.height
            ),
              e.framebufferRenderbuffer(
                e.FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + i,
                e.RENDERBUFFER,
                h.__webglColorRenderbuffer[i]
              );
          }
          e.bindRenderbuffer(e.RENDERBUFFER, null),
            t.depthBuffer &&
              ((h.__webglDepthRenderbuffer = e.createRenderbuffer()),
              ie(h.__webglDepthRenderbuffer, t, !0)),
            i.bindFramebuffer(e.FRAMEBUFFER, null);
        }
      }
      if (u) {
        i.bindTexture(e.TEXTURE_CUBE_MAP, c.__webglTexture),
          J(e.TEXTURE_CUBE_MAP, l, p);
        for (let i = 0; i < 6; i++)
          if (o && l.mipmaps && l.mipmaps.length > 0)
            for (let n = 0; n < l.mipmaps.length; n++)
              te(
                h.__webglFramebuffer[i][n],
                t,
                l,
                e.COLOR_ATTACHMENT0,
                e.TEXTURE_CUBE_MAP_POSITIVE_X + i,
                n
              );
          else
            te(
              h.__webglFramebuffer[i],
              t,
              l,
              e.COLOR_ATTACHMENT0,
              e.TEXTURE_CUBE_MAP_POSITIVE_X + i,
              0
            );
        x(l, p) && b(e.TEXTURE_CUBE_MAP), i.unbindTexture();
      } else if (d) {
        const s = t.texture;
        for (let r = 0, a = s.length; r < a; r++) {
          const a = s[r],
            o = n.get(a);
          i.bindTexture(e.TEXTURE_2D, o.__webglTexture),
            J(e.TEXTURE_2D, a, p),
            te(
              h.__webglFramebuffer,
              t,
              a,
              e.COLOR_ATTACHMENT0 + r,
              e.TEXTURE_2D,
              0
            ),
            x(a, p) && b(e.TEXTURE_2D);
        }
        i.unbindTexture();
      } else {
        let n = e.TEXTURE_2D;
        if (
          ((t.isWebGL3DRenderTarget || t.isWebGLArrayRenderTarget) &&
            (o
              ? (n = t.isWebGL3DRenderTarget
                  ? e.TEXTURE_3D
                  : e.TEXTURE_2D_ARRAY)
              : console.error(
                  "THREE.WebGLTextures: THREE.Data3DTexture and THREE.DataArrayTexture only supported with WebGL2."
                )),
          i.bindTexture(n, c.__webglTexture),
          J(n, l, p),
          o && l.mipmaps && l.mipmaps.length > 0)
        )
          for (let i = 0; i < l.mipmaps.length; i++)
            te(h.__webglFramebuffer[i], t, l, e.COLOR_ATTACHMENT0, n, i);
        else te(h.__webglFramebuffer, t, l, e.COLOR_ATTACHMENT0, n, 0);
        x(l, p) && b(n), i.unbindTexture();
      }
      t.depthBuffer && ne(t);
    }),
    (this.updateRenderTargetMipmap = function (t) {
      const s = y(t) || o,
        r = !0 === t.isWebGLMultipleRenderTargets ? t.texture : [t.texture];
      for (let a = 0, o = r.length; a < o; a++) {
        const o = r[a];
        if (x(o, s)) {
          const s = t.isWebGLCubeRenderTarget
              ? e.TEXTURE_CUBE_MAP
              : e.TEXTURE_2D,
            r = n.get(o).__webglTexture;
          i.bindTexture(s, r), b(s), i.unbindTexture();
        }
      }
    }),
    (this.updateMultisampleRenderTarget = function (t) {
      if (o && t.samples > 0 && !1 === re(t)) {
        const s = t.isWebGLMultipleRenderTargets ? t.texture : [t.texture],
          r = t.width,
          a = t.height;
        let o = e.COLOR_BUFFER_BIT;
        const l = [],
          h = t.stencilBuffer ? e.DEPTH_STENCIL_ATTACHMENT : e.DEPTH_ATTACHMENT,
          c = n.get(t),
          u = !0 === t.isWebGLMultipleRenderTargets;
        if (u)
          for (let t = 0; t < s.length; t++)
            i.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer),
              e.framebufferRenderbuffer(
                e.FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + t,
                e.RENDERBUFFER,
                null
              ),
              i.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer),
              e.framebufferTexture2D(
                e.DRAW_FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + t,
                e.TEXTURE_2D,
                null,
                0
              );
        i.bindFramebuffer(e.READ_FRAMEBUFFER, c.__webglMultisampledFramebuffer),
          i.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglFramebuffer);
        for (let i = 0; i < s.length; i++) {
          l.push(e.COLOR_ATTACHMENT0 + i), t.depthBuffer && l.push(h);
          const d = void 0 !== c.__ignoreDepthValues && c.__ignoreDepthValues;
          if (
            (!1 === d && t.depthBuffer && (o |= e.DEPTH_BUFFER_BIT),
            u &&
              e.framebufferRenderbuffer(
                e.READ_FRAMEBUFFER,
                e.COLOR_ATTACHMENT0,
                e.RENDERBUFFER,
                c.__webglColorRenderbuffer[i]
              ),
            !0 === d &&
              (e.invalidateFramebuffer(e.READ_FRAMEBUFFER, [h]),
              e.invalidateFramebuffer(e.DRAW_FRAMEBUFFER, [h])),
            u)
          ) {
            const t = n.get(s[i]).__webglTexture;
            e.framebufferTexture2D(
              e.DRAW_FRAMEBUFFER,
              e.COLOR_ATTACHMENT0,
              e.TEXTURE_2D,
              t,
              0
            );
          }
          e.blitFramebuffer(0, 0, r, a, 0, 0, r, a, o, e.NEAREST),
            p && e.invalidateFramebuffer(e.READ_FRAMEBUFFER, l);
        }
        if (
          (i.bindFramebuffer(e.READ_FRAMEBUFFER, null),
          i.bindFramebuffer(e.DRAW_FRAMEBUFFER, null),
          u)
        )
          for (let t = 0; t < s.length; t++) {
            i.bindFramebuffer(e.FRAMEBUFFER, c.__webglMultisampledFramebuffer),
              e.framebufferRenderbuffer(
                e.FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + t,
                e.RENDERBUFFER,
                c.__webglColorRenderbuffer[t]
              );
            const r = n.get(s[t]).__webglTexture;
            i.bindFramebuffer(e.FRAMEBUFFER, c.__webglFramebuffer),
              e.framebufferTexture2D(
                e.DRAW_FRAMEBUFFER,
                e.COLOR_ATTACHMENT0 + t,
                e.TEXTURE_2D,
                r,
                0
              );
          }
        i.bindFramebuffer(e.DRAW_FRAMEBUFFER, c.__webglMultisampledFramebuffer);
      }
    }),
    (this.setupDepthRenderbuffer = ne),
    (this.setupFrameBufferTexture = te),
    (this.useMultisampledRTT = re);
}
function ga(e, t, i) {
  const n = i.isWebGL2;
  return {
    convert: function (i, s = fe) {
      let r;
      const a = s === me || s === _e ? 1 : 0;
      if (i === B) return e.UNSIGNED_BYTE;
      if (1017 === i) return e.UNSIGNED_SHORT_4_4_4_4;
      if (1018 === i) return e.UNSIGNED_SHORT_5_5_5_1;
      if (1010 === i) return e.BYTE;
      if (1011 === i) return e.SHORT;
      if (i === k) return e.UNSIGNED_SHORT;
      if (i === O) return e.INT;
      if (i === U) return e.UNSIGNED_INT;
      if (i === z) return e.FLOAT;
      if (i === G)
        return n
          ? e.HALF_FLOAT
          : ((r = t.get("OES_texture_half_float")),
            null !== r ? r.HALF_FLOAT_OES : null);
      if (1021 === i) return e.ALPHA;
      if (i === Q) return e.RGBA;
      if (1024 === i) return e.LUMINANCE;
      if (1025 === i) return e.LUMINANCE_ALPHA;
      if (i === H) return e.DEPTH_COMPONENT;
      if (i === j) return e.DEPTH_STENCIL;
      if (i === Ee)
        return (r = t.get("EXT_sRGB")), null !== r ? r.SRGB_ALPHA_EXT : null;
      if (i === W) return e.RED;
      if (1029 === i) return e.RED_INTEGER;
      if (i === q) return e.RG;
      if (1031 === i) return e.RG_INTEGER;
      if (1033 === i) return e.RGBA_INTEGER;
      if (i === X || i === Y || i === K || i === Z)
        if (1 === a) {
          if (((r = t.get("WEBGL_compressed_texture_s3tc_srgb")), null === r))
            return null;
          if (i === X) return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          if (i === Y) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          if (i === K) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
          if (i === Z) return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        } else {
          if (((r = t.get("WEBGL_compressed_texture_s3tc")), null === r))
            return null;
          if (i === X) return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
          if (i === Y) return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
          if (i === K) return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
          if (i === Z) return r.COMPRESSED_RGBA_S3TC_DXT5_EXT;
        }
      if (i === J || 35841 === i || i === $ || 35843 === i) {
        if (((r = t.get("WEBGL_compressed_texture_pvrtc")), null === r))
          return null;
        if (i === J) return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
        if (35841 === i) return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
        if (i === $) return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
        if (35843 === i) return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
      }
      if (36196 === i)
        return (
          (r = t.get("WEBGL_compressed_texture_etc1")),
          null !== r ? r.COMPRESSED_RGB_ETC1_WEBGL : null
        );
      if (i === ee || i === te) {
        if (((r = t.get("WEBGL_compressed_texture_etc")), null === r))
          return null;
        if (i === ee)
          return 1 === a ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
        if (i === te)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC
            : r.COMPRESSED_RGBA8_ETC2_EAC;
      }
      if (
        i === ie ||
        37809 === i ||
        37810 === i ||
        37811 === i ||
        i === ne ||
        37813 === i ||
        37814 === i ||
        37815 === i ||
        37816 === i ||
        37817 === i ||
        37818 === i ||
        37819 === i ||
        37820 === i ||
        37821 === i
      ) {
        if (((r = t.get("WEBGL_compressed_texture_astc")), null === r))
          return null;
        if (i === ie)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR
            : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
        if (37809 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR
            : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
        if (37810 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR
            : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
        if (37811 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR
            : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
        if (i === ne)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR
            : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
        if (37813 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR
            : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
        if (37814 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR
            : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
        if (37815 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR
            : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
        if (37816 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR
            : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
        if (37817 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR
            : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
        if (37818 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR
            : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
        if (37819 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR
            : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
        if (37820 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR
            : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
        if (37821 === i)
          return 1 === a
            ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR
            : r.COMPRESSED_RGBA_ASTC_12x12_KHR;
      }
      if (i === se || 36494 === i || 36495 === i) {
        if (((r = t.get("EXT_texture_compression_bptc")), null === r))
          return null;
        if (i === se)
          return 1 === a
            ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT
            : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
        if (36494 === i) return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
        if (36495 === i) return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT;
      }
      if (36283 === i || 36284 === i || 36285 === i || 36286 === i) {
        if (((r = t.get("EXT_texture_compression_rgtc")), null === r))
          return null;
        if (i === se) return r.COMPRESSED_RED_RGTC1_EXT;
        if (36284 === i) return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
        if (36285 === i) return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
        if (36286 === i) return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT;
      }
      return i === V
        ? n
          ? e.UNSIGNED_INT_24_8
          : ((r = t.get("WEBGL_depth_texture")),
            null !== r ? r.UNSIGNED_INT_24_8_WEBGL : null)
        : void 0 !== e[i]
        ? e[i]
        : null;
    },
  };
}
class _a extends Dn {
  constructor(e = []) {
    super(), (this.isArrayCamera = !0), (this.cameras = e);
  }
}
class va extends Object3D {
  constructor() {
    super(), (this.isGroup = !0), (this.type = "Group");
  }
}
const Aa = { type: "move" };
class ya {
  constructor() {
    (this._targetRay = null), (this._grip = null), (this._hand = null);
  }
  getHandSpace() {
    return (
      null === this._hand &&
        ((this._hand = new va()),
        (this._hand.matrixAutoUpdate = !1),
        (this._hand.visible = !1),
        (this._hand.joints = {}),
        (this._hand.inputState = { pinching: !1 })),
      this._hand
    );
  }
  getTargetRaySpace() {
    return (
      null === this._targetRay &&
        ((this._targetRay = new va()),
        (this._targetRay.matrixAutoUpdate = !1),
        (this._targetRay.visible = !1),
        (this._targetRay.hasLinearVelocity = !1),
        (this._targetRay.linearVelocity = new Vector3()),
        (this._targetRay.hasAngularVelocity = !1),
        (this._targetRay.angularVelocity = new Vector3())),
      this._targetRay
    );
  }
  getGripSpace() {
    return (
      null === this._grip &&
        ((this._grip = new va()),
        (this._grip.matrixAutoUpdate = !1),
        (this._grip.visible = !1),
        (this._grip.hasLinearVelocity = !1),
        (this._grip.linearVelocity = new Vector3()),
        (this._grip.hasAngularVelocity = !1),
        (this._grip.angularVelocity = new Vector3())),
      this._grip
    );
  }
  dispatchEvent(e) {
    return (
      null !== this._targetRay && this._targetRay.dispatchEvent(e),
      null !== this._grip && this._grip.dispatchEvent(e),
      null !== this._hand && this._hand.dispatchEvent(e),
      this
    );
  }
  connect(e) {
    if (e && e.hand) {
      const t = this._hand;
      if (t) for (const i of e.hand.values()) this._getHandJoint(t, i);
    }
    return this.dispatchEvent({ type: "connected", data: e }), this;
  }
  disconnect(e) {
    return (
      this.dispatchEvent({ type: "disconnected", data: e }),
      null !== this._targetRay && (this._targetRay.visible = !1),
      null !== this._grip && (this._grip.visible = !1),
      null !== this._hand && (this._hand.visible = !1),
      this
    );
  }
  update(e, t, i) {
    let n = null,
      s = null,
      r = null;
    const a = this._targetRay,
      o = this._grip,
      l = this._hand;
    if (e && "visible-blurred" !== t.session.visibilityState) {
      if (l && e.hand) {
        r = !0;
        for (const r of e.hand.values()) {
          const e = t.getJointPose(r, i),
            n = this._getHandJoint(l, r);
          null !== e &&
            (n.matrix.fromArray(e.transform.matrix),
            n.matrix.decompose(n.position, n.rotation, n.scale),
            (n.matrixWorldNeedsUpdate = !0),
            (n.jointRadius = e.radius)),
            (n.visible = null !== e);
        }
        const n = l.joints["index-finger-tip"],
          s = l.joints["thumb-tip"],
          a = n.position.distanceTo(s.position),
          o = 0.02,
          h = 0.005;
        l.inputState.pinching && a > o + h
          ? ((l.inputState.pinching = !1),
            this.dispatchEvent({
              type: "pinchend",
              handedness: e.handedness,
              target: this,
            }))
          : !l.inputState.pinching &&
            a <= o - h &&
            ((l.inputState.pinching = !0),
            this.dispatchEvent({
              type: "pinchstart",
              handedness: e.handedness,
              target: this,
            }));
      } else
        null !== o &&
          e.gripSpace &&
          ((s = t.getPose(e.gripSpace, i)),
          null !== s &&
            (o.matrix.fromArray(s.transform.matrix),
            o.matrix.decompose(o.position, o.rotation, o.scale),
            (o.matrixWorldNeedsUpdate = !0),
            s.linearVelocity
              ? ((o.hasLinearVelocity = !0),
                o.linearVelocity.copy(s.linearVelocity))
              : (o.hasLinearVelocity = !1),
            s.angularVelocity
              ? ((o.hasAngularVelocity = !0),
                o.angularVelocity.copy(s.angularVelocity))
              : (o.hasAngularVelocity = !1)));
      null !== a &&
        ((n = t.getPose(e.targetRaySpace, i)),
        null === n && null !== s && (n = s),
        null !== n &&
          (a.matrix.fromArray(n.transform.matrix),
          a.matrix.decompose(a.position, a.rotation, a.scale),
          (a.matrixWorldNeedsUpdate = !0),
          n.linearVelocity
            ? ((a.hasLinearVelocity = !0),
              a.linearVelocity.copy(n.linearVelocity))
            : (a.hasLinearVelocity = !1),
          n.angularVelocity
            ? ((a.hasAngularVelocity = !0),
              a.angularVelocity.copy(n.angularVelocity))
            : (a.hasAngularVelocity = !1),
          this.dispatchEvent(Aa)));
    }
    return (
      null !== a && (a.visible = null !== n),
      null !== o && (o.visible = null !== s),
      null !== l && (l.visible = null !== r),
      this
    );
  }
  _getHandJoint(e, t) {
    if (void 0 === e.joints[t.jointName]) {
      const i = new va();
      (i.matrixAutoUpdate = !1),
        (i.visible = !1),
        (e.joints[t.jointName] = i),
        e.add(i);
    }
    return e.joints[t.jointName];
  }
}
class xa extends Texture {
  constructor(e, t, i, n, s, r, a, o, l, h) {
    if ((h = void 0 !== h ? h : H) !== H && h !== j)
      throw new Error(
        "DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat"
      );
    void 0 === i && h === H && (i = U),
      void 0 === i && h === j && (i = V),
      super(null, n, s, r, a, o, h, i, l),
      (this.isDepthTexture = !0),
      (this.image = { width: e, height: t }),
      (this.magFilter = void 0 !== a ? a : R),
      (this.minFilter = void 0 !== o ? o : R),
      (this.flipY = !1),
      (this.generateMipmaps = !1),
      (this.compareFunction = null);
  }
  copy(e) {
    return super.copy(e), (this.compareFunction = e.compareFunction), this;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      null !== this.compareFunction &&
        (t.compareFunction = this.compareFunction),
      t
    );
  }
}
class ba extends EventDispatcher {
  constructor(e, t) {
    super();
    const i = this;
    let n = null,
      s = 1,
      r = null,
      a = "local-floor",
      o = 1,
      l = null,
      h = null,
      c = null,
      u = null,
      d = null,
      p = null;
    const f = t.getContextAttributes();
    let m = null,
      g = null;
    const _ = [],
      v = [],
      A = new Dn();
    A.layers.enable(1), (A.viewport = new Vector4());
    const y = new Dn();
    y.layers.enable(2), (y.viewport = new Vector4());
    const x = [A, y],
      b = new _a();
    b.layers.enable(1), b.layers.enable(2);
    let E = null,
      S = null;
    function C(e) {
      const t = v.indexOf(e.inputSource);
      if (-1 === t) return;
      const i = _[t];
      void 0 !== i &&
        (i.update(e.inputSource, e.frame, l || r),
        i.dispatchEvent({ type: e.type, data: e.inputSource }));
    }
    function M() {
      n.removeEventListener("select", C),
        n.removeEventListener("selectstart", C),
        n.removeEventListener("selectend", C),
        n.removeEventListener("squeeze", C),
        n.removeEventListener("squeezestart", C),
        n.removeEventListener("squeezeend", C),
        n.removeEventListener("end", M),
        n.removeEventListener("inputsourceschange", w);
      for (let e = 0; e < _.length; e++) {
        const t = v[e];
        null !== t && ((v[e] = null), _[e].disconnect(t));
      }
      (E = null),
        (S = null),
        e.setRenderTarget(m),
        (d = null),
        (u = null),
        (c = null),
        (n = null),
        (g = null),
        D.stop(),
        (i.isPresenting = !1),
        i.dispatchEvent({ type: "sessionend" });
    }
    function w(e) {
      for (let t = 0; t < e.removed.length; t++) {
        const i = e.removed[t],
          n = v.indexOf(i);
        n >= 0 && ((v[n] = null), _[n].disconnect(i));
      }
      for (let t = 0; t < e.added.length; t++) {
        const i = e.added[t];
        let n = v.indexOf(i);
        if (-1 === n) {
          for (let e = 0; e < _.length; e++) {
            if (e >= v.length) {
              v.push(i), (n = e);
              break;
            }
            if (null === v[e]) {
              (v[e] = i), (n = e);
              break;
            }
          }
          if (-1 === n) break;
        }
        const s = _[n];
        s && s.connect(i);
      }
    }
    (this.cameraAutoUpdate = !0),
      (this.enabled = !1),
      (this.isPresenting = !1),
      (this.getController = function (e) {
        let t = _[e];
        return (
          void 0 === t && ((t = new ya()), (_[e] = t)), t.getTargetRaySpace()
        );
      }),
      (this.getControllerGrip = function (e) {
        let t = _[e];
        return void 0 === t && ((t = new ya()), (_[e] = t)), t.getGripSpace();
      }),
      (this.getHand = function (e) {
        let t = _[e];
        return void 0 === t && ((t = new ya()), (_[e] = t)), t.getHandSpace();
      }),
      (this.setFramebufferScaleFactor = function (e) {
        (s = e),
          !0 === i.isPresenting &&
            console.warn(
              "THREE.WebXRManager: Cannot change framebuffer scale while presenting."
            );
      }),
      (this.setReferenceSpaceType = function (e) {
        (a = e),
          !0 === i.isPresenting &&
            console.warn(
              "THREE.WebXRManager: Cannot change reference space type while presenting."
            );
      }),
      (this.getReferenceSpace = function () {
        return l || r;
      }),
      (this.setReferenceSpace = function (e) {
        l = e;
      }),
      (this.getBaseLayer = function () {
        return null !== u ? u : d;
      }),
      (this.getBinding = function () {
        return c;
      }),
      (this.getFrame = function () {
        return p;
      }),
      (this.getSession = function () {
        return n;
      }),
      (this.setSession = async function (h) {
        if (((n = h), null !== n)) {
          if (
            ((m = e.getRenderTarget()),
            n.addEventListener("select", C),
            n.addEventListener("selectstart", C),
            n.addEventListener("selectend", C),
            n.addEventListener("squeeze", C),
            n.addEventListener("squeezestart", C),
            n.addEventListener("squeezeend", C),
            n.addEventListener("end", M),
            n.addEventListener("inputsourceschange", w),
            !0 !== f.xrCompatible && (await t.makeXRCompatible()),
            void 0 === n.renderState.layers || !1 === e.capabilities.isWebGL2)
          ) {
            const i = {
              antialias: void 0 !== n.renderState.layers || f.antialias,
              alpha: !0,
              depth: f.depth,
              stencil: f.stencil,
              framebufferScaleFactor: s,
            };
            (d = new XRWebGLLayer(n, t, i)),
              n.updateRenderState({ baseLayer: d }),
              (g = new ut(d.framebufferWidth, d.framebufferHeight, {
                format: Q,
                type: B,
                colorSpace: e.outputColorSpace,
                stencilBuffer: f.stencil,
              }));
          } else {
            let i = null,
              r = null,
              a = null;
            f.depth &&
              ((a = f.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24),
              (i = f.stencil ? j : H),
              (r = f.stencil ? V : U));
            const o = { colorFormat: t.RGBA8, depthFormat: a, scaleFactor: s };
            (c = new XRWebGLBinding(n, t)),
              (u = c.createProjectionLayer(o)),
              n.updateRenderState({ layers: [u] }),
              (g = new ut(u.textureWidth, u.textureHeight, {
                format: Q,
                type: B,
                depthTexture: new xa(
                  u.textureWidth,
                  u.textureHeight,
                  r,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  void 0,
                  i
                ),
                stencilBuffer: f.stencil,
                colorSpace: e.outputColorSpace,
                samples: f.antialias ? 4 : 0,
              }));
            e.properties.get(g).__ignoreDepthValues = u.ignoreDepthValues;
          }
          (g.isXRRenderTarget = !0),
            this.setFoveation(o),
            (l = null),
            (r = await n.requestReferenceSpace(a)),
            D.setContext(n),
            D.start(),
            (i.isPresenting = !0),
            i.dispatchEvent({ type: "sessionstart" });
        }
      }),
      (this.getEnvironmentBlendMode = function () {
        if (null !== n) return n.environmentBlendMode;
      });
    const T = new Vector3(),
      I = new Vector3();
    function R(e, t) {
      null === t
        ? e.matrixWorld.copy(e.matrix)
        : e.matrixWorld.multiplyMatrices(t.matrixWorld, e.matrix),
        e.matrixWorldInverse.copy(e.matrixWorld).invert();
    }
    (this.updateCamera = function (e) {
      if (null === n) return;
      (b.near = y.near = A.near = e.near),
        (b.far = y.far = A.far = e.far),
        (E === b.near && S === b.far) ||
          (n.updateRenderState({ depthNear: b.near, depthFar: b.far }),
          (E = b.near),
          (S = b.far));
      const t = e.parent,
        i = b.cameras;
      R(b, t);
      for (let n = 0; n < i.length; n++) R(i[n], t);
      2 === i.length
        ? (function (e, t, i) {
            T.setFromMatrixPosition(t.matrixWorld),
              I.setFromMatrixPosition(i.matrixWorld);
            const n = T.distanceTo(I),
              s = t.projectionMatrix.elements,
              r = i.projectionMatrix.elements,
              a = s[14] / (s[10] - 1),
              o = s[14] / (s[10] + 1),
              l = (s[9] + 1) / s[5],
              h = (s[9] - 1) / s[5],
              c = (s[8] - 1) / s[0],
              u = (r[8] + 1) / r[0],
              d = a * c,
              p = a * u,
              f = n / (-c + u),
              m = f * -c;
            t.matrixWorld.decompose(e.position, e.quaternion, e.scale),
              e.translateX(m),
              e.translateZ(f),
              e.matrixWorld.compose(e.position, e.quaternion, e.scale),
              e.matrixWorldInverse.copy(e.matrixWorld).invert();
            const g = a + f,
              _ = o + f,
              v = d - m,
              A = p + (n - m),
              y = ((l * o) / _) * g,
              x = ((h * o) / _) * g;
            e.projectionMatrix.makePerspective(v, A, y, x, g, _),
              e.projectionMatrixInverse.copy(e.projectionMatrix).invert();
          })(b, A, y)
        : b.projectionMatrix.copy(A.projectionMatrix),
        (function (e, t, i) {
          null === i
            ? e.matrix.copy(t.matrixWorld)
            : (e.matrix.copy(i.matrixWorld),
              e.matrix.invert(),
              e.matrix.multiply(t.matrixWorld));
          e.matrix.decompose(e.position, e.quaternion, e.scale),
            e.updateMatrixWorld(!0),
            e.projectionMatrix.copy(t.projectionMatrix),
            e.projectionMatrixInverse.copy(t.projectionMatrixInverse),
            e.isPerspectiveCamera &&
              ((e.fov = 2 * Re * Math.atan(1 / e.projectionMatrix.elements[5])),
              (e.zoom = 1));
        })(e, b, t);
    }),
      (this.getCamera = function () {
        return b;
      }),
      (this.getFoveation = function () {
        if (null !== u || null !== d) return o;
      }),
      (this.setFoveation = function (e) {
        (o = e),
          null !== u && (u.fixedFoveation = e),
          null !== d && void 0 !== d.fixedFoveation && (d.fixedFoveation = e);
      });
    let P = null;
    const D = new Hn();
    D.setAnimationLoop(function (t, n) {
      if (((h = n.getViewerPose(l || r)), (p = n), null !== h)) {
        const t = h.views;
        null !== d &&
          (e.setRenderTargetFramebuffer(g, d.framebuffer),
          e.setRenderTarget(g));
        let i = !1;
        t.length !== b.cameras.length && ((b.cameras.length = 0), (i = !0));
        for (let n = 0; n < t.length; n++) {
          const s = t[n];
          let r = null;
          if (null !== d) r = d.getViewport(s);
          else {
            const t = c.getViewSubImage(u, s);
            (r = t.viewport),
              0 === n &&
                (e.setRenderTargetTextures(
                  g,
                  t.colorTexture,
                  u.ignoreDepthValues ? void 0 : t.depthStencilTexture
                ),
                e.setRenderTarget(g));
          }
          let a = x[n];
          void 0 === a &&
            ((a = new Dn()),
            a.layers.enable(n),
            (a.viewport = new Vector4()),
            (x[n] = a)),
            a.matrix.fromArray(s.transform.matrix),
            a.matrix.decompose(a.position, a.quaternion, a.scale),
            a.projectionMatrix.fromArray(s.projectionMatrix),
            a.projectionMatrixInverse.copy(a.projectionMatrix).invert(),
            a.viewport.set(r.x, r.y, r.width, r.height),
            0 === n &&
              (b.matrix.copy(a.matrix),
              b.matrix.decompose(b.position, b.quaternion, b.scale)),
            !0 === i && b.cameras.push(a);
        }
      }
      for (let e = 0; e < _.length; e++) {
        const t = v[e],
          i = _[e];
        null !== t && void 0 !== i && i.update(t, n, l || r);
      }
      P && P(t, n),
        n.detectedPlanes &&
          i.dispatchEvent({ type: "planesdetected", data: n }),
        (p = null);
    }),
      (this.setAnimationLoop = function (e) {
        P = e;
      }),
      (this.dispose = function () {});
  }
}
function Ea(e, t) {
  function i(e, t) {
    !0 === e.matrixAutoUpdate && e.updateMatrix(), t.value.copy(e.matrix);
  }
  function n(n, s) {
    (n.opacity.value = s.opacity),
      s.color && n.diffuse.value.copy(s.color),
      s.emissive &&
        n.emissive.value.copy(s.emissive).multiplyScalar(s.emissiveIntensity),
      s.map && ((n.map.value = s.map), i(s.map, n.mapTransform)),
      s.alphaMap &&
        ((n.alphaMap.value = s.alphaMap), i(s.alphaMap, n.alphaMapTransform)),
      s.bumpMap &&
        ((n.bumpMap.value = s.bumpMap),
        i(s.bumpMap, n.bumpMapTransform),
        (n.bumpScale.value = s.bumpScale),
        s.side === c && (n.bumpScale.value *= -1)),
      s.normalMap &&
        ((n.normalMap.value = s.normalMap),
        i(s.normalMap, n.normalMapTransform),
        n.normalScale.value.copy(s.normalScale),
        s.side === c && n.normalScale.value.negate()),
      s.displacementMap &&
        ((n.displacementMap.value = s.displacementMap),
        i(s.displacementMap, n.displacementMapTransform),
        (n.displacementScale.value = s.displacementScale),
        (n.displacementBias.value = s.displacementBias)),
      s.emissiveMap &&
        ((n.emissiveMap.value = s.emissiveMap),
        i(s.emissiveMap, n.emissiveMapTransform)),
      s.specularMap &&
        ((n.specularMap.value = s.specularMap),
        i(s.specularMap, n.specularMapTransform)),
      s.alphaTest > 0 && (n.alphaTest.value = s.alphaTest);
    const r = t.get(s).envMap;
    if (
      (r &&
        ((n.envMap.value = r),
        (n.flipEnvMap.value =
          r.isCubeTexture && !1 === r.isRenderTargetTexture ? -1 : 1),
        (n.reflectivity.value = s.reflectivity),
        (n.ior.value = s.ior),
        (n.refractionRatio.value = s.refractionRatio)),
      s.lightMap)
    ) {
      n.lightMap.value = s.lightMap;
      const t = !0 === e._useLegacyLights ? Math.PI : 1;
      (n.lightMapIntensity.value = s.lightMapIntensity * t),
        i(s.lightMap, n.lightMapTransform);
    }
    s.aoMap &&
      ((n.aoMap.value = s.aoMap),
      (n.aoMapIntensity.value = s.aoMapIntensity),
      i(s.aoMap, n.aoMapTransform));
  }
  return {
    refreshFogUniforms: function (t, i) {
      i.color.getRGB(t.fogColor.value, Tn(e)),
        i.isFog
          ? ((t.fogNear.value = i.near), (t.fogFar.value = i.far))
          : i.isFogExp2 && (t.fogDensity.value = i.density);
    },
    refreshMaterialUniforms: function (e, s, r, a, o) {
      s.isMeshBasicMaterial || s.isMeshLambertMaterial
        ? n(e, s)
        : s.isMeshToonMaterial
        ? (n(e, s),
          (function (e, t) {
            t.gradientMap && (e.gradientMap.value = t.gradientMap);
          })(e, s))
        : s.isMeshPhongMaterial
        ? (n(e, s),
          (function (e, t) {
            e.specular.value.copy(t.specular),
              (e.shininess.value = Math.max(t.shininess, 1e-4));
          })(e, s))
        : s.isMeshStandardMaterial
        ? (n(e, s),
          (function (e, n) {
            (e.metalness.value = n.metalness),
              n.metalnessMap &&
                ((e.metalnessMap.value = n.metalnessMap),
                i(n.metalnessMap, e.metalnessMapTransform));
            (e.roughness.value = n.roughness),
              n.roughnessMap &&
                ((e.roughnessMap.value = n.roughnessMap),
                i(n.roughnessMap, e.roughnessMapTransform));
            const s = t.get(n).envMap;
            s && (e.envMapIntensity.value = n.envMapIntensity);
          })(e, s),
          s.isMeshPhysicalMaterial &&
            (function (e, t, n) {
              (e.ior.value = t.ior),
                t.sheen > 0 &&
                  (e.sheenColor.value
                    .copy(t.sheenColor)
                    .multiplyScalar(t.sheen),
                  (e.sheenRoughness.value = t.sheenRoughness),
                  t.sheenColorMap &&
                    ((e.sheenColorMap.value = t.sheenColorMap),
                    i(t.sheenColorMap, e.sheenColorMapTransform)),
                  t.sheenRoughnessMap &&
                    ((e.sheenRoughnessMap.value = t.sheenRoughnessMap),
                    i(t.sheenRoughnessMap, e.sheenRoughnessMapTransform)));
              t.clearcoat > 0 &&
                ((e.clearcoat.value = t.clearcoat),
                (e.clearcoatRoughness.value = t.clearcoatRoughness),
                t.clearcoatMap &&
                  ((e.clearcoatMap.value = t.clearcoatMap),
                  i(t.clearcoatMap, e.clearcoatMapTransform)),
                t.clearcoatRoughnessMap &&
                  ((e.clearcoatRoughnessMap.value = t.clearcoatRoughnessMap),
                  i(t.clearcoatRoughnessMap, e.clearcoatRoughnessMapTransform)),
                t.clearcoatNormalMap &&
                  ((e.clearcoatNormalMap.value = t.clearcoatNormalMap),
                  i(t.clearcoatNormalMap, e.clearcoatNormalMapTransform),
                  e.clearcoatNormalScale.value.copy(t.clearcoatNormalScale),
                  t.side === c && e.clearcoatNormalScale.value.negate()));
              t.iridescence > 0 &&
                ((e.iridescence.value = t.iridescence),
                (e.iridescenceIOR.value = t.iridescenceIOR),
                (e.iridescenceThicknessMinimum.value =
                  t.iridescenceThicknessRange[0]),
                (e.iridescenceThicknessMaximum.value =
                  t.iridescenceThicknessRange[1]),
                t.iridescenceMap &&
                  ((e.iridescenceMap.value = t.iridescenceMap),
                  i(t.iridescenceMap, e.iridescenceMapTransform)),
                t.iridescenceThicknessMap &&
                  ((e.iridescenceThicknessMap.value =
                    t.iridescenceThicknessMap),
                  i(
                    t.iridescenceThicknessMap,
                    e.iridescenceThicknessMapTransform
                  )));
              t.transmission > 0 &&
                ((e.transmission.value = t.transmission),
                (e.transmissionSamplerMap.value = n.texture),
                e.transmissionSamplerSize.value.set(n.width, n.height),
                t.transmissionMap &&
                  ((e.transmissionMap.value = t.transmissionMap),
                  i(t.transmissionMap, e.transmissionMapTransform)),
                (e.thickness.value = t.thickness),
                t.thicknessMap &&
                  ((e.thicknessMap.value = t.thicknessMap),
                  i(t.thicknessMap, e.thicknessMapTransform)),
                (e.attenuationDistance.value = t.attenuationDistance),
                e.attenuationColor.value.copy(t.attenuationColor));
              t.anisotropy > 0 &&
                (e.anisotropyVector.value.set(
                  t.anisotropy * Math.cos(t.anisotropyRotation),
                  t.anisotropy * Math.sin(t.anisotropyRotation)
                ),
                t.anisotropyMap &&
                  ((e.anisotropyMap.value = t.anisotropyMap),
                  i(t.anisotropyMap, e.anisotropyMapTransform)));
              (e.specularIntensity.value = t.specularIntensity),
                e.specularColor.value.copy(t.specularColor),
                t.specularColorMap &&
                  ((e.specularColorMap.value = t.specularColorMap),
                  i(t.specularColorMap, e.specularColorMapTransform));
              t.specularIntensityMap &&
                ((e.specularIntensityMap.value = t.specularIntensityMap),
                i(t.specularIntensityMap, e.specularIntensityMapTransform));
            })(e, s, o))
        : s.isMeshMatcapMaterial
        ? (n(e, s),
          (function (e, t) {
            t.matcap && (e.matcap.value = t.matcap);
          })(e, s))
        : s.isMeshDepthMaterial
        ? n(e, s)
        : s.isMeshDistanceMaterial
        ? (n(e, s),
          (function (e, i) {
            const n = t.get(i).light;
            e.referencePosition.value.setFromMatrixPosition(n.matrixWorld),
              (e.nearDistance.value = n.shadow.camera.near),
              (e.farDistance.value = n.shadow.camera.far);
          })(e, s))
        : s.isMeshNormalMaterial
        ? n(e, s)
        : s.isLineBasicMaterial
        ? ((function (e, t) {
            e.diffuse.value.copy(t.color),
              (e.opacity.value = t.opacity),
              t.map && ((e.map.value = t.map), i(t.map, e.mapTransform));
          })(e, s),
          s.isLineDashedMaterial &&
            (function (e, t) {
              (e.dashSize.value = t.dashSize),
                (e.totalSize.value = t.dashSize + t.gapSize),
                (e.scale.value = t.scale);
            })(e, s))
        : s.isPointsMaterial
        ? (function (e, t, n, s) {
            e.diffuse.value.copy(t.color),
              (e.opacity.value = t.opacity),
              (e.size.value = t.size * n),
              (e.scale.value = 0.5 * s),
              t.map && ((e.map.value = t.map), i(t.map, e.uvTransform));
            t.alphaMap &&
              ((e.alphaMap.value = t.alphaMap),
              i(t.alphaMap, e.alphaMapTransform));
            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
          })(e, s, r, a)
        : s.isSpriteMaterial
        ? (function (e, t) {
            e.diffuse.value.copy(t.color),
              (e.opacity.value = t.opacity),
              (e.rotation.value = t.rotation),
              t.map && ((e.map.value = t.map), i(t.map, e.mapTransform));
            t.alphaMap &&
              ((e.alphaMap.value = t.alphaMap),
              i(t.alphaMap, e.alphaMapTransform));
            t.alphaTest > 0 && (e.alphaTest.value = t.alphaTest);
          })(e, s)
        : s.isShadowMaterial
        ? (e.color.value.copy(s.color), (e.opacity.value = s.opacity))
        : s.isShaderMaterial && (s.uniformsNeedUpdate = !1);
    },
  };
}
function Sa(e, t, i, n) {
  let s = {},
    r = {},
    a = [];
  const o = i.isWebGL2 ? e.getParameter(e.MAX_UNIFORM_BUFFER_BINDINGS) : 0;
  function l(e, t, i) {
    const n = e.value;
    if (void 0 === i[t]) {
      if ("number" == typeof n) i[t] = n;
      else {
        const e = Array.isArray(n) ? n : [n],
          s = [];
        for (let t = 0; t < e.length; t++) s.push(e[t].clone());
        i[t] = s;
      }
      return !0;
    }
    if ("number" == typeof n) {
      if (i[t] !== n) return (i[t] = n), !0;
    } else {
      const e = Array.isArray(i[t]) ? i[t] : [i[t]],
        s = Array.isArray(n) ? n : [n];
      for (let t = 0; t < e.length; t++) {
        const i = e[t];
        if (!1 === i.equals(s[t])) return i.copy(s[t]), !0;
      }
    }
    return !1;
  }
  function h(e) {
    const t = { boundary: 0, storage: 0 };
    return (
      "number" == typeof e
        ? ((t.boundary = 4), (t.storage = 4))
        : e.isVector2
        ? ((t.boundary = 8), (t.storage = 8))
        : e.isVector3 || e.isColor
        ? ((t.boundary = 16), (t.storage = 12))
        : e.isVector4
        ? ((t.boundary = 16), (t.storage = 16))
        : e.isMatrix3
        ? ((t.boundary = 48), (t.storage = 48))
        : e.isMatrix4
        ? ((t.boundary = 64), (t.storage = 64))
        : e.isTexture
        ? console.warn(
            "THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group."
          )
        : console.warn(
            "THREE.WebGLRenderer: Unsupported uniform value type.",
            e
          ),
      t
    );
  }
  function c(t) {
    const i = t.target;
    i.removeEventListener("dispose", c);
    const n = a.indexOf(i.__bindingPointIndex);
    a.splice(n, 1), e.deleteBuffer(s[i.id]), delete s[i.id], delete r[i.id];
  }
  return {
    bind: function (e, t) {
      const i = t.program;
      n.uniformBlockBinding(e, i);
    },
    update: function (i, u) {
      let d = s[i.id];
      void 0 === d &&
        (!(function (e) {
          const t = e.uniforms;
          let i = 0;
          const n = 16;
          let s = 0;
          for (let r = 0, a = t.length; r < a; r++) {
            const e = t[r],
              a = { boundary: 0, storage: 0 },
              o = Array.isArray(e.value) ? e.value : [e.value];
            for (let t = 0, i = o.length; t < i; t++) {
              const e = h(o[t]);
              (a.boundary += e.boundary), (a.storage += e.storage);
            }
            if (
              ((e.__data = new Float32Array(
                a.storage / Float32Array.BYTES_PER_ELEMENT
              )),
              (e.__offset = i),
              r > 0)
            ) {
              s = i % n;
              0 !== s &&
                n - s - a.boundary < 0 &&
                ((i += n - s), (e.__offset = i));
            }
            i += a.storage;
          }
          (s = i % n), s > 0 && (i += n - s);
          (e.__size = i), (e.__cache = {});
        })(i),
        (d = (function (t) {
          const i = (function () {
            for (let e = 0; e < o; e++)
              if (-1 === a.indexOf(e)) return a.push(e), e;
            return (
              console.error(
                "THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."
              ),
              0
            );
          })();
          t.__bindingPointIndex = i;
          const n = e.createBuffer(),
            s = t.__size,
            r = t.usage;
          return (
            e.bindBuffer(e.UNIFORM_BUFFER, n),
            e.bufferData(e.UNIFORM_BUFFER, s, r),
            e.bindBuffer(e.UNIFORM_BUFFER, null),
            e.bindBufferBase(e.UNIFORM_BUFFER, i, n),
            n
          );
        })(i)),
        (s[i.id] = d),
        i.addEventListener("dispose", c));
      const p = u.program;
      n.updateUBOMapping(i, p);
      const f = t.render.frame;
      r[i.id] !== f &&
        (!(function (t) {
          const i = s[t.id],
            n = t.uniforms,
            r = t.__cache;
          e.bindBuffer(e.UNIFORM_BUFFER, i);
          for (let s = 0, a = n.length; s < a; s++) {
            const t = n[s];
            if (!0 === l(t, s, r)) {
              const i = t.__offset,
                n = Array.isArray(t.value) ? t.value : [t.value];
              let s = 0;
              for (let r = 0; r < n.length; r++) {
                const a = n[r],
                  o = h(a);
                "number" == typeof a
                  ? ((t.__data[0] = a),
                    e.bufferSubData(e.UNIFORM_BUFFER, i + s, t.__data))
                  : a.isMatrix3
                  ? ((t.__data[0] = a.elements[0]),
                    (t.__data[1] = a.elements[1]),
                    (t.__data[2] = a.elements[2]),
                    (t.__data[3] = a.elements[0]),
                    (t.__data[4] = a.elements[3]),
                    (t.__data[5] = a.elements[4]),
                    (t.__data[6] = a.elements[5]),
                    (t.__data[7] = a.elements[0]),
                    (t.__data[8] = a.elements[6]),
                    (t.__data[9] = a.elements[7]),
                    (t.__data[10] = a.elements[8]),
                    (t.__data[11] = a.elements[0]))
                  : (a.toArray(t.__data, s),
                    (s += o.storage / Float32Array.BYTES_PER_ELEMENT));
              }
              e.bufferSubData(e.UNIFORM_BUFFER, i, t.__data);
            }
          }
          e.bindBuffer(e.UNIFORM_BUFFER, null);
        })(i),
        (r[i.id] = f));
    },
    dispose: function () {
      for (const t in s) e.deleteBuffer(s[t]);
      (a = []), (s = {}), (r = {});
    },
  };
}
class WebGLRenderer {
  constructor(e = {}) {
    const {
      canvas: t = createCanvasEl(),
      context: i = null,
      depth: n = !0,
      stencil: s = !0,
      alpha: a = !1,
      antialias: o = !1,
      premultipliedAlpha: l = !0,
      preserveDrawingBuffer: u = !1,
      powerPreference: d = "default",
      failIfMajorPerformanceCaveat: p = !1,
    } = e;
    let f;
    (this.isWebGLRenderer = !0),
      (f = null !== i ? i.getContextAttributes().alpha : a);
    const m = new Uint32Array(4),
      g = new Int32Array(4);
    let v = null,
      A = null;
    const y = [],
      x = [];
    (this.domElement = t),
      (this.debug = { checkShaderErrors: !0, onShaderError: null }),
      (this.autoClear = !0),
      (this.autoClearColor = !0),
      (this.autoClearDepth = !0),
      (this.autoClearStencil = !0),
      (this.sortObjects = !0),
      (this.clippingPlanes = []),
      (this.localClippingEnabled = !1),
      (this.outputColorSpace = me),
      (this._useLegacyLights = !1),
      (this.toneMapping = _),
      (this.toneMappingExposure = 1);
    const b = this;
    let E = !1,
      S = 0,
      C = 0,
      M = null,
      w = -1,
      T = null;
    const I = new Vector4(),
      R = new Vector4();
    let P = null;
    const D = new Color(0);
    let L = 0,
      F = t.width,
      O = t.height,
      H = 1,
      j = null,
      W = null;
    const q = new Vector4(0, 0, F, O),
      X = new Vector4(0, 0, F, O);
    let Y = !1;
    const K = new Frustum();
    let Z = !1,
      J = !1,
      $ = null;
    const ee = new Matrix4(),
      te = new Vector2(),
      ie = new Vector3(),
      ne = {
        background: null,
        fog: null,
        environment: null,
        overrideMaterial: null,
        isScene: !0,
      };
    function se() {
      return null === M ? H : 1;
    }
    let re,
      ae,
      oe,
      le,
      he,
      ce,
      ue,
      de,
      pe,
      fe,
      _e,
      ve,
      Ae,
      ye,
      xe,
      be,
      Ee,
      Se,
      Ce,
      Me,
      we,
      Te,
      Ie,
      Re,
      Pe = i;
    function De(e, i) {
      for (let n = 0; n < e.length; n++) {
        const s = e[n],
          r = t.getContext(s, i);
        if (null !== r) return r;
      }
      return null;
    }
    try {
      const e = {
        alpha: !0,
        depth: n,
        stencil: s,
        antialias: o,
        premultipliedAlpha: l,
        preserveDrawingBuffer: u,
        powerPreference: d,
        failIfMajorPerformanceCaveat: p,
      };
      if (
        ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${r}`),
        t.addEventListener("webglcontextlost", Ne, !1),
        t.addEventListener("webglcontextrestored", Be, !1),
        t.addEventListener("webglcontextcreationerror", Oe, !1),
        null === Pe)
      ) {
        const t = ["webgl2", "webgl", "experimental-webgl"];
        if (
          (!0 === b.isWebGL1Renderer && t.shift(), (Pe = De(t, e)), null === Pe)
        )
          throw De(t)
            ? new Error(
                "Error creating WebGL context with your selected attributes."
              )
            : new Error("Error creating WebGL context.");
      }
      "undefined" != typeof WebGLRenderingContext &&
        Pe instanceof WebGLRenderingContext &&
        console.warn(
          "THREE.WebGLRenderer: WebGL 1 support was deprecated in r153 and will be removed in r163."
        ),
        void 0 === Pe.getShaderPrecisionFormat &&
          (Pe.getShaderPrecisionFormat = function () {
            return { rangeMin: 1, rangeMax: 1, precision: 1 };
          });
    } catch (Je) {
      throw (console.error("THREE.WebGLRenderer: " + Je.message), Je);
    }
    function Le() {
      (re = new xs(Pe)),
        (ae = new es(Pe, re, e)),
        re.init(ae),
        (Te = new ga(Pe, re, ae)),
        (oe = new fa(Pe, re, ae)),
        (le = new Ss(Pe)),
        (he = new ea()),
        (ce = new ma(Pe, re, oe, he, ae, Te, le)),
        (ue = new is(b)),
        (de = new ys(b)),
        (pe = new jn(Pe, ae)),
        (Ie = new Jn(Pe, re, pe, ae)),
        (fe = new bs(Pe, pe, le, Ie)),
        (_e = new Ts(Pe, fe, pe, le)),
        (Ce = new ws(Pe, ae, ce)),
        (be = new ts(he)),
        (ve = new $r(b, ue, de, re, ae, Ie, be)),
        (Ae = new Ea(b, he)),
        (ye = new sa()),
        (xe = new ca(re, ae)),
        (Se = new Zn(b, ue, de, oe, _e, f, l)),
        (Ee = new pa(b, _e, ae)),
        (Re = new Sa(Pe, le, ae, oe)),
        (Me = new $n(Pe, re, le, ae)),
        (we = new Es(Pe, re, le, ae)),
        (le.programs = ve.programs),
        (b.capabilities = ae),
        (b.extensions = re),
        (b.properties = he),
        (b.renderLists = ye),
        (b.shadowMap = Ee),
        (b.state = oe),
        (b.info = le);
    }
    Le();
    const Fe = new ba(b, Pe);
    function Ne(e) {
      e.preventDefault(),
        console.log("THREE.WebGLRenderer: Context Lost."),
        (E = !0);
    }
    function Be() {
      console.log("THREE.WebGLRenderer: Context Restored."), (E = !1);
      const e = le.autoReset,
        t = Ee.enabled,
        i = Ee.autoUpdate,
        n = Ee.needsUpdate,
        s = Ee.type;
      Le(),
        (le.autoReset = e),
        (Ee.enabled = t),
        (Ee.autoUpdate = i),
        (Ee.needsUpdate = n),
        (Ee.type = s);
    }
    function Oe(e) {
      console.error(
        "THREE.WebGLRenderer: A WebGL context could not be created. Reason: ",
        e.statusMessage
      );
    }
    function Ue(e) {
      const t = e.target;
      t.removeEventListener("dispose", Ue),
        (function (e) {
          (function (e) {
            const t = he.get(e).programs;
            void 0 !== t &&
              (t.forEach(function (e) {
                ve.releaseProgram(e);
              }),
              e.isShaderMaterial && ve.releaseShaderCache(e));
          })(e),
            he.remove(e);
        })(t);
    }
    (this.xr = Fe),
      (this.getContext = function () {
        return Pe;
      }),
      (this.getContextAttributes = function () {
        return Pe.getContextAttributes();
      }),
      (this.forceContextLoss = function () {
        const e = re.get("WEBGL_lose_context");
        e && e.loseContext();
      }),
      (this.forceContextRestore = function () {
        const e = re.get("WEBGL_lose_context");
        e && e.restoreContext();
      }),
      (this.getPixelRatio = function () {
        return H;
      }),
      (this.setPixelRatio = function (e) {
        void 0 !== e && ((H = e), this.setSize(F, O, !1));
      }),
      (this.getSize = function (e) {
        return e.set(F, O);
      }),
      (this.setSize = function (e, i, n = !0) {
        Fe.isPresenting
          ? console.warn(
              "THREE.WebGLRenderer: Can't change size while VR device is presenting."
            )
          : ((F = e),
            (O = i),
            (t.width = Math.floor(e * H)),
            (t.height = Math.floor(i * H)),
            !0 === n &&
              ((t.style.width = e + "px"), (t.style.height = i + "px")),
            this.setViewport(0, 0, e, i));
      }),
      (this.getDrawingBufferSize = function (e) {
        return e.set(F * H, O * H).floor();
      }),
      (this.setDrawingBufferSize = function (e, i, n) {
        (F = e),
          (O = i),
          (H = n),
          (t.width = Math.floor(e * n)),
          (t.height = Math.floor(i * n)),
          this.setViewport(0, 0, e, i);
      }),
      (this.getCurrentViewport = function (e) {
        return e.copy(I);
      }),
      (this.getViewport = function (e) {
        return e.copy(q);
      }),
      (this.setViewport = function (e, t, i, n) {
        e.isVector4 ? q.set(e.x, e.y, e.z, e.w) : q.set(e, t, i, n),
          oe.viewport(I.copy(q).multiplyScalar(H).floor());
      }),
      (this.getScissor = function (e) {
        return e.copy(X);
      }),
      (this.setScissor = function (e, t, i, n) {
        e.isVector4 ? X.set(e.x, e.y, e.z, e.w) : X.set(e, t, i, n),
          oe.scissor(R.copy(X).multiplyScalar(H).floor());
      }),
      (this.getScissorTest = function () {
        return Y;
      }),
      (this.setScissorTest = function (e) {
        oe.setScissorTest((Y = e));
      }),
      (this.setOpaqueSort = function (e) {
        j = e;
      }),
      (this.setTransparentSort = function (e) {
        W = e;
      }),
      (this.getClearColor = function (e) {
        return e.copy(Se.getClearColor());
      }),
      (this.setClearColor = function () {
        Se.setClearColor.apply(Se, arguments);
      }),
      (this.getClearAlpha = function () {
        return Se.getClearAlpha();
      }),
      (this.setClearAlpha = function () {
        Se.setClearAlpha.apply(Se, arguments);
      }),
      (this.clear = function (e = !0, t = !0, i = !0) {
        let n = 0;
        if (e) {
          let e = !1;
          if (null !== M) {
            const t = M.texture.format;
            e = 1033 === t || 1031 === t || 1029 === t;
          }
          if (e) {
            const e = M.texture.type,
              t =
                e === B ||
                e === U ||
                e === k ||
                e === V ||
                1017 === e ||
                1018 === e,
              i = Se.getClearColor(),
              n = Se.getClearAlpha(),
              s = i.r,
              r = i.g,
              a = i.b;
            t
              ? ((m[0] = s),
                (m[1] = r),
                (m[2] = a),
                (m[3] = n),
                Pe.clearBufferuiv(Pe.COLOR, 0, m))
              : ((g[0] = s),
                (g[1] = r),
                (g[2] = a),
                (g[3] = n),
                Pe.clearBufferiv(Pe.COLOR, 0, g));
          } else n |= Pe.COLOR_BUFFER_BIT;
        }
        t && (n |= Pe.DEPTH_BUFFER_BIT),
          i && (n |= Pe.STENCIL_BUFFER_BIT),
          Pe.clear(n);
      }),
      (this.clearColor = function () {
        this.clear(!0, !1, !1);
      }),
      (this.clearDepth = function () {
        this.clear(!1, !0, !1);
      }),
      (this.clearStencil = function () {
        this.clear(!1, !1, !0);
      }),
      (this.dispose = function () {
        t.removeEventListener("webglcontextlost", Ne, !1),
          t.removeEventListener("webglcontextrestored", Be, !1),
          t.removeEventListener("webglcontextcreationerror", Oe, !1),
          ye.dispose(),
          xe.dispose(),
          he.dispose(),
          ue.dispose(),
          de.dispose(),
          _e.dispose(),
          Ie.dispose(),
          Re.dispose(),
          ve.dispose(),
          Fe.dispose(),
          Fe.removeEventListener("sessionstart", Ve),
          Fe.removeEventListener("sessionend", Qe),
          $ && ($.dispose(), ($ = null)),
          He.stop();
      }),
      (this.renderBufferDirect = function (e, t, i, n, s, r) {
        null === t && (t = ne);
        const a = s.isMesh && s.matrixWorld.determinant() < 0,
          o = (function (e, t, i, n, s) {
            !0 !== t.isScene && (t = ne);
            ce.resetTextureUnits();
            const r = t.fog,
              a = n.isMeshStandardMaterial ? t.environment : null,
              o =
                null === M
                  ? b.outputColorSpace
                  : !0 === M.isXRRenderTarget
                  ? M.texture.colorSpace
                  : ge,
              l = (n.isMeshStandardMaterial ? de : ue).get(n.envMap || a),
              h =
                !0 === n.vertexColors &&
                !!i.attributes.color &&
                4 === i.attributes.color.itemSize,
              c = !!i.attributes.tangent && (!!n.normalMap || n.anisotropy > 0),
              u = !!i.morphAttributes.position,
              d = !!i.morphAttributes.normal,
              p = !!i.morphAttributes.color;
            let f = _;
            n.toneMapped &&
              ((null !== M && !0 !== M.isXRRenderTarget) ||
                (f = b.toneMapping));
            const m =
                i.morphAttributes.position ||
                i.morphAttributes.normal ||
                i.morphAttributes.color,
              g = void 0 !== m ? m.length : 0,
              v = he.get(n),
              y = A.state.lights,
              x = b.extraProgramCacheKey;
            if (!0 === Z && (!0 === J || e !== T)) {
              const t = e === T && n.id === w;
              be.setState(n, e, t);
            }
            let E = !1;
            n.version === v.__version
              ? (v.needsLights && v.lightsStateVersion !== y.state.version) ||
                v.outputColorSpace !== o ||
                (s.isInstancedMesh && !1 === v.instancing)
                ? (E = !0)
                : s.isInstancedMesh || !0 !== v.instancing
                ? s.isSkinnedMesh && !1 === v.skinning
                  ? (E = !0)
                  : s.isSkinnedMesh || !0 !== v.skinning
                  ? (s.isInstancedMesh &&
                      !0 === v.instancingColor &&
                      null === s.instanceColor) ||
                    (s.isInstancedMesh &&
                      !1 === v.instancingColor &&
                      null !== s.instanceColor) ||
                    v.envMap !== l ||
                    (!0 === n.fog && v.fog !== r)
                    ? (E = !0)
                    : void 0 === v.numClippingPlanes ||
                      (v.numClippingPlanes === be.numPlanes &&
                        v.numIntersection === be.numIntersection)
                    ? (v.vertexAlphas !== h ||
                        v.vertexTangents !== c ||
                        v.morphTargets !== u ||
                        v.morphNormals !== d ||
                        v.morphColors !== p ||
                        v.toneMapping !== f ||
                        (!0 === ae.isWebGL2 && v.morphTargetsCount !== g) ||
                        x !== v.extraProgramCacheKey) &&
                      (E = !0)
                    : (E = !0)
                  : (E = !0)
                : (E = !0)
              : ((E = !0), (v.__version = n.version));
            let S = v.currentProgram;
            !0 === E && (S = Ke(n, t, s));
            let C = !1,
              I = !1,
              R = !1;
            const P = S.getUniforms(),
              D = v.uniforms;
            oe.useProgram(S.program) && ((C = !0), (I = !0), (R = !0));
            n.id !== w && ((w = n.id), (I = !0));
            if (C || T !== e) {
              P.setValue(Pe, "projectionMatrix", e.projectionMatrix),
                P.setValue(Pe, "viewMatrix", e.matrixWorldInverse);
              const t = P.map.cameraPosition;
              void 0 !== t &&
                t.setValue(Pe, ie.setFromMatrixPosition(e.matrixWorld)),
                ae.logarithmicDepthBuffer &&
                  P.setValue(
                    Pe,
                    "logDepthBufFC",
                    2 / (Math.log(e.far + 1) / Math.LN2)
                  ),
                (n.isMeshPhongMaterial ||
                  n.isMeshToonMaterial ||
                  n.isMeshLambertMaterial ||
                  n.isMeshBasicMaterial ||
                  n.isMeshStandardMaterial ||
                  n.isShaderMaterial) &&
                  P.setValue(
                    Pe,
                    "isOrthographic",
                    !0 === e.isOrthographicCamera
                  ),
                T !== e && ((T = e), (I = !0), (R = !0));
            }
            if (s.isSkinnedMesh) {
              P.setOptional(Pe, s, "bindMatrix"),
                P.setOptional(Pe, s, "bindMatrixInverse");
              const e = s.skeleton;
              e &&
                (ae.floatVertexTextures
                  ? (null === e.boneTexture && e.computeBoneTexture(),
                    P.setValue(Pe, "boneTexture", e.boneTexture, ce),
                    P.setValue(Pe, "boneTextureSize", e.boneTextureSize))
                  : console.warn(
                      "THREE.WebGLRenderer: SkinnedMesh can only be used with WebGL 2. With WebGL 1 OES_texture_float and vertex textures support is required."
                    ));
            }
            const L = i.morphAttributes;
            (void 0 !== L.position ||
              void 0 !== L.normal ||
              (void 0 !== L.color && !0 === ae.isWebGL2)) &&
              Ce.update(s, i, S);
            (I || v.receiveShadow !== s.receiveShadow) &&
              ((v.receiveShadow = s.receiveShadow),
              P.setValue(Pe, "receiveShadow", s.receiveShadow));
            n.isMeshGouraudMaterial &&
              null !== n.envMap &&
              ((D.envMap.value = l),
              (D.flipEnvMap.value =
                l.isCubeTexture && !1 === l.isRenderTargetTexture ? -1 : 1));
            I &&
              (P.setValue(Pe, "toneMappingExposure", b.toneMappingExposure),
              v.needsLights &&
                ((N = R),
                ((F = D).ambientLightColor.needsUpdate = N),
                (F.lightProbe.needsUpdate = N),
                (F.directionalLights.needsUpdate = N),
                (F.directionalLightShadows.needsUpdate = N),
                (F.pointLights.needsUpdate = N),
                (F.pointLightShadows.needsUpdate = N),
                (F.spotLights.needsUpdate = N),
                (F.spotLightShadows.needsUpdate = N),
                (F.rectAreaLights.needsUpdate = N),
                (F.hemisphereLights.needsUpdate = N)),
              r && !0 === n.fog && Ae.refreshFogUniforms(D, r),
              Ae.refreshMaterialUniforms(D, n, H, O, $),
              Dr.upload(Pe, v.uniformsList, D, ce));
            var F, N;
            n.isShaderMaterial &&
              !0 === n.uniformsNeedUpdate &&
              (Dr.upload(Pe, v.uniformsList, D, ce),
              (n.uniformsNeedUpdate = !1));
            n.isSpriteMaterial && P.setValue(Pe, "center", s.center);
            if (
              (P.setValue(Pe, "modelViewMatrix", s.modelViewMatrix),
              P.setValue(Pe, "normalMatrix", s.normalMatrix),
              P.setValue(Pe, "modelMatrix", s.matrixWorld),
              n.isShaderMaterial || n.isRawShaderMaterial)
            ) {
              const e = n.uniformsGroups;
              for (let t = 0, i = e.length; t < i; t++)
                if (ae.isWebGL2) {
                  const i = e[t];
                  Re.update(i, S), Re.bind(i, S);
                } else
                  console.warn(
                    "THREE.WebGLRenderer: Uniform Buffer Objects can only be used with WebGL 2."
                  );
            }
            return S;
          })(e, t, i, n, s);
        oe.setMaterial(n, a);
        let l = i.index,
          h = 1;
        if (!0 === n.wireframe) {
          if (((l = fe.getWireframeAttribute(i)), void 0 === l)) return;
          h = 2;
        }
        const c = i.drawRange,
          u = i.attributes.position;
        let d = c.start * h,
          p = (c.start + c.count) * h;
        null !== r &&
          ((d = Math.max(d, r.start * h)),
          (p = Math.min(p, (r.start + r.count) * h))),
          null !== l
            ? ((d = Math.max(d, 0)), (p = Math.min(p, l.count)))
            : null != u && ((d = Math.max(d, 0)), (p = Math.min(p, u.count)));
        const f = p - d;
        if (f < 0 || f === 1 / 0) return;
        let m;
        Ie.setup(s, n, o, i, l);
        let g = Me;
        if (
          (null !== l && ((m = pe.get(l)), (g = we), g.setIndex(m)), s.isMesh)
        )
          !0 === n.wireframe
            ? (oe.setLineWidth(n.wireframeLinewidth * se()),
              g.setMode(Pe.LINES))
            : g.setMode(Pe.TRIANGLES);
        else if (s.isLine) {
          let e = n.linewidth;
          void 0 === e && (e = 1),
            oe.setLineWidth(e * se()),
            s.isLineSegments
              ? g.setMode(Pe.LINES)
              : s.isLineLoop
              ? g.setMode(Pe.LINE_LOOP)
              : g.setMode(Pe.LINE_STRIP);
        } else
          s.isPoints
            ? g.setMode(Pe.POINTS)
            : s.isSprite && g.setMode(Pe.TRIANGLES);
        if (s.isInstancedMesh) g.renderInstances(d, f, s.count);
        else if (i.isInstancedBufferGeometry) {
          const e =
              void 0 !== i._maxInstanceCount ? i._maxInstanceCount : 1 / 0,
            t = Math.min(i.instanceCount, e);
          g.renderInstances(d, f, t);
        } else g.render(d, f);
      }),
      (this.compile = function (e, t) {
        function i(e, t, i) {
          !0 === e.transparent && 2 === e.side && !1 === e.forceSinglePass
            ? ((e.side = c),
              (e.needsUpdate = !0),
              Ke(e, t, i),
              (e.side = h),
              (e.needsUpdate = !0),
              Ke(e, t, i),
              (e.side = 2))
            : Ke(e, t, i);
        }
        (A = xe.get(e)),
          A.init(),
          x.push(A),
          e.traverseVisible(function (e) {
            e.isLight &&
              e.layers.test(t.layers) &&
              (A.pushLight(e), e.castShadow && A.pushShadow(e));
          }),
          A.setupLights(b._useLegacyLights),
          e.traverse(function (t) {
            const n = t.material;
            if (n)
              if (Array.isArray(n))
                for (let s = 0; s < n.length; s++) {
                  i(n[s], e, t);
                }
              else i(n, e, t);
          }),
          x.pop(),
          (A = null);
      });
    let ze = null;
    function Ve() {
      He.stop();
    }
    function Qe() {
      He.start();
    }
    const He = new Hn();
    function je(e, t, i, n) {
      if (!1 === e.visible) return;
      if (e.layers.test(t.layers))
        if (e.isGroup) i = e.renderOrder;
        else if (e.isLOD) !0 === e.autoUpdate && e.update(t);
        else if (e.isLight) A.pushLight(e), e.castShadow && A.pushShadow(e);
        else if (e.isSprite) {
          if (!e.frustumCulled || K.intersectsSprite(e)) {
            n && ie.setFromMatrixPosition(e.matrixWorld).applyMatrix4(ee);
            const t = _e.update(e),
              s = e.material;
            s.visible && v.push(e, t, s, i, ie.z, null);
          }
        } else if (
          (e.isMesh || e.isLine || e.isPoints) &&
          (!e.frustumCulled || K.intersectsObject(e))
        ) {
          const t = _e.update(e),
            s = e.material;
          if (
            (n &&
              (void 0 !== e.boundingSphere
                ? (null === e.boundingSphere && e.computeBoundingSphere(),
                  ie.copy(e.boundingSphere.center))
                : (null === t.boundingSphere && t.computeBoundingSphere(),
                  ie.copy(t.boundingSphere.center)),
              ie.applyMatrix4(e.matrixWorld).applyMatrix4(ee)),
            Array.isArray(s))
          ) {
            const n = t.groups;
            for (let r = 0, a = n.length; r < a; r++) {
              const a = n[r],
                o = s[a.materialIndex];
              o && o.visible && v.push(e, t, o, i, ie.z, a);
            }
          } else s.visible && v.push(e, t, s, i, ie.z, null);
        }
      const s = e.children;
      for (let r = 0, a = s.length; r < a; r++) je(s[r], t, i, n);
    }
    function qe(e, t, i, n) {
      const s = e.opaque,
        r = e.transmissive,
        a = e.transparent;
      A.setupLightsView(i),
        !0 === Z && be.setGlobalState(b.clippingPlanes, i),
        r.length > 0 &&
          (function (e, t, i, n) {
            const s = ae.isWebGL2;
            null === $ &&
              ($ = new ut(1, 1, {
                generateMipmaps: !0,
                type: re.has("EXT_color_buffer_half_float") ? G : B,
                minFilter: N,
                samples: s ? 4 : 0,
              }));
            b.getDrawingBufferSize(te),
              s ? $.setSize(te.x, te.y) : $.setSize(ke(te.x), ke(te.y));
            const r = b.getRenderTarget();
            b.setRenderTarget($),
              b.getClearColor(D),
              (L = b.getClearAlpha()),
              L < 1 && b.setClearColor(16777215, 0.5);
            b.clear();
            const a = b.toneMapping;
            (b.toneMapping = _),
              Xe(e, i, n),
              ce.updateMultisampleRenderTarget($),
              ce.updateRenderTargetMipmap($);
            let o = !1;
            for (let l = 0, h = t.length; l < h; l++) {
              const e = t[l],
                s = e.object,
                r = e.geometry,
                a = e.material,
                h = e.group;
              if (2 === a.side && s.layers.test(n.layers)) {
                const e = a.side;
                (a.side = c),
                  (a.needsUpdate = !0),
                  Ye(s, i, n, r, a, h),
                  (a.side = e),
                  (a.needsUpdate = !0),
                  (o = !0);
              }
            }
            !0 === o &&
              (ce.updateMultisampleRenderTarget($),
              ce.updateRenderTargetMipmap($));
            b.setRenderTarget(r), b.setClearColor(D, L), (b.toneMapping = a);
          })(s, r, t, i),
        n && oe.viewport(I.copy(n)),
        s.length > 0 && Xe(s, t, i),
        r.length > 0 && Xe(r, t, i),
        a.length > 0 && Xe(a, t, i),
        oe.buffers.depth.setTest(!0),
        oe.buffers.depth.setMask(!0),
        oe.buffers.color.setMask(!0),
        oe.setPolygonOffset(!1);
    }
    function Xe(e, t, i) {
      const n = !0 === t.isScene ? t.overrideMaterial : null;
      for (let s = 0, r = e.length; s < r; s++) {
        const r = e[s],
          a = r.object,
          o = r.geometry,
          l = null === n ? r.material : n,
          h = r.group;
        a.layers.test(i.layers) && Ye(a, t, i, o, l, h);
      }
    }
    function Ye(e, t, i, n, s, r) {
      e.onBeforeRender(b, t, i, n, s, r);
      e.modelViewMatrix.multiplyMatrices(i.matrixWorldInverse, e.matrixWorld);
      e.normalMatrix.getNormalMatrix(e.modelViewMatrix);
      s.onBeforeRender(b, t, i, n, e, r);
      !0 === s.transparent && 2 === s.side && !1 === s.forceSinglePass
        ? ((s.side = c),
          (s.needsUpdate = !0),
          b.renderBufferDirect(i, t, n, s, e, r),
          (s.side = h),
          (s.needsUpdate = !0),
          b.renderBufferDirect(i, t, n, s, e, r),
          (s.side = 2))
        : b.renderBufferDirect(i, t, n, s, e, r),
        e.onAfterRender(b, t, i, n, s, r);
    }
    function Ke(e, t, i) {
      !0 !== t.isScene && (t = ne);
      const n = he.get(e),
        s = A.state.lights,
        r = A.state.shadowsArray,
        a = s.state.version,
        o = ve.getParameters(e, s.state, r, t, i),
        l = ve.getProgramCacheKey(o);
      let h = n.programs;
      (n.environment = e.isMeshStandardMaterial ? t.environment : null),
        (n.fog = t.fog),
        (n.envMap = (e.isMeshStandardMaterial ? de : ue).get(
          e.envMap || n.environment
        )),
        void 0 === h &&
          (e.addEventListener("dispose", Ue),
          (h = new Map()),
          (n.programs = h));
      let c = h.get(l);
      if (void 0 !== c) {
        if (n.currentProgram === c && n.lightsStateVersion === a)
          return Ze(e, o), c;
      } else
        (o.uniforms = ve.getUniforms(e)),
          e.onBuild(i, o, b),
          e.onBeforeCompile(o, b),
          (c = ve.acquireProgram(o, l)),
          h.set(l, c),
          (n.uniforms = o.uniforms);
      const u = n.uniforms;
      ((e.isShaderMaterial || e.isRawShaderMaterial) && !0 !== e.clipping) ||
        (u.clippingPlanes = be.uniform),
        Ze(e, o),
        (n.needsLights = (function (e) {
          return (
            e.isMeshLambertMaterial ||
            e.isMeshToonMaterial ||
            e.isMeshPhongMaterial ||
            e.isMeshStandardMaterial ||
            e.isShadowMaterial ||
            (e.isShaderMaterial && !0 === e.lights)
          );
        })(e)),
        (n.lightsStateVersion = a),
        n.needsLights &&
          ((u.ambientLightColor.value = s.state.ambient),
          (u.lightProbe.value = s.state.probe),
          (u.directionalLights.value = s.state.directional),
          (u.directionalLightShadows.value = s.state.directionalShadow),
          (u.spotLights.value = s.state.spot),
          (u.spotLightShadows.value = s.state.spotShadow),
          (u.rectAreaLights.value = s.state.rectArea),
          (u.ltc_1.value = s.state.rectAreaLTC1),
          (u.ltc_2.value = s.state.rectAreaLTC2),
          (u.pointLights.value = s.state.point),
          (u.pointLightShadows.value = s.state.pointShadow),
          (u.hemisphereLights.value = s.state.hemi),
          (u.directionalShadowMap.value = s.state.directionalShadowMap),
          (u.directionalShadowMatrix.value = s.state.directionalShadowMatrix),
          (u.spotShadowMap.value = s.state.spotShadowMap),
          (u.spotLightMatrix.value = s.state.spotLightMatrix),
          (u.spotLightMap.value = s.state.spotLightMap),
          (u.pointShadowMap.value = s.state.pointShadowMap),
          (u.pointShadowMatrix.value = s.state.pointShadowMatrix));
      const d = c.getUniforms(),
        p = Dr.seqWithValue(d.seq, u);
      return (n.currentProgram = c), (n.uniformsList = p), c;
    }
    function Ze(e, t) {
      const i = he.get(e);
      (i.outputColorSpace = t.outputColorSpace),
        (i.instancing = t.instancing),
        (i.instancingColor = t.instancingColor),
        (i.skinning = t.skinning),
        (i.morphTargets = t.morphTargets),
        (i.morphNormals = t.morphNormals),
        (i.morphColors = t.morphColors),
        (i.morphTargetsCount = t.morphTargetsCount),
        (i.numClippingPlanes = t.numClippingPlanes),
        (i.numIntersection = t.numClipIntersection),
        (i.vertexAlphas = t.vertexAlphas),
        (i.vertexTangents = t.vertexTangents),
        (i.toneMapping = t.toneMapping),
        (i.extraProgramCacheKey = t.extraProgramCacheKey);
    }
    He.setAnimationLoop(function (e) {
      ze && ze(e);
    }),
      "undefined" != typeof self && He.setContext(self),
      (this.setAnimationLoop = function (e) {
        (ze = e), Fe.setAnimationLoop(e), null === e ? He.stop() : He.start();
      }),
      Fe.addEventListener("sessionstart", Ve),
      Fe.addEventListener("sessionend", Qe),
      (this.render = function (e, t) {
        if (void 0 !== t && !0 !== t.isCamera)
          return void console.error(
            "THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera."
          );
        if (!0 === E) return;
        !0 === e.matrixWorldAutoUpdate && e.updateMatrixWorld(),
          null === t.parent &&
            !0 === t.matrixWorldAutoUpdate &&
            t.updateMatrixWorld(),
          !0 === Fe.enabled &&
            !0 === Fe.isPresenting &&
            (!0 === Fe.cameraAutoUpdate && Fe.updateCamera(t),
            (t = Fe.getCamera())),
          !0 === e.isScene && e.onBeforeRender(b, e, t, M),
          (A = xe.get(e, x.length)),
          A.init(),
          x.push(A),
          ee.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
          K.setFromProjectionMatrix(ee),
          (J = this.localClippingEnabled),
          (Z = be.init(this.clippingPlanes, J)),
          (v = ye.get(e, y.length)),
          v.init(),
          y.push(v),
          je(e, t, 0, b.sortObjects),
          v.finish(),
          !0 === b.sortObjects && v.sort(j, W),
          this.info.render.frame++,
          !0 === Z && be.beginShadows();
        const i = A.state.shadowsArray;
        if (
          (Ee.render(i, e, t),
          !0 === Z && be.endShadows(),
          !0 === this.info.autoReset && this.info.reset(),
          Se.render(v, e),
          A.setupLights(b._useLegacyLights),
          t.isArrayCamera)
        ) {
          const i = t.cameras;
          for (let t = 0, n = i.length; t < n; t++) {
            const n = i[t];
            qe(v, e, n, n.viewport);
          }
        } else qe(v, e, t);
        null !== M &&
          (ce.updateMultisampleRenderTarget(M), ce.updateRenderTargetMipmap(M)),
          !0 === e.isScene && e.onAfterRender(b, e, t),
          Ie.resetDefaultState(),
          (w = -1),
          (T = null),
          x.pop(),
          (A = x.length > 0 ? x[x.length - 1] : null),
          y.pop(),
          (v = y.length > 0 ? y[y.length - 1] : null);
      }),
      (this.getActiveCubeFace = function () {
        return S;
      }),
      (this.getActiveMipmapLevel = function () {
        return C;
      }),
      (this.getRenderTarget = function () {
        return M;
      }),
      (this.setRenderTargetTextures = function (e, t, i) {
        (he.get(e.texture).__webglTexture = t),
          (he.get(e.depthTexture).__webglTexture = i);
        const n = he.get(e);
        (n.__hasExternalTextures = !0),
          n.__hasExternalTextures &&
            ((n.__autoAllocateDepthBuffer = void 0 === i),
            n.__autoAllocateDepthBuffer ||
              (!0 === re.has("WEBGL_multisampled_render_to_texture") &&
                (console.warn(
                  "THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"
                ),
                (n.__useRenderToTexture = !1))));
      }),
      (this.setRenderTargetFramebuffer = function (e, t) {
        const i = he.get(e);
        (i.__webglFramebuffer = t), (i.__useDefaultFramebuffer = void 0 === t);
      }),
      (this.setRenderTarget = function (e, t = 0, i = 0) {
        (M = e), (S = t), (C = i);
        let n = !0,
          s = null,
          r = !1,
          a = !1;
        if (e) {
          const o = he.get(e);
          void 0 !== o.__useDefaultFramebuffer
            ? (oe.bindFramebuffer(Pe.FRAMEBUFFER, null), (n = !1))
            : void 0 === o.__webglFramebuffer
            ? ce.setupRenderTarget(e)
            : o.__hasExternalTextures &&
              ce.rebindTextures(
                e,
                he.get(e.texture).__webglTexture,
                he.get(e.depthTexture).__webglTexture
              );
          const l = e.texture;
          (l.isData3DTexture ||
            l.isDataArrayTexture ||
            l.isCompressedArrayTexture) &&
            (a = !0);
          const h = he.get(e).__webglFramebuffer;
          e.isWebGLCubeRenderTarget
            ? ((s = Array.isArray(h[t]) ? h[t][i] : h[t]), (r = !0))
            : (s =
                ae.isWebGL2 && e.samples > 0 && !1 === ce.useMultisampledRTT(e)
                  ? he.get(e).__webglMultisampledFramebuffer
                  : Array.isArray(h)
                  ? h[i]
                  : h),
            I.copy(e.viewport),
            R.copy(e.scissor),
            (P = e.scissorTest);
        } else
          I.copy(q).multiplyScalar(H).floor(),
            R.copy(X).multiplyScalar(H).floor(),
            (P = Y);
        if (
          (oe.bindFramebuffer(Pe.FRAMEBUFFER, s) &&
            ae.drawBuffers &&
            n &&
            oe.drawBuffers(e, s),
          oe.viewport(I),
          oe.scissor(R),
          oe.setScissorTest(P),
          r)
        ) {
          const n = he.get(e.texture);
          Pe.framebufferTexture2D(
            Pe.FRAMEBUFFER,
            Pe.COLOR_ATTACHMENT0,
            Pe.TEXTURE_CUBE_MAP_POSITIVE_X + t,
            n.__webglTexture,
            i
          );
        } else if (a) {
          const n = he.get(e.texture),
            s = t || 0;
          Pe.framebufferTextureLayer(
            Pe.FRAMEBUFFER,
            Pe.COLOR_ATTACHMENT0,
            n.__webglTexture,
            i || 0,
            s
          );
        }
        w = -1;
      }),
      (this.readRenderTargetPixels = function (e, t, i, n, s, r, a) {
        if (!e || !e.isWebGLRenderTarget)
          return void console.error(
            "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget."
          );
        let o = he.get(e).__webglFramebuffer;
        if ((e.isWebGLCubeRenderTarget && void 0 !== a && (o = o[a]), o)) {
          oe.bindFramebuffer(Pe.FRAMEBUFFER, o);
          try {
            const a = e.texture,
              o = a.format,
              l = a.type;
            if (
              o !== Q &&
              Te.convert(o) !==
                Pe.getParameter(Pe.IMPLEMENTATION_COLOR_READ_FORMAT)
            )
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format."
              );
            const h =
              l === G &&
              (re.has("EXT_color_buffer_half_float") ||
                (ae.isWebGL2 && re.has("EXT_color_buffer_float")));
            if (
              !(
                l === B ||
                Te.convert(l) ===
                  Pe.getParameter(Pe.IMPLEMENTATION_COLOR_READ_TYPE) ||
                (l === z &&
                  (ae.isWebGL2 ||
                    re.has("OES_texture_float") ||
                    re.has("WEBGL_color_buffer_float"))) ||
                h
              )
            )
              return void console.error(
                "THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type."
              );
            t >= 0 &&
              t <= e.width - n &&
              i >= 0 &&
              i <= e.height - s &&
              Pe.readPixels(t, i, n, s, Te.convert(o), Te.convert(l), r);
          } finally {
            const e = null !== M ? he.get(M).__webglFramebuffer : null;
            oe.bindFramebuffer(Pe.FRAMEBUFFER, e);
          }
        }
      }),
      (this.copyFramebufferToTexture = function (e, t, i = 0) {
        const n = Math.pow(2, -i),
          s = Math.floor(t.image.width * n),
          r = Math.floor(t.image.height * n);
        ce.setTexture2D(t, 0),
          Pe.copyTexSubImage2D(Pe.TEXTURE_2D, i, 0, 0, e.x, e.y, s, r),
          oe.unbindTexture();
      }),
      (this.copyTextureToTexture = function (e, t, i, n = 0) {
        const s = t.image.width,
          r = t.image.height,
          a = Te.convert(i.format),
          o = Te.convert(i.type);
        ce.setTexture2D(i, 0),
          Pe.pixelStorei(Pe.UNPACK_FLIP_Y_WEBGL, i.flipY),
          Pe.pixelStorei(Pe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.premultiplyAlpha),
          Pe.pixelStorei(Pe.UNPACK_ALIGNMENT, i.unpackAlignment),
          t.isDataTexture
            ? Pe.texSubImage2D(
                Pe.TEXTURE_2D,
                n,
                e.x,
                e.y,
                s,
                r,
                a,
                o,
                t.image.data
              )
            : t.isCompressedTexture
            ? Pe.compressedTexSubImage2D(
                Pe.TEXTURE_2D,
                n,
                e.x,
                e.y,
                t.mipmaps[0].width,
                t.mipmaps[0].height,
                a,
                t.mipmaps[0].data
              )
            : Pe.texSubImage2D(Pe.TEXTURE_2D, n, e.x, e.y, a, o, t.image),
          0 === n && i.generateMipmaps && Pe.generateMipmap(Pe.TEXTURE_2D),
          oe.unbindTexture();
      }),
      (this.copyTextureToTexture3D = function (e, t, i, n, s = 0) {
        if (b.isWebGL1Renderer)
          return void console.warn(
            "THREE.WebGLRenderer.copyTextureToTexture3D: can only be used with WebGL2."
          );
        const r = e.max.x - e.min.x + 1,
          a = e.max.y - e.min.y + 1,
          o = e.max.z - e.min.z + 1,
          l = Te.convert(n.format),
          h = Te.convert(n.type);
        let c;
        if (n.isData3DTexture) ce.setTexture3D(n, 0), (c = Pe.TEXTURE_3D);
        else {
          if (!n.isDataArrayTexture)
            return void console.warn(
              "THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray."
            );
          ce.setTexture2DArray(n, 0), (c = Pe.TEXTURE_2D_ARRAY);
        }
        Pe.pixelStorei(Pe.UNPACK_FLIP_Y_WEBGL, n.flipY),
          Pe.pixelStorei(Pe.UNPACK_PREMULTIPLY_ALPHA_WEBGL, n.premultiplyAlpha),
          Pe.pixelStorei(Pe.UNPACK_ALIGNMENT, n.unpackAlignment);
        const u = Pe.getParameter(Pe.UNPACK_ROW_LENGTH),
          d = Pe.getParameter(Pe.UNPACK_IMAGE_HEIGHT),
          p = Pe.getParameter(Pe.UNPACK_SKIP_PIXELS),
          f = Pe.getParameter(Pe.UNPACK_SKIP_ROWS),
          m = Pe.getParameter(Pe.UNPACK_SKIP_IMAGES),
          g = i.isCompressedTexture ? i.mipmaps[0] : i.image;
        Pe.pixelStorei(Pe.UNPACK_ROW_LENGTH, g.width),
          Pe.pixelStorei(Pe.UNPACK_IMAGE_HEIGHT, g.height),
          Pe.pixelStorei(Pe.UNPACK_SKIP_PIXELS, e.min.x),
          Pe.pixelStorei(Pe.UNPACK_SKIP_ROWS, e.min.y),
          Pe.pixelStorei(Pe.UNPACK_SKIP_IMAGES, e.min.z),
          i.isDataTexture || i.isData3DTexture
            ? Pe.texSubImage3D(c, s, t.x, t.y, t.z, r, a, o, l, h, g.data)
            : i.isCompressedArrayTexture
            ? (console.warn(
                "THREE.WebGLRenderer.copyTextureToTexture3D: untested support for compressed srcTexture."
              ),
              Pe.compressedTexSubImage3D(
                c,
                s,
                t.x,
                t.y,
                t.z,
                r,
                a,
                o,
                l,
                g.data
              ))
            : Pe.texSubImage3D(c, s, t.x, t.y, t.z, r, a, o, l, h, g),
          Pe.pixelStorei(Pe.UNPACK_ROW_LENGTH, u),
          Pe.pixelStorei(Pe.UNPACK_IMAGE_HEIGHT, d),
          Pe.pixelStorei(Pe.UNPACK_SKIP_PIXELS, p),
          Pe.pixelStorei(Pe.UNPACK_SKIP_ROWS, f),
          Pe.pixelStorei(Pe.UNPACK_SKIP_IMAGES, m),
          0 === s && n.generateMipmaps && Pe.generateMipmap(c),
          oe.unbindTexture();
      }),
      (this.initTexture = function (e) {
        e.isCubeTexture
          ? ce.setTextureCube(e, 0)
          : e.isData3DTexture
          ? ce.setTexture3D(e, 0)
          : e.isDataArrayTexture || e.isCompressedArrayTexture
          ? ce.setTexture2DArray(e, 0)
          : ce.setTexture2D(e, 0),
          oe.unbindTexture();
      }),
      (this.resetState = function () {
        (S = 0), (C = 0), (M = null), oe.reset(), Ie.reset();
      }),
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  get coordinateSystem() {
    return Se;
  }
  get physicallyCorrectLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
      ),
      !this.useLegacyLights
    );
  }
  set physicallyCorrectLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .physicallyCorrectLights has been removed. Set renderer.useLegacyLights instead."
    ),
      (this.useLegacyLights = !e);
  }
  get outputEncoding() {
    return (
      console.warn(
        "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
      ),
      this.outputColorSpace === me ? pe : de
    );
  }
  set outputEncoding(e) {
    console.warn(
      "THREE.WebGLRenderer: Property .outputEncoding has been removed. Use .outputColorSpace instead."
    ),
      (this.outputColorSpace = e === pe ? me : ge);
  }
  get useLegacyLights() {
    return (
      console.warn(
        "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
      ),
      this._useLegacyLights
    );
  }
  set useLegacyLights(e) {
    console.warn(
      "THREE.WebGLRenderer: The property .useLegacyLights has been deprecated. Migrate your lighting according to the following guide: https://discourse.threejs.org/t/updates-to-lighting-in-three-js-r155/53733."
    ),
      (this._useLegacyLights = e);
  }
}
(class extends WebGLRenderer {}).prototype.isWebGL1Renderer = !0;
class Ma {
  constructor(e, t = 1, i = 1e3) {
    (this.isFog = !0),
      (this.name = ""),
      (this.color = new Color(e)),
      (this.near = t),
      (this.far = i);
  }
  clone() {
    return new Ma(this.color, this.near, this.far);
  }
  toJSON() {
    return {
      type: "Fog",
      color: this.color.getHex(),
      near: this.near,
      far: this.far,
    };
  }
}
class wa extends Object3D {
  constructor() {
    super(),
      (this.isScene = !0),
      (this.type = "Scene"),
      (this.background = null),
      (this.environment = null),
      (this.fog = null),
      (this.backgroundBlurriness = 0),
      (this.backgroundIntensity = 1),
      (this.overrideMaterial = null),
      "undefined" != typeof __THREE_DEVTOOLS__ &&
        __THREE_DEVTOOLS__.dispatchEvent(
          new CustomEvent("observe", { detail: this })
        );
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      null !== e.background && (this.background = e.background.clone()),
      null !== e.environment && (this.environment = e.environment.clone()),
      null !== e.fog && (this.fog = e.fog.clone()),
      (this.backgroundBlurriness = e.backgroundBlurriness),
      (this.backgroundIntensity = e.backgroundIntensity),
      null !== e.overrideMaterial &&
        (this.overrideMaterial = e.overrideMaterial.clone()),
      (this.matrixAutoUpdate = e.matrixAutoUpdate),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      null !== this.fog && (t.object.fog = this.fog.toJSON()),
      this.backgroundBlurriness > 0 &&
        (t.object.backgroundBlurriness = this.backgroundBlurriness),
      1 !== this.backgroundIntensity &&
        (t.object.backgroundIntensity = this.backgroundIntensity),
      t
    );
  }
}
class Ta {
  constructor(e, t) {
    (this.isInterleavedBuffer = !0),
      (this.array = e),
      (this.stride = t),
      (this.count = void 0 !== e ? e.length / t : 0),
      (this.usage = ye),
      (this.updateRange = { offset: 0, count: -1 }),
      (this.version = 0),
      (this.uuid = Pe());
  }
  onUploadCallback() {}
  set needsUpdate(e) {
    !0 === e && this.version++;
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  copy(e) {
    return (
      (this.array = new e.array.constructor(e.array)),
      (this.count = e.count),
      (this.stride = e.stride),
      (this.usage = e.usage),
      this
    );
  }
  copyAt(e, t, i) {
    (e *= this.stride), (i *= t.stride);
    for (let n = 0, s = this.stride; n < s; n++)
      this.array[e + n] = t.array[i + n];
    return this;
  }
  set(e, t = 0) {
    return this.array.set(e, t), this;
  }
  clone(e) {
    void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Pe()),
      void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
        (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
    const t = new this.array.constructor(
        e.arrayBuffers[this.array.buffer._uuid]
      ),
      i = new this.constructor(t, this.stride);
    return i.setUsage(this.usage), i;
  }
  onUpload(e) {
    return (this.onUploadCallback = e), this;
  }
  toJSON(e) {
    return (
      void 0 === e.arrayBuffers && (e.arrayBuffers = {}),
      void 0 === this.array.buffer._uuid && (this.array.buffer._uuid = Pe()),
      void 0 === e.arrayBuffers[this.array.buffer._uuid] &&
        (e.arrayBuffers[this.array.buffer._uuid] = Array.from(
          new Uint32Array(this.array.buffer)
        )),
      {
        uuid: this.uuid,
        buffer: this.array.buffer._uuid,
        type: this.array.constructor.name,
        stride: this.stride,
      }
    );
  }
}
const Ia = new Vector3();
class Ra {
  constructor(e, t, i, n = !1) {
    (this.isInterleavedBufferAttribute = !0),
      (this.name = ""),
      (this.data = e),
      (this.itemSize = t),
      (this.offset = i),
      (this.normalized = n);
  }
  get count() {
    return this.data.count;
  }
  get array() {
    return this.data.array;
  }
  set needsUpdate(e) {
    this.data.needsUpdate = e;
  }
  applyMatrix4(e) {
    for (let t = 0, i = this.data.count; t < i; t++)
      Ia.fromBufferAttribute(this, t),
        Ia.applyMatrix4(e),
        this.setXYZ(t, Ia.x, Ia.y, Ia.z);
    return this;
  }
  applyNormalMatrix(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ia.fromBufferAttribute(this, t),
        Ia.applyNormalMatrix(e),
        this.setXYZ(t, Ia.x, Ia.y, Ia.z);
    return this;
  }
  transformDirection(e) {
    for (let t = 0, i = this.count; t < i; t++)
      Ia.fromBufferAttribute(this, t),
        Ia.transformDirection(e),
        this.setXYZ(t, Ia.x, Ia.y, Ia.z);
    return this;
  }
  setX(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset] = t),
      this
    );
  }
  setY(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 1] = t),
      this
    );
  }
  setZ(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 2] = t),
      this
    );
  }
  setW(e, t) {
    return (
      this.normalized && (t = Ue(t, this.array)),
      (this.data.array[e * this.data.stride + this.offset + 3] = t),
      this
    );
  }
  getX(e) {
    let t = this.data.array[e * this.data.stride + this.offset];
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  getY(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 1];
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  getZ(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 2];
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  getW(e) {
    let t = this.data.array[e * this.data.stride + this.offset + 3];
    return this.normalized && (t = Oe(t, this.array)), t;
  }
  setXY(e, t, i) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized && ((t = Ue(t, this.array)), (i = Ue(i, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      this
    );
  }
  setXYZ(e, t, i, n) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Ue(t, this.array)),
        (i = Ue(i, this.array)),
        (n = Ue(n, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = n),
      this
    );
  }
  setXYZW(e, t, i, n, s) {
    return (
      (e = e * this.data.stride + this.offset),
      this.normalized &&
        ((t = Ue(t, this.array)),
        (i = Ue(i, this.array)),
        (n = Ue(n, this.array)),
        (s = Ue(s, this.array))),
      (this.data.array[e + 0] = t),
      (this.data.array[e + 1] = i),
      (this.data.array[e + 2] = n),
      (this.data.array[e + 3] = s),
      this
    );
  }
  clone(e) {
    if (void 0 === e) {
      console.log(
        "THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data."
      );
      const e = [];
      for (let t = 0; t < this.count; t++) {
        const i = t * this.data.stride + this.offset;
        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[i + t]);
      }
      return new Wi(
        new this.array.constructor(e),
        this.itemSize,
        this.normalized
      );
    }
    return (
      void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
      void 0 === e.interleavedBuffers[this.data.uuid] &&
        (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
      new Ra(
        e.interleavedBuffers[this.data.uuid],
        this.itemSize,
        this.offset,
        this.normalized
      )
    );
  }
  toJSON(e) {
    if (void 0 === e) {
      console.log(
        "THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data."
      );
      const e = [];
      for (let t = 0; t < this.count; t++) {
        const i = t * this.data.stride + this.offset;
        for (let t = 0; t < this.itemSize; t++) e.push(this.data.array[i + t]);
      }
      return {
        itemSize: this.itemSize,
        type: this.array.constructor.name,
        array: e,
        normalized: this.normalized,
      };
    }
    return (
      void 0 === e.interleavedBuffers && (e.interleavedBuffers = {}),
      void 0 === e.interleavedBuffers[this.data.uuid] &&
        (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
      {
        isInterleavedBufferAttribute: !0,
        itemSize: this.itemSize,
        data: this.data.uuid,
        offset: this.offset,
        normalized: this.normalized,
      }
    );
  }
}
const Pa = new Vector3(),
  Da = new Vector4(),
  La = new Vector4(),
  Fa = new Vector3(),
  Na = new Matrix4(),
  Ba = new Vector3(),
  ka = new kt(),
  Oa = new Matrix4(),
  Ua = new jt();
class za extends En {
  constructor(e, t) {
    super(e, t),
      (this.isSkinnedMesh = !0),
      (this.type = "SkinnedMesh"),
      (this.bindMode = "attached"),
      (this.bindMatrix = new Matrix4()),
      (this.bindMatrixInverse = new Matrix4()),
      (this.boundingBox = null),
      (this.boundingSphere = null);
  }
  computeBoundingBox() {
    const e = this.geometry;
    null === this.boundingBox && (this.boundingBox = new Box3()),
      this.boundingBox.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      Ba.fromBufferAttribute(t, i),
        this.applyBoneTransform(i, Ba),
        this.boundingBox.expandByPoint(Ba);
  }
  computeBoundingSphere() {
    const e = this.geometry;
    null === this.boundingSphere && (this.boundingSphere = new kt()),
      this.boundingSphere.makeEmpty();
    const t = e.getAttribute("position");
    for (let i = 0; i < t.count; i++)
      Ba.fromBufferAttribute(t, i),
        this.applyBoneTransform(i, Ba),
        this.boundingSphere.expandByPoint(Ba);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.bindMode = e.bindMode),
      this.bindMatrix.copy(e.bindMatrix),
      this.bindMatrixInverse.copy(e.bindMatrixInverse),
      (this.skeleton = e.skeleton),
      null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
      null !== e.boundingSphere &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  raycast(e, t) {
    const i = this.material,
      n = this.matrixWorld;
    void 0 !== i &&
      (null === this.boundingSphere && this.computeBoundingSphere(),
      ka.copy(this.boundingSphere),
      ka.applyMatrix4(n),
      !1 !== e.ray.intersectsSphere(ka) &&
        (Oa.copy(n).invert(),
        Ua.copy(e.ray).applyMatrix4(Oa),
        (null !== this.boundingBox &&
          !1 === Ua.intersectsBox(this.boundingBox)) ||
          this._computeIntersections(e, t, Ua)));
  }
  getVertexPosition(e, t) {
    return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t;
  }
  bind(e, t) {
    (this.skeleton = e),
      void 0 === t &&
        (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        (t = this.matrixWorld)),
      this.bindMatrix.copy(t),
      this.bindMatrixInverse.copy(t).invert();
  }
  pose() {
    this.skeleton.pose();
  }
  normalizeSkinWeights() {
    const e = new Vector4(),
      t = this.geometry.attributes.skinWeight;
    for (let i = 0, n = t.count; i < n; i++) {
      e.fromBufferAttribute(t, i);
      const n = 1 / e.manhattanLength();
      n !== 1 / 0 ? e.multiplyScalar(n) : e.set(1, 0, 0, 0),
        t.setXYZW(i, e.x, e.y, e.z, e.w);
    }
  }
  updateMatrixWorld(e) {
    super.updateMatrixWorld(e),
      "attached" === this.bindMode
        ? this.bindMatrixInverse.copy(this.matrixWorld).invert()
        : "detached" === this.bindMode
        ? this.bindMatrixInverse.copy(this.bindMatrix).invert()
        : console.warn(
            "THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode
          );
  }
  applyBoneTransform(e, t) {
    const i = this.skeleton,
      n = this.geometry;
    Da.fromBufferAttribute(n.attributes.skinIndex, e),
      La.fromBufferAttribute(n.attributes.skinWeight, e),
      Pa.copy(t).applyMatrix4(this.bindMatrix),
      t.set(0, 0, 0);
    for (let s = 0; s < 4; s++) {
      const e = La.getComponent(s);
      if (0 !== e) {
        const n = Da.getComponent(s);
        Na.multiplyMatrices(i.bones[n].matrixWorld, i.boneInverses[n]),
          t.addScaledVector(Fa.copy(Pa).applyMatrix4(Na), e);
      }
    }
    return t.applyMatrix4(this.bindMatrixInverse);
  }
  boneTransform(e, t) {
    return (
      console.warn(
        "THREE.SkinnedMesh: .boneTransform() was renamed to .applyBoneTransform() in r151."
      ),
      this.applyBoneTransform(e, t)
    );
  }
}
class Ga extends Object3D {
  constructor() {
    super(), (this.isBone = !0), (this.type = "Bone");
  }
}
class Va extends Texture {
  constructor(e = null, t = 1, i = 1, n, s, r, a, o, l = 1003, h = 1003, c, u) {
    super(null, r, a, o, l, h, n, s, c, u),
      (this.isDataTexture = !0),
      (this.image = { data: e, width: t, height: i }),
      (this.generateMipmaps = !1),
      (this.flipY = !1),
      (this.unpackAlignment = 1);
  }
}
const Qa = new Matrix4(),
  Ha = new Matrix4();
class ja {
  constructor(e = [], t = []) {
    (this.uuid = Pe()),
      (this.bones = e.slice(0)),
      (this.boneInverses = t),
      (this.boneMatrices = null),
      (this.boneTexture = null),
      (this.boneTextureSize = 0),
      this.init();
  }
  init() {
    const e = this.bones,
      t = this.boneInverses;
    if (((this.boneMatrices = new Float32Array(16 * e.length)), 0 === t.length))
      this.calculateInverses();
    else if (e.length !== t.length) {
      console.warn(
        "THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."
      ),
        (this.boneInverses = []);
      for (let e = 0, t = this.bones.length; e < t; e++)
        this.boneInverses.push(new Matrix4());
    }
  }
  calculateInverses() {
    this.boneInverses.length = 0;
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const t = new Matrix4();
      this.bones[e] && t.copy(this.bones[e].matrixWorld).invert(),
        this.boneInverses.push(t);
    }
  }
  pose() {
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const t = this.bones[e];
      t && t.matrixWorld.copy(this.boneInverses[e]).invert();
    }
    for (let e = 0, t = this.bones.length; e < t; e++) {
      const t = this.bones[e];
      t &&
        (t.parent && t.parent.isBone
          ? (t.matrix.copy(t.parent.matrixWorld).invert(),
            t.matrix.multiply(t.matrixWorld))
          : t.matrix.copy(t.matrixWorld),
        t.matrix.decompose(t.position, t.quaternion, t.scale));
    }
  }
  update() {
    const e = this.bones,
      t = this.boneInverses,
      i = this.boneMatrices,
      n = this.boneTexture;
    for (let s = 0, r = e.length; s < r; s++) {
      const n = e[s] ? e[s].matrixWorld : Ha;
      Qa.multiplyMatrices(n, t[s]), Qa.toArray(i, 16 * s);
    }
    null !== n && (n.needsUpdate = !0);
  }
  clone() {
    return new ja(this.bones, this.boneInverses);
  }
  computeBoneTexture() {
    let e = Math.sqrt(4 * this.bones.length);
    (e = Be(e)), (e = Math.max(e, 4));
    const t = new Float32Array(e * e * 4);
    t.set(this.boneMatrices);
    const i = new Va(t, e, e, Q, z);
    return (
      (i.needsUpdate = !0),
      (this.boneMatrices = t),
      (this.boneTexture = i),
      (this.boneTextureSize = e),
      this
    );
  }
  getBoneByName(e) {
    for (let t = 0, i = this.bones.length; t < i; t++) {
      const i = this.bones[t];
      if (i.name === e) return i;
    }
  }
  dispose() {
    null !== this.boneTexture &&
      (this.boneTexture.dispose(), (this.boneTexture = null));
  }
  fromJSON(e, t) {
    this.uuid = e.uuid;
    for (let i = 0, n = e.bones.length; i < n; i++) {
      const n = e.bones[i];
      let s = t[n];
      void 0 === s &&
        (console.warn("THREE.Skeleton: No bone found with UUID:", n),
        (s = new Ga())),
        this.bones.push(s),
        this.boneInverses.push(new Matrix4().fromArray(e.boneInverses[i]));
    }
    return this.init(), this;
  }
  toJSON() {
    const e = {
      metadata: {
        version: 4.6,
        type: "Skeleton",
        generator: "Skeleton.toJSON",
      },
      bones: [],
      boneInverses: [],
    };
    e.uuid = this.uuid;
    const t = this.bones,
      i = this.boneInverses;
    for (let n = 0, s = t.length; n < s; n++) {
      const s = t[n];
      e.bones.push(s.uuid);
      const r = i[n];
      e.boneInverses.push(r.toArray());
    }
    return e;
  }
}
class Wa extends Wi {
  constructor(e, t, i, n = 1) {
    super(e, t, i),
      (this.isInstancedBufferAttribute = !0),
      (this.meshPerAttribute = n);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.meshPerAttribute = this.meshPerAttribute),
      (e.isInstancedBufferAttribute = !0),
      e
    );
  }
}
const qa = new Matrix4(),
  Xa = new Matrix4(),
  Ya = [],
  Ka = new Box3(),
  Za = new Matrix4(),
  Ja = new En(),
  $a = new kt();
class eo extends En {
  constructor(e, t, i) {
    super(e, t),
      (this.isInstancedMesh = !0),
      (this.instanceMatrix = new Wa(new Float32Array(16 * i), 16)),
      (this.instanceColor = null),
      (this.count = i),
      (this.boundingBox = null),
      (this.boundingSphere = null);
    for (let n = 0; n < i; n++) this.setMatrixAt(n, Za);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    null === this.boundingBox && (this.boundingBox = new Box3()),
      null === e.boundingBox && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, qa),
        Ka.copy(e.boundingBox).applyMatrix4(qa),
        this.boundingBox.union(Ka);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    null === this.boundingSphere && (this.boundingSphere = new kt()),
      null === e.boundingSphere && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, qa),
        $a.copy(e.boundingSphere).applyMatrix4(qa),
        this.boundingSphere.union($a);
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      this.instanceMatrix.copy(e.instanceMatrix),
      null !== e.instanceColor &&
        (this.instanceColor = e.instanceColor.clone()),
      (this.count = e.count),
      null !== e.boundingBox && (this.boundingBox = e.boundingBox.clone()),
      null !== e.boundingSphere &&
        (this.boundingSphere = e.boundingSphere.clone()),
      this
    );
  }
  getColorAt(e, t) {
    t.fromArray(this.instanceColor.array, 3 * e);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, 16 * e);
  }
  raycast(e, t) {
    const i = this.matrixWorld,
      n = this.count;
    if (
      ((Ja.geometry = this.geometry),
      (Ja.material = this.material),
      void 0 !== Ja.material &&
        (null === this.boundingSphere && this.computeBoundingSphere(),
        $a.copy(this.boundingSphere),
        $a.applyMatrix4(i),
        !1 !== e.ray.intersectsSphere($a)))
    )
      for (let s = 0; s < n; s++) {
        this.getMatrixAt(s, qa),
          Xa.multiplyMatrices(i, qa),
          (Ja.matrixWorld = Xa),
          Ja.raycast(e, Ya);
        for (let e = 0, i = Ya.length; e < i; e++) {
          const i = Ya[e];
          (i.instanceId = s), (i.object = this), t.push(i);
        }
        Ya.length = 0;
      }
  }
  setColorAt(e, t) {
    null === this.instanceColor &&
      (this.instanceColor = new Wa(
        new Float32Array(3 * this.instanceMatrix.count),
        3
      )),
      t.toArray(this.instanceColor.array, 3 * e);
  }
  setMatrixAt(e, t) {
    t.toArray(this.instanceMatrix.array, 16 * e);
  }
  updateMorphTargets() {}
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
}
class to extends Material {
  constructor(e) {
    super(),
      (this.isLineBasicMaterial = !0),
      (this.type = "LineBasicMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.linewidth = 1),
      (this.linecap = "round"),
      (this.linejoin = "round"),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.linewidth = e.linewidth),
      (this.linecap = e.linecap),
      (this.linejoin = e.linejoin),
      (this.fog = e.fog),
      this
    );
  }
}
const io = new Vector3(),
  no = new Vector3(),
  so = new Matrix4(),
  ro = new jt(),
  ao = new kt();
class oo extends Object3D {
  constructor(e = new rn(), t = new to()) {
    super(),
      (this.isLine = !0),
      (this.type = "Line"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  computeLineDistances() {
    const e = this.geometry;
    if (null === e.index) {
      const t = e.attributes.position,
        i = [0];
      for (let e = 1, n = t.count; e < n; e++)
        io.fromBufferAttribute(t, e - 1),
          no.fromBufferAttribute(t, e),
          (i[e] = i[e - 1]),
          (i[e] += io.distanceTo(no));
      e.setAttribute("lineDistance", new Ki(i, 1));
    } else
      console.warn(
        "THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
  raycast(e, t) {
    const i = this.geometry,
      n = this.matrixWorld,
      s = e.params.Line.threshold,
      r = i.drawRange;
    if (
      (null === i.boundingSphere && i.computeBoundingSphere(),
      ao.copy(i.boundingSphere),
      ao.applyMatrix4(n),
      (ao.radius += s),
      !1 === e.ray.intersectsSphere(ao))
    )
      return;
    so.copy(n).invert(), ro.copy(e.ray).applyMatrix4(so);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = a * a,
      l = new Vector3(),
      h = new Vector3(),
      c = new Vector3(),
      u = new Vector3(),
      d = this.isLineSegments ? 2 : 1,
      p = i.index,
      f = i.attributes.position;
    if (null !== p) {
      for (
        let i = Math.max(0, r.start),
          n = Math.min(p.count, r.start + r.count) - 1;
        i < n;
        i += d
      ) {
        const n = p.getX(i),
          s = p.getX(i + 1);
        l.fromBufferAttribute(f, n), h.fromBufferAttribute(f, s);
        if (ro.distanceSqToSegment(l, h, u, c) > o) continue;
        u.applyMatrix4(this.matrixWorld);
        const r = e.ray.origin.distanceTo(u);
        r < e.near ||
          r > e.far ||
          t.push({
            distance: r,
            point: c.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    } else {
      for (
        let i = Math.max(0, r.start),
          n = Math.min(f.count, r.start + r.count) - 1;
        i < n;
        i += d
      ) {
        l.fromBufferAttribute(f, i), h.fromBufferAttribute(f, i + 1);
        if (ro.distanceSqToSegment(l, h, u, c) > o) continue;
        u.applyMatrix4(this.matrixWorld);
        const n = e.ray.origin.distanceTo(u);
        n < e.near ||
          n > e.far ||
          t.push({
            distance: n,
            point: c.clone().applyMatrix4(this.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: this,
          });
      }
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      t = Object.keys(e);
    if (t.length > 0) {
      const i = e[t[0]];
      if (void 0 !== i) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let e = 0, t = i.length; e < t; e++) {
          const t = i[e].name || String(e);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[t] = e);
        }
      }
    }
  }
}
const lo = new Vector3(),
  ho = new Vector3();
class co extends oo {
  constructor(e, t) {
    super(e, t), (this.isLineSegments = !0), (this.type = "LineSegments");
  }
  computeLineDistances() {
    const e = this.geometry;
    if (null === e.index) {
      const t = e.attributes.position,
        i = [];
      for (let e = 0, n = t.count; e < n; e += 2)
        lo.fromBufferAttribute(t, e),
          ho.fromBufferAttribute(t, e + 1),
          (i[e] = 0 === e ? 0 : i[e - 1]),
          (i[e + 1] = i[e] + lo.distanceTo(ho));
      e.setAttribute("lineDistance", new Ki(i, 1));
    } else
      console.warn(
        "THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry."
      );
    return this;
  }
}
class uo extends oo {
  constructor(e, t) {
    super(e, t), (this.isLineLoop = !0), (this.type = "LineLoop");
  }
}
class po extends Material {
  constructor(e) {
    super(),
      (this.isPointsMaterial = !0),
      (this.type = "PointsMaterial"),
      (this.color = new Color(16777215)),
      (this.map = null),
      (this.alphaMap = null),
      (this.size = 1),
      (this.sizeAttenuation = !0),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      this.color.copy(e.color),
      (this.map = e.map),
      (this.alphaMap = e.alphaMap),
      (this.size = e.size),
      (this.sizeAttenuation = e.sizeAttenuation),
      (this.fog = e.fog),
      this
    );
  }
}
const fo = new Matrix4(),
  mo = new jt(),
  go = new kt(),
  _o = new Vector3();
class vo extends Object3D {
  constructor(e = new rn(), t = new po()) {
    super(),
      (this.isPoints = !0),
      (this.type = "Points"),
      (this.geometry = e),
      (this.material = t),
      this.updateMorphTargets();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.material = Array.isArray(e.material)
        ? e.material.slice()
        : e.material),
      (this.geometry = e.geometry),
      this
    );
  }
  raycast(e, t) {
    const i = this.geometry,
      n = this.matrixWorld,
      s = e.params.Points.threshold,
      r = i.drawRange;
    if (
      (null === i.boundingSphere && i.computeBoundingSphere(),
      go.copy(i.boundingSphere),
      go.applyMatrix4(n),
      (go.radius += s),
      !1 === e.ray.intersectsSphere(go))
    )
      return;
    fo.copy(n).invert(), mo.copy(e.ray).applyMatrix4(fo);
    const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      o = a * a,
      l = i.index,
      h = i.attributes.position;
    if (null !== l) {
      for (
        let i = Math.max(0, r.start), s = Math.min(l.count, r.start + r.count);
        i < s;
        i++
      ) {
        const s = l.getX(i);
        _o.fromBufferAttribute(h, s), Ao(_o, s, o, n, e, t, this);
      }
    } else {
      for (
        let i = Math.max(0, r.start), s = Math.min(h.count, r.start + r.count);
        i < s;
        i++
      )
        _o.fromBufferAttribute(h, i), Ao(_o, i, o, n, e, t, this);
    }
  }
  updateMorphTargets() {
    const e = this.geometry.morphAttributes,
      t = Object.keys(e);
    if (t.length > 0) {
      const i = e[t[0]];
      if (void 0 !== i) {
        (this.morphTargetInfluences = []), (this.morphTargetDictionary = {});
        for (let e = 0, t = i.length; e < t; e++) {
          const t = i[e].name || String(e);
          this.morphTargetInfluences.push(0),
            (this.morphTargetDictionary[t] = e);
        }
      }
    }
  }
}
function Ao(e, t, i, n, s, r, a) {
  const o = mo.distanceSqToPoint(e);
  if (o < i) {
    const i = new Vector3();
    mo.closestPointToPoint(e, i), i.applyMatrix4(n);
    const l = s.ray.origin.distanceTo(i);
    if (l < s.near || l > s.far) return;
    r.push({
      distance: l,
      distanceToRay: Math.sqrt(o),
      point: i,
      index: t,
      face: null,
      object: a,
    });
  }
}
class yo extends Texture {
  constructor(e, t, i, n, s, r, a, o, l, h, c, u) {
    super(null, r, a, o, l, h, n, s, c, u),
      (this.isCompressedTexture = !0),
      (this.image = { width: t, height: i }),
      (this.mipmaps = e),
      (this.flipY = !1),
      (this.generateMipmaps = !1);
  }
}
class xo extends yo {
  constructor(e, t, i, n, s, r) {
    super(e, t, i, s, r),
      (this.isCompressedArrayTexture = !0),
      (this.image.depth = n),
      (this.wrapR = T);
  }
}
class bo extends yo {
  constructor(e, t, i) {
    super(void 0, e[0].width, e[0].height, t, i, E),
      (this.isCompressedCubeTexture = !0),
      (this.isCubeTexture = !0),
      (this.image = e);
  }
}
class CanvasTexture extends Texture {
  constructor(e, t, i, n, s, r, a, o, l) {
    super(e, t, i, n, s, r, a, o, l),
      (this.isCanvasTexture = !0),
      (this.needsUpdate = !0);
  }
}
class So {
  constructor() {
    (this.type = "Curve"), (this.arcLengthDivisions = 200);
  }
  getPoint() {
    return console.warn("THREE.Curve: .getPoint() not implemented."), null;
  }
  getPointAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getPoint(i, t);
  }
  getPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPoint(i / e));
    return t;
  }
  getSpacedPoints(e = 5) {
    const t = [];
    for (let i = 0; i <= e; i++) t.push(this.getPointAt(i / e));
    return t;
  }
  getLength() {
    const e = this.getLengths();
    return e[e.length - 1];
  }
  getLengths(e = this.arcLengthDivisions) {
    if (
      this.cacheArcLengths &&
      this.cacheArcLengths.length === e + 1 &&
      !this.needsUpdate
    )
      return this.cacheArcLengths;
    this.needsUpdate = !1;
    const t = [];
    let i,
      n = this.getPoint(0),
      s = 0;
    t.push(0);
    for (let r = 1; r <= e; r++)
      (i = this.getPoint(r / e)), (s += i.distanceTo(n)), t.push(s), (n = i);
    return (this.cacheArcLengths = t), t;
  }
  updateArcLengths() {
    (this.needsUpdate = !0), this.getLengths();
  }
  getUtoTmapping(e, t) {
    const i = this.getLengths();
    let n = 0;
    const s = i.length;
    let r;
    r = t || e * i[s - 1];
    let a,
      o = 0,
      l = s - 1;
    for (; o <= l; )
      if (((n = Math.floor(o + (l - o) / 2)), (a = i[n] - r), a < 0)) o = n + 1;
      else {
        if (!(a > 0)) {
          l = n;
          break;
        }
        l = n - 1;
      }
    if (((n = l), i[n] === r)) return n / (s - 1);
    const h = i[n];
    return (n + (r - h) / (i[n + 1] - h)) / (s - 1);
  }
  getTangent(e, t) {
    const i = 1e-4;
    let n = e - i,
      s = e + i;
    n < 0 && (n = 0), s > 1 && (s = 1);
    const r = this.getPoint(n),
      a = this.getPoint(s),
      o = t || (r.isVector2 ? new Vector2() : new Vector3());
    return o.copy(a).sub(r).normalize(), o;
  }
  getTangentAt(e, t) {
    const i = this.getUtoTmapping(e);
    return this.getTangent(i, t);
  }
  computeFrenetFrames(e, t) {
    const i = new Vector3(),
      n = [],
      s = [],
      r = [],
      a = new Vector3(),
      o = new Matrix4();
    for (let d = 0; d <= e; d++) {
      const t = d / e;
      n[d] = this.getTangentAt(t, new Vector3());
    }
    (s[0] = new Vector3()), (r[0] = new Vector3());
    let l = Number.MAX_VALUE;
    const h = Math.abs(n[0].x),
      c = Math.abs(n[0].y),
      u = Math.abs(n[0].z);
    h <= l && ((l = h), i.set(1, 0, 0)),
      c <= l && ((l = c), i.set(0, 1, 0)),
      u <= l && i.set(0, 0, 1),
      a.crossVectors(n[0], i).normalize(),
      s[0].crossVectors(n[0], a),
      r[0].crossVectors(n[0], s[0]);
    for (let d = 1; d <= e; d++) {
      if (
        ((s[d] = s[d - 1].clone()),
        (r[d] = r[d - 1].clone()),
        a.crossVectors(n[d - 1], n[d]),
        a.length() > Number.EPSILON)
      ) {
        a.normalize();
        const e = Math.acos(De(n[d - 1].dot(n[d]), -1, 1));
        s[d].applyMatrix4(o.makeRotationAxis(a, e));
      }
      r[d].crossVectors(n[d], s[d]);
    }
    if (!0 === t) {
      let t = Math.acos(De(s[0].dot(s[e]), -1, 1));
      (t /= e), n[0].dot(a.crossVectors(s[0], s[e])) > 0 && (t = -t);
      for (let i = 1; i <= e; i++)
        s[i].applyMatrix4(o.makeRotationAxis(n[i], t * i)),
          r[i].crossVectors(n[i], s[i]);
    }
    return { tangents: n, normals: s, binormals: r };
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
  toJSON() {
    const e = {
      metadata: { version: 4.6, type: "Curve", generator: "Curve.toJSON" },
    };
    return (
      (e.arcLengthDivisions = this.arcLengthDivisions), (e.type = this.type), e
    );
  }
  fromJSON(e) {
    return (this.arcLengthDivisions = e.arcLengthDivisions), this;
  }
}
function Co() {
  let e = 0,
    t = 0,
    i = 0,
    n = 0;
  function s(s, r, a, o) {
    (e = s),
      (t = a),
      (i = -3 * s + 3 * r - 2 * a - o),
      (n = 2 * s - 2 * r + a + o);
  }
  return {
    initCatmullRom: function (e, t, i, n, r) {
      s(t, i, r * (i - e), r * (n - t));
    },
    initNonuniformCatmullRom: function (e, t, i, n, r, a, o) {
      let l = (t - e) / r - (i - e) / (r + a) + (i - t) / a,
        h = (i - t) / a - (n - t) / (a + o) + (n - i) / o;
      (l *= a), (h *= a), s(t, i, l, h);
    },
    calc: function (s) {
      const r = s * s;
      return e + t * s + i * r + n * (r * s);
    },
  };
}
const Mo = new Vector3(),
  wo = new Co(),
  To = new Co(),
  Io = new Co();
class Ro extends So {
  constructor(e = [], t = !1, i = "centripetal", n = 0.5) {
    super(),
      (this.isCatmullRomCurve3 = !0),
      (this.type = "CatmullRomCurve3"),
      (this.points = e),
      (this.closed = t),
      (this.curveType = i),
      (this.tension = n);
  }
  getPoint(e, t = new Vector3()) {
    const i = t,
      n = this.points,
      s = n.length,
      r = (s - (this.closed ? 0 : 1)) * e;
    let a,
      o,
      l = Math.floor(r),
      h = r - l;
    this.closed
      ? (l += l > 0 ? 0 : (Math.floor(Math.abs(l) / s) + 1) * s)
      : 0 === h && l === s - 1 && ((l = s - 2), (h = 1)),
      this.closed || l > 0
        ? (a = n[(l - 1) % s])
        : (Mo.subVectors(n[0], n[1]).add(n[0]), (a = Mo));
    const c = n[l % s],
      u = n[(l + 1) % s];
    if (
      (this.closed || l + 2 < s
        ? (o = n[(l + 2) % s])
        : (Mo.subVectors(n[s - 1], n[s - 2]).add(n[s - 1]), (o = Mo)),
      "centripetal" === this.curveType || "chordal" === this.curveType)
    ) {
      const e = "chordal" === this.curveType ? 0.5 : 0.25;
      let t = Math.pow(a.distanceToSquared(c), e),
        i = Math.pow(c.distanceToSquared(u), e),
        n = Math.pow(u.distanceToSquared(o), e);
      i < 1e-4 && (i = 1),
        t < 1e-4 && (t = i),
        n < 1e-4 && (n = i),
        wo.initNonuniformCatmullRom(a.x, c.x, u.x, o.x, t, i, n),
        To.initNonuniformCatmullRom(a.y, c.y, u.y, o.y, t, i, n),
        Io.initNonuniformCatmullRom(a.z, c.z, u.z, o.z, t, i, n);
    } else
      "catmullrom" === this.curveType &&
        (wo.initCatmullRom(a.x, c.x, u.x, o.x, this.tension),
        To.initCatmullRom(a.y, c.y, u.y, o.y, this.tension),
        Io.initCatmullRom(a.z, c.z, u.z, o.z, this.tension));
    return i.set(wo.calc(h), To.calc(h), Io.calc(h)), i;
  }
  copy(e) {
    super.copy(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const i = e.points[t];
      this.points.push(i.clone());
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
  toJSON() {
    const e = super.toJSON();
    e.points = [];
    for (let t = 0, i = this.points.length; t < i; t++) {
      const i = this.points[t];
      e.points.push(i.toArray());
    }
    return (
      (e.closed = this.closed),
      (e.curveType = this.curveType),
      (e.tension = this.tension),
      e
    );
  }
  fromJSON(e) {
    super.fromJSON(e), (this.points = []);
    for (let t = 0, i = e.points.length; t < i; t++) {
      const i = e.points[t];
      this.points.push(new Vector3().fromArray(i));
    }
    return (
      (this.closed = e.closed),
      (this.curveType = e.curveType),
      (this.tension = e.tension),
      this
    );
  }
}
class Po extends rn {
  constructor(
    e = 1,
    t = 1,
    i = 1,
    n = 32,
    s = 1,
    r = !1,
    a = 0,
    o = 2 * Math.PI
  ) {
    super(),
      (this.type = "CylinderGeometry"),
      (this.parameters = {
        radiusTop: e,
        radiusBottom: t,
        height: i,
        radialSegments: n,
        heightSegments: s,
        openEnded: r,
        thetaStart: a,
        thetaLength: o,
      });
    const l = this;
    (n = Math.floor(n)), (s = Math.floor(s));
    const h = [],
      c = [],
      u = [],
      d = [];
    let p = 0;
    const f = [],
      m = i / 2;
    let g = 0;
    function _(i) {
      const s = p,
        r = new Vector2(),
        f = new Vector3();
      let _ = 0;
      const v = !0 === i ? e : t,
        A = !0 === i ? 1 : -1;
      for (let e = 1; e <= n; e++)
        c.push(0, m * A, 0), u.push(0, A, 0), d.push(0.5, 0.5), p++;
      const y = p;
      for (let e = 0; e <= n; e++) {
        const t = (e / n) * o + a,
          i = Math.cos(t),
          s = Math.sin(t);
        (f.x = v * s),
          (f.y = m * A),
          (f.z = v * i),
          c.push(f.x, f.y, f.z),
          u.push(0, A, 0),
          (r.x = 0.5 * i + 0.5),
          (r.y = 0.5 * s * A + 0.5),
          d.push(r.x, r.y),
          p++;
      }
      for (let e = 0; e < n; e++) {
        const t = s + e,
          n = y + e;
        !0 === i ? h.push(n, n + 1, t) : h.push(n + 1, n, t), (_ += 3);
      }
      l.addGroup(g, _, !0 === i ? 1 : 2), (g += _);
    }
    !(function () {
      const r = new Vector3(),
        _ = new Vector3();
      let v = 0;
      const A = (t - e) / i;
      for (let l = 0; l <= s; l++) {
        const h = [],
          g = l / s,
          v = g * (t - e) + e;
        for (let e = 0; e <= n; e++) {
          const t = e / n,
            s = t * o + a,
            l = Math.sin(s),
            f = Math.cos(s);
          (_.x = v * l),
            (_.y = -g * i + m),
            (_.z = v * f),
            c.push(_.x, _.y, _.z),
            r.set(l, A, f).normalize(),
            u.push(r.x, r.y, r.z),
            d.push(t, 1 - g),
            h.push(p++);
        }
        f.push(h);
      }
      for (let e = 0; e < n; e++)
        for (let t = 0; t < s; t++) {
          const i = f[t][e],
            n = f[t + 1][e],
            s = f[t + 1][e + 1],
            r = f[t][e + 1];
          h.push(i, n, r), h.push(n, s, r), (v += 6);
        }
      l.addGroup(g, v, 0), (g += v);
    })(),
      !1 === r && (e > 0 && _(!0), t > 0 && _(!1)),
      this.setIndex(h),
      this.setAttribute("position", new Ki(c, 3)),
      this.setAttribute("normal", new Ki(u, 3)),
      this.setAttribute("uv", new Ki(d, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Po(
      e.radiusTop,
      e.radiusBottom,
      e.height,
      e.radialSegments,
      e.heightSegments,
      e.openEnded,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class Do extends rn {
  constructor(e = [], t = [], i = 1, n = 0) {
    super(),
      (this.type = "PolyhedronGeometry"),
      (this.parameters = { vertices: e, indices: t, radius: i, detail: n });
    const s = [],
      r = [];
    function a(e, t, i, n) {
      const s = n + 1,
        r = [];
      for (let a = 0; a <= s; a++) {
        r[a] = [];
        const n = e.clone().lerp(i, a / s),
          o = t.clone().lerp(i, a / s),
          l = s - a;
        for (let e = 0; e <= l; e++)
          r[a][e] = 0 === e && a === s ? n : n.clone().lerp(o, e / l);
      }
      for (let a = 0; a < s; a++)
        for (let e = 0; e < 2 * (s - a) - 1; e++) {
          const t = Math.floor(e / 2);
          e % 2 == 0
            ? (o(r[a][t + 1]), o(r[a + 1][t]), o(r[a][t]))
            : (o(r[a][t + 1]), o(r[a + 1][t + 1]), o(r[a + 1][t]));
        }
    }
    function o(e) {
      s.push(e.x, e.y, e.z);
    }
    function l(t, i) {
      const n = 3 * t;
      (i.x = e[n + 0]), (i.y = e[n + 1]), (i.z = e[n + 2]);
    }
    function h(e, t, i, n) {
      n < 0 && 1 === e.x && (r[t] = e.x - 1),
        0 === i.x && 0 === i.z && (r[t] = n / 2 / Math.PI + 0.5);
    }
    function c(e) {
      return Math.atan2(e.z, -e.x);
    }
    !(function (e) {
      const i = new Vector3(),
        n = new Vector3(),
        s = new Vector3();
      for (let r = 0; r < t.length; r += 3)
        l(t[r + 0], i), l(t[r + 1], n), l(t[r + 2], s), a(i, n, s, e);
    })(n),
      (function (e) {
        const t = new Vector3();
        for (let i = 0; i < s.length; i += 3)
          (t.x = s[i + 0]),
            (t.y = s[i + 1]),
            (t.z = s[i + 2]),
            t.normalize().multiplyScalar(e),
            (s[i + 0] = t.x),
            (s[i + 1] = t.y),
            (s[i + 2] = t.z);
      })(i),
      (function () {
        const e = new Vector3();
        for (let i = 0; i < s.length; i += 3) {
          (e.x = s[i + 0]), (e.y = s[i + 1]), (e.z = s[i + 2]);
          const n = c(e) / 2 / Math.PI + 0.5,
            a =
              ((t = e),
              Math.atan2(-t.y, Math.sqrt(t.x * t.x + t.z * t.z)) / Math.PI +
                0.5);
          r.push(n, 1 - a);
        }
        var t;
        (function () {
          const e = new Vector3(),
            t = new Vector3(),
            i = new Vector3(),
            n = new Vector3(),
            a = new Vector2(),
            o = new Vector2(),
            l = new Vector2();
          for (let u = 0, d = 0; u < s.length; u += 9, d += 6) {
            e.set(s[u + 0], s[u + 1], s[u + 2]),
              t.set(s[u + 3], s[u + 4], s[u + 5]),
              i.set(s[u + 6], s[u + 7], s[u + 8]),
              a.set(r[d + 0], r[d + 1]),
              o.set(r[d + 2], r[d + 3]),
              l.set(r[d + 4], r[d + 5]),
              n.copy(e).add(t).add(i).divideScalar(3);
            const p = c(n);
            h(a, d + 0, e, p), h(o, d + 2, t, p), h(l, d + 4, i, p);
          }
        })(),
          (function () {
            for (let e = 0; e < r.length; e += 6) {
              const t = r[e + 0],
                i = r[e + 2],
                n = r[e + 4],
                s = Math.max(t, i, n),
                a = Math.min(t, i, n);
              s > 0.9 &&
                a < 0.1 &&
                (t < 0.2 && (r[e + 0] += 1),
                i < 0.2 && (r[e + 2] += 1),
                n < 0.2 && (r[e + 4] += 1));
            }
          })();
      })(),
      this.setAttribute("position", new Ki(s, 3)),
      this.setAttribute("normal", new Ki(s.slice(), 3)),
      this.setAttribute("uv", new Ki(r, 2)),
      0 === n ? this.computeVertexNormals() : this.normalizeNormals();
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Do(e.vertices, e.indices, e.radius, e.details);
  }
}
const Lo = new Vector3(),
  Fo = new Vector3(),
  No = new Vector3(),
  Bo = new Ii();
class ko extends rn {
  constructor(e = null, t = 1) {
    if (
      (super(),
      (this.type = "EdgesGeometry"),
      (this.parameters = { geometry: e, thresholdAngle: t }),
      null !== e)
    ) {
      const i = 4,
        n = Math.pow(10, i),
        s = Math.cos(Ie * t),
        r = e.getIndex(),
        a = e.getAttribute("position"),
        o = r ? r.count : a.count,
        l = [0, 0, 0],
        h = ["a", "b", "c"],
        c = new Array(3),
        u = {},
        d = [];
      for (let e = 0; e < o; e += 3) {
        r
          ? ((l[0] = r.getX(e)), (l[1] = r.getX(e + 1)), (l[2] = r.getX(e + 2)))
          : ((l[0] = e), (l[1] = e + 1), (l[2] = e + 2));
        const { a: t, b: i, c: o } = Bo;
        if (
          (t.fromBufferAttribute(a, l[0]),
          i.fromBufferAttribute(a, l[1]),
          o.fromBufferAttribute(a, l[2]),
          Bo.getNormal(No),
          (c[0] = `${Math.round(t.x * n)},${Math.round(t.y * n)},${Math.round(
            t.z * n
          )}`),
          (c[1] = `${Math.round(i.x * n)},${Math.round(i.y * n)},${Math.round(
            i.z * n
          )}`),
          (c[2] = `${Math.round(o.x * n)},${Math.round(o.y * n)},${Math.round(
            o.z * n
          )}`),
          c[0] !== c[1] && c[1] !== c[2] && c[2] !== c[0])
        )
          for (let e = 0; e < 3; e++) {
            const t = (e + 1) % 3,
              i = c[e],
              n = c[t],
              r = Bo[h[e]],
              a = Bo[h[t]],
              o = `${i}_${n}`,
              p = `${n}_${i}`;
            p in u && u[p]
              ? (No.dot(u[p].normal) <= s &&
                  (d.push(r.x, r.y, r.z), d.push(a.x, a.y, a.z)),
                (u[p] = null))
              : o in u ||
                (u[o] = { index0: l[e], index1: l[t], normal: No.clone() });
          }
      }
      for (const e in u)
        if (u[e]) {
          const { index0: t, index1: i } = u[e];
          Lo.fromBufferAttribute(a, t),
            Fo.fromBufferAttribute(a, i),
            d.push(Lo.x, Lo.y, Lo.z),
            d.push(Fo.x, Fo.y, Fo.z);
        }
      this.setAttribute("position", new Ki(d, 3));
    }
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
}
class Oo extends Do {
  constructor(e = 1, t = 0) {
    super(
      [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
      [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2],
      e,
      t
    ),
      (this.type = "OctahedronGeometry"),
      (this.parameters = { radius: e, detail: t });
  }
  static fromJSON(e) {
    return new Oo(e.radius, e.detail);
  }
}
class Uo extends rn {
  constructor(
    e = 1,
    t = 32,
    i = 16,
    n = 0,
    s = 2 * Math.PI,
    r = 0,
    a = Math.PI
  ) {
    super(),
      (this.type = "SphereGeometry"),
      (this.parameters = {
        radius: e,
        widthSegments: t,
        heightSegments: i,
        phiStart: n,
        phiLength: s,
        thetaStart: r,
        thetaLength: a,
      }),
      (t = Math.max(3, Math.floor(t))),
      (i = Math.max(2, Math.floor(i)));
    const o = Math.min(r + a, Math.PI);
    let l = 0;
    const h = [],
      c = new Vector3(),
      u = new Vector3(),
      d = [],
      p = [],
      f = [],
      m = [];
    for (let g = 0; g <= i; g++) {
      const d = [],
        _ = g / i;
      let v = 0;
      0 === g && 0 === r
        ? (v = 0.5 / t)
        : g === i && o === Math.PI && (v = -0.5 / t);
      for (let i = 0; i <= t; i++) {
        const o = i / t;
        (c.x = -e * Math.cos(n + o * s) * Math.sin(r + _ * a)),
          (c.y = e * Math.cos(r + _ * a)),
          (c.z = e * Math.sin(n + o * s) * Math.sin(r + _ * a)),
          p.push(c.x, c.y, c.z),
          u.copy(c).normalize(),
          f.push(u.x, u.y, u.z),
          m.push(o + v, 1 - _),
          d.push(l++);
      }
      h.push(d);
    }
    for (let g = 0; g < i; g++)
      for (let e = 0; e < t; e++) {
        const t = h[g][e + 1],
          n = h[g][e],
          s = h[g + 1][e],
          a = h[g + 1][e + 1];
        (0 !== g || r > 0) && d.push(t, n, a),
          (g !== i - 1 || o < Math.PI) && d.push(n, s, a);
      }
    this.setIndex(d),
      this.setAttribute("position", new Ki(p, 3)),
      this.setAttribute("normal", new Ki(f, 3)),
      this.setAttribute("uv", new Ki(m, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new Uo(
      e.radius,
      e.widthSegments,
      e.heightSegments,
      e.phiStart,
      e.phiLength,
      e.thetaStart,
      e.thetaLength
    );
  }
}
class zo extends rn {
  constructor(e = 1, t = 0.4, i = 12, n = 48, s = 2 * Math.PI) {
    super(),
      (this.type = "TorusGeometry"),
      (this.parameters = {
        radius: e,
        tube: t,
        radialSegments: i,
        tubularSegments: n,
        arc: s,
      }),
      (i = Math.floor(i)),
      (n = Math.floor(n));
    const r = [],
      a = [],
      o = [],
      l = [],
      h = new Vector3(),
      c = new Vector3(),
      u = new Vector3();
    for (let d = 0; d <= i; d++)
      for (let r = 0; r <= n; r++) {
        const p = (r / n) * s,
          f = (d / i) * Math.PI * 2;
        (c.x = (e + t * Math.cos(f)) * Math.cos(p)),
          (c.y = (e + t * Math.cos(f)) * Math.sin(p)),
          (c.z = t * Math.sin(f)),
          a.push(c.x, c.y, c.z),
          (h.x = e * Math.cos(p)),
          (h.y = e * Math.sin(p)),
          u.subVectors(c, h).normalize(),
          o.push(u.x, u.y, u.z),
          l.push(r / n),
          l.push(d / i);
      }
    for (let d = 1; d <= i; d++)
      for (let e = 1; e <= n; e++) {
        const t = (n + 1) * d + e - 1,
          i = (n + 1) * (d - 1) + e - 1,
          s = (n + 1) * (d - 1) + e,
          a = (n + 1) * d + e;
        r.push(t, i, a), r.push(i, s, a);
      }
    this.setIndex(r),
      this.setAttribute("position", new Ki(a, 3)),
      this.setAttribute("normal", new Ki(o, 3)),
      this.setAttribute("uv", new Ki(l, 2));
  }
  copy(e) {
    return (
      super.copy(e), (this.parameters = Object.assign({}, e.parameters)), this
    );
  }
  static fromJSON(e) {
    return new zo(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc);
  }
}
class Go extends ShaderMaterial {
  constructor(e) {
    super(e),
      (this.isRawShaderMaterial = !0),
      (this.type = "RawShaderMaterial");
  }
}
class Vo extends Material {
  constructor(e) {
    super(),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.type = "MeshStandardMaterial"),
      (this.color = new Color(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1),
      (this.fog = !0),
      this.setValues(e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "" }),
      this.color.copy(e.color),
      (this.roughness = e.roughness),
      (this.metalness = e.metalness),
      (this.map = e.map),
      (this.lightMap = e.lightMap),
      (this.lightMapIntensity = e.lightMapIntensity),
      (this.aoMap = e.aoMap),
      (this.aoMapIntensity = e.aoMapIntensity),
      this.emissive.copy(e.emissive),
      (this.emissiveMap = e.emissiveMap),
      (this.emissiveIntensity = e.emissiveIntensity),
      (this.bumpMap = e.bumpMap),
      (this.bumpScale = e.bumpScale),
      (this.normalMap = e.normalMap),
      (this.normalMapType = e.normalMapType),
      this.normalScale.copy(e.normalScale),
      (this.displacementMap = e.displacementMap),
      (this.displacementScale = e.displacementScale),
      (this.displacementBias = e.displacementBias),
      (this.roughnessMap = e.roughnessMap),
      (this.metalnessMap = e.metalnessMap),
      (this.alphaMap = e.alphaMap),
      (this.envMap = e.envMap),
      (this.envMapIntensity = e.envMapIntensity),
      (this.wireframe = e.wireframe),
      (this.wireframeLinewidth = e.wireframeLinewidth),
      (this.wireframeLinecap = e.wireframeLinecap),
      (this.wireframeLinejoin = e.wireframeLinejoin),
      (this.flatShading = e.flatShading),
      (this.fog = e.fog),
      this
    );
  }
}
class Qo extends Vo {
  constructor(e) {
    super(),
      (this.isMeshPhysicalMaterial = !0),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.type = "MeshPhysicalMaterial"),
      (this.anisotropyRotation = 0),
      (this.anisotropyMap = null),
      (this.clearcoatMap = null),
      (this.clearcoatRoughness = 0),
      (this.clearcoatRoughnessMap = null),
      (this.clearcoatNormalScale = new Vector2(1, 1)),
      (this.clearcoatNormalMap = null),
      (this.ior = 1.5),
      Object.defineProperty(this, "reflectivity", {
        get: function () {
          return De((2.5 * (this.ior - 1)) / (this.ior + 1), 0, 1);
        },
        set: function (e) {
          this.ior = (1 + 0.4 * e) / (1 - 0.4 * e);
        },
      }),
      (this.iridescenceMap = null),
      (this.iridescenceIOR = 1.3),
      (this.iridescenceThicknessRange = [100, 400]),
      (this.iridescenceThicknessMap = null),
      (this.sheenColor = new Color(0)),
      (this.sheenColorMap = null),
      (this.sheenRoughness = 1),
      (this.sheenRoughnessMap = null),
      (this.transmissionMap = null),
      (this.thickness = 0),
      (this.thicknessMap = null),
      (this.attenuationDistance = 1 / 0),
      (this.attenuationColor = new Color(1, 1, 1)),
      (this.specularIntensity = 1),
      (this.specularIntensityMap = null),
      (this.specularColor = new Color(1, 1, 1)),
      (this.specularColorMap = null),
      (this._anisotropy = 0),
      (this._clearcoat = 0),
      (this._iridescence = 0),
      (this._sheen = 0),
      (this._transmission = 0),
      this.setValues(e);
  }
  get anisotropy() {
    return this._anisotropy;
  }
  set anisotropy(e) {
    this._anisotropy > 0 != e > 0 && this.version++, (this._anisotropy = e);
  }
  get clearcoat() {
    return this._clearcoat;
  }
  set clearcoat(e) {
    this._clearcoat > 0 != e > 0 && this.version++, (this._clearcoat = e);
  }
  get iridescence() {
    return this._iridescence;
  }
  set iridescence(e) {
    this._iridescence > 0 != e > 0 && this.version++, (this._iridescence = e);
  }
  get sheen() {
    return this._sheen;
  }
  set sheen(e) {
    this._sheen > 0 != e > 0 && this.version++, (this._sheen = e);
  }
  get transmission() {
    return this._transmission;
  }
  set transmission(e) {
    this._transmission > 0 != e > 0 && this.version++, (this._transmission = e);
  }
  copy(e) {
    return (
      super.copy(e),
      (this.defines = { STANDARD: "", PHYSICAL: "" }),
      (this.anisotropy = e.anisotropy),
      (this.anisotropyRotation = e.anisotropyRotation),
      (this.anisotropyMap = e.anisotropyMap),
      (this.clearcoat = e.clearcoat),
      (this.clearcoatMap = e.clearcoatMap),
      (this.clearcoatRoughness = e.clearcoatRoughness),
      (this.clearcoatRoughnessMap = e.clearcoatRoughnessMap),
      (this.clearcoatNormalMap = e.clearcoatNormalMap),
      this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
      (this.ior = e.ior),
      (this.iridescence = e.iridescence),
      (this.iridescenceMap = e.iridescenceMap),
      (this.iridescenceIOR = e.iridescenceIOR),
      (this.iridescenceThicknessRange = [...e.iridescenceThicknessRange]),
      (this.iridescenceThicknessMap = e.iridescenceThicknessMap),
      (this.sheen = e.sheen),
      this.sheenColor.copy(e.sheenColor),
      (this.sheenColorMap = e.sheenColorMap),
      (this.sheenRoughness = e.sheenRoughness),
      (this.sheenRoughnessMap = e.sheenRoughnessMap),
      (this.transmission = e.transmission),
      (this.transmissionMap = e.transmissionMap),
      (this.thickness = e.thickness),
      (this.thicknessMap = e.thicknessMap),
      (this.attenuationDistance = e.attenuationDistance),
      this.attenuationColor.copy(e.attenuationColor),
      (this.specularIntensity = e.specularIntensity),
      (this.specularIntensityMap = e.specularIntensityMap),
      this.specularColor.copy(e.specularColor),
      (this.specularColorMap = e.specularColorMap),
      this
    );
  }
}
function Ho(e, t, i) {
  return Wo(e)
    ? new e.constructor(e.subarray(t, void 0 !== i ? i : e.length))
    : e.slice(t, i);
}
function jo(e, t, i) {
  return !e || (!i && e.constructor === t)
    ? e
    : "number" == typeof t.BYTES_PER_ELEMENT
    ? new t(e)
    : Array.prototype.slice.call(e);
}
function Wo(e) {
  return ArrayBuffer.isView(e) && !(e instanceof DataView);
}
function qo(e) {
  const t = e.length,
    i = new Array(t);
  for (let n = 0; n !== t; ++n) i[n] = n;
  return (
    i.sort(function (t, i) {
      return e[t] - e[i];
    }),
    i
  );
}
function Xo(e, t, i) {
  const n = e.length,
    s = new e.constructor(n);
  for (let r = 0, a = 0; a !== n; ++r) {
    const n = i[r] * t;
    for (let i = 0; i !== t; ++i) s[a++] = e[n + i];
  }
  return s;
}
function Yo(e, t, i, n) {
  let s = 1,
    r = e[0];
  for (; void 0 !== r && void 0 === r[n]; ) r = e[s++];
  if (void 0 === r) return;
  let a = r[n];
  if (void 0 !== a)
    if (Array.isArray(a))
      do {
        (a = r[n]),
          void 0 !== a && (t.push(r.time), i.push.apply(i, a)),
          (r = e[s++]);
      } while (void 0 !== r);
    else if (void 0 !== a.toArray)
      do {
        (a = r[n]),
          void 0 !== a && (t.push(r.time), a.toArray(i, i.length)),
          (r = e[s++]);
      } while (void 0 !== r);
    else
      do {
        (a = r[n]), void 0 !== a && (t.push(r.time), i.push(a)), (r = e[s++]);
      } while (void 0 !== r);
}
class Ko {
  constructor(e, t, i, n) {
    (this.parameterPositions = e),
      (this._cachedIndex = 0),
      (this.resultBuffer = void 0 !== n ? n : new t.constructor(i)),
      (this.sampleValues = t),
      (this.valueSize = i),
      (this.settings = null),
      (this.DefaultSettings_ = {});
  }
  evaluate(e) {
    const t = this.parameterPositions;
    let i = this._cachedIndex,
      n = t[i],
      s = t[i - 1];
    e: {
      t: {
        let r;
        i: {
          n: if (!(e < n)) {
            for (let r = i + 2; ; ) {
              if (void 0 === n) {
                if (e < s) break n;
                return (
                  (i = t.length),
                  (this._cachedIndex = i),
                  this.copySampleValue_(i - 1)
                );
              }
              if (i === r) break;
              if (((s = n), (n = t[++i]), e < n)) break t;
            }
            r = t.length;
            break i;
          }
          if (e >= s) break e;
          {
            const a = t[1];
            e < a && ((i = 2), (s = a));
            for (let r = i - 2; ; ) {
              if (void 0 === s)
                return (this._cachedIndex = 0), this.copySampleValue_(0);
              if (i === r) break;
              if (((n = s), (s = t[--i - 1]), e >= s)) break t;
            }
            (r = i), (i = 0);
          }
        }
        for (; i < r; ) {
          const n = (i + r) >>> 1;
          e < t[n] ? (r = n) : (i = n + 1);
        }
        if (((n = t[i]), (s = t[i - 1]), void 0 === s))
          return (this._cachedIndex = 0), this.copySampleValue_(0);
        if (void 0 === n)
          return (
            (i = t.length),
            (this._cachedIndex = i),
            this.copySampleValue_(i - 1)
          );
      }
      (this._cachedIndex = i), this.intervalChanged_(i, s, n);
    }
    return this.interpolate_(i, s, e, n);
  }
  getSettings_() {
    return this.settings || this.DefaultSettings_;
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      n = this.valueSize,
      s = e * n;
    for (let r = 0; r !== n; ++r) t[r] = i[s + r];
    return t;
  }
  interpolate_() {
    throw new Error("call to abstract method");
  }
  intervalChanged_() {}
}
class Zo extends Ko {
  constructor(e, t, i, n) {
    super(e, t, i, n),
      (this._weightPrev = -0),
      (this._offsetPrev = -0),
      (this._weightNext = -0),
      (this._offsetNext = -0),
      (this.DefaultSettings_ = { endingStart: le, endingEnd: le });
  }
  intervalChanged_(e, t, i) {
    const n = this.parameterPositions;
    let s = e - 2,
      r = e + 1,
      a = n[s],
      o = n[r];
    if (void 0 === a)
      switch (this.getSettings_().endingStart) {
        case he:
          (s = e), (a = 2 * t - i);
          break;
        case ce:
          (s = n.length - 2), (a = t + n[s] - n[s + 1]);
          break;
        default:
          (s = e), (a = i);
      }
    if (void 0 === o)
      switch (this.getSettings_().endingEnd) {
        case he:
          (r = e), (o = 2 * i - t);
          break;
        case ce:
          (r = 1), (o = i + n[1] - n[0]);
          break;
        default:
          (r = e - 1), (o = t);
      }
    const l = 0.5 * (i - t),
      h = this.valueSize;
    (this._weightPrev = l / (t - a)),
      (this._weightNext = l / (o - i)),
      (this._offsetPrev = s * h),
      (this._offsetNext = r * h);
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      a = this.valueSize,
      o = e * a,
      l = o - a,
      h = this._offsetPrev,
      c = this._offsetNext,
      u = this._weightPrev,
      d = this._weightNext,
      p = (i - t) / (n - t),
      f = p * p,
      m = f * p,
      g = -u * m + 2 * u * f - u * p,
      _ = (1 + u) * m + (-1.5 - 2 * u) * f + (-0.5 + u) * p + 1,
      v = (-1 - d) * m + (1.5 + d) * f + 0.5 * p,
      A = d * m - d * f;
    for (let y = 0; y !== a; ++y)
      s[y] = g * r[h + y] + _ * r[l + y] + v * r[o + y] + A * r[c + y];
    return s;
  }
}
class Jo extends Ko {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      a = this.valueSize,
      o = e * a,
      l = o - a,
      h = (i - t) / (n - t),
      c = 1 - h;
    for (let u = 0; u !== a; ++u) s[u] = r[l + u] * c + r[o + u] * h;
    return s;
  }
}
class $o extends Ko {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e) {
    return this.copySampleValue_(e - 1);
  }
}
class el {
  constructor(e, t, i, n) {
    if (void 0 === e)
      throw new Error("THREE.KeyframeTrack: track name is undefined");
    if (void 0 === t || 0 === t.length)
      throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
    (this.name = e),
      (this.times = jo(t, this.TimeBufferType)),
      (this.values = jo(i, this.ValueBufferType)),
      this.setInterpolation(n || this.DefaultInterpolation);
  }
  static toJSON(e) {
    const t = e.constructor;
    let i;
    if (t.toJSON !== this.toJSON) i = t.toJSON(e);
    else {
      i = {
        name: e.name,
        times: jo(e.times, Array),
        values: jo(e.values, Array),
      };
      const t = e.getInterpolation();
      t !== e.DefaultInterpolation && (i.interpolation = t);
    }
    return (i.type = e.ValueTypeName), i;
  }
  InterpolantFactoryMethodDiscrete(e) {
    return new $o(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodLinear(e) {
    return new Jo(this.times, this.values, this.getValueSize(), e);
  }
  InterpolantFactoryMethodSmooth(e) {
    return new Zo(this.times, this.values, this.getValueSize(), e);
  }
  setInterpolation(e) {
    let t;
    switch (e) {
      case re:
        t = this.InterpolantFactoryMethodDiscrete;
        break;
      case ae:
        t = this.InterpolantFactoryMethodLinear;
        break;
      case oe:
        t = this.InterpolantFactoryMethodSmooth;
    }
    if (void 0 === t) {
      const t =
        "unsupported interpolation for " +
        this.ValueTypeName +
        " keyframe track named " +
        this.name;
      if (void 0 === this.createInterpolant) {
        if (e === this.DefaultInterpolation) throw new Error(t);
        this.setInterpolation(this.DefaultInterpolation);
      }
      return console.warn("THREE.KeyframeTrack:", t), this;
    }
    return (this.createInterpolant = t), this;
  }
  getInterpolation() {
    switch (this.createInterpolant) {
      case this.InterpolantFactoryMethodDiscrete:
        return re;
      case this.InterpolantFactoryMethodLinear:
        return ae;
      case this.InterpolantFactoryMethodSmooth:
        return oe;
    }
  }
  getValueSize() {
    return this.values.length / this.times.length;
  }
  shift(e) {
    if (0 !== e) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i) t[i] += e;
    }
    return this;
  }
  scale(e) {
    if (1 !== e) {
      const t = this.times;
      for (let i = 0, n = t.length; i !== n; ++i) t[i] *= e;
    }
    return this;
  }
  trim(e, t) {
    const i = this.times,
      n = i.length;
    let s = 0,
      r = n - 1;
    for (; s !== n && i[s] < e; ) ++s;
    for (; -1 !== r && i[r] > t; ) --r;
    if ((++r, 0 !== s || r !== n)) {
      s >= r && ((r = Math.max(r, 1)), (s = r - 1));
      const e = this.getValueSize();
      (this.times = Ho(i, s, r)), (this.values = Ho(this.values, s * e, r * e));
    }
    return this;
  }
  validate() {
    let e = !0;
    const t = this.getValueSize();
    t - Math.floor(t) != 0 &&
      (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
      (e = !1));
    const i = this.times,
      n = this.values,
      s = i.length;
    0 === s &&
      (console.error("THREE.KeyframeTrack: Track is empty.", this), (e = !1));
    let r = null;
    for (let a = 0; a !== s; a++) {
      const t = i[a];
      if ("number" == typeof t && isNaN(t)) {
        console.error(
          "THREE.KeyframeTrack: Time is not a valid number.",
          this,
          a,
          t
        ),
          (e = !1);
        break;
      }
      if (null !== r && r > t) {
        console.error("THREE.KeyframeTrack: Out of order keys.", this, a, t, r),
          (e = !1);
        break;
      }
      r = t;
    }
    if (void 0 !== n && Wo(n))
      for (let a = 0, o = n.length; a !== o; ++a) {
        const t = n[a];
        if (isNaN(t)) {
          console.error(
            "THREE.KeyframeTrack: Value is not a valid number.",
            this,
            a,
            t
          ),
            (e = !1);
          break;
        }
      }
    return e;
  }
  optimize() {
    const e = Ho(this.times),
      t = Ho(this.values),
      i = this.getValueSize(),
      n = this.getInterpolation() === oe,
      s = e.length - 1;
    let r = 1;
    for (let a = 1; a < s; ++a) {
      let s = !1;
      const o = e[a];
      if (o !== e[a + 1] && (1 !== a || o !== e[0]))
        if (n) s = !0;
        else {
          const e = a * i,
            n = e - i,
            r = e + i;
          for (let a = 0; a !== i; ++a) {
            const i = t[e + a];
            if (i !== t[n + a] || i !== t[r + a]) {
              s = !0;
              break;
            }
          }
        }
      if (s) {
        if (a !== r) {
          e[r] = e[a];
          const n = a * i,
            s = r * i;
          for (let e = 0; e !== i; ++e) t[s + e] = t[n + e];
        }
        ++r;
      }
    }
    if (s > 0) {
      e[r] = e[s];
      for (let e = s * i, n = r * i, a = 0; a !== i; ++a) t[n + a] = t[e + a];
      ++r;
    }
    return (
      r !== e.length
        ? ((this.times = Ho(e, 0, r)), (this.values = Ho(t, 0, r * i)))
        : ((this.times = e), (this.values = t)),
      this
    );
  }
  clone() {
    const e = Ho(this.times, 0),
      t = Ho(this.values, 0),
      i = new (0, this.constructor)(this.name, e, t);
    return (i.createInterpolant = this.createInterpolant), i;
  }
}
(el.prototype.TimeBufferType = Float32Array),
  (el.prototype.ValueBufferType = Float32Array),
  (el.prototype.DefaultInterpolation = ae);
class tl extends el {}
(tl.prototype.ValueTypeName = "bool"),
  (tl.prototype.ValueBufferType = Array),
  (tl.prototype.DefaultInterpolation = re),
  (tl.prototype.InterpolantFactoryMethodLinear = void 0),
  (tl.prototype.InterpolantFactoryMethodSmooth = void 0);
class il extends el {}
il.prototype.ValueTypeName = "color";
class nl extends el {}
nl.prototype.ValueTypeName = "number";
class sl extends Ko {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      a = this.valueSize,
      o = (i - t) / (n - t);
    let l = e * a;
    for (let h = l + a; l !== h; l += 4)
      Quaternion.slerpFlat(s, 0, r, l - a, r, l, o);
    return s;
  }
}
class rl extends el {
  InterpolantFactoryMethodLinear(e) {
    return new sl(this.times, this.values, this.getValueSize(), e);
  }
}
(rl.prototype.ValueTypeName = "quaternion"),
  (rl.prototype.DefaultInterpolation = ae),
  (rl.prototype.InterpolantFactoryMethodSmooth = void 0);
class al extends el {}
(al.prototype.ValueTypeName = "string"),
  (al.prototype.ValueBufferType = Array),
  (al.prototype.DefaultInterpolation = re),
  (al.prototype.InterpolantFactoryMethodLinear = void 0),
  (al.prototype.InterpolantFactoryMethodSmooth = void 0);
class ol extends el {}
ol.prototype.ValueTypeName = "vector";
class ll {
  constructor(e, t = -1, i, n = 2500) {
    (this.name = e),
      (this.tracks = i),
      (this.duration = t),
      (this.blendMode = n),
      (this.uuid = Pe()),
      this.duration < 0 && this.resetDuration();
  }
  static parse(e) {
    const t = [],
      i = e.tracks,
      n = 1 / (e.fps || 1);
    for (let r = 0, a = i.length; r !== a; ++r) t.push(hl(i[r]).scale(n));
    const s = new this(e.name, e.duration, t, e.blendMode);
    return (s.uuid = e.uuid), s;
  }
  static toJSON(e) {
    const t = [],
      i = e.tracks,
      n = {
        name: e.name,
        duration: e.duration,
        tracks: t,
        uuid: e.uuid,
        blendMode: e.blendMode,
      };
    for (let s = 0, r = i.length; s !== r; ++s) t.push(el.toJSON(i[s]));
    return n;
  }
  static CreateFromMorphTargetSequence(e, t, i, n) {
    const s = t.length,
      r = [];
    for (let a = 0; a < s; a++) {
      let e = [],
        o = [];
      e.push((a + s - 1) % s, a, (a + 1) % s), o.push(0, 1, 0);
      const l = qo(e);
      (e = Xo(e, 1, l)),
        (o = Xo(o, 1, l)),
        n || 0 !== e[0] || (e.push(s), o.push(o[0])),
        r.push(
          new nl(".morphTargetInfluences[" + t[a].name + "]", e, o).scale(1 / i)
        );
    }
    return new this(e, -1, r);
  }
  static findByName(e, t) {
    let i = e;
    if (!Array.isArray(e)) {
      const t = e;
      i = (t.geometry && t.geometry.animations) || t.animations;
    }
    for (let n = 0; n < i.length; n++) if (i[n].name === t) return i[n];
    return null;
  }
  static CreateClipsFromMorphTargetSequences(e, t, i) {
    const n = {},
      s = /^([\w-]*?)([\d]+)$/;
    for (let a = 0, o = e.length; a < o; a++) {
      const t = e[a],
        i = t.name.match(s);
      if (i && i.length > 1) {
        const e = i[1];
        let s = n[e];
        s || (n[e] = s = []), s.push(t);
      }
    }
    const r = [];
    for (const a in n)
      r.push(this.CreateFromMorphTargetSequence(a, n[a], t, i));
    return r;
  }
  static parseAnimation(e, t) {
    if (!e)
      return (
        console.error("THREE.AnimationClip: No animation in JSONLoader data."),
        null
      );
    const i = function (e, t, i, n, s) {
        if (0 !== i.length) {
          const r = [],
            a = [];
          Yo(i, r, a, n), 0 !== r.length && s.push(new e(t, r, a));
        }
      },
      n = [],
      s = e.name || "default",
      r = e.fps || 30,
      a = e.blendMode;
    let o = e.length || -1;
    const l = e.hierarchy || [];
    for (let h = 0; h < l.length; h++) {
      const e = l[h].keys;
      if (e && 0 !== e.length)
        if (e[0].morphTargets) {
          const t = {};
          let i;
          for (i = 0; i < e.length; i++)
            if (e[i].morphTargets)
              for (let n = 0; n < e[i].morphTargets.length; n++)
                t[e[i].morphTargets[n]] = -1;
          for (const s in t) {
            const t = [],
              r = [];
            for (let n = 0; n !== e[i].morphTargets.length; ++n) {
              const n = e[i];
              t.push(n.time), r.push(n.morphTarget === s ? 1 : 0);
            }
            n.push(new nl(".morphTargetInfluence[" + s + "]", t, r));
          }
          o = t.length * r;
        } else {
          const s = ".bones[" + t[h].name + "]";
          i(ol, s + ".position", e, "pos", n),
            i(rl, s + ".quaternion", e, "rot", n),
            i(ol, s + ".scale", e, "scl", n);
        }
    }
    if (0 === n.length) return null;
    return new this(s, o, n, a);
  }
  resetDuration() {
    let e = 0;
    for (let t = 0, i = this.tracks.length; t !== i; ++t) {
      const i = this.tracks[t];
      e = Math.max(e, i.times[i.times.length - 1]);
    }
    return (this.duration = e), this;
  }
  trim() {
    for (let e = 0; e < this.tracks.length; e++)
      this.tracks[e].trim(0, this.duration);
    return this;
  }
  validate() {
    let e = !0;
    for (let t = 0; t < this.tracks.length; t++)
      e = e && this.tracks[t].validate();
    return e;
  }
  optimize() {
    for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
    return this;
  }
  clone() {
    const e = [];
    for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
    return new this.constructor(this.name, this.duration, e, this.blendMode);
  }
  toJSON() {
    return this.constructor.toJSON(this);
  }
}
function hl(e) {
  if (void 0 === e.type)
    throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
  const t = (function (e) {
    switch (e.toLowerCase()) {
      case "scalar":
      case "double":
      case "float":
      case "number":
      case "integer":
        return nl;
      case "vector":
      case "vector2":
      case "vector3":
      case "vector4":
        return ol;
      case "color":
        return il;
      case "quaternion":
        return rl;
      case "bool":
      case "boolean":
        return tl;
      case "string":
        return al;
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + e);
  })(e.type);
  if (void 0 === e.times) {
    const t = [],
      i = [];
    Yo(e.keys, t, i, "value"), (e.times = t), (e.values = i);
  }
  return void 0 !== t.parse
    ? t.parse(e)
    : new t(e.name, e.times, e.values, e.interpolation);
}
const cl = {
  enabled: !1,
  files: {},
  add: function (e, t) {
    !1 !== this.enabled && (this.files[e] = t);
  },
  get: function (e) {
    if (!1 !== this.enabled) return this.files[e];
  },
  remove: function (e) {
    delete this.files[e];
  },
  clear: function () {
    this.files = {};
  },
};
class ul {
  constructor(e, t, i) {
    const n = this;
    let s,
      r = !1,
      a = 0,
      o = 0;
    const l = [];
    (this.onStart = void 0),
      (this.onLoad = e),
      (this.onProgress = t),
      (this.onError = i),
      (this.itemStart = function (e) {
        o++, !1 === r && void 0 !== n.onStart && n.onStart(e, a, o), (r = !0);
      }),
      (this.itemEnd = function (e) {
        a++,
          void 0 !== n.onProgress && n.onProgress(e, a, o),
          a === o && ((r = !1), void 0 !== n.onLoad && n.onLoad());
      }),
      (this.itemError = function (e) {
        void 0 !== n.onError && n.onError(e);
      }),
      (this.resolveURL = function (e) {
        return s ? s(e) : e;
      }),
      (this.setURLModifier = function (e) {
        return (s = e), this;
      }),
      (this.addHandler = function (e, t) {
        return l.push(e, t), this;
      }),
      (this.removeHandler = function (e) {
        const t = l.indexOf(e);
        return -1 !== t && l.splice(t, 2), this;
      }),
      (this.getHandler = function (e) {
        for (let t = 0, i = l.length; t < i; t += 2) {
          const i = l[t],
            n = l[t + 1];
          if ((i.global && (i.lastIndex = 0), i.test(e))) return n;
        }
        return null;
      });
  }
}
const dl = new ul();
class pl {
  constructor(e) {
    (this.manager = void 0 !== e ? e : dl),
      (this.crossOrigin = "anonymous"),
      (this.withCredentials = !1),
      (this.path = ""),
      (this.resourcePath = ""),
      (this.requestHeader = {});
  }
  load() {}
  loadAsync(e, t) {
    const i = this;
    return new Promise(function (n, s) {
      i.load(e, n, t, s);
    });
  }
  parse() {}
  setCrossOrigin(e) {
    return (this.crossOrigin = e), this;
  }
  setWithCredentials(e) {
    return (this.withCredentials = e), this;
  }
  setPath(e) {
    return (this.path = e), this;
  }
  setResourcePath(e) {
    return (this.resourcePath = e), this;
  }
  setRequestHeader(e) {
    return (this.requestHeader = e), this;
  }
}
pl.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const fl = {};
class ml extends Error {
  constructor(e, t) {
    super(e), (this.response = t);
  }
}
class gl extends pl {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    void 0 === e && (e = ""),
      void 0 !== this.path && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = cl.get(e);
    if (void 0 !== s)
      return (
        this.manager.itemStart(e),
        setTimeout(() => {
          t && t(s), this.manager.itemEnd(e);
        }, 0),
        s
      );
    if (void 0 !== fl[e])
      return void fl[e].push({ onLoad: t, onProgress: i, onError: n });
    (fl[e] = []), fl[e].push({ onLoad: t, onProgress: i, onError: n });
    const r = new Request(e, {
        headers: new Headers(this.requestHeader),
        credentials: this.withCredentials ? "include" : "same-origin",
      }),
      a = this.mimeType,
      o = this.responseType;
    fetch(r)
      .then((t) => {
        if (200 === t.status || 0 === t.status) {
          if (
            (0 === t.status &&
              console.warn("THREE.FileLoader: HTTP Status 0 received."),
            "undefined" == typeof ReadableStream ||
              void 0 === t.body ||
              void 0 === t.body.getReader)
          )
            return t;
          const i = fl[e],
            n = t.body.getReader(),
            s = t.headers.get("Content-Length") || t.headers.get("X-File-Size"),
            r = s ? parseInt(s) : 0,
            a = 0 !== r;
          let o = 0;
          const l = new ReadableStream({
            start(e) {
              !(function t() {
                n.read().then(({ done: n, value: s }) => {
                  if (n) e.close();
                  else {
                    o += s.byteLength;
                    const n = new ProgressEvent("progress", {
                      lengthComputable: a,
                      loaded: o,
                      total: r,
                    });
                    for (let e = 0, t = i.length; e < t; e++) {
                      const t = i[e];
                      t.onProgress && t.onProgress(n);
                    }
                    e.enqueue(s), t();
                  }
                });
              })();
            },
          });
          return new Response(l);
        }
        throw new ml(
          `fetch for "${t.url}" responded with ${t.status}: ${t.statusText}`,
          t
        );
      })
      .then((e) => {
        switch (o) {
          case "arraybuffer":
            return e.arrayBuffer();
          case "blob":
            return e.blob();
          case "document":
            return e.text().then((e) => new DOMParser().parseFromString(e, a));
          case "json":
            return e.json();
          default:
            if (void 0 === a) return e.text();
            {
              const t = /charset="?([^;"\s]*)"?/i.exec(a),
                i = t && t[1] ? t[1].toLowerCase() : void 0,
                n = new TextDecoder(i);
              return e.arrayBuffer().then((e) => n.decode(e));
            }
        }
      })
      .then((t) => {
        cl.add(e, t);
        const i = fl[e];
        delete fl[e];
        for (let e = 0, n = i.length; e < n; e++) {
          const n = i[e];
          n.onLoad && n.onLoad(t);
        }
      })
      .catch((t) => {
        const i = fl[e];
        if (void 0 === i) throw (this.manager.itemError(e), t);
        delete fl[e];
        for (let e = 0, n = i.length; e < n; e++) {
          const n = i[e];
          n.onError && n.onError(t);
        }
        this.manager.itemError(e);
      })
      .finally(() => {
        this.manager.itemEnd(e);
      }),
      this.manager.itemStart(e);
  }
  setResponseType(e) {
    return (this.responseType = e), this;
  }
  setMimeType(e) {
    return (this.mimeType = e), this;
  }
}
class _l extends pl {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    void 0 !== this.path && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      r = cl.get(e);
    if (void 0 !== r)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(r), s.manager.itemEnd(e);
        }, 0),
        r
      );
    const a = createElement("img");
    function o() {
      h(), cl.add(e, this), t && t(this), s.manager.itemEnd(e);
    }
    function l(t) {
      h(), n && n(t), s.manager.itemError(e), s.manager.itemEnd(e);
    }
    function h() {
      a.removeEventListener("load", o, !1),
        a.removeEventListener("error", l, !1);
    }
    return (
      a.addEventListener("load", o, !1),
      a.addEventListener("error", l, !1),
      "data:" !== e.slice(0, 5) &&
        void 0 !== this.crossOrigin &&
        (a.crossOrigin = this.crossOrigin),
      s.manager.itemStart(e),
      (a.src = e),
      a
    );
  }
}
class vl extends pl {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const s = new Nn();
    s.colorSpace = me;
    const r = new _l(this.manager);
    r.setCrossOrigin(this.crossOrigin), r.setPath(this.path);
    let a = 0;
    function o(i) {
      r.load(
        e[i],
        function (e) {
          (s.images[i] = e), a++, 6 === a && ((s.needsUpdate = !0), t && t(s));
        },
        void 0,
        n
      );
    }
    for (let l = 0; l < e.length; ++l) o(l);
    return s;
  }
}
class Al extends pl {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const s = this,
      r = new Va(),
      a = new gl(this.manager);
    return (
      a.setResponseType("arraybuffer"),
      a.setRequestHeader(this.requestHeader),
      a.setPath(this.path),
      a.setWithCredentials(s.withCredentials),
      a.load(
        e,
        function (e) {
          let i;
          try {
            i = s.parse(e);
          } catch (a) {
            if (void 0 === n) return void console.error(a);
            n(a);
          }
          void 0 !== i.image
            ? (r.image = i.image)
            : void 0 !== i.data &&
              ((r.image.width = i.width),
              (r.image.height = i.height),
              (r.image.data = i.data)),
            (r.wrapS = void 0 !== i.wrapS ? i.wrapS : T),
            (r.wrapT = void 0 !== i.wrapT ? i.wrapT : T),
            (r.magFilter = void 0 !== i.magFilter ? i.magFilter : L),
            (r.minFilter = void 0 !== i.minFilter ? i.minFilter : L),
            (r.anisotropy = void 0 !== i.anisotropy ? i.anisotropy : 1),
            void 0 !== i.colorSpace
              ? (r.colorSpace = i.colorSpace)
              : void 0 !== i.encoding && (r.encoding = i.encoding),
            void 0 !== i.flipY && (r.flipY = i.flipY),
            void 0 !== i.format && (r.format = i.format),
            void 0 !== i.type && (r.type = i.type),
            void 0 !== i.mipmaps &&
              ((r.mipmaps = i.mipmaps), (r.minFilter = N)),
            1 === i.mipmapCount && (r.minFilter = L),
            void 0 !== i.generateMipmaps &&
              (r.generateMipmaps = i.generateMipmaps),
            (r.needsUpdate = !0),
            t && t(r, i);
        },
        i,
        n
      ),
      r
    );
  }
}
class yl extends pl {
  constructor(e) {
    super(e);
  }
  load(e, t, i, n) {
    const s = new Texture(),
      r = new _l(this.manager);
    return (
      r.setCrossOrigin(this.crossOrigin),
      r.setPath(this.path),
      r.load(
        e,
        function (e) {
          (s.image = e), (s.needsUpdate = !0), void 0 !== t && t(s);
        },
        i,
        n
      ),
      s
    );
  }
}
class xl extends Object3D {
  constructor(e, t = 1) {
    super(),
      (this.isLight = !0),
      (this.type = "Light"),
      (this.color = new Color(e)),
      (this.intensity = t);
  }
  dispose() {}
  copy(e, t) {
    return (
      super.copy(e, t),
      this.color.copy(e.color),
      (this.intensity = e.intensity),
      this
    );
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.object.color = this.color.getHex()),
      (t.object.intensity = this.intensity),
      void 0 !== this.groundColor &&
        (t.object.groundColor = this.groundColor.getHex()),
      void 0 !== this.distance && (t.object.distance = this.distance),
      void 0 !== this.angle && (t.object.angle = this.angle),
      void 0 !== this.decay && (t.object.decay = this.decay),
      void 0 !== this.penumbra && (t.object.penumbra = this.penumbra),
      void 0 !== this.shadow && (t.object.shadow = this.shadow.toJSON()),
      t
    );
  }
}
class bl extends xl {
  constructor(e, t, i) {
    super(e, i),
      (this.isHemisphereLight = !0),
      (this.type = "HemisphereLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.groundColor = new Color(t));
  }
  copy(e, t) {
    return super.copy(e, t), this.groundColor.copy(e.groundColor), this;
  }
}
const El = new Matrix4(),
  Sl = new Vector3(),
  Cl = new Vector3();
class Ml {
  constructor(e) {
    (this.camera = e),
      (this.bias = 0),
      (this.normalBias = 0),
      (this.radius = 1),
      (this.blurSamples = 8),
      (this.mapSize = new Vector2(512, 512)),
      (this.map = null),
      (this.mapPass = null),
      (this.matrix = new Matrix4()),
      (this.autoUpdate = !0),
      (this.needsUpdate = !1),
      (this._frustum = new Frustum()),
      (this._frameExtents = new Vector2(1, 1)),
      (this._viewportCount = 1),
      (this._viewports = [new Vector4(0, 0, 1, 1)]);
  }
  getViewportCount() {
    return this._viewportCount;
  }
  getFrustum() {
    return this._frustum;
  }
  updateMatrices(e) {
    const t = this.camera,
      i = this.matrix;
    Sl.setFromMatrixPosition(e.matrixWorld),
      t.position.copy(Sl),
      Cl.setFromMatrixPosition(e.target.matrixWorld),
      t.lookAt(Cl),
      t.updateMatrixWorld(),
      El.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(El),
      i.set(0.5, 0, 0, 0.5, 0, 0.5, 0, 0.5, 0, 0, 0.5, 0.5, 0, 0, 0, 1),
      i.multiply(El);
  }
  getViewport(e) {
    return this._viewports[e];
  }
  getFrameExtents() {
    return this._frameExtents;
  }
  dispose() {
    this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose();
  }
  copy(e) {
    return (
      (this.camera = e.camera.clone()),
      (this.bias = e.bias),
      (this.radius = e.radius),
      this.mapSize.copy(e.mapSize),
      this
    );
  }
  clone() {
    return new this.constructor().copy(this);
  }
  toJSON() {
    const e = {};
    return (
      0 !== this.bias && (e.bias = this.bias),
      0 !== this.normalBias && (e.normalBias = this.normalBias),
      1 !== this.radius && (e.radius = this.radius),
      (512 === this.mapSize.x && 512 === this.mapSize.y) ||
        (e.mapSize = this.mapSize.toArray()),
      (e.camera = this.camera.toJSON(!1).object),
      delete e.camera.matrix,
      e
    );
  }
}
class wl extends Ml {
  constructor() {
    super(new Dn(50, 1, 0.5, 500)),
      (this.isSpotLightShadow = !0),
      (this.focus = 1);
  }
  updateMatrices(e) {
    const t = this.camera,
      i = 2 * Re * e.angle * this.focus,
      n = this.mapSize.width / this.mapSize.height,
      s = e.distance || t.far;
    (i === t.fov && n === t.aspect && s === t.far) ||
      ((t.fov = i), (t.aspect = n), (t.far = s), t.updateProjectionMatrix()),
      super.updateMatrices(e);
  }
  copy(e) {
    return super.copy(e), (this.focus = e.focus), this;
  }
}
class Tl extends xl {
  constructor(e, t, i = 0, n = Math.PI / 3, s = 0, r = 2) {
    super(e, t),
      (this.isSpotLight = !0),
      (this.type = "SpotLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.distance = i),
      (this.angle = n),
      (this.penumbra = s),
      (this.decay = r),
      (this.map = null),
      (this.shadow = new wl());
  }
  get power() {
    return this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / Math.PI;
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.angle = e.angle),
      (this.penumbra = e.penumbra),
      (this.decay = e.decay),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
const Il = new Matrix4(),
  Rl = new Vector3(),
  Pl = new Vector3();
class Dl extends Ml {
  constructor() {
    super(new Dn(90, 1, 0.5, 500)),
      (this.isPointLightShadow = !0),
      (this._frameExtents = new Vector2(4, 2)),
      (this._viewportCount = 6),
      (this._viewports = [
        new Vector4(2, 1, 1, 1),
        new Vector4(0, 1, 1, 1),
        new Vector4(3, 1, 1, 1),
        new Vector4(1, 1, 1, 1),
        new Vector4(3, 0, 1, 1),
        new Vector4(1, 0, 1, 1),
      ]),
      (this._cubeDirections = [
        new Vector3(1, 0, 0),
        new Vector3(-1, 0, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
        new Vector3(0, 1, 0),
        new Vector3(0, -1, 0),
      ]),
      (this._cubeUps = [
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 1, 0),
        new Vector3(0, 0, 1),
        new Vector3(0, 0, -1),
      ]);
  }
  updateMatrices(e, t = 0) {
    const i = this.camera,
      n = this.matrix,
      s = e.distance || i.far;
    s !== i.far && ((i.far = s), i.updateProjectionMatrix()),
      Rl.setFromMatrixPosition(e.matrixWorld),
      i.position.copy(Rl),
      Pl.copy(i.position),
      Pl.add(this._cubeDirections[t]),
      i.up.copy(this._cubeUps[t]),
      i.lookAt(Pl),
      i.updateMatrixWorld(),
      n.makeTranslation(-Rl.x, -Rl.y, -Rl.z),
      Il.multiplyMatrices(i.projectionMatrix, i.matrixWorldInverse),
      this._frustum.setFromProjectionMatrix(Il);
  }
}
class Ll extends xl {
  constructor(e, t, i = 0, n = 2) {
    super(e, t),
      (this.isPointLight = !0),
      (this.type = "PointLight"),
      (this.distance = i),
      (this.decay = n),
      (this.shadow = new Dl());
  }
  get power() {
    return 4 * this.intensity * Math.PI;
  }
  set power(e) {
    this.intensity = e / (4 * Math.PI);
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e, t) {
    return (
      super.copy(e, t),
      (this.distance = e.distance),
      (this.decay = e.decay),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Fl extends Ml {
  constructor() {
    super(new ns(-5, 5, 5, -5, 0.5, 500)), (this.isDirectionalLightShadow = !0);
  }
}
class Nl extends xl {
  constructor(e, t) {
    super(e, t),
      (this.isDirectionalLight = !0),
      (this.type = "DirectionalLight"),
      this.position.copy(Object3D.DEFAULT_UP),
      this.updateMatrix(),
      (this.target = new Object3D()),
      (this.shadow = new Fl());
  }
  dispose() {
    this.shadow.dispose();
  }
  copy(e) {
    return (
      super.copy(e),
      (this.target = e.target.clone()),
      (this.shadow = e.shadow.clone()),
      this
    );
  }
}
class Bl {
  static decodeText(e) {
    if ("undefined" != typeof TextDecoder) return new TextDecoder().decode(e);
    let t = "";
    for (let i = 0, n = e.length; i < n; i++) t += String.fromCharCode(e[i]);
    try {
      return decodeURIComponent(escape(t));
    } catch (Ym) {
      return t;
    }
  }
  static extractUrlBase(e) {
    const t = e.lastIndexOf("/");
    return -1 === t ? "./" : e.slice(0, t + 1);
  }
  static resolveURL(e, t) {
    return "string" != typeof e || "" === e
      ? ""
      : (/^https?:\/\//i.test(t) &&
          /^\//.test(e) &&
          (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) ||
        /^data:.*,.*$/i.test(e) ||
        /^blob:.*$/i.test(e)
          ? e
          : t + e);
  }
}
class kl extends rn {
  constructor() {
    super(),
      (this.isInstancedBufferGeometry = !0),
      (this.type = "InstancedBufferGeometry"),
      (this.instanceCount = 1 / 0);
  }
  copy(e) {
    return super.copy(e), (this.instanceCount = e.instanceCount), this;
  }
  toJSON() {
    const e = super.toJSON();
    return (
      (e.instanceCount = this.instanceCount),
      (e.isInstancedBufferGeometry = !0),
      e
    );
  }
}
class Ol extends pl {
  constructor(e) {
    super(e),
      (this.isImageBitmapLoader = !0),
      "undefined" == typeof createImageBitmap &&
        console.warn(
          "THREE.ImageBitmapLoader: createImageBitmap() not supported."
        ),
      "undefined" == typeof fetch &&
        console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
      (this.options = { premultiplyAlpha: "none" });
  }
  setOptions(e) {
    return (this.options = e), this;
  }
  load(e, t, i, n) {
    void 0 === e && (e = ""),
      void 0 !== this.path && (e = this.path + e),
      (e = this.manager.resolveURL(e));
    const s = this,
      r = cl.get(e);
    if (void 0 !== r)
      return (
        s.manager.itemStart(e),
        setTimeout(function () {
          t && t(r), s.manager.itemEnd(e);
        }, 0),
        r
      );
    const a = {};
    (a.credentials =
      "anonymous" === this.crossOrigin ? "same-origin" : "include"),
      (a.headers = this.requestHeader),
      fetch(e, a)
        .then(function (e) {
          return e.blob();
        })
        .then(function (e) {
          return createImageBitmap(
            e,
            Object.assign(s.options, { colorSpaceConversion: "none" })
          );
        })
        .then(function (i) {
          cl.add(e, i), t && t(i), s.manager.itemEnd(e);
        })
        .catch(function (t) {
          n && n(t), s.manager.itemError(e), s.manager.itemEnd(e);
        }),
      s.manager.itemStart(e);
  }
}
class Ul {
  constructor(e = !0) {
    (this.autoStart = e),
      (this.startTime = 0),
      (this.oldTime = 0),
      (this.elapsedTime = 0),
      (this.running = !1);
  }
  start() {
    (this.startTime = zl()),
      (this.oldTime = this.startTime),
      (this.elapsedTime = 0),
      (this.running = !0);
  }
  stop() {
    this.getElapsedTime(), (this.running = !1), (this.autoStart = !1);
  }
  getElapsedTime() {
    return this.getDelta(), this.elapsedTime;
  }
  getDelta() {
    let e = 0;
    if (this.autoStart && !this.running) return this.start(), 0;
    if (this.running) {
      const t = zl();
      (e = (t - this.oldTime) / 1e3),
        (this.oldTime = t),
        (this.elapsedTime += e);
    }
    return e;
  }
}
function zl() {
  return ("undefined" == typeof performance ? Date : performance).now();
}
class Gl {
  constructor(e, t, i) {
    let n, s, r;
    switch (((this.binding = e), (this.valueSize = i), t)) {
      case "quaternion":
        (n = this._slerp),
          (s = this._slerpAdditive),
          (r = this._setAdditiveIdentityQuaternion),
          (this.buffer = new Float64Array(6 * i)),
          (this._workIndex = 5);
        break;
      case "string":
      case "bool":
        (n = this._select),
          (s = this._select),
          (r = this._setAdditiveIdentityOther),
          (this.buffer = new Array(5 * i));
        break;
      default:
        (n = this._lerp),
          (s = this._lerpAdditive),
          (r = this._setAdditiveIdentityNumeric),
          (this.buffer = new Float64Array(5 * i));
    }
    (this._mixBufferRegion = n),
      (this._mixBufferRegionAdditive = s),
      (this._setIdentity = r),
      (this._origIndex = 3),
      (this._addIndex = 4),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0),
      (this.useCount = 0),
      (this.referenceCount = 0);
  }
  accumulate(e, t) {
    const i = this.buffer,
      n = this.valueSize,
      s = e * n + n;
    let r = this.cumulativeWeight;
    if (0 === r) {
      for (let e = 0; e !== n; ++e) i[s + e] = i[e];
      r = t;
    } else {
      r += t;
      const e = t / r;
      this._mixBufferRegion(i, s, 0, e, n);
    }
    this.cumulativeWeight = r;
  }
  accumulateAdditive(e) {
    const t = this.buffer,
      i = this.valueSize,
      n = i * this._addIndex;
    0 === this.cumulativeWeightAdditive && this._setIdentity(),
      this._mixBufferRegionAdditive(t, n, 0, e, i),
      (this.cumulativeWeightAdditive += e);
  }
  apply(e) {
    const t = this.valueSize,
      i = this.buffer,
      n = e * t + t,
      s = this.cumulativeWeight,
      r = this.cumulativeWeightAdditive,
      a = this.binding;
    if (
      ((this.cumulativeWeight = 0), (this.cumulativeWeightAdditive = 0), s < 1)
    ) {
      const e = t * this._origIndex;
      this._mixBufferRegion(i, n, e, 1 - s, t);
    }
    r > 0 && this._mixBufferRegionAdditive(i, n, this._addIndex * t, 1, t);
    for (let o = t, l = t + t; o !== l; ++o)
      if (i[o] !== i[o + t]) {
        a.setValue(i, n);
        break;
      }
  }
  saveOriginalState() {
    const e = this.binding,
      t = this.buffer,
      i = this.valueSize,
      n = i * this._origIndex;
    e.getValue(t, n);
    for (let s = i, r = n; s !== r; ++s) t[s] = t[n + (s % i)];
    this._setIdentity(),
      (this.cumulativeWeight = 0),
      (this.cumulativeWeightAdditive = 0);
  }
  restoreOriginalState() {
    const e = 3 * this.valueSize;
    this.binding.setValue(this.buffer, e);
  }
  _setAdditiveIdentityNumeric() {
    const e = this._addIndex * this.valueSize,
      t = e + this.valueSize;
    for (let i = e; i < t; i++) this.buffer[i] = 0;
  }
  _setAdditiveIdentityQuaternion() {
    this._setAdditiveIdentityNumeric(),
      (this.buffer[this._addIndex * this.valueSize + 3] = 1);
  }
  _setAdditiveIdentityOther() {
    const e = this._origIndex * this.valueSize,
      t = this._addIndex * this.valueSize;
    for (let i = 0; i < this.valueSize; i++)
      this.buffer[t + i] = this.buffer[e + i];
  }
  _select(e, t, i, n, s) {
    if (n >= 0.5) for (let r = 0; r !== s; ++r) e[t + r] = e[i + r];
  }
  _slerp(e, t, i, n) {
    Quaternion.slerpFlat(e, t, e, t, e, i, n);
  }
  _slerpAdditive(e, t, i, n, s) {
    const r = this._workIndex * s;
    Quaternion.multiplyQuaternionsFlat(e, r, e, t, e, i),
      Quaternion.slerpFlat(e, t, e, t, e, r, n);
  }
  _lerp(e, t, i, n, s) {
    const r = 1 - n;
    for (let a = 0; a !== s; ++a) {
      const s = t + a;
      e[s] = e[s] * r + e[i + a] * n;
    }
  }
  _lerpAdditive(e, t, i, n, s) {
    for (let r = 0; r !== s; ++r) {
      const s = t + r;
      e[s] = e[s] + e[i + r] * n;
    }
  }
}
const Vl = "\\[\\]\\.:\\/",
  Ql = new RegExp("[" + Vl + "]", "g"),
  Hl = "[^" + Vl + "]",
  jl = "[^" + Vl.replace("\\.", "") + "]",
  Wl = new RegExp(
    "^" +
      /((?:WC+[\/:])*)/.source.replace("WC", Hl) +
      /(WCOD+)?/.source.replace("WCOD", jl) +
      /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Hl) +
      /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Hl) +
      "$"
  ),
  ql = ["material", "materials", "bones", "map"];
class Xl {
  constructor(e, t, i) {
    (this.path = t),
      (this.parsedPath = i || Xl.parseTrackName(t)),
      (this.node = Xl.findNode(e, this.parsedPath.nodeName)),
      (this.rootNode = e),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
  static create(e, t, i) {
    return e && e.isAnimationObjectGroup
      ? new Xl.Composite(e, t, i)
      : new Xl(e, t, i);
  }
  static sanitizeNodeName(e) {
    return e.replace(/\s/g, "_").replace(Ql, "");
  }
  static parseTrackName(e) {
    const t = Wl.exec(e);
    if (null === t)
      throw new Error("PropertyBinding: Cannot parse trackName: " + e);
    const i = {
        nodeName: t[2],
        objectName: t[3],
        objectIndex: t[4],
        propertyName: t[5],
        propertyIndex: t[6],
      },
      n = i.nodeName && i.nodeName.lastIndexOf(".");
    if (void 0 !== n && -1 !== n) {
      const e = i.nodeName.substring(n + 1);
      -1 !== ql.indexOf(e) &&
        ((i.nodeName = i.nodeName.substring(0, n)), (i.objectName = e));
    }
    if (null === i.propertyName || 0 === i.propertyName.length)
      throw new Error(
        "PropertyBinding: can not parse propertyName from trackName: " + e
      );
    return i;
  }
  static findNode(e, t) {
    if (
      void 0 === t ||
      "" === t ||
      "." === t ||
      -1 === t ||
      t === e.name ||
      t === e.uuid
    )
      return e;
    if (e.skeleton) {
      const i = e.skeleton.getBoneByName(t);
      if (void 0 !== i) return i;
    }
    if (e.children) {
      const i = function (e) {
          for (let n = 0; n < e.length; n++) {
            const s = e[n];
            if (s.name === t || s.uuid === t) return s;
            const r = i(s.children);
            if (r) return r;
          }
          return null;
        },
        n = i(e.children);
      if (n) return n;
    }
    return null;
  }
  _getValue_unavailable() {}
  _setValue_unavailable() {}
  _getValue_direct(e, t) {
    e[t] = this.targetObject[this.propertyName];
  }
  _getValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n) e[t++] = i[n];
  }
  _getValue_arrayElement(e, t) {
    e[t] = this.resolvedProperty[this.propertyIndex];
  }
  _getValue_toArray(e, t) {
    this.resolvedProperty.toArray(e, t);
  }
  _setValue_direct(e, t) {
    this.targetObject[this.propertyName] = e[t];
  }
  _setValue_direct_setNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
    (this.targetObject[this.propertyName] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_array(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
  }
  _setValue_array_setNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
    this.targetObject.needsUpdate = !0;
  }
  _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
    const i = this.resolvedProperty;
    for (let n = 0, s = i.length; n !== s; ++n) i[n] = e[t++];
    this.targetObject.matrixWorldNeedsUpdate = !0;
  }
  _setValue_arrayElement(e, t) {
    this.resolvedProperty[this.propertyIndex] = e[t];
  }
  _setValue_arrayElement_setNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.needsUpdate = !0);
  }
  _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
    (this.resolvedProperty[this.propertyIndex] = e[t]),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _setValue_fromArray(e, t) {
    this.resolvedProperty.fromArray(e, t);
  }
  _setValue_fromArray_setNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t), (this.targetObject.needsUpdate = !0);
  }
  _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
    this.resolvedProperty.fromArray(e, t),
      (this.targetObject.matrixWorldNeedsUpdate = !0);
  }
  _getValue_unbound(e, t) {
    this.bind(), this.getValue(e, t);
  }
  _setValue_unbound(e, t) {
    this.bind(), this.setValue(e, t);
  }
  bind() {
    let e = this.node;
    const t = this.parsedPath,
      i = t.objectName,
      n = t.propertyName;
    let s = t.propertyIndex;
    if (
      (e || ((e = Xl.findNode(this.rootNode, t.nodeName)), (this.node = e)),
      (this.getValue = this._getValue_unavailable),
      (this.setValue = this._setValue_unavailable),
      !e)
    )
      return void console.warn(
        "THREE.PropertyBinding: No target node found for track: " +
          this.path +
          "."
      );
    if (i) {
      let n = t.objectIndex;
      switch (i) {
        case "materials":
          if (!e.material)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
          if (!e.material.materials)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",
              this
            );
          e = e.material.materials;
          break;
        case "bones":
          if (!e.skeleton)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.",
              this
            );
          e = e.skeleton.bones;
          for (let t = 0; t < e.length; t++)
            if (e[t].name === n) {
              n = t;
              break;
            }
          break;
        case "map":
          if ("map" in e) {
            e = e.map;
            break;
          }
          if (!e.material)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to material as node does not have a material.",
              this
            );
          if (!e.material.map)
            return void console.error(
              "THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.",
              this
            );
          e = e.material.map;
          break;
        default:
          if (void 0 === e[i])
            return void console.error(
              "THREE.PropertyBinding: Can not bind to objectName of node undefined.",
              this
            );
          e = e[i];
      }
      if (void 0 !== n) {
        if (void 0 === e[n])
          return void console.error(
            "THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",
            this,
            e
          );
        e = e[n];
      }
    }
    const r = e[n];
    if (void 0 === r) {
      const i = t.nodeName;
      return void console.error(
        "THREE.PropertyBinding: Trying to update property for track: " +
          i +
          "." +
          n +
          " but it wasn't found.",
        e
      );
    }
    let a = this.Versioning.None;
    (this.targetObject = e),
      void 0 !== e.needsUpdate
        ? (a = this.Versioning.NeedsUpdate)
        : void 0 !== e.matrixWorldNeedsUpdate &&
          (a = this.Versioning.MatrixWorldNeedsUpdate);
    let o = this.BindingType.Direct;
    if (void 0 !== s) {
      if ("morphTargetInfluences" === n) {
        if (!e.geometry)
          return void console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",
            this
          );
        if (!e.geometry.morphAttributes)
          return void console.error(
            "THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",
            this
          );
        void 0 !== e.morphTargetDictionary[s] &&
          (s = e.morphTargetDictionary[s]);
      }
      (o = this.BindingType.ArrayElement),
        (this.resolvedProperty = r),
        (this.propertyIndex = s);
    } else
      void 0 !== r.fromArray && void 0 !== r.toArray
        ? ((o = this.BindingType.HasFromToArray), (this.resolvedProperty = r))
        : Array.isArray(r)
        ? ((o = this.BindingType.EntireArray), (this.resolvedProperty = r))
        : (this.propertyName = n);
    (this.getValue = this.GetterByBindingType[o]),
      (this.setValue = this.SetterByBindingTypeAndVersioning[o][a]);
  }
  unbind() {
    (this.node = null),
      (this.getValue = this._getValue_unbound),
      (this.setValue = this._setValue_unbound);
  }
}
(Xl.Composite = class {
  constructor(e, t, i) {
    const n = i || Xl.parseTrackName(t);
    (this._targetGroup = e), (this._bindings = e.subscribe_(t, n));
  }
  getValue(e, t) {
    this.bind();
    const i = this._targetGroup.nCachedObjects_,
      n = this._bindings[i];
    void 0 !== n && n.getValue(e, t);
  }
  setValue(e, t) {
    const i = this._bindings;
    for (let n = this._targetGroup.nCachedObjects_, s = i.length; n !== s; ++n)
      i[n].setValue(e, t);
  }
  bind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].bind();
  }
  unbind() {
    const e = this._bindings;
    for (let t = this._targetGroup.nCachedObjects_, i = e.length; t !== i; ++t)
      e[t].unbind();
  }
}),
  (Xl.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3,
  }),
  (Xl.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2,
  }),
  (Xl.prototype.GetterByBindingType = [
    Xl.prototype._getValue_direct,
    Xl.prototype._getValue_array,
    Xl.prototype._getValue_arrayElement,
    Xl.prototype._getValue_toArray,
  ]),
  (Xl.prototype.SetterByBindingTypeAndVersioning = [
    [
      Xl.prototype._setValue_direct,
      Xl.prototype._setValue_direct_setNeedsUpdate,
      Xl.prototype._setValue_direct_setMatrixWorldNeedsUpdate,
    ],
    [
      Xl.prototype._setValue_array,
      Xl.prototype._setValue_array_setNeedsUpdate,
      Xl.prototype._setValue_array_setMatrixWorldNeedsUpdate,
    ],
    [
      Xl.prototype._setValue_arrayElement,
      Xl.prototype._setValue_arrayElement_setNeedsUpdate,
      Xl.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate,
    ],
    [
      Xl.prototype._setValue_fromArray,
      Xl.prototype._setValue_fromArray_setNeedsUpdate,
      Xl.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate,
    ],
  ]);
class Yl {
  constructor(e, t, i = null, n = t.blendMode) {
    (this._mixer = e),
      (this._clip = t),
      (this._localRoot = i),
      (this.blendMode = n);
    const s = t.tracks,
      r = s.length,
      a = new Array(r),
      o = { endingStart: le, endingEnd: le };
    for (let l = 0; l !== r; ++l) {
      const e = s[l].createInterpolant(null);
      (a[l] = e), (e.settings = o);
    }
    (this._interpolantSettings = o),
      (this._interpolants = a),
      (this._propertyBindings = new Array(r)),
      (this._cacheIndex = null),
      (this._byClipCacheIndex = null),
      (this._timeScaleInterpolant = null),
      (this._weightInterpolant = null),
      (this.loop = 2201),
      (this._loopCount = -1),
      (this._startTime = null),
      (this.time = 0),
      (this.timeScale = 1),
      (this._effectiveTimeScale = 1),
      (this.weight = 1),
      (this._effectiveWeight = 1),
      (this.repetitions = 1 / 0),
      (this.paused = !1),
      (this.enabled = !0),
      (this.clampWhenFinished = !1),
      (this.zeroSlopeAtStart = !0),
      (this.zeroSlopeAtEnd = !0);
  }
  play() {
    return this._mixer._activateAction(this), this;
  }
  stop() {
    return this._mixer._deactivateAction(this), this.reset();
  }
  reset() {
    return (
      (this.paused = !1),
      (this.enabled = !0),
      (this.time = 0),
      (this._loopCount = -1),
      (this._startTime = null),
      this.stopFading().stopWarping()
    );
  }
  isRunning() {
    return (
      this.enabled &&
      !this.paused &&
      0 !== this.timeScale &&
      null === this._startTime &&
      this._mixer._isActiveAction(this)
    );
  }
  isScheduled() {
    return this._mixer._isActiveAction(this);
  }
  startAt(e) {
    return (this._startTime = e), this;
  }
  setLoop(e, t) {
    return (this.loop = e), (this.repetitions = t), this;
  }
  setEffectiveWeight(e) {
    return (
      (this.weight = e),
      (this._effectiveWeight = this.enabled ? e : 0),
      this.stopFading()
    );
  }
  getEffectiveWeight() {
    return this._effectiveWeight;
  }
  fadeIn(e) {
    return this._scheduleFading(e, 0, 1);
  }
  fadeOut(e) {
    return this._scheduleFading(e, 1, 0);
  }
  crossFadeFrom(e, t, i) {
    if ((e.fadeOut(t), this.fadeIn(t), i)) {
      const i = this._clip.duration,
        n = e._clip.duration,
        s = n / i,
        r = i / n;
      e.warp(1, s, t), this.warp(r, 1, t);
    }
    return this;
  }
  crossFadeTo(e, t, i) {
    return e.crossFadeFrom(this, t, i);
  }
  stopFading() {
    const e = this._weightInterpolant;
    return (
      null !== e &&
        ((this._weightInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  setEffectiveTimeScale(e) {
    return (
      (this.timeScale = e),
      (this._effectiveTimeScale = this.paused ? 0 : e),
      this.stopWarping()
    );
  }
  getEffectiveTimeScale() {
    return this._effectiveTimeScale;
  }
  setDuration(e) {
    return (this.timeScale = this._clip.duration / e), this.stopWarping();
  }
  syncWith(e) {
    return (
      (this.time = e.time), (this.timeScale = e.timeScale), this.stopWarping()
    );
  }
  halt(e) {
    return this.warp(this._effectiveTimeScale, 0, e);
  }
  warp(e, t, i) {
    const n = this._mixer,
      s = n.time,
      r = this.timeScale;
    let a = this._timeScaleInterpolant;
    null === a &&
      ((a = n._lendControlInterpolant()), (this._timeScaleInterpolant = a));
    const o = a.parameterPositions,
      l = a.sampleValues;
    return (o[0] = s), (o[1] = s + i), (l[0] = e / r), (l[1] = t / r), this;
  }
  stopWarping() {
    const e = this._timeScaleInterpolant;
    return (
      null !== e &&
        ((this._timeScaleInterpolant = null),
        this._mixer._takeBackControlInterpolant(e)),
      this
    );
  }
  getMixer() {
    return this._mixer;
  }
  getClip() {
    return this._clip;
  }
  getRoot() {
    return this._localRoot || this._mixer._root;
  }
  _update(e, t, i, n) {
    if (!this.enabled) return void this._updateWeight(e);
    const s = this._startTime;
    if (null !== s) {
      const n = (e - s) * i;
      n < 0 || 0 === i ? (t = 0) : ((this._startTime = null), (t = i * n));
    }
    t *= this._updateTimeScale(e);
    const r = this._updateTime(t),
      a = this._updateWeight(e);
    if (a > 0) {
      const e = this._interpolants,
        t = this._propertyBindings;
      if (2501 === this.blendMode)
        for (let i = 0, n = e.length; i !== n; ++i)
          e[i].evaluate(r), t[i].accumulateAdditive(a);
      else
        for (let i = 0, s = e.length; i !== s; ++i)
          e[i].evaluate(r), t[i].accumulate(n, a);
    }
  }
  _updateWeight(e) {
    let t = 0;
    if (this.enabled) {
      t = this.weight;
      const i = this._weightInterpolant;
      if (null !== i) {
        const n = i.evaluate(e)[0];
        (t *= n),
          e > i.parameterPositions[1] &&
            (this.stopFading(), 0 === n && (this.enabled = !1));
      }
    }
    return (this._effectiveWeight = t), t;
  }
  _updateTimeScale(e) {
    let t = 0;
    if (!this.paused) {
      t = this.timeScale;
      const i = this._timeScaleInterpolant;
      if (null !== i) {
        (t *= i.evaluate(e)[0]),
          e > i.parameterPositions[1] &&
            (this.stopWarping(),
            0 === t ? (this.paused = !0) : (this.timeScale = t));
      }
    }
    return (this._effectiveTimeScale = t), t;
  }
  _updateTime(e) {
    const t = this._clip.duration,
      i = this.loop;
    let n = this.time + e,
      s = this._loopCount;
    const r = 2202 === i;
    if (0 === e) return -1 === s ? n : r && 1 == (1 & s) ? t - n : n;
    if (2200 === i) {
      -1 === s && ((this._loopCount = 0), this._setEndings(!0, !0, !1));
      e: {
        if (n >= t) n = t;
        else {
          if (!(n < 0)) {
            this.time = n;
            break e;
          }
          n = 0;
        }
        this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
          (this.time = n),
          this._mixer.dispatchEvent({
            type: "finished",
            action: this,
            direction: e < 0 ? -1 : 1,
          });
      }
    } else {
      if (
        (-1 === s &&
          (e >= 0
            ? ((s = 0), this._setEndings(!0, 0 === this.repetitions, r))
            : this._setEndings(0 === this.repetitions, !0, r)),
        n >= t || n < 0)
      ) {
        const i = Math.floor(n / t);
        (n -= t * i), (s += Math.abs(i));
        const a = this.repetitions - s;
        if (a <= 0)
          this.clampWhenFinished ? (this.paused = !0) : (this.enabled = !1),
            (n = e > 0 ? t : 0),
            (this.time = n),
            this._mixer.dispatchEvent({
              type: "finished",
              action: this,
              direction: e > 0 ? 1 : -1,
            });
        else {
          if (1 === a) {
            const t = e < 0;
            this._setEndings(t, !t, r);
          } else this._setEndings(!1, !1, r);
          (this._loopCount = s),
            (this.time = n),
            this._mixer.dispatchEvent({
              type: "loop",
              action: this,
              loopDelta: i,
            });
        }
      } else this.time = n;
      if (r && 1 == (1 & s)) return t - n;
    }
    return n;
  }
  _setEndings(e, t, i) {
    const n = this._interpolantSettings;
    i
      ? ((n.endingStart = he), (n.endingEnd = he))
      : ((n.endingStart = e ? (this.zeroSlopeAtStart ? he : le) : ce),
        (n.endingEnd = t ? (this.zeroSlopeAtEnd ? he : le) : ce));
  }
  _scheduleFading(e, t, i) {
    const n = this._mixer,
      s = n.time;
    let r = this._weightInterpolant;
    null === r &&
      ((r = n._lendControlInterpolant()), (this._weightInterpolant = r));
    const a = r.parameterPositions,
      o = r.sampleValues;
    return (a[0] = s), (o[0] = t), (a[1] = s + e), (o[1] = i), this;
  }
}
const Kl = new Float32Array(1);
class Zl extends EventDispatcher {
  constructor(e) {
    super(),
      (this._root = e),
      this._initMemoryManager(),
      (this._accuIndex = 0),
      (this.time = 0),
      (this.timeScale = 1);
  }
  _bindAction(e, t) {
    const i = e._localRoot || this._root,
      n = e._clip.tracks,
      s = n.length,
      r = e._propertyBindings,
      a = e._interpolants,
      o = i.uuid,
      l = this._bindingsByRootAndName;
    let h = l[o];
    void 0 === h && ((h = {}), (l[o] = h));
    for (let c = 0; c !== s; ++c) {
      const e = n[c],
        s = e.name;
      let l = h[s];
      if (void 0 !== l) ++l.referenceCount, (r[c] = l);
      else {
        if (((l = r[c]), void 0 !== l)) {
          null === l._cacheIndex &&
            (++l.referenceCount, this._addInactiveBinding(l, o, s));
          continue;
        }
        const n = t && t._propertyBindings[c].binding.parsedPath;
        (l = new Gl(Xl.create(i, s, n), e.ValueTypeName, e.getValueSize())),
          ++l.referenceCount,
          this._addInactiveBinding(l, o, s),
          (r[c] = l);
      }
      a[c].resultBuffer = l.buffer;
    }
  }
  _activateAction(e) {
    if (!this._isActiveAction(e)) {
      if (null === e._cacheIndex) {
        const t = (e._localRoot || this._root).uuid,
          i = e._clip.uuid,
          n = this._actionsByClip[i];
        this._bindAction(e, n && n.knownActions[0]),
          this._addInactiveAction(e, i, t);
      }
      const t = e._propertyBindings;
      for (let e = 0, i = t.length; e !== i; ++e) {
        const i = t[e];
        0 == i.useCount++ && (this._lendBinding(i), i.saveOriginalState());
      }
      this._lendAction(e);
    }
  }
  _deactivateAction(e) {
    if (this._isActiveAction(e)) {
      const t = e._propertyBindings;
      for (let e = 0, i = t.length; e !== i; ++e) {
        const i = t[e];
        0 == --i.useCount &&
          (i.restoreOriginalState(), this._takeBackBinding(i));
      }
      this._takeBackAction(e);
    }
  }
  _initMemoryManager() {
    (this._actions = []),
      (this._nActiveActions = 0),
      (this._actionsByClip = {}),
      (this._bindings = []),
      (this._nActiveBindings = 0),
      (this._bindingsByRootAndName = {}),
      (this._controlInterpolants = []),
      (this._nActiveControlInterpolants = 0);
    const e = this;
    this.stats = {
      actions: {
        get total() {
          return e._actions.length;
        },
        get inUse() {
          return e._nActiveActions;
        },
      },
      bindings: {
        get total() {
          return e._bindings.length;
        },
        get inUse() {
          return e._nActiveBindings;
        },
      },
      controlInterpolants: {
        get total() {
          return e._controlInterpolants.length;
        },
        get inUse() {
          return e._nActiveControlInterpolants;
        },
      },
    };
  }
  _isActiveAction(e) {
    const t = e._cacheIndex;
    return null !== t && t < this._nActiveActions;
  }
  _addInactiveAction(e, t, i) {
    const n = this._actions,
      s = this._actionsByClip;
    let r = s[t];
    if (void 0 === r)
      (r = { knownActions: [e], actionByRoot: {} }),
        (e._byClipCacheIndex = 0),
        (s[t] = r);
    else {
      const t = r.knownActions;
      (e._byClipCacheIndex = t.length), t.push(e);
    }
    (e._cacheIndex = n.length), n.push(e), (r.actionByRoot[i] = e);
  }
  _removeInactiveAction(e) {
    const t = this._actions,
      i = t[t.length - 1],
      n = e._cacheIndex;
    (i._cacheIndex = n), (t[n] = i), t.pop(), (e._cacheIndex = null);
    const s = e._clip.uuid,
      r = this._actionsByClip,
      a = r[s],
      o = a.knownActions,
      l = o[o.length - 1],
      h = e._byClipCacheIndex;
    (l._byClipCacheIndex = h),
      (o[h] = l),
      o.pop(),
      (e._byClipCacheIndex = null);
    delete a.actionByRoot[(e._localRoot || this._root).uuid],
      0 === o.length && delete r[s],
      this._removeInactiveBindingsForAction(e);
  }
  _removeInactiveBindingsForAction(e) {
    const t = e._propertyBindings;
    for (let i = 0, n = t.length; i !== n; ++i) {
      const e = t[i];
      0 == --e.referenceCount && this._removeInactiveBinding(e);
    }
  }
  _lendAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      n = this._nActiveActions++,
      s = t[n];
    (e._cacheIndex = n), (t[n] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackAction(e) {
    const t = this._actions,
      i = e._cacheIndex,
      n = --this._nActiveActions,
      s = t[n];
    (e._cacheIndex = n), (t[n] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _addInactiveBinding(e, t, i) {
    const n = this._bindingsByRootAndName,
      s = this._bindings;
    let r = n[t];
    void 0 === r && ((r = {}), (n[t] = r)),
      (r[i] = e),
      (e._cacheIndex = s.length),
      s.push(e);
  }
  _removeInactiveBinding(e) {
    const t = this._bindings,
      i = e.binding,
      n = i.rootNode.uuid,
      s = i.path,
      r = this._bindingsByRootAndName,
      a = r[n],
      o = t[t.length - 1],
      l = e._cacheIndex;
    (o._cacheIndex = l),
      (t[l] = o),
      t.pop(),
      delete a[s],
      0 === Object.keys(a).length && delete r[n];
  }
  _lendBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      n = this._nActiveBindings++,
      s = t[n];
    (e._cacheIndex = n), (t[n] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _takeBackBinding(e) {
    const t = this._bindings,
      i = e._cacheIndex,
      n = --this._nActiveBindings,
      s = t[n];
    (e._cacheIndex = n), (t[n] = e), (s._cacheIndex = i), (t[i] = s);
  }
  _lendControlInterpolant() {
    const e = this._controlInterpolants,
      t = this._nActiveControlInterpolants++;
    let i = e[t];
    return (
      void 0 === i &&
        ((i = new Jo(new Float32Array(2), new Float32Array(2), 1, Kl)),
        (i.__cacheIndex = t),
        (e[t] = i)),
      i
    );
  }
  _takeBackControlInterpolant(e) {
    const t = this._controlInterpolants,
      i = e.__cacheIndex,
      n = --this._nActiveControlInterpolants,
      s = t[n];
    (e.__cacheIndex = n), (t[n] = e), (s.__cacheIndex = i), (t[i] = s);
  }
  clipAction(e, t, i) {
    const n = t || this._root,
      s = n.uuid;
    let r = "string" == typeof e ? ll.findByName(n, e) : e;
    const a = null !== r ? r.uuid : e,
      o = this._actionsByClip[a];
    let l = null;
    if ((void 0 === i && (i = null !== r ? r.blendMode : ue), void 0 !== o)) {
      const e = o.actionByRoot[s];
      if (void 0 !== e && e.blendMode === i) return e;
      (l = o.knownActions[0]), null === r && (r = l._clip);
    }
    if (null === r) return null;
    const h = new Yl(this, r, t, i);
    return this._bindAction(h, l), this._addInactiveAction(h, a, s), h;
  }
  existingAction(e, t) {
    const i = t || this._root,
      n = i.uuid,
      s = "string" == typeof e ? ll.findByName(i, e) : e,
      r = s ? s.uuid : e,
      a = this._actionsByClip[r];
    return (void 0 !== a && a.actionByRoot[n]) || null;
  }
  stopAllAction() {
    const e = this._actions;
    for (let t = this._nActiveActions - 1; t >= 0; --t) e[t].stop();
    return this;
  }
  update(e) {
    e *= this.timeScale;
    const t = this._actions,
      i = this._nActiveActions,
      n = (this.time += e),
      s = Math.sign(e),
      r = (this._accuIndex ^= 1);
    for (let l = 0; l !== i; ++l) {
      t[l]._update(n, e, s, r);
    }
    const a = this._bindings,
      o = this._nActiveBindings;
    for (let l = 0; l !== o; ++l) a[l].apply(r);
    return this;
  }
  setTime(e) {
    this.time = 0;
    for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
    return this.update(e);
  }
  getRoot() {
    return this._root;
  }
  uncacheClip(e) {
    const t = this._actions,
      i = e.uuid,
      n = this._actionsByClip,
      s = n[i];
    if (void 0 !== s) {
      const e = s.knownActions;
      for (let i = 0, n = e.length; i !== n; ++i) {
        const n = e[i];
        this._deactivateAction(n);
        const s = n._cacheIndex,
          r = t[t.length - 1];
        (n._cacheIndex = null),
          (n._byClipCacheIndex = null),
          (r._cacheIndex = s),
          (t[s] = r),
          t.pop(),
          this._removeInactiveBindingsForAction(n);
      }
      delete n[i];
    }
  }
  uncacheRoot(e) {
    const t = e.uuid,
      i = this._actionsByClip;
    for (const s in i) {
      const e = i[s].actionByRoot[t];
      void 0 !== e &&
        (this._deactivateAction(e), this._removeInactiveAction(e));
    }
    const n = this._bindingsByRootAndName[t];
    if (void 0 !== n)
      for (const s in n) {
        const e = n[s];
        e.restoreOriginalState(), this._removeInactiveBinding(e);
      }
  }
  uncacheAction(e, t) {
    const i = this.existingAction(e, t);
    null !== i && (this._deactivateAction(i), this._removeInactiveAction(i));
  }
}
class Jl extends Ta {
  constructor(e, t, i = 1) {
    super(e, t),
      (this.isInstancedInterleavedBuffer = !0),
      (this.meshPerAttribute = i);
  }
  copy(e) {
    return super.copy(e), (this.meshPerAttribute = e.meshPerAttribute), this;
  }
  clone(e) {
    const t = super.clone(e);
    return (t.meshPerAttribute = this.meshPerAttribute), t;
  }
  toJSON(e) {
    const t = super.toJSON(e);
    return (
      (t.isInstancedInterleavedBuffer = !0),
      (t.meshPerAttribute = this.meshPerAttribute),
      t
    );
  }
}
class $l {
  constructor(e, t, i = 0, n = 1 / 0) {
    (this.ray = new jt(e, t)),
      (this.near = i),
      (this.far = n),
      (this.camera = null),
      (this.layers = new ni()),
      (this.params = {
        Mesh: {},
        Line: { threshold: 1 },
        LOD: {},
        Points: { threshold: 1 },
        Sprite: {},
      });
  }
  set(e, t) {
    this.ray.set(e, t);
  }
  setFromCamera(e, t) {
    t.isPerspectiveCamera
      ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld),
        this.ray.direction
          .set(e.x, e.y, 0.5)
          .unproject(t)
          .sub(this.ray.origin)
          .normalize(),
        (this.camera = t))
      : t.isOrthographicCamera
      ? (this.ray.origin
          .set(e.x, e.y, (t.near + t.far) / (t.near - t.far))
          .unproject(t),
        this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld),
        (this.camera = t))
      : console.error("THREE.Raycaster: Unsupported camera type: " + t.type);
  }
  intersectObject(e, t = !0, i = []) {
    return th(e, this, i, t), i.sort(eh), i;
  }
  intersectObjects(e, t = !0, i = []) {
    for (let n = 0, s = e.length; n < s; n++) th(e[n], this, i, t);
    return i.sort(eh), i;
  }
}
function eh(e, t) {
  return e.distance - t.distance;
}
function th(e, t, i, n) {
  if ((e.layers.test(t.layers) && e.raycast(t, i), !0 === n)) {
    const n = e.children;
    for (let e = 0, s = n.length; e < s; e++) th(n[e], t, i, !0);
  }
}
const ih = new Vector2();
class nh {
  constructor(e = new Vector2(1 / 0, 1 / 0), t = new Vector2(-1 / 0, -1 / 0)) {
    (this.isBox2 = !0), (this.min = e), (this.max = t);
  }
  set(e, t) {
    return this.min.copy(e), this.max.copy(t), this;
  }
  setFromPoints(e) {
    this.makeEmpty();
    for (let t = 0, i = e.length; t < i; t++) this.expandByPoint(e[t]);
    return this;
  }
  setFromCenterAndSize(e, t) {
    const i = ih.copy(t).multiplyScalar(0.5);
    return this.min.copy(e).sub(i), this.max.copy(e).add(i), this;
  }
  clone() {
    return new this.constructor().copy(this);
  }
  copy(e) {
    return this.min.copy(e.min), this.max.copy(e.max), this;
  }
  makeEmpty() {
    return (
      (this.min.x = this.min.y = 1 / 0),
      (this.max.x = this.max.y = -1 / 0),
      this
    );
  }
  isEmpty() {
    return this.max.x < this.min.x || this.max.y < this.min.y;
  }
  getCenter(e) {
    return this.isEmpty()
      ? e.set(0, 0)
      : e.addVectors(this.min, this.max).multiplyScalar(0.5);
  }
  getSize(e) {
    return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min);
  }
  expandByPoint(e) {
    return this.min.min(e), this.max.max(e), this;
  }
  expandByVector(e) {
    return this.min.sub(e), this.max.add(e), this;
  }
  expandByScalar(e) {
    return this.min.addScalar(-e), this.max.addScalar(e), this;
  }
  containsPoint(e) {
    return !(
      e.x < this.min.x ||
      e.x > this.max.x ||
      e.y < this.min.y ||
      e.y > this.max.y
    );
  }
  containsBox(e) {
    return (
      this.min.x <= e.min.x &&
      e.max.x <= this.max.x &&
      this.min.y <= e.min.y &&
      e.max.y <= this.max.y
    );
  }
  getParameter(e, t) {
    return t.set(
      (e.x - this.min.x) / (this.max.x - this.min.x),
      (e.y - this.min.y) / (this.max.y - this.min.y)
    );
  }
  intersectsBox(e) {
    return !(
      e.max.x < this.min.x ||
      e.min.x > this.max.x ||
      e.max.y < this.min.y ||
      e.min.y > this.max.y
    );
  }
  clampPoint(e, t) {
    return t.copy(e).clamp(this.min, this.max);
  }
  distanceToPoint(e) {
    return this.clampPoint(e, ih).distanceTo(e);
  }
  intersect(e) {
    return (
      this.min.max(e.min),
      this.max.min(e.max),
      this.isEmpty() && this.makeEmpty(),
      this
    );
  }
  union(e) {
    return this.min.min(e.min), this.max.max(e.max), this;
  }
  translate(e) {
    return this.min.add(e), this.max.add(e), this;
  }
  equals(e) {
    return e.min.equals(this.min) && e.max.equals(this.max);
  }
}
const sh = new Vector3(),
  rh = new Pn();
class ah extends co {
  constructor(e) {
    const t = new rn(),
      i = new to({ color: 16777215, vertexColors: !0, toneMapped: !1 }),
      n = [],
      s = [],
      r = {};
    function a(e, t) {
      o(e), o(t);
    }
    function o(e) {
      n.push(0, 0, 0),
        s.push(0, 0, 0),
        void 0 === r[e] && (r[e] = []),
        r[e].push(n.length / 3 - 1);
    }
    a("n1", "n2"),
      a("n2", "n4"),
      a("n4", "n3"),
      a("n3", "n1"),
      a("f1", "f2"),
      a("f2", "f4"),
      a("f4", "f3"),
      a("f3", "f1"),
      a("n1", "f1"),
      a("n2", "f2"),
      a("n3", "f3"),
      a("n4", "f4"),
      a("p", "n1"),
      a("p", "n2"),
      a("p", "n3"),
      a("p", "n4"),
      a("u1", "u2"),
      a("u2", "u3"),
      a("u3", "u1"),
      a("c", "t"),
      a("p", "c"),
      a("cn1", "cn2"),
      a("cn3", "cn4"),
      a("cf1", "cf2"),
      a("cf3", "cf4"),
      t.setAttribute("position", new Ki(n, 3)),
      t.setAttribute("color", new Ki(s, 3)),
      super(t, i),
      (this.type = "CameraHelper"),
      (this.camera = e),
      this.camera.updateProjectionMatrix &&
        this.camera.updateProjectionMatrix(),
      (this.matrix = e.matrixWorld),
      (this.matrixAutoUpdate = !1),
      (this.pointMap = r),
      this.update();
    const l = new Color(16755200),
      h = new Color(16711680),
      c = new Color(43775),
      u = new Color(16777215),
      d = new Color(3355443);
    this.setColors(l, h, c, u, d);
  }
  setColors(e, t, i, n, s) {
    const r = this.geometry.getAttribute("color");
    r.setXYZ(0, e.r, e.g, e.b),
      r.setXYZ(1, e.r, e.g, e.b),
      r.setXYZ(2, e.r, e.g, e.b),
      r.setXYZ(3, e.r, e.g, e.b),
      r.setXYZ(4, e.r, e.g, e.b),
      r.setXYZ(5, e.r, e.g, e.b),
      r.setXYZ(6, e.r, e.g, e.b),
      r.setXYZ(7, e.r, e.g, e.b),
      r.setXYZ(8, e.r, e.g, e.b),
      r.setXYZ(9, e.r, e.g, e.b),
      r.setXYZ(10, e.r, e.g, e.b),
      r.setXYZ(11, e.r, e.g, e.b),
      r.setXYZ(12, e.r, e.g, e.b),
      r.setXYZ(13, e.r, e.g, e.b),
      r.setXYZ(14, e.r, e.g, e.b),
      r.setXYZ(15, e.r, e.g, e.b),
      r.setXYZ(16, e.r, e.g, e.b),
      r.setXYZ(17, e.r, e.g, e.b),
      r.setXYZ(18, e.r, e.g, e.b),
      r.setXYZ(19, e.r, e.g, e.b),
      r.setXYZ(20, e.r, e.g, e.b),
      r.setXYZ(21, e.r, e.g, e.b),
      r.setXYZ(22, e.r, e.g, e.b),
      r.setXYZ(23, e.r, e.g, e.b),
      r.setXYZ(24, t.r, t.g, t.b),
      r.setXYZ(25, t.r, t.g, t.b),
      r.setXYZ(26, t.r, t.g, t.b),
      r.setXYZ(27, t.r, t.g, t.b),
      r.setXYZ(28, t.r, t.g, t.b),
      r.setXYZ(29, t.r, t.g, t.b),
      r.setXYZ(30, t.r, t.g, t.b),
      r.setXYZ(31, t.r, t.g, t.b),
      r.setXYZ(32, i.r, i.g, i.b),
      r.setXYZ(33, i.r, i.g, i.b),
      r.setXYZ(34, i.r, i.g, i.b),
      r.setXYZ(35, i.r, i.g, i.b),
      r.setXYZ(36, i.r, i.g, i.b),
      r.setXYZ(37, i.r, i.g, i.b),
      r.setXYZ(38, n.r, n.g, n.b),
      r.setXYZ(39, n.r, n.g, n.b),
      r.setXYZ(40, s.r, s.g, s.b),
      r.setXYZ(41, s.r, s.g, s.b),
      r.setXYZ(42, s.r, s.g, s.b),
      r.setXYZ(43, s.r, s.g, s.b),
      r.setXYZ(44, s.r, s.g, s.b),
      r.setXYZ(45, s.r, s.g, s.b),
      r.setXYZ(46, s.r, s.g, s.b),
      r.setXYZ(47, s.r, s.g, s.b),
      r.setXYZ(48, s.r, s.g, s.b),
      r.setXYZ(49, s.r, s.g, s.b),
      (r.needsUpdate = !0);
  }
  update() {
    const e = this.geometry,
      t = this.pointMap;
    rh.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse),
      oh("c", t, e, rh, 0, 0, -1),
      oh("t", t, e, rh, 0, 0, 1),
      oh("n1", t, e, rh, -1, -1, -1),
      oh("n2", t, e, rh, 1, -1, -1),
      oh("n3", t, e, rh, -1, 1, -1),
      oh("n4", t, e, rh, 1, 1, -1),
      oh("f1", t, e, rh, -1, -1, 1),
      oh("f2", t, e, rh, 1, -1, 1),
      oh("f3", t, e, rh, -1, 1, 1),
      oh("f4", t, e, rh, 1, 1, 1),
      oh("u1", t, e, rh, 0.7, 1.1, -1),
      oh("u2", t, e, rh, -0.7, 1.1, -1),
      oh("u3", t, e, rh, 0, 2, -1),
      oh("cf1", t, e, rh, -1, 0, 1),
      oh("cf2", t, e, rh, 1, 0, 1),
      oh("cf3", t, e, rh, 0, -1, 1),
      oh("cf4", t, e, rh, 0, 1, 1),
      oh("cn1", t, e, rh, -1, 0, -1),
      oh("cn2", t, e, rh, 1, 0, -1),
      oh("cn3", t, e, rh, 0, -1, -1),
      oh("cn4", t, e, rh, 0, 1, -1),
      (e.getAttribute("position").needsUpdate = !0);
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
function oh(e, t, i, n, s, r, a) {
  sh.set(s, r, a).unproject(n);
  const o = t[e];
  if (void 0 !== o) {
    const e = i.getAttribute("position");
    for (let t = 0, i = o.length; t < i; t++) e.setXYZ(o[t], sh.x, sh.y, sh.z);
  }
}
class lh extends co {
  constructor(e, t = 16776960) {
    const i = new Uint16Array([
        0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7,
      ]),
      n = new rn();
    n.setIndex(new Wi(i, 1)),
      n.setAttribute(
        "position",
        new Ki(
          [
            1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1,
            -1, 1, -1, -1,
          ],
          3
        )
      ),
      super(n, new to({ color: t, toneMapped: !1 })),
      (this.box = e),
      (this.type = "Box3Helper"),
      this.geometry.computeBoundingSphere();
  }
  updateMatrixWorld(e) {
    const t = this.box;
    t.isEmpty() ||
      (t.getCenter(this.position),
      t.getSize(this.scale),
      this.scale.multiplyScalar(0.5),
      super.updateMatrixWorld(e));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}

"undefined" != typeof __THREE_DEVTOOLS__ &&
  __THREE_DEVTOOLS__.dispatchEvent(
    new CustomEvent("register", { detail: { revision: r } })
  ),
  "undefined" != typeof window &&
    (window.__THREE__
      ? console.warn("WARNING: Multiple instances of Three.js being imported.")
      : (window.__THREE__ = r));

const hh = "vertex",
  ch = "none",
  uh = "frame",
  dh = "render",
  ph = "object",
  fh = ["fragment", "vertex"],
  mh = ["construct", "analyze", "generate"],
  gh = [...fh, "compute"],
  _h = ["x", "y", "z", "w"];
function vh(e) {
  let t = "{";
  !0 === e.isNode && (t += `uuid:"${e.uuid}"`);
  for (const { property: i, index: n, childNode: s } of Ah(e)) {
    let e = vh(s);
    e.includes(",") || (e = e.slice(e.indexOf('"'), e.indexOf("}"))),
      (t += `,${i}${void 0 !== n ? "/" + n : ""}:${e}`);
  }
  return (t += "}"), t;
}

function* Ah(e, t = !1) {
  for (const i in e) {
    if (!0 === i.startsWith("_")) continue;
    const n = e[i];
    if (!0 === Array.isArray(n))
      for (let e = 0; e < n.length; e++) {
        const s = n[e];
        s &&
          (!0 === s.isNode || (t && "function" == typeof s.toJSON)) &&
          (yield { property: i, index: e, childNode: s });
      }
    else if (n && !0 === n.isNode) yield { property: i, childNode: n };
    else if ("object" == typeof n)
      for (const e in n) {
        const s = n[e];
        s &&
          (!0 === s.isNode || (t && "function" == typeof s.toJSON)) &&
          (yield { property: i, index: e, childNode: s });
      }
  }
}

function yh(e) {
  if (null == e) return null;
  const t = typeof e;
  return !0 === e.isNode
    ? "node"
    : "number" === t
    ? "float"
    : "boolean" === t
    ? "bool"
    : "string" === t
    ? "string"
    : "function" === t
    ? "shader"
    : !0 === e.isVector2
    ? "vec2"
    : !0 === e.isVector3
    ? "vec3"
    : !0 === e.isVector4
    ? "vec4"
    : !0 === e.isMatrix3
    ? "mat3"
    : !0 === e.isMatrix4
    ? "mat4"
    : !0 === e.isColor
    ? "color"
    : e instanceof ArrayBuffer
    ? "ArrayBuffer"
    : null;
}
function xh(e, ...t) {
  const i = e ? e.slice(-4) : void 0;
  return (
    ("vec2" !== i && "vec3" !== i && "vec4" !== i) ||
      1 !== t.length ||
      (t = "vec2" === i ? [t[0], t[0]] : [t[0], t[0], t[0]]),
    "color" === e
      ? new Color(...t)
      : "vec2" === i
      ? new Vector2(...t)
      : "vec3" === i
      ? new Vector3(...t)
      : "vec4" === i
      ? new Vector4(...t)
      : "mat3" === i
      ? new Matrix3(...t)
      : "mat4" === i
      ? new Matrix4(...t)
      : "bool" === e
      ? t[0] || !1
      : "float" === e || "int" === e || "uint" === e
      ? t[0] || 0
      : "string" === e
      ? t[0] || ""
      : "ArrayBuffer" === e
      ? ((n = t[0]), Uint8Array.from(atob(n), (e) => e.charCodeAt(0)).buffer)
      : null
  );
  var n;
}
const bh = new Map();
let Eh = 0;
const Sh = class extends EventDispatcher {
  constructor(e = null) {
    super(),
      (this.nodeType = e),
      (this.updateType = ch),
      (this.updateBeforeType = ch),
      (this.uuid = ze.generateUUID()),
      (this.isNode = !0),
      Object.defineProperty(this, "id", { value: Eh++ });
  }
  get type() {
    return this.constructor.name;
  }
  getSelf() {
    return this.self || this;
  }
  isGlobal() {
    return !1;
  }
  *getChildren() {
    const e = this;
    for (const { property: t, index: i, childNode: n } of Ah(this))
      yield {
        childNode: n,
        replaceNode(n) {
          void 0 === i ? (e[t] = n) : (e[t][i] = n);
        },
      };
  }
  dispose() {
    this.dispatchEvent({ type: "dispose" });
  }
  traverse(e, t = null) {
    e(this, t);
    for (const { childNode: i, replaceNode: n } of this.getChildren())
      i.traverse(e, n);
  }
  getCacheKey() {
    return vh(this);
  }
  getHash() {
    return this.uuid;
  }
  getUpdateType() {
    return this.updateType;
  }
  getUpdateBeforeType() {
    return this.updateBeforeType;
  }
  getNodeType(e) {
    const t = e.getNodeProperties(this);
    return t.outputNode ? t.outputNode.getNodeType(e) : this.nodeType;
  }
  getReference(e) {
    const t = this.getHash(e);
    return e.getNodeFromHash(t) || this;
  }
  construct(e) {
    const t = e.getNodeProperties(this);
    for (const { childNode: i } of this.getChildren()) t["_node" + i.id] = i;
    return null;
  }
  analyze(e) {
    const t = e.getDataFromNode(this);
    if (
      ((t.dependenciesCount =
        void 0 === t.dependenciesCount ? 1 : t.dependenciesCount + 1),
      1 === t.dependenciesCount)
    ) {
      const t = e.getNodeProperties(this);
      for (const i of Object.values(t)) i && !0 === i.isNode && i.build(e);
    }
  }
  generate(e, t) {
    const { outputNode: i } = e.getNodeProperties(this);
    if (i && !0 === i.isNode) return i.build(e, t);
  }
  updateBefore() {
    console.warn("Abstract function.");
  }
  update() {
    console.warn("Abstract function.");
  }
  build(e, t = null) {
    const i = this.getReference(e);
    if (this !== i) return i.build(e, t);
    e.addNode(this), e.addChain(this);
    let n = null;
    const s = e.getBuildStage();
    if ("construct" === s) {
      const t = e.getNodeProperties(this);
      if (!0 !== t.initialized || !1 === e.context.tempRead) {
        const i = e.stack.nodes.length;
        (t.initialized = !0),
          (t.outputNode = this.construct(e)),
          null !== t.outputNode &&
            e.stack.nodes.length !== i &&
            (t.outputNode = e.stack);
        for (const n of Object.values(t)) n && !0 === n.isNode && n.build(e);
      }
    } else if ("analyze" === s) this.analyze(e);
    else if ("generate" === s) {
      if (1 === this.generate.length) {
        const i = this.getNodeType(e),
          s = e.getDataFromNode(this);
        (n = s.snippet),
          void 0 === n && ((n = this.generate(e) || ""), (s.snippet = n)),
          (n = e.format(n, i, t));
      } else n = this.generate(e, t) || "";
    }
    return e.removeChain(this), n;
  }
  getSerializeChildren() {
    return Ah(this);
  }
  serialize(e) {
    const t = this.getSerializeChildren(),
      i = {};
    for (const { property: n, index: s, childNode: r } of t)
      void 0 !== s
        ? (void 0 === i[n] && (i[n] = Number.isInteger(s) ? [] : {}),
          (i[n][s] = r.toJSON(e.meta).uuid))
        : (i[n] = r.toJSON(e.meta).uuid);
    Object.keys(i).length > 0 && (e.inputNodes = i);
  }
  deserialize(e) {
    if (void 0 !== e.inputNodes) {
      const t = e.meta.nodes;
      for (const i in e.inputNodes)
        if (Array.isArray(e.inputNodes[i])) {
          const n = [];
          for (const s of e.inputNodes[i]) n.push(t[s]);
          this[i] = n;
        } else if ("object" == typeof e.inputNodes[i]) {
          const n = {};
          for (const s in e.inputNodes[i]) {
            const r = e.inputNodes[i][s];
            n[s] = t[r];
          }
          this[i] = n;
        } else {
          const n = e.inputNodes[i];
          this[i] = t[n];
        }
    }
  }
  toJSON(e) {
    const { uuid: t, type: i } = this,
      n = void 0 === e || "string" == typeof e;
    n && (e = { textures: {}, images: {}, nodes: {} });
    let s = e.nodes[t];
    function r(e) {
      const t = [];
      for (const i in e) {
        const n = e[i];
        delete n.metadata, t.push(n);
      }
      return t;
    }
    if (
      (void 0 === s &&
        ((s = {
          uuid: t,
          type: i,
          meta: e,
          metadata: { version: 4.6, type: "Node", generator: "Node.toJSON" },
        }),
        !0 !== n && (e.nodes[s.uuid] = s),
        this.serialize(s),
        delete s.meta),
      n)
    ) {
      const t = r(e.textures),
        i = r(e.images),
        n = r(e.nodes);
      t.length > 0 && (s.textures = t),
        i.length > 0 && (s.images = i),
        n.length > 0 && (s.nodes = n);
    }
    return s;
  }
};
function Ch(e) {
  if ("function" != typeof e || !e.name)
    throw new Error(`Node class ${e.name} is not a class`);
  if (bh.has(e.name)) throw new Error(`Redefinition of node class ${e.name}`);
  bh.set(e.name, e);
}
class Mh extends Sh {
  constructor(e, t = null) {
    super(t),
      (this.isInputNode = !0),
      (this.value = e),
      (this.precision = null);
  }
  getNodeType() {
    return null === this.nodeType ? yh(this.value) : this.nodeType;
  }
  getInputType(e) {
    return this.getNodeType(e);
  }
  setPrecision(e) {
    return (this.precision = e), this;
  }
  serialize(e) {
    super.serialize(e),
      (e.value = this.value),
      this.value && this.value.toArray && (e.value = this.value.toArray()),
      (e.valueType = yh(this.value)),
      (e.nodeType = this.nodeType),
      "ArrayBuffer" === e.valueType &&
        (e.value = (function (e) {
          let t = "";
          const i = new Uint8Array(e);
          for (let n = 0; n < i.length; n++) t += String.fromCharCode(i[n]);
          return btoa(t);
        })(e.value)),
      (e.precision = this.precision);
  }
  deserialize(e) {
    super.deserialize(e),
      (this.nodeType = e.nodeType),
      (this.value = Array.isArray(e.value)
        ? xh(e.valueType, ...e.value)
        : e.value),
      (this.precision = e.precision || null),
      this.value &&
        this.value.fromArray &&
        (this.value = this.value.fromArray(e.value));
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const wh = Mh;
Ch(Mh);
class Th extends Sh {
  constructor(e, t) {
    super(), (this.node = e), (this.indexNode = t);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    return `${this.node.build(e)}[ ${this.indexNode.build(e, "uint")} ]`;
  }
}
const Ih = Th;
Ch(Th);
class Rh extends Sh {
  constructor(e, t) {
    super(), (this.node = e), (this.convertTo = t);
  }
  getNodeType(e) {
    const t = this.node.getNodeType(e);
    let i = null;
    for (const n of this.convertTo.split("|"))
      (null !== i && e.getTypeLength(t) !== e.getTypeLength(n)) || (i = n);
    return i;
  }
  serialize(e) {
    super.serialize(e), (e.convertTo = this.convertTo);
  }
  deserialize(e) {
    super.deserialize(e), (this.convertTo = e.convertTo);
  }
  generate(e, t) {
    const i = this.node,
      n = this.getNodeType(e),
      s = i.build(e, n);
    return e.format(s, n, t);
  }
}
const Ph = Rh;
Ch(Rh);
class Dh extends Sh {
  constructor(e) {
    super(e), (this.isTempNode = !0);
  }
  hasDependencies(e) {
    return e.getDataFromNode(this).dependenciesCount > 1;
  }
  build(e, t) {
    if ("generate" === e.getBuildStage()) {
      const i = e.getVectorType(this.getNodeType(e, t)),
        n = e.getDataFromNode(this);
      if (!1 !== e.context.tempRead && void 0 !== n.propertyName)
        return e.format(n.propertyName, i, t);
      if (
        !1 !== e.context.tempWrite &&
        "void" !== i &&
        "void" !== t &&
        this.hasDependencies(e)
      ) {
        const s = super.build(e, i),
          r = e.getVarFromNode(this, i),
          a = e.getPropertyName(r);
        return (
          e.addLineFlowCode(`${a} = ${s}`),
          (n.snippet = s),
          (n.propertyName = a),
          e.format(n.propertyName, i, t)
        );
      }
    }
    return super.build(e, t);
  }
}
const Lh = Dh;
Ch(Dh);
class Fh extends Lh {
  constructor(e = [], t = null) {
    super(t), (this.nodes = e);
  }
  getNodeType(e) {
    return null !== this.nodeType
      ? e.getVectorType(this.nodeType)
      : e.getTypeFromLength(
          this.nodes.reduce((t, i) => t + e.getTypeLength(i.getNodeType(e)), 0)
        );
  }
  generate(e, t) {
    const i = this.getNodeType(e),
      n = this.nodes,
      s = [];
    for (const a of n) {
      const t = a.build(e);
      s.push(t);
    }
    const r = `${e.getType(i)}( ${s.join(", ")} )`;
    return e.format(r, i, t);
  }
}
const Nh = Fh;
Ch(Fh);
const Bh = _h.join("");
class kh extends Sh {
  constructor(e, t = "x") {
    super(), (this.node = e), (this.components = t);
  }
  getVectorLength() {
    let e = this.components.length;
    for (const t of this.components) e = Math.max(_h.indexOf(t) + 1, e);
    return e;
  }
  getNodeType(e) {
    return e.getTypeFromLength(this.components.length);
  }
  generate(e, t) {
    const i = this.node,
      n = e.getTypeLength(i.getNodeType(e));
    let s = null;
    if (n > 1) {
      let r = null;
      this.getVectorLength() >= n &&
        (r = e.getTypeFromLength(this.getVectorLength()));
      const a = i.build(e, r);
      s =
        this.components.length === n &&
        this.components === Bh.slice(0, this.components.length)
          ? e.format(a, r, t)
          : e.format(`${a}.${this.components}`, this.getNodeType(e), t);
    } else s = i.build(e, t);
    return s;
  }
  serialize(e) {
    super.serialize(e), (e.components = this.components);
  }
  deserialize(e) {
    super.deserialize(e), (this.components = e.components);
  }
}
const Oh = kh;
Ch(kh);
class Uh extends wh {
  constructor(e, t = null) {
    super(e, t), (this.isConstNode = !0);
  }
  generateConst(e) {
    return e.getConst(this.getNodeType(e), this.value);
  }
  generate(e, t) {
    const i = this.getNodeType(e);
    return e.format(this.generateConst(e), i, t);
  }
}
const zh = Uh;
Ch(Uh);
const Gh = new Map();
function Vh(e, t) {
  if (Gh.has(e)) throw new Error(`Redefinition of node element ${e}`);
  if ("function" != typeof t)
    throw new Error(`Node element ${e} is not a function`);
  Gh.set(e, t);
}
const Qh = {
    construct(e, t) {
      const i = t.shift();
      return e(cc(i), ...t);
    },
    get: function (e, t, i) {
      if ("string" == typeof t && void 0 === e[t]) {
        if (Gh.has(t)) {
          const e = Gh.get(t);
          return (...t) => e(i, ...t);
        }
        if ("self" === t) return e;
        if (t.endsWith("Assign") && Gh.has(t.slice(0, t.length - 6))) {
          const e = Gh.get(t.slice(0, t.length - 6));
          return (...t) => i.assign(e(i, ...t));
        }
        if (!0 === /^[xyzwrgbastpq]{1,4}$/.test(t))
          return (
            (t = t
              .replace(/r|s/g, "x")
              .replace(/g|t/g, "y")
              .replace(/b|p/g, "z")
              .replace(/a|q/g, "w")),
            hc(new Oh(e, t))
          );
        if ("width" === t || "height" === t)
          return hc(new Oh(e, "width" === t ? "x" : "y"));
        if (!0 === /^\d+$/.test(t))
          return hc(new Ih(e, new zh(Number(t), "uint")));
      }
      return e[t];
    },
  },
  Hh = new WeakMap(),
  jh = function (e, t = null) {
    for (const i in e) e[i] = hc(e[i], t);
    return e;
  },
  Wh = function (e, t = null) {
    const i = e.length;
    for (let n = 0; n < i; n++) e[n] = hc(e[n], t);
    return e;
  },
  qh = function (e, t = null, i = null, n = null) {
    const s = (e) => hc(null !== n ? Object.assign(e, n) : e);
    return null === t
      ? (...t) => s(new e(...uc(t)))
      : null !== i
      ? ((i = hc(i)), (...n) => s(new e(t, ...uc(n), i)))
      : (...i) => s(new e(t, ...uc(i)));
  },
  Xh = function (e, ...t) {
    return hc(new e(...uc(t)));
  };
class Yh extends Sh {
  constructor(e) {
    super(), (this._jsFunc = e);
  }
  call(e, t, i) {
    return (e = cc(e)), hc(this._jsFunc(e, t, i));
  }
  getNodeType(e) {
    const { outputNode: t } = e.getNodeProperties(this);
    return t ? t.getNodeType(e) : super.getNodeType(e);
  }
  construct(e) {
    return (
      e.addStack(),
      (e.stack.outputNode = hc(this._jsFunc(e.stack, e))),
      e.removeStack()
    );
  }
}
const Kh = [!1, !0],
  Zh = [0, 1, 2, 3],
  Jh = [-1, -2],
  $h = [
    0.5,
    1.5,
    1 / 3,
    1e-6,
    1e6,
    Math.PI,
    2 * Math.PI,
    1 / Math.PI,
    2 / Math.PI,
    1 / (2 * Math.PI),
    Math.PI / 2,
  ],
  ec = new Map();
for (const xN of Kh) ec.set(xN, new zh(xN));
const tc = new Map();
for (const xN of Zh) tc.set(xN, new zh(xN, "uint"));
const ic = new Map([...tc].map((e) => new zh(e.value, "int")));
for (const xN of Jh) ic.set(xN, new zh(xN, "int"));
const nc = new Map([...ic].map((e) => new zh(e.value)));
for (const xN of $h) nc.set(xN, new zh(xN));
for (const xN of $h) nc.set(-xN, new zh(-xN));
const sc = { bool: ec, uint: tc, ints: ic, float: nc },
  rc = new Map([...ec, ...nc]),
  ac = (e, t) => (rc.has(e) ? rc.get(e) : !0 === e.isNode ? e : new zh(e, t)),
  oc = function (e, t = null) {
    return (...i) => {
      if (
        ((0 === i.length ||
          (!["bool", "float", "int", "uint"].includes(e) &&
            i.every((e) => "object" != typeof e))) &&
          (i = [xh(e, ...i)]),
        1 === i.length && null !== t && t.has(i[0]))
      )
        return hc(t.get(i[0]));
      if (1 === i.length) {
        const t = ac(i[0], e);
        return ((e) => {
          try {
            return e.getNodeType();
          } catch (t) {
            return;
          }
        })(t) === e
          ? hc(t)
          : hc(new Ph(t, e));
      }
      const n = i.map((e) => ac(e));
      return hc(new Nh(n, e));
    };
  };
function lc(e) {
  return new Proxy(new Yh(e), Qh);
}
const hc = (e, t = null) =>
    (function (e, t = null) {
      const i = yh(e);
      if ("node" === i) {
        let t = Hh.get(e);
        return (
          void 0 === t && ((t = new Proxy(e, Qh)), Hh.set(e, t), Hh.set(t, t)),
          t
        );
      }
      return (null === t && ("float" === i || "boolean" === i)) ||
        (i && "shader" !== i && "string" !== i)
        ? hc(ac(e, t))
        : "shader" === i
        ? fc(e)
        : e;
    })(e, t),
  cc = (e, t = null) => new jh(e, t),
  uc = (e, t = null) => new Wh(e, t),
  dc = (...e) => new qh(...e),
  pc = (...e) => new Xh(...e),
  fc = (e) => {
    let t = null;
    return (...i) => (null === t && (t = new lc(e)), t.call(...i));
  };
Ch(lc);
const mc = new oc("color"),
  gc = new oc("float", sc.float),
  _c = new oc("int", sc.int),
  vc = new oc("uint", sc.uint),
  Ac = new oc("bool", sc.bool),
  yc = new oc("vec2"),
  xc = new oc("ivec2"),
  bc = new oc("uvec2"),
  Ec = new oc("bvec2"),
  Sc = new oc("vec3"),
  Cc = new oc("ivec3"),
  Mc = new oc("uvec3"),
  wc = new oc("bvec3"),
  Tc = new oc("vec4"),
  Ic = new oc("ivec4"),
  Rc = new oc("uvec4"),
  Pc = new oc("bvec4"),
  Dc = new oc("mat3"),
  Lc = new oc("imat3"),
  Fc = new oc("umat3"),
  Nc = new oc("bmat3"),
  Bc = new oc("mat4"),
  kc = new oc("imat4"),
  Oc = new oc("umat4"),
  Uc = new oc("bmat4");
Vh("color", mc),
  Vh("float", gc),
  Vh("int", _c),
  Vh("uint", vc),
  Vh("bool", Ac),
  Vh("vec2", yc),
  Vh("ivec2", xc),
  Vh("uvec2", bc),
  Vh("bvec2", Ec),
  Vh("vec3", Sc),
  Vh("ivec3", Cc),
  Vh("uvec3", Mc),
  Vh("bvec3", wc),
  Vh("vec4", Tc),
  Vh("ivec4", Ic),
  Vh("uvec4", Rc),
  Vh("bvec4", Pc),
  Vh("mat3", Dc),
  Vh("imat3", Lc),
  Vh("umat3", Fc),
  Vh("bmat3", Nc),
  Vh("mat4", Bc),
  Vh("imat4", kc),
  Vh("umat4", Oc),
  Vh("bmat4", Uc),
  Vh("string", (e = "") => hc(new zh(e, "string"))),
  Vh("arrayBuffer", (e) => hc(new zh(e, "ArrayBuffer")));
Vh("element", dc(Ih)), Vh("convert", (e, t) => hc(new Ph(hc(e), t)));
class zc extends wh {
  constructor(e, t = null) {
    super(e, t), (this.isUniformNode = !0);
  }
  getUniformHash(e) {
    return this.getHash(e);
  }
  generate(e, t) {
    const i = this.getNodeType(e),
      n = this.getUniformHash(e);
    let s = e.getNodeFromHash(n);
    void 0 === s && (e.setHashNode(this, n), (s = this));
    const r = s.getInputType(e),
      a = e.getUniformFromNode(s, r, e.shaderStage, e.context.label),
      o = e.getPropertyName(a);
    return e.format(o, i, t);
  }
}
const Gc = zc,
  Vc = (e, t) => {
    const i = ((e) =>
        null != e
          ? e.nodeType || e.convertTo || ("string" == typeof e ? e : null)
          : null)(t || e),
      n = e && !0 === e.isNode ? (e.node && e.node.value) || e.value : e;
    return hc(new zc(n, i));
  };
Ch(zc);
class Qc extends Sh {
  constructor(e, t = null) {
    super(), (this.node = e), (this.name = t);
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const { name: t, node: i } = this,
      n = this.getNodeType(e),
      s = e.getVaryingFromNode(this, n);
    s.needsInterpolation ||
      (s.needsInterpolation = "fragment" === e.shaderStage),
      null !== t && (s.name = t);
    const r = e.getPropertyName(s, hh);
    return e.flowNodeFromShaderStage(hh, i, n, r), e.getPropertyName(s);
  }
}
const Hc = dc(Qc);
Vh("varying", Hc), Ch(Qc);
class jc extends Sh {
  constructor(e, t = null) {
    super(t), (this._attributeName = e);
  }
  getHash(e) {
    return this.getAttributeName(e);
  }
  getNodeType(e) {
    let t = super.getNodeType(e);
    if (null === t) {
      const i = this.getAttributeName(e);
      if (e.hasGeometryAttribute(i)) {
        const n = e.geometry.getAttribute(i);
        t = e.getTypeFromAttribute(n);
      } else t = "float";
    }
    return t;
  }
  setAttributeName(e) {
    return (this._attributeName = e), this;
  }
  getAttributeName() {
    return this._attributeName;
  }
  generate(e) {
    const t = this.getAttributeName(e),
      i = this.getNodeType(e);
    if (!0 === e.hasGeometryAttribute(t)) {
      const n = e.geometry.getAttribute(t),
        s = e.getTypeFromAttribute(n),
        r = e.getAttribute(t, s);
      if ("vertex" === e.shaderStage) return e.format(r.name, s, i);
      return Hc(this).build(e, i);
    }
    return (
      console.warn(`AttributeNode: Attribute "${t}" not found.`), e.getConst(i)
    );
  }
}
const Wc = (e, t) => hc(new jc(e, t));
Ch(jc);
class qc extends Sh {
  constructor(e, t) {
    super(),
      (this.isBypassNode = !0),
      (this.outputNode = e),
      (this.callNode = t);
  }
  getNodeType(e) {
    return this.outputNode.getNodeType(e);
  }
  generate(e) {
    const t = this.callNode.build(e, "void");
    return "" !== t && e.addLineFlowCode(t), this.outputNode.build(e);
  }
}
const Xc = dc(qc);
Vh("bypass", Xc), Ch(qc);
let Yc = 0;
const Kc = class {
  constructor() {
    (this.id = Yc++), (this.nodesData = new WeakMap());
  }
  getNodeData(e) {
    return this.nodesData.get(e);
  }
  setNodeData(e, t) {
    this.nodesData.set(e, t);
  }
};
class Zc extends Sh {
  constructor(e, t = new Kc()) {
    super(), (this.isCacheNode = !0), (this.node = e), (this.cache = t);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  build(e, ...t) {
    const i = e.getCache();
    e.setCache(this.cache);
    const n = this.node.build(e, ...t);
    return e.setCache(i), n;
  }
}
const Jc = dc(Zc);
Vh("cache", Jc), Ch(Zc);
class $c extends Sh {
  constructor(e, t = {}) {
    super(), (this.isContextNode = !0), (this.node = e), (this.context = t);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  construct(e) {
    const t = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const i = this.node.build(e);
    return e.setContext(t), i;
  }
  generate(e, t) {
    const i = e.getContext();
    e.setContext({ ...e.context, ...this.context });
    const n = this.node.build(e, t);
    return e.setContext(i), n;
  }
}
const eu = dc($c),
  tu = (e, t) => eu(e, { label: t });
Vh("context", eu), Vh("label", tu), Ch($c);
const iu = class {
  constructor(e, t, i = null) {
    (this.isNodeAttribute = !0),
      (this.name = e),
      (this.type = t),
      (this.node = i);
  }
};
const nu = class {
  constructor(e, t, i, n = void 0) {
    (this.isNodeUniform = !0),
      (this.name = e),
      (this.type = t),
      (this.node = i.getSelf()),
      (this.needsUpdate = n);
  }
  get value() {
    return this.node.value;
  }
  set value(e) {
    this.node.value = e;
  }
};
const su = class {
  constructor(e, t) {
    (this.isNodeVar = !0), (this.name = e), (this.type = t);
  }
};
const ru = class extends su {
  constructor(e, t) {
    super(e, t), (this.needsInterpolation = !1), (this.isNodeVarying = !0);
  }
};
const au = class {
  constructor(e, t, i = "") {
    (this.name = e),
      (this.type = t),
      (this.code = i),
      Object.defineProperty(this, "isNodeCode", { value: !0 });
  }
};
const ou = class {
  constructor() {
    (this.keywords = []), (this.nodes = []), (this.keywordsCallback = {});
  }
  getNode(e) {
    let t = this.nodes[e];
    return (
      void 0 === t &&
        void 0 !== this.keywordsCallback[e] &&
        ((t = this.keywordsCallback[e](e)), (this.nodes[e] = t)),
      t
    );
  }
  addKeyword(e, t) {
    return this.keywords.push(e), (this.keywordsCallback[e] = t), this;
  }
  parse(e) {
    const t = this.keywords,
      i = new RegExp(`\\b${t.join("\\b|\\b")}\\b`, "g"),
      n = e.match(i),
      s = [];
    if (null !== n)
      for (const r of n) {
        const e = this.getNode(r);
        void 0 !== e && -1 === s.indexOf(e) && s.push(e);
      }
    return s;
  }
  include(e, t) {
    const i = this.parse(t);
    for (const n of i) n.build(e);
  }
};
class lu extends Sh {
  constructor(e, t = null) {
    super(e), (this.name = t);
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  isGlobal() {
    return !0;
  }
  generate(e) {
    const t = e.getVarFromNode(this, this.getNodeType(e)),
      i = this.name;
    return null !== i && (t.name = i), e.getPropertyName(t);
  }
}
const hu = (e, t) => hc(new lu(e, t)),
  cu = pc(lu, "vec4", "DiffuseColor"),
  uu = pc(lu, "float", "Roughness");
pc(lu, "float", "Metalness"), pc(lu, "float", "Clearcoat");
const du = pc(lu, "float", "ClearcoatRoughness");
pc(lu, "vec3", "Sheen"),
  pc(lu, "float", "SheenRoughness"),
  pc(lu, "float", "Iridescence"),
  pc(lu, "float", "IridescenceIOR"),
  pc(lu, "float", "IridescenceThickness"),
  pc(lu, "color", "SpecularColor"),
  pc(lu, "float", "Shininess");
const pu = pc(lu, "vec4", "Output");
pc(lu, "float", "dashScale"), pc(lu, "float", "gapSize"), Ch(lu);
class fu extends jc {
  constructor(e = 0) {
    super(null, "vec2"), (this.isUVNode = !0), (this.index = e);
  }
  getAttributeName() {
    const e = this.index;
    return "uv" + (e > 0 ? e : "");
  }
  serialize(e) {
    super.serialize(e), (e.index = this.index);
  }
  deserialize(e) {
    super.deserialize(e), (this.index = e.index);
  }
}
const mu = (...e) => hc(new fu(...e));
Ch(fu);
class gu extends Sh {
  constructor(e, t = null) {
    super("uvec2"),
      (this.isTextureSizeNode = !0),
      (this.textureNode = e),
      (this.levelNode = t);
  }
  generate(e, t) {
    const i = this.textureNode.build(e, "property"),
      n = this.levelNode.build(e, "int");
    return e.format(`textureDimensions( ${i}, ${n} )`, this.getNodeType(e), t);
  }
}
const _u = dc(gu);
Vh("textureSize", _u), Ch(gu);
class vu extends Lh {
  constructor(e, t, i, ...n) {
    if ((super(), (this.op = e), n.length > 0)) {
      let t = i;
      for (let i = 0; i < n.length; i++) t = new vu(e, t, n[i]);
      i = t;
    }
    (this.aNode = t), (this.bNode = i);
  }
  hasDependencies(e) {
    return "=" !== this.op && super.hasDependencies(e);
  }
  getNodeType(e, t) {
    const i = this.op,
      n = this.aNode,
      s = this.bNode,
      r = n.getNodeType(e),
      a = s.getNodeType(e);
    if ("void" === r || "void" === a) return "void";
    if ("=" === i || "%" === i) return r;
    if ("&" === i || "|" === i || "^" === i || ">>" === i || "<<" === i)
      return e.getIntegerType(r);
    if ("==" === i || "&&" === i || "||" === i || "^^" === i) return "bool";
    if ("<" === i || ">" === i || "<=" === i || ">=" === i) {
      const i = t
        ? e.getTypeLength(t)
        : Math.max(e.getTypeLength(r), e.getTypeLength(a));
      return i > 1 ? `bvec${i}` : "bool";
    }
    return "float" === r && e.isMatrix(a)
      ? a
      : e.isMatrix(r) && e.isVector(a)
      ? e.getVectorFromMatrix(r)
      : e.isVector(r) && e.isMatrix(a)
      ? e.getVectorFromMatrix(a)
      : e.getTypeLength(a) > e.getTypeLength(r)
      ? a
      : r;
  }
  generate(e, t) {
    const i = this.op,
      n = this.aNode,
      s = this.bNode,
      r = this.getNodeType(e, t);
    let a = null,
      o = null;
    "void" !== r
      ? ((a = n.getNodeType(e)),
        (o = s.getNodeType(e)),
        "=" === i
          ? (o = a)
          : "<" === i || ">" === i || "<=" === i || ">=" === i || "==" === i
          ? e.isVector(a)
            ? (o = a)
            : (a = o = "float")
          : ">>" === i || "<<" === i
          ? ((a = r), (o = e.changeComponentType(o, "uint")))
          : e.isMatrix(a) && e.isVector(o)
          ? (o = e.getVectorFromMatrix(a))
          : (a =
              e.isVector(a) && e.isMatrix(o)
                ? e.getVectorFromMatrix(o)
                : (o = r)))
      : (a = o = r);
    const l = n.build(e, a),
      h = s.build(e, o),
      c = e.getTypeLength(t);
    return "void" !== t
      ? "=" === i
        ? (e.addLineFlowCode(`${l} ${this.op} ${h}`), l)
        : "<" === i && c > 1
        ? e.format(`${e.getMethod("lessThan")}( ${l}, ${h} )`, r, t)
        : "<=" === i && c > 1
        ? e.format(`${e.getMethod("lessThanEqual")}( ${l}, ${h} )`, r, t)
        : ">" === i && c > 1
        ? e.format(`${e.getMethod("greaterThan")}( ${l}, ${h} )`, r, t)
        : ">=" === i && c > 1
        ? e.format(`${e.getMethod("greaterThanEqual")}( ${l}, ${h} )`, r, t)
        : e.format(`( ${l} ${this.op} ${h} )`, r, t)
      : "void" !== a
      ? e.format(`${l} ${this.op} ${h}`, r, t)
      : void 0;
  }
  serialize(e) {
    super.serialize(e), (e.op = this.op);
  }
  deserialize(e) {
    super.deserialize(e), (this.op = e.op);
  }
}
const Au = dc(vu, "+"),
  yu = dc(vu, "-"),
  xu = dc(vu, "*"),
  bu = dc(vu, "/"),
  Eu = dc(vu, "%"),
  Su = dc(vu, "=="),
  Cu = dc(vu, "="),
  Mu = dc(vu, "<"),
  wu = dc(vu, ">"),
  Tu = dc(vu, "<="),
  Iu = dc(vu, ">="),
  Ru = dc(vu, "&&"),
  Pu = dc(vu, "||"),
  Du = dc(vu, "^^"),
  Lu = dc(vu, "&"),
  Fu = dc(vu, "|"),
  Nu = dc(vu, "^"),
  Bu = dc(vu, "<<"),
  ku = dc(vu, ">>");
Vh("add", Au),
  Vh("sub", yu),
  Vh("mul", xu),
  Vh("div", bu),
  Vh("remainder", Eu),
  Vh("equal", Su),
  Vh("assign", Cu),
  Vh("lessThan", Mu),
  Vh("greaterThan", wu),
  Vh("lessThanEqual", Tu),
  Vh("greaterThanEqual", Iu),
  Vh("and", Ru),
  Vh("or", Pu),
  Vh("xor", Du),
  Vh("bitAnd", Lu),
  Vh("bitOr", Fu),
  Vh("bitXor", Nu),
  Vh("shiftLeft", Bu),
  Vh("shiftRight", ku),
  Ch(vu);
class Ou extends Lh {
  constructor(e, t, i = null, n = null) {
    super(),
      (this.method = e),
      (this.aNode = t),
      (this.bNode = i),
      (this.cNode = n);
  }
  getInputType(e) {
    const t = this.aNode.getNodeType(e),
      i = this.bNode ? this.bNode.getNodeType(e) : null,
      n = this.cNode ? this.cNode.getNodeType(e) : null,
      s = e.isMatrix(t) ? 0 : e.getTypeLength(t),
      r = e.isMatrix(i) ? 0 : e.getTypeLength(i),
      a = e.isMatrix(n) ? 0 : e.getTypeLength(n);
    return s > r && s > a ? t : r > a ? i : a > s ? n : t;
  }
  getNodeType(e) {
    const t = this.method;
    return t === Ou.LENGTH || t === Ou.DISTANCE || t === Ou.DOT
      ? "float"
      : t === Ou.CROSS
      ? "vec3"
      : this.getInputType(e);
  }
  generate(e, t) {
    const i = this.method,
      n = this.getNodeType(e),
      s = this.getInputType(e),
      r = this.aNode,
      a = this.bNode,
      o = this.cNode,
      l = !0 === e.renderer.isWebGLRenderer;
    if (i === Ou.TRANSFORM_DIRECTION) {
      let i = r,
        n = a;
      e.isMatrix(i.getNodeType(e)) ? (n = Tc(Sc(n), 0)) : (i = Tc(Sc(i), 0));
      const s = xu(i, n).xyz;
      return Ku(s).build(e, t);
    }
    if (i === Ou.NEGATE) return e.format("-" + r.build(e, s), n, t);
    if (i === Ou.ONE_MINUS) return yu(1, r).build(e, t);
    if (i === Ou.RECIPROCAL) return bu(1, r).build(e, t);
    if (i === Ou.DIFFERENCE) return sd(yu(r, a)).build(e, t);
    {
      const h = [];
      return (
        i === Ou.CROSS
          ? h.push(r.build(e, n), a.build(e, n))
          : i === Ou.STEP
          ? h.push(
              r.build(e, 1 === e.getTypeLength(r.getNodeType(e)) ? "float" : s),
              a.build(e, s)
            )
          : (l && (i === Ou.MIN || i === Ou.MAX)) || i === Ou.MOD
          ? h.push(
              r.build(e, s),
              a.build(e, 1 === e.getTypeLength(a.getNodeType(e)) ? "float" : s)
            )
          : i === Ou.REFRACT
          ? h.push(r.build(e, s), a.build(e, s), o.build(e, "float"))
          : i === Ou.MIX
          ? h.push(
              r.build(e, s),
              a.build(e, s),
              o.build(e, 1 === e.getTypeLength(o.getNodeType(e)) ? "float" : s)
            )
          : (h.push(r.build(e, s)),
            null !== a && h.push(a.build(e, s)),
            null !== o && h.push(o.build(e, s))),
        e.format(`${e.getMethod(i)}( ${h.join(", ")} )`, n, t)
      );
    }
  }
  serialize(e) {
    super.serialize(e), (e.method = this.method);
  }
  deserialize(e) {
    super.deserialize(e), (this.method = e.method);
  }
}
(Ou.RADIANS = "radians"),
  (Ou.DEGREES = "degrees"),
  (Ou.EXP = "exp"),
  (Ou.EXP2 = "exp2"),
  (Ou.LOG = "log"),
  (Ou.LOG2 = "log2"),
  (Ou.SQRT = "sqrt"),
  (Ou.INVERSE_SQRT = "inversesqrt"),
  (Ou.FLOOR = "floor"),
  (Ou.CEIL = "ceil"),
  (Ou.NORMALIZE = "normalize"),
  (Ou.FRACT = "fract"),
  (Ou.SIN = "sin"),
  (Ou.COS = "cos"),
  (Ou.TAN = "tan"),
  (Ou.ASIN = "asin"),
  (Ou.ACOS = "acos"),
  (Ou.ATAN = "atan"),
  (Ou.ABS = "abs"),
  (Ou.SIGN = "sign"),
  (Ou.LENGTH = "length"),
  (Ou.NEGATE = "negate"),
  (Ou.ONE_MINUS = "oneMinus"),
  (Ou.DFDX = "dFdx"),
  (Ou.DFDY = "dFdy"),
  (Ou.ROUND = "round"),
  (Ou.RECIPROCAL = "reciprocal"),
  (Ou.TRUNC = "trunc"),
  (Ou.FWIDTH = "fwidth"),
  (Ou.ATAN2 = "atan2"),
  (Ou.MIN = "min"),
  (Ou.MAX = "max"),
  (Ou.MOD = "mod"),
  (Ou.STEP = "step"),
  (Ou.REFLECT = "reflect"),
  (Ou.DISTANCE = "distance"),
  (Ou.DIFFERENCE = "difference"),
  (Ou.DOT = "dot"),
  (Ou.CROSS = "cross"),
  (Ou.POW = "pow"),
  (Ou.TRANSFORM_DIRECTION = "transformDirection"),
  (Ou.MIX = "mix"),
  (Ou.CLAMP = "clamp"),
  (Ou.REFRACT = "refract"),
  (Ou.SMOOTHSTEP = "smoothstep"),
  (Ou.FACEFORWARD = "faceforward");
const Uu = Ou;
gc(1e-6), gc(1e6);
const zu = dc(Ou, Ou.RADIANS),
  Gu = dc(Ou, Ou.DEGREES),
  Vu = dc(Ou, Ou.EXP),
  Qu = dc(Ou, Ou.EXP2),
  Hu = dc(Ou, Ou.LOG),
  ju = dc(Ou, Ou.LOG2),
  Wu = dc(Ou, Ou.SQRT),
  qu = dc(Ou, Ou.INVERSE_SQRT),
  Xu = dc(Ou, Ou.FLOOR),
  Yu = dc(Ou, Ou.CEIL),
  Ku = dc(Ou, Ou.NORMALIZE),
  Zu = dc(Ou, Ou.FRACT),
  Ju = dc(Ou, Ou.SIN),
  $u = dc(Ou, Ou.COS),
  ed = dc(Ou, Ou.TAN),
  td = dc(Ou, Ou.ASIN),
  id = dc(Ou, Ou.ACOS),
  nd = dc(Ou, Ou.ATAN),
  sd = dc(Ou, Ou.ABS),
  rd = dc(Ou, Ou.SIGN),
  ad = dc(Ou, Ou.LENGTH),
  od = dc(Ou, Ou.NEGATE),
  ld = dc(Ou, Ou.ONE_MINUS),
  hd = dc(Ou, Ou.DFDX),
  cd = dc(Ou, Ou.DFDY),
  ud = dc(Ou, Ou.ROUND),
  dd = dc(Ou, Ou.RECIPROCAL),
  pd = dc(Ou, Ou.TRUNC),
  fd = dc(Ou, Ou.FWIDTH),
  md = dc(Ou, Ou.ATAN2),
  gd = dc(Ou, Ou.MIN),
  _d = dc(Ou, Ou.MAX),
  vd = dc(Ou, Ou.MOD),
  Ad = dc(Ou, Ou.STEP),
  yd = dc(Ou, Ou.REFLECT),
  xd = dc(Ou, Ou.DISTANCE),
  bd = dc(Ou, Ou.DIFFERENCE),
  Ed = dc(Ou, Ou.DOT),
  Sd = dc(Ou, Ou.CROSS),
  Cd = dc(Ou, Ou.POW),
  Md = dc(Ou, Ou.POW, 2),
  wd = dc(Ou, Ou.POW, 3),
  Td = dc(Ou, Ou.POW, 4),
  Id = dc(Ou, Ou.TRANSFORM_DIRECTION),
  Rd = dc(Ou, Ou.MIX),
  Pd = (e, t = 0, i = 1) => hc(new Ou(Ou.CLAMP, hc(e), hc(t), hc(i))),
  Dd = dc(Ou, Ou.REFRACT),
  Ld = dc(Ou, Ou.SMOOTHSTEP),
  Fd = dc(Ou, Ou.FACEFORWARD);
Vh("radians", zu),
  Vh("degrees", Gu),
  Vh("exp", Vu),
  Vh("exp2", Qu),
  Vh("log", Hu),
  Vh("log2", ju),
  Vh("sqrt", Wu),
  Vh("inverseSqrt", qu),
  Vh("floor", Xu),
  Vh("ceil", Yu),
  Vh("normalize", Ku),
  Vh("fract", Zu),
  Vh("sin", Ju),
  Vh("cos", $u),
  Vh("tan", ed),
  Vh("asin", td),
  Vh("acos", id),
  Vh("atan", nd),
  Vh("abs", sd),
  Vh("sign", rd),
  Vh("length", ad),
  Vh("negate", od),
  Vh("oneMinus", ld),
  Vh("dFdx", hd),
  Vh("dFdy", cd),
  Vh("round", ud),
  Vh("reciprocal", dd),
  Vh("trunc", pd),
  Vh("fwidth", fd),
  Vh("atan2", md),
  Vh("min", gd),
  Vh("max", _d),
  Vh("mod", vd),
  Vh("step", Ad),
  Vh("reflect", yd),
  Vh("distance", xd),
  Vh("dot", Ed),
  Vh("cross", Sd),
  Vh("pow", Cd),
  Vh("pow2", Md),
  Vh("pow3", wd),
  Vh("pow4", Td),
  Vh("transformDirection", Id),
  Vh("mix", (e, t, i) => Rd(t, i, e)),
  Vh("clamp", Pd),
  Vh("refract", Dd),
  Vh("smoothstep", (e, t, i) => Ld(t, i, e)),
  Vh("faceForward", Fd),
  Vh("difference", bd),
  Vh("saturate", (e) => Pd(e)),
  Ch(Ou);
const Nd = fc((e) => {
    const { value: t } = e,
      { rgb: i } = t,
      n = i.mul(0.9478672986).add(0.0521327014).pow(2.4),
      s = i.mul(0.0773993808),
      r = i.lessThanEqual(0.04045),
      a = Rd(n, s, r);
    return Tc(a, t.a);
  }),
  Bd = fc((e) => {
    const { value: t } = e,
      { rgb: i } = t,
      n = i.pow(0.41666).mul(1.055).sub(0.055),
      s = i.mul(12.92),
      r = i.lessThanEqual(0.0031308),
      a = Rd(n, s, r);
    return Tc(a, t.a);
  }),
  kd = (e) => {
    let t = null;
    return e === ge ? (t = "Linear") : e === me && (t = "sRGB"), t;
  },
  Od = (e, t) => kd(e) + "To" + kd(t);
class Ud extends Lh {
  constructor(e, t) {
    super("vec4"), (this.method = e), (this.node = t);
  }
  construct() {
    const { method: e, node: t } = this;
    return e === Ud.LINEAR_TO_LINEAR ? t : zd[e]({ value: t });
  }
}
(Ud.LINEAR_TO_LINEAR = "LinearToLinear"),
  (Ud.LINEAR_TO_sRGB = "LinearTosRGB"),
  (Ud.sRGB_TO_LINEAR = "sRGBToLinear");
const zd = { [Ud.LINEAR_TO_sRGB]: Bd, [Ud.sRGB_TO_LINEAR]: Nd },
  Gd = (e, t) => hc(new Ud(Od(t, ge), hc(e))),
  Vd = dc(Ud, Ud.LINEAR_TO_sRGB),
  Qd = dc(Ud, Ud.sRGB_TO_LINEAR);
Vh("linearTosRGB", Vd),
  Vh("sRGBToLinear", Qd),
  Vh("linearToColorSpace", (e, t) => hc(new Ud(Od(ge, t), hc(e)))),
  Vh("colorSpaceToLinear", Gd),
  Ch(Ud);
class Hd extends Sh {
  constructor(e = "", t = "void") {
    super(t), (this.snippet = e);
  }
  generate(e, t) {
    const i = this.getNodeType(e),
      n = this.snippet;
    if ("void" !== i) return e.format(`( ${n} )`, i, t);
    e.addLineFlowCode(n);
  }
}
const jd = dc(Hd);
Ch(Hd);
class Wd extends Gc {
  constructor(e, t = null, i = null, n = null) {
    super(e),
      (this.isTextureNode = !0),
      (this.uvNode = t),
      (this.levelNode = i),
      (this.compareNode = n),
      (this.updateMatrix = !1),
      (this.updateType = ch),
      this.setUpdateMatrix(null === t);
  }
  getUniformHash() {
    return this.value.uuid;
  }
  getNodeType() {
    return !0 === this.value.isDepthTexture ? "float" : "vec4";
  }
  getInputType() {
    return "texture";
  }
  getDefaultUV() {
    return mu(this.value.channel);
  }
  getTextureMatrix(e) {
    const t = this.value;
    return Vc(t.matrix).mul(Sc(e, 1)).xy;
  }
  setUpdateMatrix(e) {
    return (this.updateMatrix = e), (this.updateType = e ? uh : ch), this;
  }
  construct(e) {
    const t = e.getNodeProperties(this);
    let i = this.uvNode;
    null === i && e.context.getUVNode && (i = e.context.getUVNode(this)),
      i || (i = this.getDefaultUV()),
      this.updateMatrix && (i = this.getTextureMatrix(i));
    let n = this.levelNode;
    null === n &&
      e.context.getSamplerLevelNode &&
      (n = e.context.getSamplerLevelNode(this)),
      (t.uvNode = i),
      (t.levelNode = n ? e.context.getMIPLevelAlgorithmNode(this, n) : null);
  }
  generate(e, t) {
    const { uvNode: i, levelNode: n } = e.getNodeProperties(this),
      s = this.compareNode,
      r = this.value;
    if (!r || !0 !== r.isTexture)
      throw new Error("TextureNode: Need a three.js texture.");
    const a = super.generate(e, "property");
    if ("sampler" === t) return a + "_sampler";
    if (e.isReference(t)) return a;
    {
      const o = this.getNodeType(e),
        l = e.getDataFromNode(this);
      let h = l.propertyName;
      if (void 0 === h) {
        const t = i.build(e, "vec2"),
          c = e.getVarFromNode(this, o);
        h = e.getPropertyName(c);
        let u = null;
        if (n && !0 === n.isNode) {
          const i = n.build(e, "float");
          u = e.getTextureLevel(r, a, t, i);
        } else if (null !== s) {
          const i = s.build(e, "float");
          u = e.getTextureCompare(r, a, t, i);
        } else u = e.getTexture(r, a, t);
        e.addLineFlowCode(`${h} = ${u}`),
          !1 !== e.context.tempWrite && ((l.snippet = u), (l.propertyName = h));
      }
      let c = h;
      return (
        e.needsColorSpaceToLinear(this.value) &&
          (c = Gd(jd(c, o), this.value.colorSpace).construct(e).build(e, o)),
        e.format(c, o, t)
      );
    }
  }
  uv(e) {
    const t = this.clone();
    return (t.uvNode = e), hc(t);
  }
  level(e) {
    const t = this.clone();
    return (t.levelNode = e), eu(t, { getMIPLevelAlgorithmNode: (e, t) => t });
  }
  size(e) {
    return _u(this, e);
  }
  compare(e) {
    const t = this.clone();
    return (t.compareNode = hc(e)), hc(t);
  }
  serialize(e) {
    super.serialize(e), (e.value = this.value.toJSON(e.meta).uuid);
  }
  deserialize(e) {
    super.deserialize(e), (this.value = e.meta.textures[e.value]);
  }
  update() {
    const e = this.value;
    !0 === e.matrixAutoUpdate && e.updateMatrix();
  }
  clone() {
    return new this.constructor(
      this.value,
      this.uvNode,
      this.levelNode,
      this.compareNode
    );
  }
}
const qd = dc(Wd);
Vh("texture", qd), Ch(Wd);
class Xd extends Sh {
  constructor(e, t, i = null) {
    super(),
      (this.property = e),
      (this.uniformType = t),
      (this.object = i),
      (this.node = null),
      (this.updateType = ph),
      this.setNodeType(t);
  }
  setNodeType(e) {
    let t = null;
    (t = "texture" === e ? qd(null) : Vc(e)), (this.node = t);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  update(e) {
    const t = null !== this.object ? this.object : e.object,
      i = this.property;
    this.node.value = t[i];
  }
  construct() {
    return this.node;
  }
}
const Yd = (e, t, i) => hc(new Xd(e, t, i));
Ch(Xd);
class Kd extends Xd {
  constructor(e, t, i = null) {
    super(e, t, i), (this.material = i), (this.updateType = dh);
  }
  construct(e) {
    const t = null !== this.material ? this.material : e.material;
    return (this.node.value = t[this.property]), super.construct(e);
  }
  update(e) {
    (this.object = null !== this.material ? this.material : e.material),
      super.update(e);
  }
}
const Zd = (e, t, i) => hc(new Kd(e, t, i));
Ch(Kd);
const Jd = new WeakMap();
class $d extends Sh {
  constructor(e) {
    super(), (this.scope = e);
  }
  getCache(e, t, i) {
    const n = e.context.material;
    let s = Jd.get(n);
    void 0 === s && ((s = {}), Jd.set(n, s));
    let r = s[t];
    return void 0 === r && ((r = Zd(t, i)), (s[t] = r)), r;
  }
  getFloat(e, t) {
    return this.getCache(e, t, "float");
  }
  getColor(e, t) {
    return this.getCache(e, t, "color");
  }
  getTexture(e, t) {
    return this.getCache(e, t, "texture");
  }
  construct(e) {
    const t = e.context.material,
      i = this.scope;
    let n = null;
    if (
      i === $d.ALPHA_TEST ||
      i === $d.SHININESS ||
      i === $d.REFLECTIVITY ||
      i === $d.ROTATION ||
      i === $d.IRIDESCENCE ||
      i === $d.IRIDESCENCE_IOR
    )
      n = this.getFloat(e, i);
    else if (i === $d.SPECULAR_COLOR) n = this.getColor(e, "specular");
    else if (i === $d.COLOR) {
      const i = this.getColor(e, "color");
      n =
        t.map && !0 === t.map.isTexture ? i.mul(this.getTexture(e, "map")) : i;
    } else if (i === $d.OPACITY) {
      const i = this.getFloat(e, "opacity");
      n =
        t.alphaMap && !0 === t.alphaMap.isTexture
          ? i.mul(this.getTexture(e, "alphaMap"))
          : i;
    } else if (i === $d.SPECULAR_STRENGTH)
      n =
        t.specularMap && !0 === t.specularMap.isTexture
          ? this.getTexture(e, "specularMap").r
          : gc(1);
    else if (i === $d.ROUGHNESS) {
      const i = this.getFloat(e, "roughness");
      n =
        t.roughnessMap && !0 === t.roughnessMap.isTexture
          ? i.mul(this.getTexture(e, "roughnessMap").g)
          : i;
    } else if (i === $d.METALNESS) {
      const i = this.getFloat(e, "metalness");
      n =
        t.metalnessMap && !0 === t.metalnessMap.isTexture
          ? i.mul(this.getTexture(e, "metalnessMap").b)
          : i;
    } else if (i === $d.EMISSIVE) {
      const i = this.getColor(e, "emissive");
      n =
        t.emissiveMap && !0 === t.emissiveMap.isTexture
          ? i.mul(this.getTexture(e, "emissiveMap"))
          : i;
    } else if (i === $d.CLEARCOAT) {
      const i = this.getFloat(e, "clearcoat");
      n =
        t.clearcoatMap && !0 === t.clearcoatMap.isTexture
          ? i.mul(this.getTexture(e, "clearcoatMap").r)
          : i;
    } else if (i === $d.CLEARCOAT_ROUGHNESS) {
      const i = this.getFloat(e, "clearcoatRoughness");
      n =
        t.clearcoatRoughnessMap && !0 === t.clearcoatRoughnessMap.isTexture
          ? i.mul(this.getTexture(e, "clearcoatRoughnessMap").r)
          : i;
    } else if (i === $d.SHEEN) {
      const i = this.getColor(e, "sheenColor").mul(this.getFloat(e, "sheen"));
      n =
        t.sheenColorMap && !0 === t.sheenColorMap.isTexture
          ? i.mul(this.getTexture(e, "sheenColorMap").rgb)
          : i;
    } else if (i === $d.SHEEN_ROUGHNESS) {
      const i = this.getFloat(e, "sheenRoughness");
      (n =
        t.sheenRoughnessMap && !0 === t.sheenRoughnessMap.isTexture
          ? i.mul(this.getTexture(e, "sheenRoughnessMap").a)
          : i),
        (n = n.clamp(0.07, 1));
    } else if (i === $d.IRIDESCENCE_THICKNESS) {
      const i = Yd(1, "float", t.iridescenceThicknessRange);
      if (t.iridescenceThicknessMap) {
        const s = Yd(0, "float", t.iridescenceThicknessRange);
        n = i
          .sub(s)
          .mul(this.getTexture(e, "iridescenceThicknessMap").g)
          .add(s);
      } else n = i;
    } else {
      const t = this.getNodeType(e);
      n = Zd(i, t);
    }
    return n;
  }
}
($d.ALPHA_TEST = "alphaTest"),
  ($d.COLOR = "color"),
  ($d.OPACITY = "opacity"),
  ($d.SHININESS = "shininess"),
  ($d.SPECULAR = "specular"),
  ($d.SPECULAR_STRENGTH = "specularStrength"),
  ($d.REFLECTIVITY = "reflectivity"),
  ($d.ROUGHNESS = "roughness"),
  ($d.METALNESS = "metalness"),
  ($d.CLEARCOAT = "clearcoat"),
  ($d.CLEARCOAT_ROUGHNESS = "clearcoatRoughness"),
  ($d.EMISSIVE = "emissive"),
  ($d.ROTATION = "rotation"),
  ($d.SHEEN = "sheen"),
  ($d.SHEEN_ROUGHNESS = "sheenRoughness"),
  ($d.IRIDESCENCE = "iridescence"),
  ($d.IRIDESCENCE_IOR = "iridescenceIOR"),
  ($d.IRIDESCENCE_THICKNESS = "iridescenceThickness");
const ep = pc($d, $d.ALPHA_TEST),
  tp = pc($d, $d.COLOR);
pc($d, $d.SHININESS);
const ip = pc($d, $d.EMISSIVE),
  np = pc($d, $d.OPACITY);
pc($d, $d.SPECULAR_COLOR),
  pc($d, $d.SPECULAR_STRENGTH),
  pc($d, $d.REFLECTIVITY),
  pc($d, $d.ROUGHNESS),
  pc($d, $d.METALNESS),
  pc($d, $d.CLEARCOAT),
  pc($d, $d.CLEARCOAT_ROUGHNESS),
  pc($d, $d.ROTATION),
  pc($d, $d.SHEEN),
  pc($d, $d.SHEEN_ROUGHNESS),
  pc($d, $d.IRIDESCENCE),
  pc($d, $d.IRIDESCENCE_IOR),
  pc($d, $d.IRIDESCENCE_THICKNESS),
  Ch($d);
class sp extends Sh {
  constructor(e = sp.VIEW_MATRIX, t = null) {
    super(),
      (this.scope = e),
      (this.object3d = t),
      (this.updateType = ph),
      (this._uniformNode = new Gc(null));
  }
  getNodeType() {
    const e = this.scope;
    return e === sp.WORLD_MATRIX || e === sp.VIEW_MATRIX
      ? "mat4"
      : e === sp.NORMAL_MATRIX
      ? "mat3"
      : e === sp.POSITION ||
        e === sp.VIEW_POSITION ||
        e === sp.DIRECTION ||
        e === sp.SCALE
      ? "vec3"
      : void 0;
  }
  update(e) {
    const t = this.object3d,
      i = this._uniformNode,
      n = this.scope;
    if (n === sp.VIEW_MATRIX) i.value = t.modelViewMatrix;
    else if (n === sp.NORMAL_MATRIX) i.value = t.normalMatrix;
    else if (n === sp.WORLD_MATRIX) i.value = t.matrixWorld;
    else if (n === sp.POSITION)
      (i.value = i.value || new Vector3()),
        i.value.setFromMatrixPosition(t.matrixWorld);
    else if (n === sp.SCALE)
      (i.value = i.value || new Vector3()),
        i.value.setFromMatrixScale(t.matrixWorld);
    else if (n === sp.DIRECTION)
      (i.value = i.value || new Vector3()), t.getWorldDirection(i.value);
    else if (n === sp.VIEW_POSITION) {
      const n = e.camera;
      (i.value = i.value || new Vector3()),
        i.value.setFromMatrixPosition(t.matrixWorld),
        i.value.applyMatrix4(n.matrixWorldInverse);
    }
  }
  generate(e) {
    const t = this.scope;
    return (
      t === sp.WORLD_MATRIX || t === sp.VIEW_MATRIX
        ? (this._uniformNode.nodeType = "mat4")
        : t === sp.NORMAL_MATRIX
        ? (this._uniformNode.nodeType = "mat3")
        : (t !== sp.POSITION &&
            t !== sp.VIEW_POSITION &&
            t !== sp.DIRECTION &&
            t !== sp.SCALE) ||
          (this._uniformNode.nodeType = "vec3"),
      this._uniformNode.build(e)
    );
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
(sp.VIEW_MATRIX = "viewMatrix"),
  (sp.NORMAL_MATRIX = "normalMatrix"),
  (sp.WORLD_MATRIX = "worldMatrix"),
  (sp.POSITION = "position"),
  (sp.SCALE = "scale"),
  (sp.VIEW_POSITION = "viewPosition"),
  (sp.DIRECTION = "direction");
const rp = sp;
dc(sp, sp.DIRECTION),
  dc(sp, sp.VIEW_MATRIX),
  dc(sp, sp.NORMAL_MATRIX),
  dc(sp, sp.WORLD_MATRIX),
  dc(sp, sp.POSITION),
  dc(sp, sp.SCALE),
  dc(sp, sp.VIEW_POSITION),
  Ch(sp);
class ap extends rp {
  constructor(e = ap.POSITION) {
    super(e);
  }
  getNodeType(e) {
    const t = this.scope;
    return t === ap.PROJECTION_MATRIX
      ? "mat4"
      : t === ap.NEAR || t === ap.FAR
      ? "float"
      : super.getNodeType(e);
  }
  update(e) {
    const t = e.camera,
      i = this._uniformNode,
      n = this.scope;
    n === ap.VIEW_MATRIX
      ? (i.value = t.matrixWorldInverse)
      : n === ap.PROJECTION_MATRIX
      ? (i.value = t.projectionMatrix)
      : n === ap.NEAR
      ? (i.value = t.near)
      : n === ap.FAR
      ? (i.value = t.far)
      : ((this.object3d = t), super.update(e));
  }
  generate(e) {
    const t = this.scope;
    return (
      t === ap.PROJECTION_MATRIX
        ? (this._uniformNode.nodeType = "mat4")
        : (t !== ap.NEAR && t !== ap.FAR) ||
          (this._uniformNode.nodeType = "float"),
      super.generate(e)
    );
  }
}
(ap.PROJECTION_MATRIX = "projectionMatrix"),
  (ap.NEAR = "near"),
  (ap.FAR = "far");
const op = tu(pc(ap, ap.PROJECTION_MATRIX), "projectionMatrix");
pc(ap, ap.NEAR), pc(ap, ap.FAR);
const lp = pc(ap, ap.VIEW_MATRIX);
pc(ap, ap.NORMAL_MATRIX), pc(ap, ap.WORLD_MATRIX), pc(ap, ap.POSITION), Ch(ap);
class hp extends rp {
  constructor(e = hp.VIEW_MATRIX) {
    super(e);
  }
  update(e) {
    (this.object3d = e.object), super.update(e);
  }
}
pc(hp, hp.DIRECTION);
const cp = tu(pc(hp, hp.VIEW_MATRIX), "modelViewMatrix"),
  up = pc(hp, hp.NORMAL_MATRIX),
  dp = pc(hp, hp.WORLD_MATRIX);
pc(hp, hp.POSITION), pc(hp, hp.SCALE), pc(hp, hp.VIEW_POSITION), Ch(hp);
class pp extends Sh {
  constructor(e = pp.LOCAL) {
    super("vec3"), (this.scope = e);
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `normal-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let i = null;
    if (t === pp.GEOMETRY) i = Wc("normal", "vec3");
    else if (t === pp.LOCAL) i = Hc(fp);
    else if (t === pp.VIEW) {
      const e = up.mul(mp);
      i = Ku(Hc(e));
    } else if (t === pp.WORLD) {
      const e = gp.transformDirection(lp);
      i = Ku(Hc(e));
    }
    return i.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
(pp.GEOMETRY = "geometry"),
  (pp.LOCAL = "local"),
  (pp.VIEW = "view"),
  (pp.WORLD = "world");
const fp = pc(pp, pp.GEOMETRY),
  mp = pc(pp, pp.LOCAL),
  gp = pc(pp, pp.VIEW),
  _p = pc(pp, pp.WORLD),
  vp = hu("vec3", "TransformedNormalView"),
  Ap = vp.transformDirection(lp).normalize(),
  yp = hu("vec3", "TransformedClearcoatNormalView");
Ch(pp);
class xp extends Sh {
  constructor(e, t = null) {
    super(), (this.node = e), (this.name = t);
  }
  assign(e) {
    return (
      e.traverse((e, t) => {
        t && e.uuid === this.uuid && t(this.node);
      }),
      (this.node = e),
      this
    );
  }
  isGlobal() {
    return !0;
  }
  getHash(e) {
    return this.name || super.getHash(e);
  }
  getNodeType(e) {
    return this.node.getNodeType(e);
  }
  generate(e) {
    const t = this.node,
      i = this.name;
    if (null === i && !0 === t.isTempNode) return t.build(e);
    const n = e.getVectorType(this.getNodeType(e)),
      s = t.build(e, n),
      r = e.getVarFromNode(this, n);
    null !== i && (r.name = i);
    const a = e.getPropertyName(r);
    return e.addLineFlowCode(`${a} = ${s}`), a;
  }
}
const bp = dc(xp);
Vh("temp", bp), Ch(xp);
class Ep extends Sh {
  constructor(e = Ep.LOCAL) {
    super(), (this.scope = e);
  }
  getHash() {
    return `tangent-${this.scope}`;
  }
  getNodeType() {
    return this.scope === Ep.GEOMETRY ? "vec4" : "vec3";
  }
  generate(e) {
    const t = this.scope;
    let i = null;
    if (t === Ep.GEOMETRY) i = Wc("tangent", "vec4");
    else if (t === Ep.LOCAL) i = Hc(Sp.xyz);
    else if (t === Ep.VIEW) {
      const e = cp.mul(Cp).xyz;
      i = Ku(Hc(e));
    } else if (t === Ep.WORLD) {
      const e = Mp.transformDirection(lp);
      i = Ku(Hc(e));
    }
    return i.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
(Ep.GEOMETRY = "geometry"),
  (Ep.LOCAL = "local"),
  (Ep.VIEW = "view"),
  (Ep.WORLD = "world");
const Sp = pc(Ep, Ep.GEOMETRY),
  Cp = pc(Ep, Ep.LOCAL),
  Mp = pc(Ep, Ep.VIEW),
  wp = pc(Ep, Ep.WORLD),
  Tp = bp(Mp, "TransformedTangentView");
Ku(Tp.transformDirection(lp)), Ch(Ep);
class Ip extends Sh {
  constructor(e = Ip.LOCAL) {
    super("vec3"), (this.scope = e);
  }
  getHash() {
    return `bitangent-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let i;
    t === Ip.GEOMETRY
      ? (i = fp.cross(Sp))
      : t === Ip.LOCAL
      ? (i = mp.cross(Cp))
      : t === Ip.VIEW
      ? (i = gp.cross(Mp))
      : t === Ip.WORLD && (i = _p.cross(wp));
    const n = i.mul(Sp.w).xyz;
    return Ku(Hc(n)).build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
(Ip.GEOMETRY = "geometry"),
  (Ip.LOCAL = "local"),
  (Ip.VIEW = "view"),
  (Ip.WORLD = "world"),
  pc(Ip, Ip.GEOMETRY),
  pc(Ip, Ip.LOCAL);
const Rp = pc(Ip, Ip.VIEW);
pc(Ip, Ip.WORLD);
const Pp = Ku(vp.cross(Tp).mul(Sp.w));
Ku(Pp.transformDirection(lp)), Ch(Ip);
class Dp extends Sh {
  constructor(e = Dp.LOCAL) {
    super("vec3"), (this.scope = e);
  }
  isGlobal() {
    return !0;
  }
  getHash() {
    return `position-${this.scope}`;
  }
  generate(e) {
    const t = this.scope;
    let i = null;
    if (t === Dp.GEOMETRY) i = Wc("position", "vec3");
    else if (t === Dp.LOCAL) i = Hc(Lp);
    else if (t === Dp.WORLD) {
      const e = dp.mul(Fp);
      i = Hc(e);
    } else if (t === Dp.VIEW) {
      const e = cp.mul(Fp);
      i = Hc(e);
    } else if (t === Dp.VIEW_DIRECTION) {
      const e = kp.negate();
      i = Ku(Hc(e));
    } else if (t === Dp.WORLD_DIRECTION) {
      const e = Fp.transformDirection(dp);
      i = Ku(Hc(e));
    }
    return i.build(e, this.getNodeType(e));
  }
  serialize(e) {
    super.serialize(e), (e.scope = this.scope);
  }
  deserialize(e) {
    super.deserialize(e), (this.scope = e.scope);
  }
}
(Dp.GEOMETRY = "geometry"),
  (Dp.LOCAL = "local"),
  (Dp.WORLD = "world"),
  (Dp.WORLD_DIRECTION = "worldDirection"),
  (Dp.VIEW = "view"),
  (Dp.VIEW_DIRECTION = "viewDirection");
const Lp = pc(Dp, Dp.GEOMETRY),
  Fp = pc(Dp, Dp.LOCAL),
  Np = pc(Dp, Dp.WORLD),
  Bp = pc(Dp, Dp.WORLD_DIRECTION),
  kp = pc(Dp, Dp.VIEW),
  Op = pc(Dp, Dp.VIEW_DIRECTION);
Ch(Dp);
class Up extends Sh {
  constructor() {
    super("bool"), (this.isFrontFacingNode = !0);
  }
  generate(e) {
    return e.getFrontFacing();
  }
}
const zp = pc(Up),
  Gp = gc(zp).mul(2).sub(1);
Ch(Up);
const Vp = fc((e) => {
  const { eye_pos: t, surf_norm: i, mapN: n, uv: s } = e,
    r = t.dFdx(),
    a = t.dFdy(),
    o = s.dFdx(),
    l = s.dFdy(),
    h = i,
    c = a.cross(h),
    u = h.cross(r),
    d = c.mul(o.x).add(u.mul(l.x)),
    p = c.mul(o.y).add(u.mul(l.y)),
    f = d.dot(d).max(p.dot(p)),
    m = Gp.mul(f.inverseSqrt());
  return Au(d.mul(n.x, m), p.mul(n.y, m), h.mul(n.z)).normalize();
});
class Qp extends Lh {
  constructor(e, t = null) {
    super("vec3"),
      (this.node = e),
      (this.scaleNode = t),
      (this.normalMapType = 0);
  }
  construct(e) {
    const { normalMapType: t, scaleNode: i } = this;
    let n = this.node.mul(2).sub(1);
    null !== i && (n = Sc(n.xy.mul(i), n.z));
    let s = null;
    if (1 === t) s = up.mul(n).normalize();
    else if (0 === t) {
      s =
        !0 === e.hasGeometryAttribute("tangent")
          ? jp.mul(n).normalize()
          : Vp({ eye_pos: kp, surf_norm: gp, mapN: n, uv: mu() });
    }
    return s;
  }
}
const Hp = dc(Qp),
  jp = Dc(Mp, Rp, gp);
Ch(Qp);
const Wp = fc(({ bumpTexture: e, bumpScale: t }) => {
    const i = mu(),
      n = qd(e, i).x;
    return yc(
      qd(e, i.add(i.dFdx())).x.sub(n),
      qd(e, i.add(i.dFdy())).x.sub(n)
    ).mul(t);
  }),
  qp = fc((e) => {
    const { surf_pos: t, surf_norm: i, dHdxy: n } = e,
      s = t.dFdx(),
      r = i,
      a = t.dFdy().cross(r),
      o = r.cross(s),
      l = s.dot(a).mul(Gp),
      h = l.sign().mul(n.x.mul(a).add(n.y.mul(o)));
    return l.abs().mul(i).sub(h).normalize();
  });
class Xp extends Lh {
  constructor(e, t = null) {
    super("vec3"), (this.texture = e), (this.scaleNode = t);
  }
  construct() {
    const e = null !== this.scaleNode ? this.scaleNode : 1,
      t = Wp({ bumpTexture: this.texture, bumpScale: e });
    return qp({ surf_pos: kp.negate(), surf_norm: gp, dHdxy: t });
  }
}
const Yp = dc(Xp);
Ch(Xp);
class Kp extends $d {
  constructor(e) {
    super(e);
  }
  getNodeType(e) {
    const t = this.scope;
    let i = null;
    return (
      (t !== Kp.NORMAL && t !== Kp.CLEARCOAT_NORMAL) || (i = "vec3"),
      i || super.getNodeType(e)
    );
  }
  construct(e) {
    const t = e.material,
      i = this.scope;
    let n = null;
    return (
      i === Kp.NORMAL
        ? (n = t.normalMap
            ? Hp(this.getTexture(e, "normalMap"), Zd("normalScale", "vec2"))
            : t.bumpMap
            ? Yp(t.bumpMap, Zd("bumpScale", "float"))
            : gp)
        : i === Kp.CLEARCOAT_NORMAL &&
          (n = t.clearcoatNormalMap
            ? Hp(
                this.getTexture(e, "clearcoatNormalMap"),
                Zd("clearcoatNormalScale", "vec2")
              )
            : gp),
      n || super.construct(e)
    );
  }
}
(Kp.NORMAL = "normal"), (Kp.CLEARCOAT_NORMAL = "clearcoatNormal");
const Zp = pc(Kp, Kp.NORMAL);
pc(Kp, Kp.CLEARCOAT_NORMAL), Ch(Kp);
class Jp extends Sh {
  constructor(e = Fp) {
    super("vec4"), (this.positionNode = e);
  }
  construct() {
    return op.mul(cp).mul(this.positionNode);
  }
}
const $p = dc(Jp);
Ch(Jp);
class ef extends wh {
  constructor(e, t = null, i = 0, n = 0) {
    super(e, t),
      (this.isBufferNode = !0),
      (this.bufferType = t),
      (this.bufferStride = i),
      (this.bufferOffset = n),
      (this.usage = ye),
      (this.instanced = !1),
      (this.attribute = null),
      e &&
        !0 === e.isBufferAttribute &&
        ((this.attribute = e),
        (this.usage = e.usage),
        (this.instanced = e.isInstancedBufferAttribute));
  }
  getNodeType(e) {
    return (
      null === this.bufferType &&
        (this.bufferType = e.getTypeFromAttribute(this.attribute)),
      this.bufferType
    );
  }
  construct(e) {
    if (null !== this.attribute) return;
    const t = this.getNodeType(e),
      i = this.value,
      n = e.getTypeLength(t),
      s = this.bufferStride || n,
      r = this.bufferOffset,
      a = !0 === i.isInterleavedBuffer ? i : new Ta(i, s),
      o = new Ra(a, n, r);
    a.setUsage(this.usage),
      (this.attribute = o),
      (this.attribute.isInstancedBufferAttribute = this.instanced);
  }
  generate(e) {
    const t = this.getNodeType(e),
      i = e.getBufferAttributeFromNode(this, t),
      n = e.getPropertyName(i);
    let s = null;
    if ("vertex" === e.shaderStage) s = n;
    else {
      s = Hc(this).build(e, t);
    }
    return s;
  }
  getInputType() {
    return "bufferAttribute";
  }
  setUsage(e) {
    return (this.usage = e), this;
  }
  setInstanced(e) {
    return (this.instanced = e), this;
  }
}
const tf = (e, t, i, n) => hc(new ef(e, t, i, n)),
  nf = (e, t, i, n) => tf(e, t, i, n).setInstanced(!0),
  sf = (e, t, i, n) =>
    ((e, t, i, n) => tf(e, t, i, n).setUsage(xe))(e, t, i, n).setInstanced(!0);
Vh("toAttribute", (e) => tf(e.value)), Ch(ef);
class rf extends Sh {
  constructor(e) {
    super("void"), (this.instanceMesh = e), (this.instanceMatrixNode = null);
  }
  construct(e) {
    let t = this.instanceMatrixNode;
    if (null === t) {
      const e = this.instanceMesh.instanceMatrix,
        i = new Jl(e.array, 16, 1),
        n = e.usage === xe ? sf : nf,
        s = [
          n(i, "vec4", 16, 0),
          n(i, "vec4", 16, 4),
          n(i, "vec4", 16, 8),
          n(i, "vec4", 16, 12),
        ];
      (t = Bc(...s)), (this.instanceMatrixNode = t);
    }
    const i = t.mul(Fp).xyz,
      n = Dc(t[0].xyz, t[1].xyz, t[2].xyz),
      s = mp.div(Sc(n[0].dot(n[0]), n[1].dot(n[1]), n[2].dot(n[2]))),
      r = n.mul(s).xyz;
    e.stack.assign(Fp, i), e.stack.assign(mp, r);
  }
}
const af = dc(rf);
Ch(rf);
class of extends Gc {
  constructor(e, t, i = 0) {
    super(e, t),
      (this.isBufferNode = !0),
      (this.bufferType = t),
      (this.bufferCount = i);
  }
  getInputType() {
    return "buffer";
  }
}
Ch(of);
class lf extends Sh {
  constructor(e) {
    var t, i, n;
    super("void"),
      (this.skinnedMesh = e),
      (this.updateType = ph),
      (this.skinIndexNode = Wc("skinIndex", "uvec4")),
      (this.skinWeightNode = Wc("skinWeight", "vec4")),
      (this.bindMatrixNode = Vc(e.bindMatrix, "mat4")),
      (this.bindMatrixInverseNode = Vc(e.bindMatrixInverse, "mat4")),
      (this.boneMatricesNode =
        ((t = e.skeleton.boneMatrices),
        (i = "mat4"),
        (n = e.skeleton.bones.length),
        hc(new of(t, i, n))));
  }
  construct(e) {
    const {
        skinIndexNode: t,
        skinWeightNode: i,
        bindMatrixNode: n,
        bindMatrixInverseNode: s,
        boneMatricesNode: r,
      } = this,
      a = r.element(t.x),
      o = r.element(t.y),
      l = r.element(t.z),
      h = r.element(t.w),
      c = n.mul(Fp),
      u = Au(
        a.mul(i.x).mul(c),
        o.mul(i.y).mul(c),
        l.mul(i.z).mul(c),
        h.mul(i.w).mul(c)
      ),
      d = s.mul(u).xyz;
    let p = Au(i.x.mul(a), i.y.mul(o), i.z.mul(l), i.w.mul(h));
    p = s.mul(p).mul(n);
    const f = p.transformDirection(mp).xyz;
    e.stack.assign(Fp, d),
      e.stack.assign(mp, f),
      e.hasGeometryAttribute("tangent") && e.stack.assign(Cp, f);
  }
  update() {
    this.skinnedMesh.skeleton.update();
  }
}
const hf = dc(lf);
Ch(lf);
class cf extends Sh {
  constructor(e) {
    super("void"),
      (this.mesh = e),
      (this.morphBaseInfluence = Vc(1)),
      (this.updateType = ph);
  }
  constructAttribute(e, t, i = Fp) {
    const n = this.mesh,
      s = n.geometry.morphAttributes[t];
    e.stack.assign(i, i.mul(this.morphBaseInfluence));
    for (let r = 0; r < s.length; r++) {
      const t = s[r],
        a = tf(t.array, "vec3"),
        o = Yd(r, "float", n.morphTargetInfluences);
      e.stack.assign(i, i.add(a.mul(o)));
    }
  }
  construct(e) {
    this.constructAttribute(e, "position");
  }
  update() {
    const e = this.morphBaseInfluence;
    this.mesh.geometry.morphTargetsRelative
      ? (e.value = 1)
      : (e.value =
          1 - this.mesh.morphTargetInfluences.reduce((e, t) => e + t, 0));
  }
}
const uf = dc(cf);
Ch(cf);
class df extends Sh {
  constructor() {
    super("vec3");
  }
  getHash() {
    return "reflectVector";
  }
  construct() {
    return Op.negate().reflect(vp).transformDirection(lp);
  }
}
const pf = pc(df);
Ch(df);
class ff extends Wd {
  constructor(e, t = null, i = null) {
    super(e, t, i), (this.isCubeTextureNode = !0);
  }
  getInputType() {
    return "cubeTexture";
  }
  getDefaultUV() {
    return pf;
  }
  setUpdateMatrix() {}
  generate(e, t) {
    const { uvNode: i, levelNode: n } = e.getNodeProperties(this),
      s = this.value;
    if (!s || !0 !== s.isCubeTexture)
      throw new Error("CubeTextureNode: Need a three.js cube texture.");
    const r = Gc.prototype.generate.call(this, e, "cubeTexture");
    if ("sampler" === t) return r + "_sampler";
    if (e.isReference(t)) return r;
    {
      const s = this.getNodeType(e),
        a = e.getDataFromNode(this);
      let o = a.propertyName;
      if (void 0 === o) {
        const t = Sc(i.x.negate(), i.yz).build(e, "vec3"),
          s = e.getVarFromNode(this, "vec4");
        o = e.getPropertyName(s);
        let l = null;
        if (n && !0 === n.isNode) {
          const i = n.build(e, "float");
          l = e.getTextureLevel(this, r, t, i);
        } else l = e.getTexture(this, r, t);
        e.addLineFlowCode(`${o} = ${l}`),
          !1 !== e.context.tempWrite && ((a.snippet = l), (a.propertyName = o));
      }
      let l = o;
      return (
        e.needsColorSpaceToLinear(this.value) &&
          (l = Gd(jd(l, s), this.value.colorSpace).construct(e).build(e, s)),
        e.format(l, "vec4", t)
      );
    }
  }
}
const mf = dc(ff);
Vh("cubeTexture", mf), Ch(ff);
class gf extends Sh {
  constructor() {
    super("vec3");
  }
  generate() {
    console.warn("Abstract function.");
  }
}
const _f = gf;
Ch(gf);
let vf = null;
class Af extends _f {
  constructor(e = null) {
    super(),
      (this.updateType = uh),
      (this.light = e),
      (this.rtt = null),
      (this.shadowNode = null),
      (this.color = new Color()),
      (this.colorNode = Vc(this.color));
  }
  getHash() {
    return this.light.uuid;
  }
  constructShadow(e) {
    let t = this.shadowNode;
    if (null === t) {
      null === vf && (vf = e.createNodeMaterial("MeshBasicNodeMaterial"));
      const i = this.light.shadow,
        n = e.getRenderTarget(i.mapSize.width, i.mapSize.height),
        s = new xa();
      (s.minFilter = R),
        (s.magFilter = R),
        (s.image.width = i.mapSize.width),
        (s.image.height = i.mapSize.height),
        (s.compareFunction = 513),
        (n.depthTexture = s),
        i.camera.updateProjectionMatrix();
      const r = Yd("bias", "float", i),
        a = Yd("normalBias", "float", i);
      let o = Vc(i.matrix).mul(Np.add(_p.mul(a)));
      o = o.xyz.div(o.w);
      const l = o.x
        .greaterThanEqual(0)
        .and(o.x.lessThanEqual(1))
        .and(o.y.greaterThanEqual(0))
        .and(o.y.lessThanEqual(1))
        .and(o.z.lessThanEqual(1));
      o = Sc(o.x, o.y.oneMinus(), o.z.add(r).mul(2).sub(1));
      (t = ((e, t, i) => qd(e, t).compare(i))(s, o.xy, o.z)),
        (this.rtt = n),
        (this.colorNode = this.colorNode.mul(l.mix(1, t))),
        (this.shadowNode = t),
        (this.updateBeforeType = dh);
    }
  }
  construct(e) {
    this.light.castShadow && this.constructShadow(e);
  }
  updateShadow(e) {
    const { rtt: t, light: i } = this,
      { renderer: n, scene: s } = e;
    (s.overrideMaterial = vf),
      t.setSize(i.shadow.mapSize.width, i.shadow.mapSize.height),
      i.shadow.updateMatrices(i),
      n.setRenderTarget(t),
      n.render(s, i.shadow.camera),
      n.setRenderTarget(null),
      (s.overrideMaterial = null);
  }
  updateBefore(e) {
    const { light: t } = this;
    t.castShadow && this.updateShadow(e);
  }
  update() {
    const { light: e } = this;
    this.color.copy(e.color).multiplyScalar(e.intensity);
  }
}
const yf = Af;
Ch(Af);
const xf = new WeakMap();
const bf = dc(
  class extends Sh {
    constructor(e = []) {
      super("vec3"), (this.lightNodes = e), (this._hash = null);
    }
    get hasLight() {
      return this.lightNodes.length > 0;
    }
    construct(e) {
      const t = this.lightNodes;
      for (const i of t) i.build(e);
    }
    getHash(e) {
      if (null === this._hash) {
        let t = "";
        const i = this.lightNodes;
        for (const n of i) t += n.getHash(e) + " ";
        this._hash = t;
      }
      return this._hash;
    }
    getLightNodeByHash(e) {
      const t = this.lightNodes;
      for (const i of t) if (i.light.uuid === e) return i;
      return null;
    }
    fromLights(e = []) {
      const t = [];
      e = ((e) => e.sort((e, t) => e.id - t.id))(e);
      for (const i of e) {
        let e = this.getLightNodeByHash(i.uuid);
        if (null === e) {
          const t = i.constructor,
            n = xf.has(t) ? xf.get(t) : yf;
          e = hc(new n(i));
        }
        t.push(e);
      }
      return (this.lightNodes = t), (this._hash = null), this;
    }
  }
);
class Ef extends _f {
  constructor(e = null) {
    super(), (this.aoNode = e);
  }
  construct(e) {
    const t = this.aoNode.x.sub(1).mul(1).add(1);
    e.context.ambientOcclusion.mulAssign(t);
  }
}
const Sf = Ef;
Ch(Ef);
class Cf extends $c {
  constructor(e, t = null, i = null, n = null) {
    super(e),
      (this.lightingModel = t),
      (this.backdropNode = i),
      (this.backdropAlphaNode = n);
  }
  getNodeType() {
    return "vec3";
  }
  construct(e) {
    const { lightingModel: t, backdropNode: i, backdropAlphaNode: n } = this,
      s = (this.context = {}),
      r = e.getNodeProperties(this),
      a = Sc().temp(),
      o = Sc().temp(),
      l = Sc().temp(),
      h = Sc().temp();
    let c = Au(a, l);
    null !== i && (c = Sc(null !== n ? Rd(c, i, n) : i));
    const u = Au(o, h),
      d = {
        directDiffuse: a,
        directSpecular: o,
        indirectDiffuse: l,
        indirectSpecular: h,
        total: Au(c, u).temp(),
      },
      p = {
        radiance: Sc().temp(),
        irradiance: Sc().temp(),
        iblIrradiance: Sc().temp(),
        ambientOcclusion: gc(1).temp(),
      };
    return (
      (s.reflectedLight = d),
      (s.lightingModel = t || s.lightingModel),
      Object.assign(r, d, p),
      Object.assign(s, p),
      t &&
        (t.init(s, e.stack, e),
        t.indirectDiffuse(s, e.stack, e),
        t.indirectSpecular(s, e.stack, e),
        t.ambientOcclusion(s, e.stack, e)),
      super.construct(e)
    );
  }
  generate(e) {
    const { context: t } = this,
      i = this.getNodeType(e);
    return super.generate(e, i), t.reflectedLight.total.build(e, i);
  }
}
const Mf = dc(Cf);
Vh("lightingContext", Mf), Ch(Cf);
class wf extends Lh {
  constructor(e = Bp) {
    super("vec2"), (this.dirNode = e);
  }
  construct() {
    const e = this.dirNode,
      t = e.z
        .atan2(e.x)
        .mul(1 / (2 * Math.PI))
        .add(0.5),
      i = e.y
        .negate()
        .clamp(-1, 1)
        .asin()
        .mul(1 / Math.PI)
        .add(0.5);
    return yc(t, i);
  }
}
const Tf = dc(wf);
Ch(wf);
class If extends Gc {
  constructor(e) {
    super(0), (this.textureNode = e), (this.updateType = uh);
  }
  get texture() {
    return this.textureNode.value;
  }
  update() {
    const e = this.texture,
      t = e.images,
      i = t && t.length > 0 ? (t[0] && t[0].image) || t[0] : e.image;
    if (i && void 0 !== i.width) {
      const { width: e, height: t } = i;
      this.value = Math.log2(Math.max(e, t));
    }
  }
}
const Rf = dc(If);
Ch(If);
class Pf extends Sh {
  constructor(e, t = null) {
    super("float"), (this.textureNode = e), (this.roughnessNode = t);
  }
  construct() {
    const { textureNode: e, roughnessNode: t } = this,
      i = Rf(e),
      n = t.mul(t).mul(Math.PI).div(t.add(1));
    return i.add(n.log2()).clamp(0, i);
  }
}
const Df = dc(Pf);
Ch(Pf);
const Lf = new WeakMap();
class Ff extends _f {
  constructor(e = null) {
    super(), (this.envNode = e);
  }
  construct(e) {
    let t = this.envNode;
    const i = e.getNodeProperties(this);
    if (t.isTextureNode && !0 !== t.value.isCubeTexture) {
      let i = Lf.get(t.value);
      if (void 0 === i) {
        const n = t.value,
          s = e.renderer,
          r = e.getCubeRenderTarget(512).fromEquirectangularTexture(s, n);
        (i = mf(r.texture)), Lf.set(t.value, i);
      }
      t = i;
    }
    const n = Yd("envMapIntensity", "float", e.material),
      s = eu(t, Nf(uu, vp)).mul(n),
      r = eu(t, Bf(Ap)).mul(Math.PI).mul(n),
      a = Jc(s);
    e.context.radiance.addAssign(a), e.context.iblIrradiance.addAssign(r);
    const o = e.context.lightingModel.clearcoatRadiance;
    if (o) {
      const e = eu(t, Nf(du, yp)).mul(n),
        i = Jc(e);
      o.addAssign(i);
    }
    (i.radiance = a), (i.irradiance = r);
  }
}
const Nf = (e, t) => {
    let i = null,
      n = null;
    return {
      getUVNode: (s) => {
        let r = null;
        return (
          null === i &&
            ((i = Op.negate().reflect(t)),
            (i = e.mul(e).mix(i, t).normalize()),
            (i = i.transformDirection(lp))),
          s.isCubeTextureNode
            ? (r = i)
            : s.isTextureNode && (null === n && (n = Tf(i)), (r = n)),
          r
        );
      },
      getSamplerLevelNode: () => e,
      getMIPLevelAlgorithmNode: (e, t) => Df(e, t),
    };
  },
  Bf = (e) => {
    let t = null;
    return {
      getUVNode: (i) => {
        let n = null;
        return (
          i.isCubeTextureNode
            ? (n = e)
            : i.isTextureNode &&
              (null === t && ((t = Tf(e)), (t = yc(t.x, t.y.oneMinus()))),
              (n = t)),
          n
        );
      },
      getSamplerLevelNode: () => gc(1),
      getMIPLevelAlgorithmNode: (e, t) => Df(e, t),
    };
  },
  kf = Ff;
Ch(Ff);
const Of = new Map();
class Uf extends ShaderMaterial {
  constructor() {
    super(),
      (this.isNodeMaterial = !0),
      (this.type = this.constructor.name),
      (this.forceSinglePass = !1),
      (this.unlit = this.constructor === Uf.prototype.constructor),
      (this.fog = !0),
      (this.lights = !0),
      (this.normals = !0),
      (this.colorSpace = !0),
      (this.lightsNode = null),
      (this.envNode = null),
      (this.colorNode = null),
      (this.normalNode = null),
      (this.opacityNode = null),
      (this.backdropNode = null),
      (this.backdropAlphaNode = null),
      (this.alphaTestNode = null),
      (this.positionNode = null),
      (this.outputNode = null),
      (this.vertexNode = null);
  }
  customProgramCacheKey() {
    return this.type + vh(this);
  }
  build(e) {
    this.construct(e);
  }
  construct(e) {
    let t;
    if (
      (e.addStack(),
      (e.stack.outputNode = this.constructPosition(e)),
      e.addFlow("vertex", e.removeStack()),
      e.addStack(),
      !1 === this.unlit)
    ) {
      !0 === this.normals && this.constructNormal(e),
        this.constructDiffuseColor(e),
        this.constructVariants(e);
      const i = this.constructLighting(e);
      (t = this.constructOutput(e, Tc(i, cu.a))),
        e.stack.assign(pu, t),
        null !== this.outputNode && (t = this.outputNode);
    } else t = this.constructOutput(e, this.outputNode || Tc(0, 0, 0, 1));
    (e.stack.outputNode = t), e.addFlow("fragment", e.removeStack());
  }
  constructPosition(e) {
    const t = e.object,
      i = t.geometry;
    return (
      e.addStack(),
      (i.morphAttributes.position ||
        i.morphAttributes.normal ||
        i.morphAttributes.color) &&
        e.stack.add(uf(t)),
      !0 === t.isSkinnedMesh && e.stack.add(hf(t)),
      t.instanceMatrix &&
        !0 === t.instanceMatrix.isInstancedBufferAttribute &&
        !0 === e.isAvailable("instance") &&
        e.stack.add(af(t)),
      null !== this.positionNode && e.stack.assign(Fp, this.positionNode),
      (e.context.vertex = e.removeStack()),
      this.vertexNode || $p()
    );
  }
  constructDiffuseColor({ stack: e, geometry: t }) {
    let i = this.colorNode ? Tc(this.colorNode) : tp;
    !0 === this.vertexColors &&
      t.hasAttribute("color") &&
      (i = Tc(i.xyz.mul(Wc("color")), i.a)),
      e.assign(cu, i);
    const n = this.opacityNode ? gc(this.opacityNode) : np;
    if (
      (e.assign(cu.a, cu.a.mul(n)),
      null !== this.alphaTestNode || this.alphaTest > 0)
    ) {
      const t = null !== this.alphaTestNode ? gc(this.alphaTestNode) : ep;
      e.add(cu.a.lessThanEqual(t).discard());
    }
  }
  constructVariants() {}
  constructNormal({ stack: e }) {
    if (!0 === this.flatShading) {
      const t = hd(kp),
        i = cd(kp.negate()),
        n = t.cross(i).normalize();
      e.assign(vp, n);
    } else {
      const t = this.normalNode ? Sc(this.normalNode) : Zp;
      e.assign(vp, t);
    }
  }
  getEnvNode(e) {
    let t = null;
    return (
      this.envNode
        ? (t = this.envNode)
        : this.envMap
        ? (t = this.envMap.isCubeTexture ? mf(this.envMap) : qd(this.envMap))
        : e.environmentNode && (t = e.environmentNode),
      t
    );
  }
  constructLights(e) {
    const t = this.getEnvNode(e),
      i = [];
    t && i.push(new kf(t)),
      e.material.aoMap && i.push(new Sf(qd(e.material.aoMap)));
    let n = this.lightsNode || e.lightsNode;
    return i.length > 0 && (n = bf([...n.lightNodes, ...i])), n;
  }
  constructLightingModel() {}
  constructLighting(e) {
    const { material: t } = e,
      { backdropNode: i, backdropAlphaNode: n, emissiveNode: s } = this,
      r =
        !0 === this.lights || null !== this.lightsNode
          ? this.constructLights(e)
          : null;
    let a = cu.rgb;
    if (r && !1 !== r.hasLight) {
      const t = this.constructLightingModel(e);
      a = Mf(r, t, i, n);
    } else null !== i && (a = Sc(null !== n ? Rd(a, i, n) : i));
    return (
      ((s && !0 === s.isNode) || (t.emissive && !0 === t.emissive.isColor)) &&
        (a = a.add(Sc(s || ip))),
      a
    );
  }
  constructOutput(e, t) {
    const i = e.renderer,
      n = e.toneMappingNode;
    if ((n && (t = Tc(n.context({ color: t.rgb }), t.a)), !0 === this.fog)) {
      const i = e.fogNode;
      i && (t = Tc(i.mixAssign(t.rgb), t.a));
    }
    if (!0 === this.colorSpace) {
      const e = i.getRenderTarget();
      let n;
      (n =
        null !== e
          ? Array.isArray(e.texture)
            ? e.texture[0].colorSpace
            : e.texture.colorSpace
          : i.outputColorSpace),
        n !== ge && n !== fe && (t = t.linearToColorSpace(n));
    }
    return t;
  }
  setDefaultValues(e) {
    for (const i in e) {
      const t = e[i];
      void 0 === this[i] &&
        ((this[i] = t), t && t.clone && (this[i] = t.clone()));
    }
    Object.assign(this.defines, e.defines);
    const t = Object.getOwnPropertyDescriptors(e.constructor.prototype);
    for (const i in t)
      void 0 ===
        Object.getOwnPropertyDescriptor(this.constructor.prototype, i) &&
        void 0 !== t[i].get &&
        Object.defineProperty(this.constructor.prototype, i, t[i]);
  }
  toJSON(e) {
    const t = void 0 === e || "string" == typeof e;
    t && (e = { textures: {}, images: {}, nodes: {} });
    const i = Material.prototype.toJSON.call(this, e),
      n = Ah(this);
    i.inputNodes = {};
    for (const { property: r, childNode: a } of n)
      i.inputNodes[r] = a.toJSON(e).uuid;
    function s(e) {
      const t = [];
      for (const i in e) {
        const n = e[i];
        delete n.metadata, t.push(n);
      }
      return t;
    }
    if (t) {
      const t = s(e.textures),
        n = s(e.images),
        r = s(e.nodes);
      t.length > 0 && (i.textures = t),
        n.length > 0 && (i.images = n),
        r.length > 0 && (i.nodes = r);
    }
    return i;
  }
  copy(e) {
    return (
      (this.lightsNode = e.lightsNode),
      (this.envNode = e.envNode),
      (this.colorNode = e.colorNode),
      (this.normalNode = e.normalNode),
      (this.opacityNode = e.opacityNode),
      (this.backdropNode = e.backdropNode),
      (this.backdropAlphaNode = e.backdropAlphaNode),
      (this.alphaTestNode = e.alphaTestNode),
      (this.positionNode = e.positionNode),
      (this.outputNode = e.outputNode),
      (this.vertexNode = e.vertexNode),
      super.copy(e)
    );
  }
  static fromMaterial(e) {
    if (!0 === e.isNodeMaterial) return e;
    const t = zf(e.type.replace("Material", "NodeMaterial"));
    if (void 0 === t)
      throw new Error(`NodeMaterial: Material "${e.type}" is not compatible.`);
    for (const i in e) t[i] = e[i];
    return t;
  }
}
function zf(e) {
  const t = Of.get(e);
  if (void 0 !== t) return new t();
}
!(function (e) {
  if ("function" != typeof e || !e.name)
    throw new Error(`Node material ${e.name} is not a class`);
  if (Of.has(e.name))
    throw new Error(`Redefinition of node material ${e.name}`);
  Of.set(e.name, e);
})(Uf);
class Gf {
  constructor(e, t = null) {
    (this.name = e),
      (this.value = t),
      (this.boundary = 0),
      (this.itemSize = 0),
      (this.offset = 0);
  }
  setValue(e) {
    this.value = e;
  }
  getValue() {
    return this.value;
  }
}
class Vf extends Gf {
  constructor(e, t = 0) {
    super(e, t),
      (this.isFloatUniform = !0),
      (this.boundary = 4),
      (this.itemSize = 1);
  }
}
class Qf extends Gf {
  constructor(e, t = new Vector2()) {
    super(e, t),
      (this.isVector2Uniform = !0),
      (this.boundary = 8),
      (this.itemSize = 2);
  }
}
class Hf extends Gf {
  constructor(e, t = new Vector3()) {
    super(e, t),
      (this.isVector3Uniform = !0),
      (this.boundary = 16),
      (this.itemSize = 3);
  }
}
class jf extends Gf {
  constructor(e, t = new Vector4()) {
    super(e, t),
      (this.isVector4Uniform = !0),
      (this.boundary = 16),
      (this.itemSize = 4);
  }
}
class Wf extends Gf {
  constructor(e, t = new Color()) {
    super(e, t),
      (this.isColorUniform = !0),
      (this.boundary = 16),
      (this.itemSize = 3);
  }
}
class qf extends Gf {
  constructor(e, t = new Matrix3()) {
    super(e, t),
      (this.isMatrix3Uniform = !0),
      (this.boundary = 48),
      (this.itemSize = 12);
  }
}
class Xf extends Gf {
  constructor(e, t = new Matrix4()) {
    super(e, t),
      (this.isMatrix4Uniform = !0),
      (this.boundary = 64),
      (this.itemSize = 16);
  }
}
class Yf extends Vf {
  constructor(e) {
    super(e.name, e.value), (this.nodeUniform = e);
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Kf extends Qf {
  constructor(e) {
    super(e.name, e.value), (this.nodeUniform = e);
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Zf extends Hf {
  constructor(e) {
    super(e.name, e.value), (this.nodeUniform = e);
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class Jf extends jf {
  constructor(e) {
    super(e.name, e.value), (this.nodeUniform = e);
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class $f extends Wf {
  constructor(e) {
    super(e.name, e.value), (this.nodeUniform = e);
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class em extends qf {
  constructor(e) {
    super(e.name, e.value), (this.nodeUniform = e);
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class tm extends Xf {
  constructor(e) {
    super(e.name, e.value), (this.nodeUniform = e);
  }
  getValue() {
    return this.nodeUniform.value;
  }
}
class im extends Sh {
  constructor(e, t, i = null) {
    super(), (this.condNode = e), (this.ifNode = t), (this.elseNode = i);
  }
  getNodeType(e) {
    const t = this.ifNode.getNodeType(e);
    if (null !== this.elseNode) {
      const i = this.elseNode.getNodeType(e);
      if (e.getTypeLength(i) > e.getTypeLength(t)) return i;
    }
    return t;
  }
  generate(e) {
    const t = this.getNodeType(e),
      i = { tempWrite: !1 },
      { ifNode: n, elseNode: s } = this,
      r = "void" !== n.getNodeType(e) || (s && "void" !== s.getNodeType(e)),
      a = r ? hu(t).build(e) : "",
      o = eu(this.condNode).build(e, "bool");
    e.addFlowCode(`\n${e.tab}if ( ${o} ) {\n\n`).addFlowTab();
    let l = eu(this.ifNode, i).build(e, t);
    if (
      ((l = r ? a + " = " + l + ";" : l),
      e.removeFlowTab().addFlowCode(e.tab + "\t" + l + "\n\n" + e.tab + "}"),
      null !== s)
    ) {
      e.addFlowCode(" else {\n\n").addFlowTab();
      let n = eu(s, i).build(e, t);
      (n = a ? a + " = " + n + ";" : n),
        e
          .removeFlowTab()
          .addFlowCode(e.tab + "\t" + n + "\n\n" + e.tab + "}\n\n");
    } else e.addFlowCode("\n\n");
    return a;
  }
}
const nm = dc(im);
Vh("cond", nm), Ch(im);
class sm extends Sh {
  constructor(e = []) {
    super(), (this.params = e);
  }
  getVarName(e) {
    return String.fromCharCode("i".charCodeAt() + e);
  }
  getProperties(e) {
    const t = e.getNodeProperties(this);
    if (void 0 !== t.stackNode) return t;
    const i = {};
    for (let n = 0, s = this.params.length - 1; n < s; n++) {
      const e = this.getVarName(n);
      i[e] = jd(e, "int");
    }
    return (
      (t.returnsNode = this.params[this.params.length - 1](i, e.addStack(), e)),
      (t.stackNode = e.removeStack()),
      t
    );
  }
  getNodeType(e) {
    const { returnsNode: t } = this.getProperties(e);
    return t ? t.getNodeType(e) : "void";
  }
  construct(e) {
    this.getProperties(e);
  }
  generate(e) {
    const t = this.getProperties(e),
      i = this.params,
      n = t.stackNode,
      s = t.returnsNode ? t.returnsNode.build(e) : "";
    for (let a = 0, o = i.length - 1; a < o; a++) {
      const t = i[a],
        n = this.getVarName(a);
      let s = null,
        r = null,
        o = null;
      t.isNode
        ? ((s = "0"), (r = t.generate(e, "int")), (o = "forward"))
        : ((s = t.start),
          (r = t.end),
          (o = t.direction),
          "number" == typeof s
            ? (s = s.toString())
            : s && s.isNode && (s = s.generate(e, "int")),
          "number" == typeof r
            ? (r = r.toString())
            : r && r.isNode && (r = r.generate(e, "int")),
          void 0 !== s && void 0 === r
            ? ((s += " - 1"), (r = "0"), (o = "backwards"))
            : void 0 !== r && void 0 === s && ((s = "0"), (o = "forward")),
          void 0 === o &&
            (o = Number(s) > Number(r) ? "backwards" : "forward"));
      const l = { start: s, end: r, direction: o },
        h = l.start,
        c = l.end;
      let u = "",
        d = "",
        p = "";
      (u += e.getVar("int", n) + " = " + h),
        "backwards" === l.direction
          ? ((d += n + " >= " + c), (p += n + " --"))
          : ((d += n + " < " + c), (p += n + " ++"));
      const f = `for ( ${u}; ${d}; ${p} )`;
      e.addFlowCode((0 === a ? "\n" : "") + e.tab + f + " {\n\n").addFlowTab();
    }
    const r = eu(n, { tempWrite: !1 }).build(e, "void");
    e.removeFlowTab().addFlowCode("\n" + e.tab + r);
    for (let a = 0, o = this.params.length - 1; a < o; a++)
      e.addFlowCode((0 === a ? "" : e.tab) + "}\n\n").removeFlowTab();
    return e.addFlowTab(), s;
  }
}
const rm = (...e) => hc(new sm(uc(e, "int")));
Vh("loop", (e, ...t) => Xc(e, rm(...t))), Ch(sm);
class am extends Sh {
  constructor(e = null) {
    super(),
      (this.nodes = []),
      (this.outputNode = null),
      (this.parent = e),
      (this._currentCond = null),
      (this.isStackNode = !0);
  }
  getNodeType(e) {
    return this.outputNode ? this.outputNode.getNodeType(e) : "void";
  }
  add(e) {
    return this.nodes.push(Xc(jd(), e)), this;
  }
  if(e, t) {
    const i = new lc(t);
    return (this._currentCond = nm(e, i)), this.add(this._currentCond);
  }
  elseif(e, t) {
    const i = new lc(t),
      n = nm(e, i);
    return (this._currentCond.elseNode = n), (this._currentCond = n), this;
  }
  else(e) {
    return (this._currentCond.elseNode = new lc(e)), this;
  }
  assign(e, t) {
    return this.add(Cu(e, t));
  }
  loop(...e) {
    return this.add(rm(...e));
  }
  build(e, ...t) {
    for (const i of this.nodes) i.build(e, "void");
    return this.outputNode
      ? this.outputNode.build(e, ...t)
      : super.build(e, ...t);
  }
}
const om = dc(am);
Ch(am);
const lm = class extends Bn {
    constructor(e = 1, t = {}) {
      super(e, t), (this.isCubeRenderTarget = !0);
    }
    fromEquirectangularTexture(e, t) {
      const i = t.minFilter,
        n = t.generateMipmaps;
      (t.generateMipmaps = !0),
        (this.texture.type = t.type),
        (this.texture.colorSpace = t.colorSpace),
        (this.texture.generateMipmaps = t.generateMipmaps),
        (this.texture.minFilter = t.minFilter),
        (this.texture.magFilter = t.magFilter);
      const s = new Cn(5, 5, 5),
        r = Tf(Bp),
        a = zf("MeshBasicNodeMaterial");
      (a.colorNode = qd(t, r, 0)), (a.side = c), (a.blending = 0);
      const o = new En(s, a),
        l = new wa();
      l.add(o), t.minFilter === N && (t.minFilter = L);
      return (
        new Fn(1, 10, this).update(e, l),
        (t.minFilter = i),
        (t.currentGenerateMipmaps = n),
        o.geometry.dispose(),
        o.material.dispose(),
        this
      );
    }
  },
  hm = new Map([
    [2, "vec2"],
    [3, "vec3"],
    [4, "vec4"],
    [9, "mat3"],
    [16, "mat4"],
  ]),
  cm = new Map([
    [Int8Array, "int"],
    [Int16Array, "int"],
    [Int32Array, "int"],
    [Uint8Array, "uint"],
    [Uint16Array, "uint"],
    [Uint32Array, "uint"],
    [Float32Array, "float"],
  ]),
  um = new Set([Int32Array, Uint32Array, Float32Array]),
  dm = (e) => (e = Number(e)) + (e % 1 ? "" : ".0");
const pm = class {
  constructor(e, t, i, n = null) {
    (this.object = e),
      (this.material = (e && e.material) || null),
      (this.geometry = (e && e.geometry) || null),
      (this.renderer = t),
      (this.parser = i),
      (this.scene = n),
      (this.nodes = []),
      (this.updateNodes = []),
      (this.updateBeforeNodes = []),
      (this.hashNodes = {}),
      (this.lightsNode = null),
      (this.environmentNode = null),
      (this.fogNode = null),
      (this.toneMappingNode = null),
      (this.vertexShader = null),
      (this.fragmentShader = null),
      (this.computeShader = null),
      (this.flowNodes = { vertex: [], fragment: [], compute: [] }),
      (this.flowCode = { vertex: "", fragment: "", compute: [] }),
      (this.uniforms = { vertex: [], fragment: [], compute: [], index: 0 }),
      (this.structs = { vertex: [], fragment: [], compute: [], index: 0 }),
      (this.codes = { vertex: [], fragment: [], compute: [] }),
      (this.bindings = { vertex: [], fragment: [], compute: [] }),
      (this.bindingsOffset = { vertex: 0, fragment: 0, compute: 0 }),
      (this.bindingsArray = null),
      (this.attributes = []),
      (this.bufferAttributes = []),
      (this.varyings = []),
      (this.vars = { vertex: [], fragment: [], compute: [] }),
      (this.flow = { code: "" }),
      (this.chaining = []),
      (this.stack = om()),
      (this.tab = "\t"),
      (this.context = {
        keywords: new ou(),
        material: this.material,
        getMIPLevelAlgorithmNode: (e, t) => t.mul(Rf(e)),
      }),
      (this.cache = new Kc()),
      (this.globalCache = this.cache),
      (this.flowsData = new WeakMap()),
      (this.shaderStage = null),
      (this.buildStage = null);
  }
  getRenderTarget(e, t, i) {
    return new RenderTarget(e, t, i);
  }
  getCubeRenderTarget(e, t) {
    return new lm(e, t);
  }
  includes(e) {
    return this.nodes.includes(e);
  }
  createBindings() {
    const e = [];
    for (const t of this.getBindings()) e.push(t.clone());
    return e;
  }
  getBindings() {
    let e = this.bindingsArray;
    if (null === e) {
      const t = this.bindings;
      this.bindingsArray = e =
        null !== this.material ? [...t.vertex, ...t.fragment] : t.compute;
    }
    return e;
  }
  setHashNode(e, t) {
    this.hashNodes[t] = e;
  }
  addNode(e) {
    !1 === this.nodes.includes(e) &&
      (this.nodes.push(e), this.setHashNode(e, e.getHash(this)));
  }
  buildUpdateNodes() {
    for (const e of this.nodes) {
      const t = e.getUpdateType(),
        i = e.getUpdateBeforeType();
      t !== ch && this.updateNodes.push(e.getSelf()),
        i !== ch && this.updateBeforeNodes.push(e);
    }
  }
  get currentNode() {
    return this.chaining[this.chaining.length - 1];
  }
  addChain(e) {
    this.chaining.push(e);
  }
  removeChain(e) {
    if (this.chaining.pop() !== e)
      throw new Error("NodeBuilder: Invalid node chaining!");
  }
  getMethod(e) {
    return e;
  }
  getNodeFromHash(e) {
    return this.hashNodes[e];
  }
  addFlow(e, t) {
    return this.flowNodes[e].push(t), t;
  }
  setContext(e) {
    this.context = e;
  }
  getContext() {
    return this.context;
  }
  setCache(e) {
    this.cache = e;
  }
  getCache() {
    return this.cache;
  }
  isAvailable() {
    return !1;
  }
  getVertexIndex() {
    console.warn("Abstract function.");
  }
  getInstanceIndex() {
    console.warn("Abstract function.");
  }
  getFrontFacing() {
    console.warn("Abstract function.");
  }
  getFragCoord() {
    console.warn("Abstract function.");
  }
  isFlipY() {
    return !1;
  }
  getTexture() {
    console.warn("Abstract function.");
  }
  getTextureLevel() {
    console.warn("Abstract function.");
  }
  getConst(e, t = null) {
    if (
      (null === t &&
        ("float" === e || "int" === e || "uint" === e
          ? (t = 0)
          : "bool" === e
          ? (t = !1)
          : "color" === e
          ? (t = new Color())
          : "vec2" === e
          ? (t = new Vector2())
          : "vec3" === e
          ? (t = new Vector3())
          : "vec4" === e && (t = new Vector4())),
      "float" === e)
    )
      return dm(t);
    if ("int" === e) return `${Math.round(t)}`;
    if ("uint" === e) return t >= 0 ? `${Math.round(t)}u` : "0u";
    if ("bool" === e) return t ? "true" : "false";
    if ("color" === e)
      return `${this.getType("vec3")}( ${dm(t.r)}, ${dm(t.g)}, ${dm(t.b)} )`;
    const i = this.getTypeLength(e),
      n = this.getComponentType(e),
      s = (e) => this.getConst(n, e);
    if (2 === i) return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)} )`;
    if (3 === i) return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)} )`;
    if (4 === i)
      return `${this.getType(e)}( ${s(t.x)}, ${s(t.y)}, ${s(t.z)}, ${s(t.w)} )`;
    if (i > 4 && t && (t.isMatrix3 || t.isMatrix4))
      return `${this.getType(e)}( ${t.elements.map(s).join(", ")} )`;
    if (i > 4) return `${this.getType(e)}()`;
    throw new Error(
      `NodeBuilder: Type '${e}' not found in generate constant attempt.`
    );
  }
  getType(e) {
    return "color" === e ? "vec3" : e;
  }
  generateMethod(e) {
    return e;
  }
  hasGeometryAttribute(e) {
    return this.geometry && void 0 !== this.geometry.getAttribute(e);
  }
  getAttribute(e, t) {
    const i = this.attributes;
    for (const s of i) if (s.name === e) return s;
    const n = new iu(e, t);
    return i.push(n), n;
  }
  getPropertyName(e) {
    return e.name;
  }
  isVector(e) {
    return /vec\d/.test(e);
  }
  isMatrix(e) {
    return /mat\d/.test(e);
  }
  isReference(e) {
    return (
      "void" === e ||
      "property" === e ||
      "sampler" === e ||
      "texture" === e ||
      "cubeTexture" === e
    );
  }
  needsColorSpaceToLinear() {
    return !1;
  }
  getTextureEncodingFromMap(e) {
    return (
      console.warn(
        "THREE.NodeBuilder: Method .getTextureEncodingFromMap replaced by .getTextureColorSpaceFromMap in r152+."
      ),
      this.getTextureColorSpaceFromMap(e) === me ? pe : de
    );
  }
  getTextureColorSpaceFromMap(e) {
    let t;
    return (
      (t =
        e && e.isTexture
          ? e.colorSpace
          : e && e.isWebGLRenderTarget
          ? e.texture.colorSpace
          : fe),
      t
    );
  }
  getComponentType(e) {
    if (
      "float" === (e = this.getVectorType(e)) ||
      "bool" === e ||
      "int" === e ||
      "uint" === e
    )
      return e;
    const t = /(b|i|u|)(vec|mat)([2-4])/.exec(e);
    return null === t
      ? null
      : "b" === t[1]
      ? "bool"
      : "i" === t[1]
      ? "int"
      : "u" === t[1]
      ? "uint"
      : "float";
  }
  getVectorType(e) {
    return "color" === e ? "vec3" : "texture" === e ? "vec4" : e;
  }
  getTypeFromLength(e, t = "float") {
    if (1 === e) return t;
    const i = hm.get(e);
    return ("float" === t ? "" : t[0]) + i;
  }
  getTypeFromArray(e) {
    return cm.get(e.constructor);
  }
  getTypeFromAttribute(e) {
    let t = e;
    e.isInterleavedBufferAttribute && (t = e.data);
    const i = t.array,
      n = um.has(i.constructor) ? e.itemSize : t.stride || e.itemSize,
      s = e.normalized;
    let r;
    return (
      e instanceof Yi || !0 === s || (r = this.getTypeFromArray(i)),
      this.getTypeFromLength(n, r)
    );
  }
  getTypeLength(e) {
    const t = this.getVectorType(e),
      i = /vec([2-4])/.exec(t);
    return null !== i
      ? Number(i[1])
      : "float" === t || "bool" === t || "int" === t || "uint" === t
      ? 1
      : !0 === /mat3/.test(e)
      ? 9
      : !0 === /mat4/.test(e)
      ? 16
      : 0;
  }
  getVectorFromMatrix(e) {
    return e.replace("mat", "vec");
  }
  changeComponentType(e, t) {
    return this.getTypeFromLength(this.getTypeLength(e), t);
  }
  getIntegerType(e) {
    const t = this.getComponentType(e);
    return "int" === t || "uint" === t ? e : this.changeComponentType(e, "int");
  }
  addStack() {
    return (this.stack = om(this.stack)), this.stack;
  }
  removeStack() {
    const e = this.stack;
    return (this.stack = e.parent), e;
  }
  getDataFromNode(e, t = this.shaderStage) {
    const i = e.isGlobal(this) ? this.globalCache : this.cache;
    let n = i.getNodeData(e);
    return (
      void 0 === n && ((n = {}), i.setNodeData(e, n)),
      void 0 === n[t] && (n[t] = {}),
      n[t]
    );
  }
  getNodeProperties(e, t = "any") {
    const i = this.getDataFromNode(e, t);
    return i.properties || (i.properties = { outputNode: null });
  }
  getBufferAttributeFromNode(e, t) {
    const i = this.getDataFromNode(e);
    let n = i.bufferAttribute;
    if (void 0 === n) {
      const s = this.uniforms.index++;
      (n = new iu("nodeAttribute" + s, t, e)),
        this.bufferAttributes.push(n),
        (i.bufferAttribute = n);
    }
    return n;
  }
  getStructTypeFromNode(e, t = this.shaderStage, i = null) {
    const n = this.getDataFromNode(e, t);
    if (void 0 === n.structType) {
      const i = this.structs.index++;
      (e.name = `StructType${i}`), this.structs[t].push(e), (n.structType = e);
    }
    return e;
  }
  getUniformFromNode(e, t, i = this.shaderStage, n = null) {
    const s = this.getDataFromNode(e, i);
    let r = s.uniform;
    if (void 0 === r) {
      const a = this.uniforms.index++;
      (r = new nu(n || "nodeUniform" + a, t, e)),
        this.uniforms[i].push(r),
        (s.uniform = r);
    }
    return r;
  }
  getVarFromNode(e, t, i = this.shaderStage) {
    const n = this.getDataFromNode(e, i);
    let s = n.variable;
    if (void 0 === s) {
      const e = this.vars[i],
        r = e.length;
      (s = new su("nodeVar" + r, t)), e.push(s), (n.variable = s);
    }
    return s;
  }
  getVaryingFromNode(e, t) {
    const i = this.getDataFromNode(e, "any");
    let n = i.varying;
    if (void 0 === n) {
      const e = this.varyings,
        s = e.length;
      (n = new ru("nodeVarying" + s, t)), e.push(n), (i.varying = n);
    }
    return n;
  }
  getCodeFromNode(e, t, i = this.shaderStage) {
    const n = this.getDataFromNode(e);
    let s = n.code;
    if (void 0 === s) {
      const e = this.codes[i],
        r = e.length;
      (s = new au("nodeCode" + r, t)), e.push(s), (n.code = s);
    }
    return s;
  }
  addLineFlowCode(e) {
    return (
      "" === e ||
        ((e = this.tab + e),
        /;\s*$/.test(e) || (e += ";\n"),
        (this.flow.code += e)),
      this
    );
  }
  addFlowCode(e) {
    return (this.flow.code += e), this;
  }
  addFlowTab() {
    return (this.tab += "\t"), this;
  }
  removeFlowTab() {
    return (this.tab = this.tab.slice(0, -1)), this;
  }
  getFlowData(e) {
    return this.flowsData.get(e);
  }
  flowNode(e) {
    const t = e.getNodeType(this),
      i = this.flowChildNode(e, t);
    return this.flowsData.set(e, i), i;
  }
  flowChildNode(e, t = null) {
    const i = this.flow,
      n = { code: "" };
    return (this.flow = n), (n.result = e.build(this, t)), (this.flow = i), n;
  }
  flowNodeFromShaderStage(e, t, i = null, n = null) {
    const s = this.shaderStage;
    this.setShaderStage(e);
    const r = this.flowChildNode(t, i);
    return (
      null !== n && (r.code += `${this.tab + n} = ${r.result};\n`),
      (this.flowCode[e] = this.flowCode[e] + r.code),
      this.setShaderStage(s),
      r
    );
  }
  getAttributesArray() {
    return this.attributes.concat(this.bufferAttributes);
  }
  getAttributes() {
    console.warn("Abstract function.");
  }
  getVaryings() {
    console.warn("Abstract function.");
  }
  getVar(e, t) {
    return `${this.getType(e)} ${t}`;
  }
  getVars(e) {
    let t = "";
    const i = this.vars[e];
    for (const n of i) t += `${this.getVar(n.type, n.name)}; `;
    return t;
  }
  getUniforms() {
    console.warn("Abstract function.");
  }
  getCodes(e) {
    const t = this.codes[e];
    let i = "";
    for (const n of t) i += n.code + "\n";
    return i;
  }
  getHash() {
    return this.vertexShader + this.fragmentShader + this.computeShader;
  }
  setShaderStage(e) {
    this.shaderStage = e;
  }
  getShaderStage() {
    return this.shaderStage;
  }
  setBuildStage(e) {
    this.buildStage = e;
  }
  getBuildStage() {
    return this.buildStage;
  }
  buildCode() {
    console.warn("Abstract function.");
  }
  build() {
    for (const e of mh) {
      this.setBuildStage(e),
        this.context.vertex &&
          this.context.vertex.isNode &&
          this.flowNodeFromShaderStage("vertex", this.context.vertex);
      for (const t of gh) {
        this.setShaderStage(t);
        const i = this.flowNodes[t];
        for (const t of i) "generate" === e ? this.flowNode(t) : t.build(this);
      }
    }
    return (
      this.setBuildStage(null),
      this.setShaderStage(null),
      this.buildCode(),
      this.buildUpdateNodes(),
      this
    );
  }
  getNodeUniform(e, t) {
    if ("float" === t) return new Yf(e);
    if ("vec2" === t) return new Kf(e);
    if ("vec3" === t) return new Zf(e);
    if ("vec4" === t) return new Jf(e);
    if ("color" === t) return new $f(e);
    if ("mat3" === t) return new em(e);
    if ("mat4" === t) return new tm(e);
    throw new Error(`Uniform "${t}" not declared.`);
  }
  createNodeMaterial(e) {
    return zf(e);
  }
  format(e, t, i) {
    if (
      (t = this.getVectorType(t)) === (i = this.getVectorType(i)) ||
      null === i ||
      this.isReference(i)
    )
      return e;
    const n = this.getTypeLength(t),
      s = this.getTypeLength(i);
    return n > 4 || s > 4 || 0 === s
      ? e
      : n === s
      ? `${this.getType(i)}( ${e} )`
      : n > s
      ? this.format(
          `${e}.${"xyz".slice(0, s)}`,
          this.getTypeFromLength(s, this.getComponentType(t)),
          i
        )
      : 4 === s
      ? `${this.getType(i)}( ${this.format(e, t, "vec3")}, 1.0 )`
      : 2 === n
      ? `${this.getType(i)}( ${this.format(e, t, "vec2")}, 0.0 )`
      : `${this.getType(i)}( ${e} )`;
  }
  getSignature() {
    return `// Three.js r${r} - NodeMaterial System\n`;
  }
};
const fm = class {
  constructor() {
    (this.time = 0),
      (this.deltaTime = 0),
      (this.frameId = 0),
      (this.renderId = 0),
      (this.startTime = null),
      (this.frameMap = new WeakMap()),
      (this.frameBeforeMap = new WeakMap()),
      (this.renderMap = new WeakMap()),
      (this.renderBeforeMap = new WeakMap()),
      (this.renderer = null),
      (this.material = null),
      (this.camera = null),
      (this.object = null),
      (this.scene = null);
  }
  updateBeforeNode(e) {
    const t = e.getUpdateBeforeType();
    t === uh
      ? this.frameBeforeMap.get(e) !== this.frameId &&
        (this.frameBeforeMap.set(e, this.frameId), e.updateBefore(this))
      : t === dh
      ? (this.renderBeforeMap.get(e) === this.renderId &&
          this.frameBeforeMap.get(e) === this.frameId) ||
        (this.renderBeforeMap.set(e, this.renderId),
        this.frameBeforeMap.set(e, this.frameId),
        e.updateBefore(this))
      : t === ph && e.updateBefore(this);
  }
  updateNode(e) {
    const t = e.getUpdateType();
    t === uh
      ? this.frameMap.get(e) !== this.frameId &&
        (this.frameMap.set(e, this.frameId), e.update(this))
      : t === dh
      ? (this.renderMap.get(e) === this.renderId &&
          this.frameMap.get(e) === this.frameId) ||
        (this.renderMap.set(e, this.renderId),
        this.frameMap.set(e, this.frameId),
        e.update(this))
      : t === ph && e.update(this);
  }
  update() {
    this.frameId++,
      void 0 === this.lastTime && (this.lastTime = performance.now()),
      (this.deltaTime = (performance.now() - this.lastTime) / 1e3),
      (this.lastTime = performance.now()),
      (this.time += this.deltaTime);
  }
};
class mm {
  constructor(e, t, i = null, n = "", s = !1) {
    (this.type = e),
      (this.name = t),
      (this.count = i),
      (this.qualifier = n),
      (this.isConst = s);
  }
}
mm.isNodeFunctionInput = !0;
const gm = mm;
const _m = class {
  parseFunction() {
    console.warn("Abstract function.");
  }
};
class vm {
  constructor(e, t, i = "", n = "") {
    (this.type = e), (this.inputs = t), (this.name = i), (this.presicion = n);
  }
  getCode() {
    console.warn("Abstract function.");
  }
}
vm.isNodeFunction = !0;
const Am = vm,
  ym =
    /^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i,
  xm = /[a-z_0-9]+/gi,
  bm = "#pragma main";
const Em = class extends Am {
  constructor(e) {
    const {
      type: t,
      inputs: i,
      name: n,
      presicion: s,
      inputsCode: r,
      blockCode: a,
      headerCode: o,
    } = ((e) => {
      const t = (e = e.trim()).indexOf(bm),
        i = -1 !== t ? e.slice(t + 12) : e,
        n = i.match(ym);
      if (null !== n && 5 === n.length) {
        const s = n[4],
          r = [];
        let a = null;
        for (; null !== (a = xm.exec(s)); ) r.push(a);
        const o = [];
        let l = 0;
        for (; l < r.length; ) {
          const e = "const" === r[l][0];
          !0 === e && l++;
          let t = r[l][0];
          "in" === t || "out" === t || "inout" === t ? l++ : (t = "");
          const i = r[l++][0];
          let n = Number.parseInt(r[l][0]);
          !1 === Number.isNaN(n) ? l++ : (n = null);
          const s = r[l++][0];
          o.push(new gm(i, s, n, t, e));
        }
        const h = i.substring(n[0].length),
          c = void 0 !== n[3] ? n[3] : "";
        return {
          type: n[2],
          inputs: o,
          name: c,
          presicion: void 0 !== n[1] ? n[1] : "",
          inputsCode: s,
          blockCode: h,
          headerCode: -1 !== t ? e.slice(0, t) : "",
        };
      }
      throw new Error("FunctionNode: Function is not a GLSL code.");
    })(e);
    super(t, i, n, s),
      (this.inputsCode = r),
      (this.blockCode = a),
      (this.headerCode = o);
  }
  getCode(e = this.name) {
    let t;
    const i = this.blockCode;
    if ("" !== i) {
      const { type: n, inputsCode: s, headerCode: r, presicion: a } = this;
      let o = `${n} ${e} ( ${s.trim()} )`;
      "" !== a && (o = `${a} ${o}`), (t = r + o + i);
    } else t = "";
    return t;
  }
};
const Sm = class extends _m {
  parseFunction(e) {
    return new Em(e);
  }
};
const Cm = class extends Sh {
    constructor(e) {
      super(e.nodeType),
        (this.node = null),
        (this.source = null),
        (this.target = null),
        (this.inclusionType = "replace"),
        Object.assign(this, e);
    }
    generate(e) {
      return this.node.build(e, this.getNodeType(e));
    }
  },
  Mm = new fm();
Mm.camera = new Dn();
const wm = {
    LineBasicNodeMaterial: Yn.basic,
    MeshBasicNodeMaterial: Yn.basic,
    PointsNodeMaterial: Yn.points,
    MeshStandardNodeMaterial: Yn.standard,
    MeshPhysicalNodeMaterial: Yn.physical,
    MeshPhongNodeMaterial: Yn.phong,
  },
  Tm = { [Uu.ATAN2]: "atan" },
  Im = { low: "lowp", medium: "mediump", high: "highp" };
function Rm(e) {
  return `#include <${e}>`;
}
function Pm(e) {
  return `${e}Shader`;
}
class Dm extends pm {
  constructor(e, t, i) {
    super(e, t, new Sm()),
      (this.shader = i),
      (this.slots = { vertex: [], fragment: [] }),
      this._parseShaderLib(),
      this._parseInclude(
        "fragment",
        "lights_physical_fragment",
        "clearcoat_normal_fragment_begin",
        "transmission_fragment"
      ),
      this._parseObject(),
      this._sortSlotsToFlow();
  }
  getMethod(e) {
    return Tm[e] || e;
  }
  addSlot(e, t) {
    this.slots[e].push(t);
  }
  _parseShaderLib() {
    const e = this.material;
    let t = e.type;
    if (
      (e.isMeshPhysicalNodeMaterial
        ? (t = "MeshPhysicalNodeMaterial")
        : e.isMeshStandardNodeMaterial
        ? (t = "MeshStandardNodeMaterial")
        : e.isMeshPhongNodeMaterial
        ? (t = "MeshPhongNodeMaterial")
        : e.isMeshBasicNodeMaterial
        ? (t = "MeshBasicNodeMaterial")
        : e.isPointsNodeMaterial
        ? (t = "PointsNodeMaterial")
        : e.isLineBasicNodeMaterial && (t = "LineBasicNodeMaterial"),
      void 0 !== wm[t])
    ) {
      const e = wm[t],
        i = this.shader;
      (i.vertexShader = e.vertexShader),
        (i.fragmentShader = e.fragmentShader),
        (i.uniforms = In.merge([e.uniforms, Xn.lights]));
    }
  }
  _parseObject() {
    const { material: e, renderer: t } = this;
    this.addSlot(
      "fragment",
      new Cm({
        node: gp,
        nodeType: "vec3",
        source: Rm("clipping_planes_fragment"),
        target: "vec3 TransformedNormalView = %RESULT%;",
        inclusionType: "append",
      })
    ),
      t.toneMappingNode &&
        !0 === t.toneMappingNode.isNode &&
        this.addSlot(
          "fragment",
          new Cm({
            node: e.colorNode,
            nodeType: "vec4",
            source: Rm("tonemapping_fragment"),
            target: "",
          })
        ),
      e.colorNode &&
        e.colorNode.isNode &&
        this.addSlot(
          "fragment",
          new Cm({
            node: e.colorNode,
            nodeType: "vec4",
            source: "vec4 diffuseColor = vec4( diffuse, opacity );",
            target: "vec4 diffuseColor = %RESULT%; diffuseColor.a *= opacity;",
          })
        ),
      e.opacityNode &&
        e.opacityNode.isNode &&
        this.addSlot(
          "fragment",
          new Cm({
            node: e.opacityNode,
            nodeType: "float",
            source: Rm("alphatest_fragment"),
            target: "diffuseColor.a = %RESULT%;",
            inclusionType: "append",
          })
        ),
      e.normalNode &&
        e.normalNode.isNode &&
        this.addSlot(
          "fragment",
          new Cm({
            node: e.normalNode,
            nodeType: "vec3",
            source: Rm("normal_fragment_begin"),
            target: "normal = %RESULT%;",
            inclusionType: "append",
          })
        ),
      e.emissiveNode &&
        e.emissiveNode.isNode &&
        this.addSlot(
          "fragment",
          new Cm({
            node: e.emissiveNode,
            nodeType: "vec3",
            source: Rm("emissivemap_fragment"),
            target: "totalEmissiveRadiance = %RESULT%;",
            inclusionType: "append",
          })
        ),
      e.isMeshStandardNodeMaterial &&
        (e.metalnessNode &&
          e.metalnessNode.isNode &&
          this.addSlot(
            "fragment",
            new Cm({
              node: e.metalnessNode,
              nodeType: "float",
              source: Rm("metalnessmap_fragment"),
              target: "metalnessFactor = %RESULT%;",
              inclusionType: "append",
            })
          ),
        e.roughnessNode &&
          e.roughnessNode.isNode &&
          this.addSlot(
            "fragment",
            new Cm({
              node: e.roughnessNode,
              nodeType: "float",
              source: Rm("roughnessmap_fragment"),
              target: "roughnessFactor = %RESULT%;",
              inclusionType: "append",
            })
          ),
        e.isMeshPhysicalNodeMaterial &&
          (e.clearcoatNode && e.clearcoatNode.isNode
            ? (this.addSlot(
                "fragment",
                new Cm({
                  node: e.clearcoatNode,
                  nodeType: "float",
                  source: "material.clearcoat = clearcoat;",
                  target: "material.clearcoat = %RESULT%;",
                })
              ),
              e.clearcoatRoughnessNode &&
                e.clearcoatRoughnessNode.isNode &&
                this.addSlot(
                  "fragment",
                  new Cm({
                    node: e.clearcoatRoughnessNode,
                    nodeType: "float",
                    source: "material.clearcoatRoughness = clearcoatRoughness;",
                    target: "material.clearcoatRoughness = %RESULT%;",
                  })
                ),
              e.clearcoatNormalNode &&
                e.clearcoatNormalNode.isNode &&
                this.addSlot(
                  "fragment",
                  new Cm({
                    node: e.clearcoatNormalNode,
                    nodeType: "vec3",
                    source: "vec3 clearcoatNormal = geometryNormal;",
                    target: "vec3 clearcoatNormal = %RESULT%;",
                  })
                ),
              (e.defines.USE_CLEARCOAT = ""))
            : delete e.defines.USE_CLEARCOAT,
          e.sheenNode && e.sheenNode.isNode
            ? (this.addSlot(
                "fragment",
                new Cm({
                  node: e.sheenNode,
                  nodeType: "vec3",
                  source: "material.sheenColor = sheenColor;",
                  target: "material.sheenColor = %RESULT%;",
                })
              ),
              e.sheenRoughnessNode &&
                e.sheenRoughnessNode.isNode &&
                this.addSlot(
                  "fragment",
                  new Cm({
                    node: e.sheenRoughnessNode,
                    nodeType: "float",
                    source:
                      "material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );",
                    target:
                      "material.sheenRoughness = clamp( %RESULT%, 0.07, 1.0 );",
                  })
                ),
              (e.defines.USE_SHEEN = ""))
            : delete e.defines.USE_SHEEN,
          e.iridescenceNode && e.iridescenceNode.isNode
            ? (this.addSlot(
                "fragment",
                new Cm({
                  node: e.iridescenceNode,
                  nodeType: "float",
                  source: "material.iridescence = iridescence;",
                  target: "material.iridescence = %RESULT%;",
                })
              ),
              e.iridescenceIORNode &&
                e.iridescenceIORNode.isNode &&
                this.addSlot(
                  "fragment",
                  new Cm({
                    node: e.iridescenceIORNode,
                    nodeType: "float",
                    source: "material.iridescenceIOR = iridescenceIOR;",
                    target: "material.iridescenceIOR = %RESULT%;",
                  })
                ),
              e.iridescenceThicknessNode &&
                e.iridescenceThicknessNode.isNode &&
                this.addSlot(
                  "fragment",
                  new Cm({
                    node: e.iridescenceThicknessNode,
                    nodeType: "float",
                    source:
                      "material.iridescenceThickness = iridescenceThicknessMaximum;",
                    target: "material.iridescenceThickness = %RESULT%;",
                  })
                ),
              (e.defines.USE_IRIDESCENCE = ""))
            : delete e.defines.USE_IRIDESCENCE,
          e.iorNode &&
            e.iorNode.isNode &&
            this.addSlot(
              "fragment",
              new Cm({
                node: e.iorNode,
                nodeType: "float",
                source: "material.ior = ior;",
                target: "material.ior = %RESULT%;",
              })
            ),
          e.specularColorNode &&
            e.specularColorNode.isNode &&
            this.addSlot(
              "fragment",
              new Cm({
                node: e.specularColorNode,
                nodeType: "vec3",
                source: "vec3 specularColorFactor = specularColor;",
                target: "vec3 specularColorFactor = %RESULT%;",
              })
            ),
          e.specularIntensityNode &&
            e.specularIntensityNode.isNode &&
            this.addSlot(
              "fragment",
              new Cm({
                node: e.specularIntensityNode,
                nodeType: "float",
                source: "float specularIntensityFactor = specularIntensity;",
                target: "float specularIntensityFactor = %RESULT%;",
              })
            ),
          e.transmissionNode && e.transmissionNode.isNode
            ? (this.addSlot(
                "fragment",
                new Cm({
                  node: e.transmissionNode,
                  nodeType: "float",
                  source: "material.transmission = transmission;",
                  target: "material.transmission = %RESULT%;",
                })
              ),
              e.thicknessNode &&
                e.thicknessNode.isNode &&
                this.addSlot(
                  "fragment",
                  new Cm({
                    node: e.thicknessNode,
                    nodeType: "float",
                    source: "material.thickness = thickness;",
                    target: "material.thickness = %RESULT%;",
                  })
                ),
              e.attenuationDistanceNode &&
                e.attenuationDistanceNode.isNode &&
                this.addSlot(
                  "fragment",
                  new Cm({
                    node: e.attenuationDistanceNode,
                    nodeType: "float",
                    source:
                      "material.attenuationDistance = attenuationDistance;",
                    target: "material.attenuationDistance = %RESULT%;",
                  })
                ),
              e.attenuationColorNode &&
                e.attenuationColorNode.isNode &&
                this.addSlot(
                  "fragment",
                  new Cm({
                    node: e.attenuationColorNode,
                    nodeType: "vec3",
                    source: "material.attenuationColor = attenuationColor;",
                    target: "material.attenuationColor = %RESULT%;",
                  })
                ),
              (e.transmission = 1),
              (e.defines.USE_TRANSMISSION = ""))
            : ((e.transmission = 0), delete e.defines.USE_TRANSMISSION))),
      e.positionNode &&
        e.positionNode.isNode &&
        this.addSlot(
          "vertex",
          new Cm({
            node: e.positionNode,
            nodeType: "vec3",
            source: Rm("begin_vertex"),
            target: "transformed = %RESULT%;",
            inclusionType: "append",
          })
        ),
      e.sizeNode &&
        e.sizeNode.isNode &&
        this.addSlot(
          "vertex",
          new Cm({
            node: e.sizeNode,
            nodeType: "float",
            source: "gl_PointSize = size;",
            target: "gl_PointSize = %RESULT%;",
          })
        );
  }
  getTexture(e, t, i) {
    return e.isTextureCube
      ? `textureCube( ${t}, ${i} )`
      : `texture2D( ${t}, ${i} )`;
  }
  getTextureBias(e, t, i, n) {
    return (
      void 0 !== this.material.extensions &&
        (this.material.extensions.shaderTextureLOD = !0),
      `textureLod( ${t}, ${i}, ${n} )`
    );
  }
  getUniforms(e) {
    const t = this.uniforms[e];
    let i = "";
    for (const n of t) {
      if (/^(modelViewMatrix|projectionMatrix)$/.test(n.name)) continue;
      let e = null;
      if ("texture" === n.type) e = `sampler2D ${n.name}; `;
      else if ("cubeTexture" === n.type) e = `samplerCube ${n.name}; `;
      else {
        e = `${this.getVectorType(n.type)} ${n.name}; `;
      }
      const t = n.node.precision;
      (e = null !== t ? "uniform " + Im[t] + " " + e : "uniform " + e),
        (i += e);
    }
    return i;
  }
  getAttributes(e) {
    let t = "";
    if ("vertex" === e) {
      const e = this.attributes;
      for (const i of e)
        /^(position|normal|uv[1-3]?)$/.test(i.name) ||
          (t += `attribute ${i.type} ${i.name}; `);
    }
    return t;
  }
  getVaryings(e) {
    let t = "";
    const i = this.varyings;
    if ("vertex" === e)
      for (const n of i)
        t += `${n.needsInterpolation ? "varying" : "/*varying*/"} ${n.type} ${
          n.name
        }; `;
    else if ("fragment" === e)
      for (const n of i)
        n.needsInterpolation && (t += `varying ${n.type} ${n.name}; `);
    return t;
  }
  addCode(e, t, i, n = this) {
    const s = Pm(e);
    let r = n[s];
    const a = r.indexOf(t);
    if (-1 !== a) {
      const e = r.substring(0, a + t.length),
        n = r.substring(a + t.length);
      r = `${e}\n${i}\n${n}`;
    }
    n[s] = r;
  }
  replaceCode(e, t, i, n = this) {
    const s = Pm(e);
    n[s] = n[s].replaceAll(t, i);
  }
  getVertexIndex() {
    return "gl_VertexID";
  }
  getFrontFacing() {
    return "gl_FrontFacing";
  }
  getFragCoord() {
    return "gl_FragCoord";
  }
  isFlipY() {
    return !0;
  }
  buildCode() {
    const e = {};
    for (const t of fh) {
      const i = this.getUniforms(t),
        n = this.getAttributes(t),
        s = this.getVaryings(t),
        r = this.getVars(t),
        a = this.getCodes(t);
      e[
        t
      ] = `${this.getSignature()}\n// <node_builder>\n\n// uniforms\n${i}\n\n// attributes\n${n}\n\n// varyings\n${s}\n\n// vars\n${r}\n\n// codes\n${a}\n\n// </node_builder>\n\n${
        this.shader[Pm(t)]
      }\n`;
    }
    (this.vertexShader = e.vertex), (this.fragmentShader = e.fragment);
  }
  build() {
    return (
      super.build(),
      this._addSnippets(),
      this._addUniforms(),
      this._updateUniforms(),
      (this.shader.vertexShader = this.vertexShader),
      (this.shader.fragmentShader = this.fragmentShader),
      this
    );
  }
  _parseInclude(e, ...t) {
    for (const i of t) {
      const t = Rm(i),
        n = qn[i],
        s = Pm(e);
      this.shader[s] = this.shader[s].replaceAll(t, n);
    }
  }
  _sortSlotsToFlow() {
    for (const e of fh) {
      const t = this.shader[Pm(e)],
        i = this.slots[e].sort((e, i) =>
          t.indexOf(e.source) > t.indexOf(i.source) ? 1 : -1
        );
      for (const n of i) this.addFlow(e, n);
    }
  }
  _addSnippets() {
    for (const e of fh) {
      for (const t of this.slots[e]) {
        const i = this.getFlowData(t),
          n = t.inclusionType,
          s = t.source,
          r = i.code + "\n\t" + t.target.replace("%RESULT%", i.result);
        "append" === n
          ? this.addCode(e, s, r)
          : "replace" === n
          ? this.replaceCode(e, s, r)
          : console.warn(`Inclusion type "${n}" not compatible.`);
      }
      this.addCode(e, "main() {", "\n\t" + this.flowCode[e]);
    }
  }
  _addUniforms() {
    for (const e of fh)
      for (const t of this.uniforms[e]) this.shader.uniforms[t.name] = t;
  }
  _updateUniforms() {
    (Mm.object = this.object), (Mm.renderer = this.renderer);
    for (const e of this.updateNodes) Mm.updateNode(e);
  }
}
const Lm = new WeakMap(),
  Fm = new fm();
(Material.prototype.onBuild = function (e, t, i) {
  !0 === e.material.isNodeMaterial && Lm.set(this, new Dm(e, i, t).build());
}),
  (Material.prototype.onBeforeRender = function (e, t, i, n, s) {
    const r = Lm.get(this);
    if (void 0 !== r) {
      (Fm.material = this), (Fm.camera = i), (Fm.object = s), (Fm.renderer = e);
      const t = r.updateNodes;
      if (t.length > 0) {
        e.state.useProgram(null);
        for (const e of t) Fm.updateNode(e);
      }
    }
  });
const Nm = (e, t, i, n) => {
  if (
    ((t || i) &&
      (e = e.replace("void main()", (t || "") + "void main()\n" + (i || ""))),
    n)
  ) {
    const t = e.lastIndexOf("}");
    (e = e.substring(0, t)), (e += n + "}");
  }
  return e;
};
var Bm,
  km,
  Om,
  Um =
    "undefined" != typeof globalThis
      ? globalThis
      : "undefined" != typeof window
      ? window
      : "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : {},
  zm = { exports: {} };
(km = Um),
  (Om = function () {
    return function () {
      return (function (e) {
        var t = [];
        if (0 === e.length) return "";
        if ("string" != typeof e[0])
          throw new TypeError("Url must be a string. Received " + e[0]);
        if (e[0].match(/^[^/:]+:\/*$/) && e.length > 1) {
          var i = e.shift();
          e[0] = i + e[0];
        }
        e[0].match(/^file:\/\/\//)
          ? (e[0] = e[0].replace(/^([^/:]+):\/*/, "$1:///"))
          : (e[0] = e[0].replace(/^([^/:]+):\/*/, "$1://"));
        for (var n = 0; n < e.length; n++) {
          var s = e[n];
          if ("string" != typeof s)
            throw new TypeError("Url must be a string. Received " + s);
          "" !== s &&
            (n > 0 && (s = s.replace(/^[\/]+/, "")),
            (s =
              n < e.length - 1
                ? s.replace(/[\/]+$/, "")
                : s.replace(/[\/]+$/, "/")),
            t.push(s));
        }
        var r = t.join("/"),
          a = (r = r.replace(/\/(\?|&|#[^!])/g, "$1")).split("?");
        return a.shift() + (a.length > 0 ? "?" : "") + a.join("&");
      })(
        "object" == typeof arguments[0]
          ? arguments[0]
          : [].slice.call(arguments)
      );
    };
  }),
  (Bm = zm).exports ? (Bm.exports = Om()) : (km.urljoin = Om());
const Gm = zm.exports;
let Vm = null;
function Qm() {
  if (null !== Vm) return Vm;
  let e = "";
  if (
    ((e =
      "string" == typeof MAPV_BASE_URL
        ? MAPV_BASE_URL
        : "https://mapv-three.bj.bcebos.com"),
    !e)
  )
    throw new Error(
      "Unable to determine base URL automatically, try defining a global variable called MAPV_BASE_URL."
    );
  return (Vm = e), e;
}
function Hm(...e) {
  return Gm(Qm(), ...e);
}
const jm = Object.freeze(
  Object.defineProperty(
    { __proto__: null, getBaseUrl: Qm, getAssetUrl: Hm },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
class Wm extends va {
  constructor() {
    super(),
      publicField(this, "isEmptySky", !0),
      publicField(this, "_addDefaultEnvMap", !1),
      publicField(this, "_time", 21600),
      publicField(this, "_startTimestamp", new Date().getTime()),
      publicField(this, "_timeAnimation", !1),
      publicField(this, "_timeAnimationSpeed", 1),
      publicField(this, "_skyLightIntensity", 0.5),
      publicField(this, "_skyLightAttenuationRatio", 0.2),
      publicField(this, "_sunIntensityBias", 0),
      publicField(this, "_sunIntensityScale", 0.8),
      publicField(this, "_weather", "partlyCloudy"),
      publicField(this, "_timeChangedListeners", []),
      publicField(this, "_sunDirection", new Vector3()),
      publicField(this, "_sunLightColorDay", new Color(16777215)),
      publicField(this, "_sunLightColorSunset", new Color(15090944)),
      publicField(this, "_sunLightColorCurrent", new Color(16777215)),
      publicField(this, "_sunRadian", null),
      publicField(this, "_skyLightColorDay", new Color(16777215)),
      publicField(this, "_skyLightColorNight", new Color(16777215)),
      publicField(this, "_groundLightColorDay", new Color(16777215)),
      publicField(this, "_groundLightColorNight", new Color(16758093)),
      publicField(this, "_lightNeedsUpdate", !1),
      publicField(this, "_sunNeedsUpdate", !1),
      publicField(this, "_affectWorld", !1),
      publicField(this, "updateSunLightShadowCamera", () => {
        const e = this.engine;
        if (!e.renderer.shadowMap.enabled) {
          const e = this.sunLight;
          return (
            e.position.copy(this._sunDirection),
            e.target.position.set(0, 0, 0),
            e.updateMatrix(),
            e.updateMatrixWorld(),
            e.target.updateMatrix(),
            void e.target.updateMatrixWorld()
          );
        }
        const t = this._sunDirection,
          i = [t.x, t.y, t.z],
          n = this.sunLight,
          [s, r] = e.map.getProjectionCenter2D();
        let a = e.map.getCameraDistance();
        const o = e.rendering.camera.position.z;
        let l = 1e3;
        const h = l * i[0],
          c = l * i[1],
          u = l * i[2];
        n.position.set(s + h, r + c, u),
          n.target.position.set(s, r, 0),
          (n.shadow.camera.left = -a),
          (n.shadow.camera.bottom = -a),
          (n.shadow.camera.right = a),
          (n.shadow.camera.top = a),
          (n.shadow.camera.near = 1),
          (n.shadow.camera.far = o > 1e4 ? 2 : 2e3),
          n.updateMatrix(),
          n.updateMatrixWorld(),
          n.target.updateMatrix(),
          n.target.updateMatrixWorld(),
          n.shadow.camera.updateProjectionMatrix();
        const d = ze.mapLinear(o, 1, 1e4, -8e-5, -0.5);
        n.shadow.bias = d < -0.005 ? -0.001 : 0.2 * d;
      });
    const e = (this.sunLight = new Nl(16777215, 0.6)),
      t = (this.skyLight = new bl(16755200, 255, this._skyLightIntensity));
    t.position.set(0, 0, 1),
      (e.castShadow = !0),
      (e.shadow.mapSize = new Vector2(1024, 1024)),
      (e.shadow.bias = -1e-4),
      this.add(e),
      this.add(e.target),
      this.add(t),
      (e.matrixAutoUpdate = !1),
      (e.target.matrixAutoUpdate = !1),
      (this.renderOrder = -100);
  }
  afterAddToEngine(e) {
    if (
      ((this.engine = e),
      !this.isDynamicSky && !this.isStaticSky && this._addDefaultEnvMap)
    ) {
      const t = new yl().load(
        Hm("assets/textures/sky/partlyCloudy_default.jpg")
      );
      (t.mapping = C), (t.colorSpace = me), (e.rendering.scene.environment = t);
    }
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  set time(e) {
    this._time = e;
    const t = (this._sunRadian = (e / 86400 - 0.25) * Math.PI * 2),
      i = Math.cos(t),
      n = Math.sin(t);
    this._sunDirection.set(i, 0, n),
      (this._lightNeedsUpdate = !0),
      this.onTimeChanged(this._time);
    for (const s of this._timeChangedListeners) s(e);
  }
  get time() {
    return this._time;
  }
  get weather() {
    return this._weather;
  }
  set weather(e) {
    (this._weather = e), this.onWeatherChanged(e);
  }
  get timeAnimation() {
    return this._timeAnimation;
  }
  set timeAnimation(e) {
    e &&
      (this._startTimestamp =
        new Date().getTime() -
        (this.time / 86400) * (86400 / this._timeAnimationSpeed)),
      (this._timeAnimation = e);
  }
  get timeAnimationSpeed() {
    return this._timeAnimationSpeed;
  }
  set timeAnimationSpeed(e) {
    this._timeAnimationSpeed = e;
  }
  tickTime() {
    const e = new Date().getTime() - this._startTimestamp,
      t = 86400 / this._timeAnimationSpeed;
    this.time = ((e % t) / t) * 86400;
  }
  onBeforeScenePrepareRender() {
    this._timeAnimation && this.tickTime(),
      this._lightNeedsUpdate && this.updateLight(),
      this.updateSunLightShadowCamera();
  }
  updateLight() {
    const e = this._sunDirection.z,
      t = e > 0.5 ? 1 : e < 0 ? 0 : 2 * e;
    this.sunLight.intensity =
      this._sunIntensityBias + this._sunIntensityScale * t;
    const i = (this.sunsetRatio = e > 0.259 ? 0 : e < 0 ? 1 : 1 - e / 0.259);
    (this.skyLight.intensity =
      this._skyLightIntensity *
      ze.clamp(1 - i, this._skyLightAttenuationRatio, 1)),
      this._sunLightColorCurrent.lerpColors(
        this._sunLightColorDay,
        this._sunLightColorSunset,
        i
      ),
      this.sunLight.color.copy(this._sunLightColorCurrent),
      this.skyLight.color.lerpColors(
        this._skyLightColorDay,
        this._skyLightColorNight,
        i
      ),
      this.skyLight.groundColor.lerpColors(
        this._groundLightColorDay,
        this._groundLightColorNight,
        i
      );
  }
  addTimeChangedListener(e) {
    -1 === this._timeChangedListeners.indexOf(e) &&
      this._timeChangedListeners.push(e);
  }
  removeTimeChangedListener(e) {
    const t = this._timeChangedListeners.indexOf(e);
    -1 !== t && this._timeChangedListeners.splice(t, 1);
  }
  onTimeChanged(e) {}
  onWeatherChanged(e) {}
  dispose() {}
  get sunIntensityBias() {
    return this._sunIntensityBias;
  }
  set sunIntensityBias(e) {
    (this._sunIntensityBias = e), (this._lightNeedsUpdate = !0);
  }
  get sunIntensityScale() {
    return this._sunIntensityScale;
  }
  set sunIntensityScale(e) {
    (this._sunIntensityScale = e), (this._lightNeedsUpdate = !0);
  }
  get skyLightIntensity() {
    return this._skyLightIntensity;
  }
  set skyLightIntensity(e) {
    (this._skyLightIntensity = e), (this._lightNeedsUpdate = !0);
  }
  get skyLightAttenuationRatio() {
    return this._skyLightAttenuationRatio;
  }
  set skyLightAttenuationRatio(e) {
    (this._skyLightAttenuationRatio = e), (this._lightNeedsUpdate = !0);
  }
  get sunDirection() {
    return this._sunDirection;
  }
  get affectWorld() {
    return this._affectWorld;
  }
}

var qm,
  Xm,
  Ym,
  Km = {
    types: {
      Boolean: "boolean",
      STRING: "string",
      NUMBER: "number",
      OBJECT: "object",
    },
    ensureTypedArg: function (e, t, i) {
      return typeof e === t ? e : i;
    },
    ensureArrayTypedArg: function (e, t, i) {
      if (Array.isArray(e)) {
        for (var n = e.length - 1; n >= 0; --n) if (typeof e[n] !== t) return i;
        return e;
      }
      return this.ensureTypedArg(e, t, i);
    },
    ensureInstanceOf: function (e, t, i) {
      return void 0 !== e ? e : i;
    },
    ensureArrayInstanceOf: function (e, t, i) {
      if (Array.isArray(e)) {
        for (var n = e.length - 1; n >= 0; --n)
          if (void 0 !== t && e[n] instanceof t == 0) return i;
        return e;
      }
      return this.ensureInstanceOf(e, t, i);
    },
    ensureValueOverLifetimeCompliance: function (e, t, i) {
      (t = t || 3),
        (i = i || 3),
        !1 === Array.isArray(e._value) && (e._value = [e._value]),
        !1 === Array.isArray(e._spread) && (e._spread = [e._spread]);
      var n = this.clamp(e._value.length, t, i),
        s = this.clamp(e._spread.length, t, i),
        r = Math.max(n, s);
      e._value.length !== r && (e._value = this.interpolateArray(e._value, r)),
        e._spread.length !== r &&
          (e._spread = this.interpolateArray(e._spread, r));
    },
    interpolateArray: function (e, t) {
      for (
        var i = e.length,
          n = ["function" == typeof e[0].clone ? e[0].clone() : e[0]],
          s = (i - 1) / (t - 1),
          r = 1;
        r < t - 1;
        ++r
      ) {
        var a = r * s,
          o = Math.floor(a),
          l = Math.ceil(a),
          h = a - o;
        n[r] = this.lerpTypeAgnostic(e[o], e[l], h);
      }
      return (
        n.push(
          "function" == typeof e[i - 1].clone ? e[i - 1].clone() : e[i - 1]
        ),
        n
      );
    },
    clamp: function (e, t, i) {
      return Math.max(t, Math.min(e, i));
    },
    zeroToEpsilon: function (e, t) {
      var i = 1e-5,
        n = e;
      return (
        (n = t ? Math.random() * i * 10 : i), e < 0 && e > -1e-5 && (n = -n), n
      );
    },
    lerpTypeAgnostic: function (e, t, i) {
      var n,
        s = this.types;
      return typeof e === s.NUMBER && typeof t === s.NUMBER
        ? e + (t - e) * i
        : e instanceof Vector2 && t instanceof Vector2
        ? (((n = e.clone()).x = this.lerp(e.x, t.x, i)),
          (n.y = this.lerp(e.y, t.y, i)),
          n)
        : e instanceof Vector3 && t instanceof Vector3
        ? (((n = e.clone()).x = this.lerp(e.x, t.x, i)),
          (n.y = this.lerp(e.y, t.y, i)),
          (n.z = this.lerp(e.z, t.z, i)),
          n)
        : e instanceof Vector4 && t instanceof Vector4
        ? (((n = e.clone()).x = this.lerp(e.x, t.x, i)),
          (n.y = this.lerp(e.y, t.y, i)),
          (n.z = this.lerp(e.z, t.z, i)),
          (n.w = this.lerp(e.w, t.w, i)),
          n)
        : e instanceof Color && t instanceof Color
        ? (((n = e.clone()).r = this.lerp(e.r, t.r, i)),
          (n.g = this.lerp(e.g, t.g, i)),
          (n.b = this.lerp(e.b, t.b, i)),
          n)
        : void console.warn(
            "Invalid argument types, or argument types do not match:",
            e,
            t
          );
    },
    lerp: function (e, t, i) {
      return e + (t - e) * i;
    },
    roundToNearestMultiple: function (e, t) {
      var i;
      return 0 === t || 0 == (i = Math.abs(e) % t)
        ? e
        : e < 0
        ? -(Math.abs(e) - i)
        : e + t - i;
    },
    arrayValuesAreEqual: function (e) {
      for (var t = 0; t < e.length - 1; ++t) if (e[t] !== e[t + 1]) return !1;
      return !0;
    },
    randomFloat: function (e, t) {
      return e + t * (Math.random() - 0.5);
    },
    randomVector3: function (e, t, i, n, s) {
      var r = i.x + (Math.random() * n.x - 0.5 * n.x),
        a = i.y + (Math.random() * n.y - 0.5 * n.y),
        o = i.z + (Math.random() * n.z - 0.5 * n.z);
      s &&
        ((r = 0.5 * -s.x + this.roundToNearestMultiple(r, s.x)),
        (a = 0.5 * -s.y + this.roundToNearestMultiple(a, s.y)),
        (o = 0.5 * -s.z + this.roundToNearestMultiple(o, s.z))),
        e.typedArray.setVec3Components(t, r, a, o);
    },
    randomColor: function (e, t, i, n) {
      var s = i.r + Math.random() * n.x,
        r = i.g + Math.random() * n.y,
        a = i.b + Math.random() * n.z;
      (s = this.clamp(s, 0, 1)),
        (r = this.clamp(r, 0, 1)),
        (a = this.clamp(a, 0, 1)),
        e.typedArray.setVec3Components(t, s, r, a);
    },
    randomColorAsHex:
      ((Xm = new Color()),
      function (e, t, i, n) {
        for (var s = i.length, r = [], a = 0; a < s; ++a) {
          var o = n[a];
          Xm.copy(i[a]),
            (Xm.r += Math.random() * o.x - 0.5 * o.x),
            (Xm.g += Math.random() * o.y - 0.5 * o.y),
            (Xm.b += Math.random() * o.z - 0.5 * o.z),
            (Xm.r = this.clamp(Xm.r, 0, 1)),
            (Xm.g = this.clamp(Xm.g, 0, 1)),
            (Xm.b = this.clamp(Xm.b, 0, 1)),
            r.push(Xm.getHex());
        }
        e.typedArray.setVec4Components(t, r[0], r[1], r[2], r[3]);
      }),
    randomVector3OnLine: function (e, t, i, n) {
      var s = i.clone();
      s.lerp(n, Math.random()),
        e.typedArray.setVec3Components(t, s.x, s.y, s.z);
    },
    randomVector3OnSphere: function (e, t, i, n, s, r, a, o) {
      var l = 2 * Math.random() - 1,
        h = 6.2832 * Math.random(),
        c = Math.sqrt(1 - l * l),
        u = this.randomFloat(n, s),
        d = 0,
        p = 0,
        f = 0;
      a && (u = Math.round(u / a) * a),
        (d = c * Math.cos(h) * u),
        (p = c * Math.sin(h) * u),
        (f = l * u),
        (d *= r.x),
        (p *= r.y),
        (f *= r.z),
        (d += i.x),
        (p += i.y),
        (f += i.z),
        e.typedArray.setVec3Components(t, d, p, f);
    },
    seededRandom: function (e) {
      var t = 1e4 * Math.sin(e);
      return t - (0 | t);
    },
    randomVector3OnDisc: function (e, t, i, n, s, r, a) {
      var o = 6.2832 * Math.random(),
        l = Math.abs(this.randomFloat(n, s)),
        h = 0,
        c = 0,
        u = 0;
      a && (l = Math.round(l / a) * a),
        (h = Math.cos(o) * l),
        (c = Math.sin(o) * l),
        (h *= r.x),
        (c *= r.y),
        (h += i.x),
        (c += i.y),
        (u += i.z),
        e.typedArray.setVec3Components(t, h, c, u);
    },
    randomDirectionVector3OnSphere:
      ((qm = new Vector3()),
      function (e, t, i, n, s, r, a, o) {
        qm.copy(r),
          (qm.x -= i),
          (qm.y -= n),
          (qm.z -= s),
          qm.normalize().multiplyScalar(-this.randomFloat(a, o)),
          e.typedArray.setVec3Components(t, qm.x, qm.y, qm.z);
      }),
    randomDirectionVector3OnDisc:
      ((Ym = new Vector3()),
      function (e, t, i, n, s, r, a, o) {
        Ym.copy(r),
          (Ym.x -= i),
          (Ym.y -= n),
          (Ym.z -= s),
          Ym.normalize().multiplyScalar(-this.randomFloat(a, o)),
          e.typedArray.setVec3Components(t, Ym.x, Ym.y, 0);
      }),
    getPackedRotationAxis: (function () {
      var e = new Vector3(),
        t = new Vector3(),
        i = new Color(),
        n = new Vector3(1, 1, 1);
      return function (s, r) {
        return (
          e.copy(s).normalize(),
          t.copy(r).normalize(),
          (e.x += 0.5 * -r.x + Math.random() * r.x),
          (e.y += 0.5 * -r.y + Math.random() * r.y),
          (e.z += 0.5 * -r.z + Math.random() * r.z),
          e.normalize().add(n).multiplyScalar(0.5),
          i.setRGB(e.x, e.y, e.z),
          i.getHex()
        );
      };
    })(),
  },
  Zm = { BOX: 1, SPHERE: 2, DISC: 3, LINE: 4 },
  Jm = 4,
  $m = (function () {
    function e(e, t, i, n) {
      (this.componentSize = i || 1),
        (this.size = t || 1),
        (this.TypedArrayConstructor = e || Float32Array),
        (this.array = new e(t * this.componentSize)),
        (this.indexOffset = n || 0);
    }
    var t = e.prototype;
    return (
      (t.setSize = function (e, t) {
        var i = this.array.length;
        return (
          t || (e *= this.componentSize),
          e < i
            ? this.shrink(e)
            : e > i
            ? this.grow(e)
            : void console.info(
                "TypedArray is already of size:",
                e + ".",
                "Will not resize."
              )
        );
      }),
      (t.shrink = function (e) {
        return (this.array = this.array.subarray(0, e)), (this.size = e), this;
      }),
      (t.grow = function (e) {
        var t = new this.TypedArrayConstructor(e);
        return t.set(this.array), (this.array = t), (this.size = e), this;
      }),
      (t.splice = function (e, t) {
        for (
          var i = e * this.componentSize,
            n = t * this.componentSize,
            s = [],
            r = this.array.length,
            a = 0;
          a < r;
          ++a
        )
          (a < i || a > n) && s.push(this.array[a]);
        return this.setFromArray(0, s), this;
      }),
      (t.setFromArray = function (e, t) {
        var i = e + t.length;
        return (
          i > this.array.length
            ? this.grow(i)
            : i < this.array.length && this.shrink(i),
          this.array.set(t, this.indexOffset + e),
          this
        );
      }),
      (t.setVec2 = function (e, t) {
        return this.setVec2Components(e, t.x, t.y);
      }),
      (t.setVec2Components = function (e, t, i) {
        var n = this.array,
          s = this.indexOffset + e * this.componentSize;
        return (n[s] = t), (n[s + 1] = i), this;
      }),
      (t.setVec3 = function (e, t) {
        return this.setVec3Components(e, t.x, t.y, t.z);
      }),
      (t.setVec3Components = function (e, t, i, n) {
        var s = this.array,
          r = this.indexOffset + e * this.componentSize;
        return (s[r] = t), (s[r + 1] = i), (s[r + 2] = n), this;
      }),
      (t.setVec4 = function (e, t) {
        return this.setVec4Components(e, t.x, t.y, t.z, t.w);
      }),
      (t.setVec4Components = function (e, t, i, n, s) {
        var r = this.array,
          a = this.indexOffset + e * this.componentSize;
        return (r[a] = t), (r[a + 1] = i), (r[a + 2] = n), (r[a + 3] = s), this;
      }),
      (t.setMat3 = function (e, t) {
        return this.setFromArray(
          this.indexOffset + e * this.componentSize,
          t.elements
        );
      }),
      (t.setMat4 = function (e, t) {
        return this.setFromArray(
          this.indexOffset + e * this.componentSize,
          t.elements
        );
      }),
      (t.setColor = function (e, t) {
        return this.setVec3Components(e, t.r, t.g, t.b);
      }),
      (t.setNumber = function (e, t) {
        return (
          (this.array[this.indexOffset + e * this.componentSize] = t), this
        );
      }),
      (t.getValueAtIndex = function (e) {
        return this.array[this.indexOffset + e];
      }),
      (t.getComponentValueAtIndex = function (e) {
        return this.array.subarray(this.indexOffset + e * this.componentSize);
      }),
      e
    );
  })(),
  eg = (function () {
    function e(t, i, n) {
      var s = e.typeSizeMap;
      (this.type = "string" == typeof t && s.hasOwnProperty(t) ? t : "f"),
        (this.componentSize = s[this.type]),
        (this.arrayType = n || Float32Array),
        (this.typedArray = null),
        (this.bufferAttribute = null),
        (this.dynamicBuffer = !!i),
        (this.updateMin = 0),
        (this.updateMax = 0);
    }
    var t = e.prototype;
    return (
      (t.setUpdateRange = function (e, t) {
        (this.updateMin = Math.min(
          e * this.componentSize,
          this.updateMin * this.componentSize
        )),
          (this.updateMax = Math.max(
            t * this.componentSize,
            this.updateMax * this.componentSize
          ));
      }),
      (t.flagUpdate = function () {
        var e = this.bufferAttribute,
          t = e.updateRange;
        (t.offset = this.updateMin),
          (t.count = Math.min(
            this.updateMax - this.updateMin + this.componentSize,
            this.typedArray.array.length
          )),
          (e.needsUpdate = !0);
      }),
      (t.resetUpdateRange = function () {
        (this.updateMin = 0), (this.updateMax = 0);
      }),
      (t.resetDynamic = function () {
        this.bufferAttribute.useage = this.dynamicBuffer ? xe : ye;
      }),
      (t.splice = function (e, t) {
        this.typedArray.splice(e, t), this.forceUpdateAll();
      }),
      (t.forceUpdateAll = function () {
        (this.bufferAttribute.array = this.typedArray.array),
          (this.bufferAttribute.updateRange.offset = 0),
          (this.bufferAttribute.updateRange.count = -1),
          (this.bufferAttribute.usage = ye),
          (this.bufferAttribute.needsUpdate = !0);
      }),
      (t._ensureTypedArray = function (e) {
        (null !== this.typedArray &&
          this.typedArray.size === e * this.componentSize) ||
          (null !== this.typedArray && this.typedArray.size !== e
            ? this.typedArray.setSize(e)
            : null === this.typedArray &&
              (this.typedArray = new $m(
                this.arrayType,
                e,
                this.componentSize
              )));
      }),
      (t._createBufferAttribute = function (e) {
        if ((this._ensureTypedArray(e), null !== this.bufferAttribute))
          return (
            (this.bufferAttribute.array = this.typedArray.array),
            (this.bufferAttribute.count =
              this.bufferAttribute.array.length /
              this.bufferAttribute.itemSize),
            void (this.bufferAttribute.needsUpdate = !0)
          );
        (this.bufferAttribute = new Wi(
          this.typedArray.array,
          this.componentSize
        )),
          (this.bufferAttribute.usage = this.dynamicBuffer ? xe : ye);
      }),
      (t.getLength = function () {
        return null === this.typedArray ? 0 : this.typedArray.array.length;
      }),
      e
    );
  })();
eg.typeSizeMap = { f: 1, v2: 2, v3: 3, v4: 4, c: 3, m3: 9, m4: 16 };
var tg = {
    defines: [
      "#define PACKED_COLOR_SIZE 256.0",
      "#define PACKED_COLOR_DIVISOR 255.0",
    ].join("\n"),
    uniforms: [
      "uniform float deltaTime;",
      "uniform float runTime;",
      "uniform sampler2D tex;",
      "uniform vec4 textureAnimation;",
      "uniform float scale;",
    ].join("\n"),
    attributes: [
      "attribute vec4 acceleration;",
      "attribute vec3 velocity;",
      "attribute vec4 rotation;",
      "attribute vec3 rotationCenter;",
      "attribute vec4 params;",
      "attribute vec4 size;",
      "attribute vec4 angle;",
      "attribute vec4 color;",
      "attribute vec4 opacity;",
    ].join("\n"),
    varyings: [
      "varying vec4 vColor;",
      "#ifdef SHOULD_ROTATE_TEXTURE",
      "    varying float vAngle;",
      "#endif",
      "#ifdef SHOULD_CALCULATE_SPRITE",
      "    varying vec4 vSpriteSheet;",
      "#endif",
    ].join("\n"),
    branchAvoidanceFunctions: [
      "float when_gt(float x, float y) {",
      "    return max(sign(x - y), 0.0);",
      "}",
      "float when_lt(float x, float y) {",
      "    return min( max(1.0 - sign(x - y), 0.0), 1.0 );",
      "}",
      "float when_eq( float x, float y ) {",
      "    return 1.0 - abs( sign( x - y ) );",
      "}",
      "float when_ge(float x, float y) {",
      "  return 1.0 - when_lt(x, y);",
      "}",
      "float when_le(float x, float y) {",
      "  return 1.0 - when_gt(x, y);",
      "}",
      "float and(float a, float b) {",
      "    return a * b;",
      "}",
      "float or(float a, float b) {",
      "    return min(a + b, 1.0);",
      "}",
    ].join("\n"),
    unpackColor: [
      "vec3 unpackColor( in float hex ) {",
      "   vec3 c = vec3( 0.0 );",
      "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );",
      "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );",
      "   float b = mod( hex, PACKED_COLOR_SIZE );",
      "   c.r = r / PACKED_COLOR_DIVISOR;",
      "   c.g = g / PACKED_COLOR_DIVISOR;",
      "   c.b = b / PACKED_COLOR_DIVISOR;",
      "   return c;",
      "}",
    ].join("\n"),
    unpackRotationAxis: [
      "vec3 unpackRotationAxis( in float hex ) {",
      "   vec3 c = vec3( 0.0 );",
      "   float r = mod( (hex / PACKED_COLOR_SIZE / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );",
      "   float g = mod( (hex / PACKED_COLOR_SIZE), PACKED_COLOR_SIZE );",
      "   float b = mod( hex, PACKED_COLOR_SIZE );",
      "   c.r = r / PACKED_COLOR_DIVISOR;",
      "   c.g = g / PACKED_COLOR_DIVISOR;",
      "   c.b = b / PACKED_COLOR_DIVISOR;",
      "   c *= vec3( 2.0 );",
      "   c -= vec3( 1.0 );",
      "   return c;",
      "}",
    ].join("\n"),
    floatOverLifetime: [
      "float getFloatOverLifetime( in float positionInTime, in vec4 attr ) {",
      "    highp float value = 0.0;",
      "    float deltaAge = positionInTime * float( VALUE_OVER_LIFETIME_LENGTH - 1 );",
      "    float fIndex = 0.0;",
      "    float shouldApplyValue = 0.0;",
      "    value += attr[ 0 ] * when_eq( deltaAge, 0.0 );",
      "",
      "    for( int i = 0; i < VALUE_OVER_LIFETIME_LENGTH - 1; ++i ) {",
      "       fIndex = float( i );",
      "       shouldApplyValue = and( when_gt( deltaAge, fIndex ), when_le( deltaAge, fIndex + 1.0 ) );",
      "       value += shouldApplyValue * mix( attr[ i ], attr[ i + 1 ], deltaAge - fIndex );",
      "    }",
      "",
      "    return value;",
      "}",
    ].join("\n"),
    colorOverLifetime: [
      "vec3 getColorOverLifetime( in float positionInTime, in vec3 color1, in vec3 color2, in vec3 color3, in vec3 color4 ) {",
      "    vec3 value = vec3( 0.0 );",
      "    value.x = getFloatOverLifetime( positionInTime, vec4( color1.x, color2.x, color3.x, color4.x ) );",
      "    value.y = getFloatOverLifetime( positionInTime, vec4( color1.y, color2.y, color3.y, color4.y ) );",
      "    value.z = getFloatOverLifetime( positionInTime, vec4( color1.z, color2.z, color3.z, color4.z ) );",
      "    return value;",
      "}",
    ].join("\n"),
    paramFetchingFunctions: [
      "float getAlive() {",
      "   return params.x;",
      "}",
      "float getAge() {",
      "   return params.y;",
      "}",
      "float getMaxAge() {",
      "   return params.z;",
      "}",
      "float getWiggle() {",
      "   return params.w;",
      "}",
    ].join("\n"),
    forceFetchingFunctions: [
      "vec4 getPosition( in float age ) {",
      "   return modelViewMatrix * vec4( position, 1.0 );",
      "}",
      "vec3 getVelocity( in float age ) {",
      "   return velocity * age;",
      "}",
      "vec3 getAcceleration( in float age ) {",
      "   return acceleration.xyz * age;",
      "}",
    ].join("\n"),
    rotationFunctions: [
      "#ifdef SHOULD_ROTATE_PARTICLES",
      "   mat4 getRotationMatrix( in vec3 axis, in float angle) {",
      "       axis = normalize(axis);",
      "       float s = sin(angle);",
      "       float c = cos(angle);",
      "       float oc = 1.0 - c;",
      "",
      "       return mat4(oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,",
      "                   oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,",
      "                   oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,",
      "                   0.0,                                0.0,                                0.0,                                1.0);",
      "   }",
      "",
      "   vec3 getRotation( in vec3 pos, in float positionInTime ) {",
      "      if( rotation.y == 0.0 ) {",
      "           return pos;",
      "      }",
      "",
      "      vec3 axis = unpackRotationAxis( rotation.x );",
      "      vec3 center = rotationCenter;",
      "      vec3 translated;",
      "      mat4 rotationMatrix;",
      "      float angle = 0.0;",
      "      angle += when_eq( rotation.z, 0.0 ) * rotation.y;",
      "      angle += when_gt( rotation.z, 0.0 ) * mix( 0.0, rotation.y, positionInTime );",
      "      translated = rotationCenter - pos;",
      "      rotationMatrix = getRotationMatrix( axis, angle );",
      "      return center - vec3( rotationMatrix * vec4( translated, 0.0 ) );",
      "   }",
      "#endif",
    ].join("\n"),
    rotateTexture: [
      "    vec2 vUv = vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y );",
      "",
      "    #ifdef SHOULD_ROTATE_TEXTURE",
      "       float x = gl_PointCoord.x - 0.5;",
      "       float y = 1.0 - gl_PointCoord.y - 0.5;",
      "       float c = cos( -vAngle );",
      "       float s = sin( -vAngle );",
      "       vUv = vec2( c * x + s * y + 0.5, c * y - s * x + 0.5 );",
      "    #endif",
      "",
      "    #ifdef SHOULD_CALCULATE_SPRITE",
      "        float framesX = vSpriteSheet.x;",
      "        float framesY = vSpriteSheet.y;",
      "        float columnNorm = vSpriteSheet.z;",
      "        float rowNorm = vSpriteSheet.w;",
      "        vUv.x = gl_PointCoord.x * framesX + columnNorm;",
      "        vUv.y = 1.0 - (gl_PointCoord.y * framesY + rowNorm);",
      "    #endif",
      "",
      "    vec4 rotatedTexture = texture2D( tex, vUv );",
    ].join("\n"),
  },
  ig = {
    vertex: [
      tg.defines,
      tg.uniforms,
      tg.attributes,
      tg.varyings,
      qn.common,
      qn.logdepthbuf_pars_vertex,
      qn.fog_pars_fragment,
      tg.branchAvoidanceFunctions,
      tg.unpackColor,
      tg.unpackRotationAxis,
      tg.floatOverLifetime,
      tg.colorOverLifetime,
      tg.paramFetchingFunctions,
      tg.forceFetchingFunctions,
      tg.rotationFunctions,
      "void main() {",
      "    highp float age = getAge();",
      "    highp float alive = getAlive();",
      "    highp float maxAge = getMaxAge();",
      "    highp float positionInTime = (age / maxAge);",
      "    highp float isAlive = when_gt( alive, 0.0 );",
      "    #ifdef SHOULD_WIGGLE_PARTICLES",
      "        float wiggleAmount = positionInTime * getWiggle();",
      "        float wiggleSin = isAlive * sin( wiggleAmount );",
      "        float wiggleCos = isAlive * cos( wiggleAmount );",
      "    #endif",
      "    vec3 vel = getVelocity( age );",
      "    vec3 accel = getAcceleration( age );",
      "    vec3 force = vec3( 0.0 );",
      "    vec3 pos = vec3( position );",
      "    float drag = 1.0 - (positionInTime * 0.5) * acceleration.w;",
      "    force += vel;",
      "    force *= drag;",
      "    force += accel * age;",
      "    pos += force;",
      "    #ifdef SHOULD_WIGGLE_PARTICLES",
      "        pos.x += wiggleSin;",
      "        pos.y += wiggleCos;",
      "        pos.z += wiggleSin;",
      "    #endif",
      "    #ifdef SHOULD_ROTATE_PARTICLES",
      "        pos = getRotation( pos, positionInTime );",
      "    #endif",
      "    vec4 mvPosition = modelViewMatrix * vec4( pos, 1.0 );",
      "    highp float pointSize = getFloatOverLifetime( positionInTime, size ) * isAlive;",
      "    #ifdef HAS_PERSPECTIVE",
      "        float perspective = scale / length( mvPosition.xyz );",
      "    #else",
      "        float perspective = 1.0;",
      "    #endif",
      "    float pointSizePerspective = pointSize * perspective;",
      "    #ifdef COLORIZE",
      "       vec3 c = isAlive * getColorOverLifetime(",
      "           positionInTime,",
      "           unpackColor( color.x ),",
      "           unpackColor( color.y ),",
      "           unpackColor( color.z ),",
      "           unpackColor( color.w )",
      "       );",
      "    #else",
      "       vec3 c = vec3(1.0);",
      "    #endif",
      "    float o = isAlive * getFloatOverLifetime( positionInTime, opacity );",
      "    vColor = vec4( c, o );",
      "    #ifdef SHOULD_ROTATE_TEXTURE",
      "        vAngle = isAlive * getFloatOverLifetime( positionInTime, angle );",
      "    #endif",
      "    #ifdef SHOULD_CALCULATE_SPRITE",
      "        float framesX = textureAnimation.x;",
      "        float framesY = textureAnimation.y;",
      "        float loopCount = textureAnimation.w;",
      "        float totalFrames = textureAnimation.z;",
      "        float frameNumber = mod( (positionInTime * loopCount) * totalFrames, totalFrames );",
      "        float column = floor(mod( frameNumber, framesX ));",
      "        float row = floor( (frameNumber - column) / framesX );",
      "        float columnNorm = column / framesX;",
      "        float rowNorm = row / framesY;",
      "        vSpriteSheet.x = 1.0 / framesX;",
      "        vSpriteSheet.y = 1.0 / framesY;",
      "        vSpriteSheet.z = columnNorm;",
      "        vSpriteSheet.w = rowNorm;",
      "    #endif",
      "    gl_PointSize = pointSizePerspective;",
      "    gl_Position = projectionMatrix * mvPosition;",
      qn.logdepthbuf_vertex,
      "}",
    ].join("\n"),
    fragment: [
      tg.uniforms,
      qn.common,
      qn.fog_pars_fragment,
      qn.logdepthbuf_pars_fragment,
      tg.varyings,
      tg.branchAvoidanceFunctions,
      "void main() {",
      "    vec3 outgoingLight = vColor.xyz;",
      "    ",
      "    #ifdef ALPHATEST",
      "       if ( vColor.w < float(ALPHATEST) ) discard;",
      "    #endif",
      tg.rotateTexture,
      qn.logdepthbuf_fragment,
      "    outgoingLight = vColor.xyz * rotatedTexture.xyz;",
      "    gl_FragColor = vec4( outgoingLight.xyz, rotatedTexture.w * vColor.w );",
      qn.fog_fragment,
      "}",
    ].join("\n"),
  },
  ng = (function () {
    function e(e) {
      var t = Km.types,
        i = Jm;
      for (var n in (((e = Km.ensureTypedArg(e, t.OBJECT, {})).position =
        Km.ensureTypedArg(e.position, t.OBJECT, {})),
      (e.velocity = Km.ensureTypedArg(e.velocity, t.OBJECT, {})),
      (e.acceleration = Km.ensureTypedArg(e.acceleration, t.OBJECT, {})),
      (e.radius = Km.ensureTypedArg(e.radius, t.OBJECT, {})),
      (e.drag = Km.ensureTypedArg(e.drag, t.OBJECT, {})),
      (e.rotation = Km.ensureTypedArg(e.rotation, t.OBJECT, {})),
      (e.color = Km.ensureTypedArg(e.color, t.OBJECT, {})),
      (e.opacity = Km.ensureTypedArg(e.opacity, t.OBJECT, {})),
      (e.size = Km.ensureTypedArg(e.size, t.OBJECT, {})),
      (e.angle = Km.ensureTypedArg(e.angle, t.OBJECT, {})),
      (e.wiggle = Km.ensureTypedArg(e.wiggle, t.OBJECT, {})),
      (e.maxAge = Km.ensureTypedArg(e.maxAge, t.OBJECT, {})),
      e.onParticleSpawn &&
        console.warn(
          "onParticleSpawn has been removed. Please set properties directly to alter values at runtime."
        ),
      (this.uuid = ze.generateUUID()),
      (this.type = Km.ensureTypedArg(e.type, t.NUMBER, Zm.BOX)),
      (this.position = {
        _value: Km.ensureInstanceOf(e.position.value, Vector3, new Vector3()),
        _spread: Km.ensureInstanceOf(e.position.spread, Vector3, new Vector3()),
        _spreadClamp: Km.ensureInstanceOf(
          e.position.spreadClamp,
          Vector3,
          new Vector3()
        ),
        _distribution: Km.ensureTypedArg(
          e.position.distribution,
          t.NUMBER,
          this.type
        ),
        _randomise: Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1),
        _radius: Km.ensureTypedArg(e.position.radius, t.NUMBER, 10),
        _radiusScale: Km.ensureInstanceOf(
          e.position.radiusScale,
          Vector3,
          new Vector3(1, 1, 1)
        ),
        _distributionClamp: Km.ensureTypedArg(
          e.position.distributionClamp,
          t.NUMBER,
          0
        ),
      }),
      (this.velocity = {
        _value: Km.ensureInstanceOf(e.velocity.value, Vector3, new Vector3()),
        _spread: Km.ensureInstanceOf(e.velocity.spread, Vector3, new Vector3()),
        _distribution: Km.ensureTypedArg(
          e.velocity.distribution,
          t.NUMBER,
          this.type
        ),
        _randomise: Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1),
      }),
      (this.acceleration = {
        _value: Km.ensureInstanceOf(
          e.acceleration.value,
          Vector3,
          new Vector3()
        ),
        _spread: Km.ensureInstanceOf(
          e.acceleration.spread,
          Vector3,
          new Vector3()
        ),
        _distribution: Km.ensureTypedArg(
          e.acceleration.distribution,
          t.NUMBER,
          this.type
        ),
        _randomise: Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1),
      }),
      (this.drag = {
        _value: Km.ensureTypedArg(e.drag.value, t.NUMBER, 0),
        _spread: Km.ensureTypedArg(e.drag.spread, t.NUMBER, 0),
        _randomise: Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1),
      }),
      (this.wiggle = {
        _value: Km.ensureTypedArg(e.wiggle.value, t.NUMBER, 0),
        _spread: Km.ensureTypedArg(e.wiggle.spread, t.NUMBER, 0),
      }),
      (this.rotation = {
        _axis: Km.ensureInstanceOf(
          e.rotation.axis,
          Vector3,
          new Vector3(0, 1, 0)
        ),
        _axisSpread: Km.ensureInstanceOf(
          e.rotation.axisSpread,
          Vector3,
          new Vector3()
        ),
        _angle: Km.ensureTypedArg(e.rotation.angle, t.NUMBER, 0),
        _angleSpread: Km.ensureTypedArg(e.rotation.angleSpread, t.NUMBER, 0),
        _static: Km.ensureTypedArg(e.rotation.static, t.BOOLEAN, !1),
        _center: Km.ensureInstanceOf(
          e.rotation.center,
          Vector3,
          this.position._value.clone()
        ),
        _randomise: Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1),
      }),
      (this.maxAge = {
        _value: Km.ensureTypedArg(e.maxAge.value, t.NUMBER, 2),
        _spread: Km.ensureTypedArg(e.maxAge.spread, t.NUMBER, 0),
      }),
      (this.color = {
        _value: Km.ensureArrayInstanceOf(e.color.value, Color, new Color()),
        _spread: Km.ensureArrayInstanceOf(
          e.color.spread,
          Vector3,
          new Vector3()
        ),
        _randomise: Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1),
      }),
      (this.opacity = {
        _value: Km.ensureArrayTypedArg(e.opacity.value, t.NUMBER, 1),
        _spread: Km.ensureArrayTypedArg(e.opacity.spread, t.NUMBER, 0),
        _randomise: Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1),
      }),
      (this.size = {
        _value: Km.ensureArrayTypedArg(e.size.value, t.NUMBER, 1),
        _spread: Km.ensureArrayTypedArg(e.size.spread, t.NUMBER, 0),
        _randomise: Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1),
      }),
      (this.angle = {
        _value: Km.ensureArrayTypedArg(e.angle.value, t.NUMBER, 0),
        _spread: Km.ensureArrayTypedArg(e.angle.spread, t.NUMBER, 0),
        _randomise: Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1),
      }),
      (this.particleCount = Km.ensureTypedArg(e.particleCount, t.NUMBER, 100)),
      (this.duration = Km.ensureTypedArg(e.duration, t.NUMBER, null)),
      (this.isStatic = Km.ensureTypedArg(e.isStatic, t.BOOLEAN, !1)),
      (this.activeMultiplier = Km.ensureTypedArg(
        e.activeMultiplier,
        t.NUMBER,
        1
      )),
      (this.direction = Km.ensureTypedArg(e.direction, t.NUMBER, 1)),
      (this.alive = Km.ensureTypedArg(e.alive, t.BOOLEAN, !0)),
      (this.particlesPerSecond = 0),
      (this.activationIndex = 0),
      (this.attributeOffset = 0),
      (this.attributeEnd = 0),
      (this.age = 0),
      (this.activeParticleCount = 0),
      (this.group = null),
      (this.attributes = null),
      (this.paramsArray = null),
      (this.resetFlags = {
        position:
          Km.ensureTypedArg(e.position.randomise, t.BOOLEAN, !1) ||
          Km.ensureTypedArg(e.radius.randomise, t.BOOLEAN, !1),
        velocity: Km.ensureTypedArg(e.velocity.randomise, t.BOOLEAN, !1),
        acceleration:
          Km.ensureTypedArg(e.acceleration.randomise, t.BOOLEAN, !1) ||
          Km.ensureTypedArg(e.drag.randomise, t.BOOLEAN, !1),
        rotation: Km.ensureTypedArg(e.rotation.randomise, t.BOOLEAN, !1),
        rotationCenter: Km.ensureTypedArg(e.rotation.randomise, t.BOOLEAN, !1),
        size: Km.ensureTypedArg(e.size.randomise, t.BOOLEAN, !1),
        color: Km.ensureTypedArg(e.color.randomise, t.BOOLEAN, !1),
        opacity: Km.ensureTypedArg(e.opacity.randomise, t.BOOLEAN, !1),
        angle: Km.ensureTypedArg(e.angle.randomise, t.BOOLEAN, !1),
      }),
      (this.updateFlags = {}),
      (this.updateCounts = {}),
      (this.updateMap = {
        maxAge: "params",
        position: "position",
        velocity: "velocity",
        acceleration: "acceleration",
        drag: "acceleration",
        wiggle: "params",
        rotation: "rotation",
        size: "size",
        color: "color",
        opacity: "opacity",
        angle: "angle",
      }),
      this.updateMap))
        this.updateMap.hasOwnProperty(n) &&
          ((this.updateCounts[this.updateMap[n]] = 0),
          (this.updateFlags[this.updateMap[n]] = !1),
          this._createGetterSetters(this[n], n));
      (this.bufferUpdateRanges = {}),
        (this.attributeKeys = null),
        (this.attributeCount = 0),
        Km.ensureValueOverLifetimeCompliance(this.color, i, i),
        Km.ensureValueOverLifetimeCompliance(this.opacity, i, i),
        Km.ensureValueOverLifetimeCompliance(this.size, i, i),
        Km.ensureValueOverLifetimeCompliance(this.angle, i, i);
    }
    var t = e.prototype;
    return (
      (t._createGetterSetters = function (e, t) {
        var i = this;
        Object.keys(e).forEach(function (n) {
          var s = n.replace("_", "");
          Object.defineProperty(e, s, {
            get: function () {
              return this[n];
            },
            set: function (e) {
              var s = i.updateMap[t],
                r = this[n],
                a = Jm;
              "_rotationCenter" === n
                ? ((i.updateFlags.rotationCenter = !0),
                  (this.updateCounts.rotationCenter = 0))
                : "_randomise" === n
                ? (i.resetFlags[s] = e)
                : ((i.updateFlags[s] = !0), (i.updateCounts[s] = 0)),
                i.group._updateDefines(),
                (this[n] = e),
                Array.isArray(r) &&
                  Km.ensureValueOverLifetimeCompliance(i[t], a, a);
            },
          });
        });
      }),
      (t._setBufferUpdateRanges = function (e) {
        (this.attributeKeys = e), (this.attributeCount = e.length);
        for (var t = this.attributeCount - 1; t >= 0; --t)
          this.bufferUpdateRanges[e[t]] = {
            min: Number.POSITIVE_INFINITY,
            max: Number.NEGATIVE_INFINITY,
          };
      }),
      (t._calculatePPSValue = function (e) {
        var t = this.particleCount;
        this.duration
          ? (this.particlesPerSecond =
              t / (e < this.duration ? e : this.duration))
          : (this.particlesPerSecond = t / e);
      }),
      (t._setAttributeOffset = function (e) {
        (this.attributeOffset = e),
          (this.activationIndex = e),
          (this.activationEnd = e + this.particleCount);
      }),
      (t._assignValue = function (e, t) {
        switch (e) {
          case "position":
            this._assignPositionValue(t);
            break;
          case "velocity":
          case "acceleration":
            this._assignForceValue(t, e);
            break;
          case "size":
          case "opacity":
            this._assignAbsLifetimeValue(t, e);
            break;
          case "angle":
            this._assignAngleValue(t);
            break;
          case "params":
            this._assignParamsValue(t);
            break;
          case "rotation":
            this._assignRotationValue(t);
            break;
          case "color":
            this._assignColorValue(t);
        }
      }),
      (t._assignPositionValue = function (e) {
        var t = Zm,
          i = this.position,
          n = this.attributes.position,
          s = i._value,
          r = i._spread;
        switch (i.distribution) {
          case t.BOX:
            Km.randomVector3(n, e, s, r, i._spreadClamp);
            break;
          case t.SPHERE:
            Km.randomVector3OnSphere(
              n,
              e,
              s,
              i._radius,
              i._spread.x,
              i._radiusScale,
              i._spreadClamp.x,
              i._distributionClamp || this.particleCount
            );
            break;
          case t.DISC:
            Km.randomVector3OnDisc(
              n,
              e,
              s,
              i._radius,
              i._spread.x,
              i._radiusScale,
              i._spreadClamp.x
            );
            break;
          case t.LINE:
            Km.randomVector3OnLine(n, e, s, r);
        }
      }),
      (t._assignForceValue = function (e, t) {
        var i,
          n,
          s,
          r,
          a,
          o = Zm,
          l = this[t],
          h = l._value,
          c = l._spread;
        switch (l._distribution) {
          case o.BOX:
            Km.randomVector3(this.attributes[t], e, h, c);
            break;
          case o.SPHERE:
            (n = (i = this.attributes.position.typedArray.array)[(a = 3 * e)]),
              (s = i[a + 1]),
              (r = i[a + 2]),
              Km.randomDirectionVector3OnSphere(
                this.attributes[t],
                e,
                n,
                s,
                r,
                this.position._value,
                l._value.x,
                l._spread.x
              );
            break;
          case o.DISC:
            (n = (i = this.attributes.position.typedArray.array)[(a = 3 * e)]),
              (s = i[a + 1]),
              (r = i[a + 2]),
              Km.randomDirectionVector3OnDisc(
                this.attributes[t],
                e,
                n,
                s,
                r,
                this.position._value,
                l._value.x,
                l._spread.x
              );
            break;
          case o.LINE:
            Km.randomVector3OnLine(this.attributes[t], e, h, c);
        }
        if ("acceleration" === t) {
          var u = Km.clamp(
            Km.randomFloat(this.drag._value, this.drag._spread),
            0,
            1
          );
          this.attributes.acceleration.typedArray.array[4 * e + 3] = u;
        }
      }),
      (t._assignAbsLifetimeValue = function (e, t) {
        var i,
          n = this.attributes[t].typedArray,
          s = this[t];
        Km.arrayValuesAreEqual(s._value) && Km.arrayValuesAreEqual(s._spread)
          ? ((i = Math.abs(Km.randomFloat(s._value[0], s._spread[0]))),
            n.setVec4Components(e, i, i, i, i))
          : n.setVec4Components(
              e,
              Math.abs(Km.randomFloat(s._value[0], s._spread[0])),
              Math.abs(Km.randomFloat(s._value[1], s._spread[1])),
              Math.abs(Km.randomFloat(s._value[2], s._spread[2])),
              Math.abs(Km.randomFloat(s._value[3], s._spread[3]))
            );
      }),
      (t._assignAngleValue = function (e) {
        var t,
          i = this.attributes.angle.typedArray,
          n = this.angle;
        Km.arrayValuesAreEqual(n._value) && Km.arrayValuesAreEqual(n._spread)
          ? ((t = Km.randomFloat(n._value[0], n._spread[0])),
            i.setVec4Components(e, t, t, t, t))
          : i.setVec4Components(
              e,
              Km.randomFloat(n._value[0], n._spread[0]),
              Km.randomFloat(n._value[1], n._spread[1]),
              Km.randomFloat(n._value[2], n._spread[2]),
              Km.randomFloat(n._value[3], n._spread[3])
            );
      }),
      (t._assignParamsValue = function (e) {
        this.attributes.params.typedArray.setVec4Components(
          e,
          this.isStatic ? 1 : 0,
          0,
          Math.abs(Km.randomFloat(this.maxAge._value, this.maxAge._spread)),
          Km.randomFloat(this.wiggle._value, this.wiggle._spread)
        );
      }),
      (t._assignRotationValue = function (e) {
        this.attributes.rotation.typedArray.setVec3Components(
          e,
          Km.getPackedRotationAxis(
            this.rotation._axis,
            this.rotation._axisSpread
          ),
          Km.randomFloat(this.rotation._angle, this.rotation._angleSpread),
          this.rotation._static ? 0 : 1
        ),
          this.attributes.rotationCenter.typedArray.setVec3(
            e,
            this.rotation._center
          );
      }),
      (t._assignColorValue = function (e) {
        Km.randomColorAsHex(
          this.attributes.color,
          e,
          this.color._value,
          this.color._spread
        );
      }),
      (t._resetParticle = function (e) {
        for (
          var t,
            i,
            n = this.resetFlags,
            s = this.updateFlags,
            r = this.updateCounts,
            a = this.attributeKeys,
            o = this.attributeCount - 1;
          o >= 0;
          --o
        )
          (i = s[(t = a[o])]),
            (!0 !== n[t] && !0 !== i) ||
              (this._assignValue(t, e),
              this._updateAttributeUpdateRange(t, e),
              !0 === i && r[t] === this.particleCount
                ? ((s[t] = !1), (r[t] = 0))
                : !0 === i && ++r[t]);
      }),
      (t._updateAttributeUpdateRange = function (e, t) {
        var i = this.bufferUpdateRanges[e];
        (i.min = Math.min(t, i.min)), (i.max = Math.max(t, i.max));
      }),
      (t._resetBufferRanges = function () {
        for (
          var e,
            t = this.bufferUpdateRanges,
            i = this.bufferUpdateKeys,
            n = this.bufferUpdateCount - 1;
          n >= 0;
          --n
        )
          (t[(e = i[n])].min = Number.POSITIVE_INFINITY),
            (t[e].max = Number.NEGATIVE_INFINITY);
      }),
      (t._onRemove = function () {
        (this.particlesPerSecond = 0),
          (this.attributeOffset = 0),
          (this.activationIndex = 0),
          (this.activeParticleCount = 0),
          (this.group = null),
          (this.attributes = null),
          (this.paramsArray = null),
          (this.age = 0);
      }),
      (t._decrementParticleCount = function () {
        --this.activeParticleCount;
      }),
      (t._incrementParticleCount = function () {
        ++this.activeParticleCount;
      }),
      (t._checkParticleAges = function (e, t, i, n) {
        for (var s, r, a, o, l = t - 1; l >= e; --l)
          0 !== (o = i[(s = 4 * l)]) &&
            ((a = i[s + 1]),
            (r = i[s + 2]),
            1 === this.direction
              ? (a += n) >= r &&
                ((a = 0), (o = 0), this._decrementParticleCount())
              : (a -= n) <= 0 &&
                ((a = r), (o = 0), this._decrementParticleCount()),
            (i[s] = o),
            (i[s + 1] = a),
            this._updateAttributeUpdateRange("params", l));
      }),
      (t._activateParticles = function (e, t, i, n) {
        for (var s, r, a = this.direction, o = e; o < t; ++o)
          (0 !== i[(s = 4 * o)] && 1 !== this.particleCount) ||
            (this._incrementParticleCount(),
            (i[s] = 1),
            this._resetParticle(o),
            (r = n * (o - e)),
            (i[s + 1] = -1 === a ? i[s + 2] - r : r),
            this._updateAttributeUpdateRange("params", o));
      }),
      (t.update = function (e) {
        if (!this.isStatic) {
          null === this.paramsArray &&
            (this.paramsArray = this.attributes.params.typedArray.array);
          var t = this.attributeOffset,
            i = t + this.particleCount,
            n = this.paramsArray,
            s = this.particlesPerSecond * this.activeMultiplier * e,
            r = this.activationIndex;
          if (
            (this._resetBufferRanges(),
            this._checkParticleAges(t, i, n, e),
            !1 !== this.alive)
          ) {
            if (null !== this.duration && this.age > this.duration)
              return (this.alive = !1), void (this.age = 0);
            var a = 1 === this.particleCount ? r : 0 | r,
              o = Math.min(a + s, this.activationEnd),
              l = (o - this.activationIndex) | 0,
              h = l > 0 ? e / l : 0;
            this._activateParticles(a, o, n, h),
              (this.activationIndex += s),
              this.activationIndex > i && (this.activationIndex = t),
              (this.age += e);
          } else this.age = 0;
        }
      }),
      (t.reset = function (e) {
        if (((this.age = 0), (this.alive = !1), !0 === e)) {
          for (
            var t,
              i = this.attributeOffset,
              n = i + this.particleCount,
              s = this.paramsArray,
              r = this.attributes.params.bufferAttribute,
              a = n - 1;
            a >= i;
            --a
          )
            (s[(t = 4 * a)] = 0), (s[t + 1] = 0);
          (r.updateRange.offset = 0),
            (r.updateRange.count = -1),
            (r.needsUpdate = !0);
        }
        return this;
      }),
      (t.enable = function () {
        return (this.alive = !0), this;
      }),
      (t.disable = function () {
        return (this.alive = !1), this;
      }),
      (t.remove = function () {
        return (
          null !== this.group
            ? this.group.removeEmitter(this)
            : console.error(
                "Emitter does not belong to a group, cannot remove."
              ),
          this
        );
      }),
      e
    );
  })(),
  sg = (function () {
    function e(e) {
      var t = Km.types;
      ((e = Km.ensureTypedArg(e, t.OBJECT, {})).texture = Km.ensureTypedArg(
        e.texture,
        t.OBJECT,
        {}
      )),
        (this.uuid = ze.generateUUID()),
        (this.fixedTimeStep = Km.ensureTypedArg(
          e.fixedTimeStep,
          t.NUMBER,
          0.0167
        )),
        (this.texture = e.texture.value || null),
        (this.textureFrames = e.texture.frames || new Vector2(1, 1)),
        (this.textureFrameCount = Km.ensureTypedArg(
          e.texture.frameCount,
          t.NUMBER,
          this.textureFrames.x * this.textureFrames.y
        )),
        (this.textureLoop = Km.ensureTypedArg(e.texture.loop, t.NUMBER, 1)),
        this.textureFrames.max(new Vector2(1, 1)),
        (this.hasPerspective = Km.ensureTypedArg(
          e.hasPerspective,
          t.BOOLEAN,
          !0
        )),
        (this.colorize = Km.ensureTypedArg(e.colorize, t.BOOLEAN, !0)),
        (this.maxParticleCount = Km.ensureTypedArg(
          e.maxParticleCount,
          t.NUMBER,
          null
        )),
        (this.blending = Km.ensureTypedArg(e.blending, t.NUMBER, 2)),
        (this.transparent = Km.ensureTypedArg(e.transparent, t.BOOLEAN, !0)),
        (this.alphaTest = parseFloat(
          Km.ensureTypedArg(e.alphaTest, t.NUMBER, 0)
        )),
        (this.depthWrite = Km.ensureTypedArg(e.depthWrite, t.BOOLEAN, !1)),
        (this.depthTest = Km.ensureTypedArg(e.depthTest, t.BOOLEAN, !0)),
        (this.fog = Km.ensureTypedArg(e.fog, t.BOOLEAN, !0)),
        (this.scale = Km.ensureTypedArg(e.scale, t.NUMBER, 300)),
        (this.emitters = []),
        (this.emitterIDs = []),
        (this._pool = []),
        (this._poolCreationSettings = null),
        (this._createNewWhenPoolEmpty = 0),
        (this._attributesNeedRefresh = !1),
        (this._attributesNeedDynamicReset = !1),
        (this.particleCount = 0),
        (this.uniforms = {
          tex: { type: "t", value: this.texture },
          textureAnimation: {
            type: "v4",
            value: new Vector4(
              this.textureFrames.x,
              this.textureFrames.y,
              this.textureFrameCount,
              Math.max(Math.abs(this.textureLoop), 1)
            ),
          },
          fogColor: { type: "c", value: this.fog ? new Color() : null },
          fogNear: { type: "f", value: 10 },
          fogFar: { type: "f", value: 200 },
          fogDensity: { type: "f", value: 0.5 },
          deltaTime: { type: "f", value: 0 },
          runTime: { type: "f", value: 0 },
          scale: { type: "f", value: this.scale },
        }),
        (this.defines = {
          HAS_PERSPECTIVE: this.hasPerspective,
          COLORIZE: this.colorize,
          VALUE_OVER_LIFETIME_LENGTH: Jm,
          SHOULD_ROTATE_TEXTURE: !1,
          SHOULD_ROTATE_PARTICLES: !1,
          SHOULD_WIGGLE_PARTICLES: !1,
          SHOULD_CALCULATE_SPRITE:
            this.textureFrames.x > 1 || this.textureFrames.y > 1,
        }),
        (this.attributes = {
          position: new eg("v3", !0),
          acceleration: new eg("v4", !0),
          velocity: new eg("v3", !0),
          rotation: new eg("v4", !0),
          rotationCenter: new eg("v3", !0),
          params: new eg("v4", !0),
          size: new eg("v4", !0),
          angle: new eg("v4", !0),
          color: new eg("v4", !0),
          opacity: new eg("v4", !0),
        }),
        (this.attributeKeys = Object.keys(this.attributes)),
        (this.attributeCount = this.attributeKeys.length),
        (this.material = new ShaderMaterial({
          uniforms: this.uniforms,
          vertexShader: ig.vertex,
          fragmentShader: ig.fragment,
          blending: this.blending,
          transparent: this.transparent,
          alphaTest: this.alphaTest,
          depthWrite: this.depthWrite,
          depthTest: this.depthTest,
          defines: this.defines,
          fog: this.fog,
        })),
        (this.geometry = new rn()),
        (this.mesh = new vo(this.geometry, this.material)),
        null === this.maxParticleCount &&
          console.warn(
            "Group: No maxParticleCount specified. Adding emitters after rendering will probably cause errors."
          );
    }
    var t = e.prototype;
    return (
      (t._updateDefines = function () {
        for (
          var e, t = this.emitters, i = this.defines, n = t.length - 1;
          n >= 0;
          --n
        )
          (e = t[n]),
            i.SHOULD_CALCULATE_SPRITE ||
              (i.SHOULD_ROTATE_TEXTURE =
                i.SHOULD_ROTATE_TEXTURE ||
                !!Math.max(
                  Math.max.apply(null, e.angle.value),
                  Math.max.apply(null, e.angle.spread)
                )),
            (i.SHOULD_ROTATE_PARTICLES =
              i.SHOULD_ROTATE_PARTICLES ||
              !!Math.max(e.rotation.angle, e.rotation.angleSpread)),
            (i.SHOULD_WIGGLE_PARTICLES =
              i.SHOULD_WIGGLE_PARTICLES ||
              !!Math.max(e.wiggle.value, e.wiggle.spread));
        this.material.needsUpdate = !0;
      }),
      (t._applyAttributesToGeometry = function () {
        var e,
          t,
          i = this.attributes,
          n = this.geometry,
          s = n.attributes;
        Object.keys(i).forEach(function (r) {
          (e = i[r]),
            (t = s[r])
              ? (t.array = e.typedArray.array)
              : n.setAttribute(r, e.bufferAttribute),
            (e.bufferAttribute.needsUpdate = !0);
        }),
          this.geometry.setDrawRange(0, this.particleCount);
      }),
      (t.addEmitter = function (e) {
        if (e instanceof ng != 0)
          if (this.emitterIDs.indexOf(e.uuid) > -1)
            console.error(
              "Emitter already exists in this group. Will not add again."
            );
          else {
            if (null === e.group) {
              var t = this.attributes,
                i = this.particleCount,
                n = i + e.particleCount;
              for (var s in ((this.particleCount = n),
              null !== this.maxParticleCount &&
                this.particleCount > this.maxParticleCount &&
                console.warn(
                  "Group: maxParticleCount exceeded. Requesting",
                  this.particleCount,
                  "particles, can support only",
                  this.maxParticleCount
                ),
              e._calculatePPSValue(e.maxAge._value + e.maxAge._spread),
              e._setBufferUpdateRanges(this.attributeKeys),
              e._setAttributeOffset(i),
              (e.group = this),
              (e.attributes = this.attributes),
              t))
                t.hasOwnProperty(s) &&
                  t[s]._createBufferAttribute(
                    null !== this.maxParticleCount
                      ? this.maxParticleCount
                      : this.particleCount
                  );
              for (var r = i; r < n; ++r)
                e._assignPositionValue(r),
                  e._assignForceValue(r, "velocity"),
                  e._assignForceValue(r, "acceleration"),
                  e._assignAbsLifetimeValue(r, "opacity"),
                  e._assignAbsLifetimeValue(r, "size"),
                  e._assignAngleValue(r),
                  e._assignRotationValue(r),
                  e._assignParamsValue(r),
                  e._assignColorValue(r);
              return (
                this._applyAttributesToGeometry(),
                this.emitters.push(e),
                this.emitterIDs.push(e.uuid),
                this._updateDefines(e),
                (this.material.needsUpdate = !0),
                (this.geometry.needsUpdate = !0),
                (this._attributesNeedRefresh = !0),
                this
              );
            }
            console.error(
              "Emitter already belongs to another group. Will not add to requested group."
            );
          }
        else
          console.error(
            "`emitter` argument must be instance of Emitter. Was provided with:",
            e
          );
      }),
      (t.removeEmitter = function (e) {
        var t = this.emitterIDs.indexOf(e, this.uuid);
        if (e instanceof ng != 0)
          if (-1 !== t) {
            for (
              var i = e.attributeOffset,
                n = i + e.particleCount,
                s = this.attributes.params.typedArray,
                r = i;
              r < n;
              ++r
            )
              (s.array[4 * r] = 0), (s.array[4 * r + 1] = 0);
            for (var a in (this.emitters.splice(t, 1),
            this.emitterIDs.splice(t, 1),
            this.attributes))
              this.attributes.hasOwnProperty(a) &&
                this.attributes[a].splice(i, n);
            (this.particleCount -= e.particleCount),
              e._onRemove(),
              (this._attributesNeedRefresh = !0);
          } else
            console.error(
              "Emitter does not exist in this group. Will not remove."
            );
        else
          console.error(
            "`emitter` argument must be instance of Emitter. Was provided with:",
            e
          );
      }),
      (t.getFromPool = function () {
        var e = this._pool,
          t = this._createNewWhenPoolEmpty;
        if (e.length) return e.pop();
        if (t) {
          var i = new ng(this._poolCreationSettings);
          return this.addEmitter(i), i;
        }
        return null;
      }),
      (t.releaseIntoPool = function (e) {
        if (e instanceof ng != 0) return e.reset(), this._pool.unshift(e), this;
        console.error("Argument is not instanceof Emitter:", e);
      }),
      (t.getPool = function () {
        return this._pool;
      }),
      (t.addPool = function (e, t, i) {
        var n;
        (this._poolCreationSettings = t), (this._createNewWhenPoolEmpty = !!i);
        for (var s = 0; s < e; ++s)
          (n = Array.isArray(t) ? new ng(t[s]) : new ng(t)),
            this.addEmitter(n),
            this.releaseIntoPool(n);
        return this;
      }),
      (t._triggerSingleEmitter = function (e) {
        var t = this.getFromPool(),
          i = this;
        if (null !== t)
          return (
            e instanceof Vector3 &&
              (t.position.value.copy(e), (t.position.value = t.position.value)),
            t.enable(),
            setTimeout(function () {
              t.disable(), i.releaseIntoPool(t);
            }, 1e3 * Math.max(t.duration, t.maxAge.value + t.maxAge.spread)),
            this
          );
        console.log("Group pool ran out.");
      }),
      (t.triggerPoolEmitter = function (e, t) {
        if ("number" == typeof e && e > 1)
          for (var i = 0; i < e; ++i) this._triggerSingleEmitter(t);
        else this._triggerSingleEmitter(t);
        return this;
      }),
      (t._updateUniforms = function (e) {
        (this.uniforms.runTime.value += e), (this.uniforms.deltaTime.value = e);
      }),
      (t._resetBufferRanges = function () {
        for (
          var e = this.attributeKeys,
            t = this.attributes,
            i = this.attributeCount - 1;
          i >= 0;
          --i
        )
          t[e[i]].resetUpdateRange();
      }),
      (t._updateBuffers = function (e) {
        for (
          var t,
            i,
            n,
            s = this.attributeKeys,
            r = this.attributes,
            a = e.bufferUpdateRanges,
            o = this.attributeCount - 1;
          o >= 0;
          --o
        )
          (i = a[(t = s[o])]),
            (n = r[t]).setUpdateRange(i.min, i.max),
            n.flagUpdate();
      }),
      (t.update = function (e) {
        var t,
          i = this.emitters,
          n = i.length,
          s = e || this.fixedTimeStep,
          r = this.attributeKeys,
          a = this.attributes;
        if (
          (this._updateUniforms(s),
          this._resetBufferRanges(),
          0 !== n ||
            !1 !== this._attributesNeedRefresh ||
            !1 !== this._attributesNeedDynamicReset)
        ) {
          for (var o, l = 0; l < n; ++l)
            (o = i[l]).update(s), this._updateBuffers(o);
          if (!0 === this._attributesNeedDynamicReset) {
            for (t = this.attributeCount - 1; t >= 0; --t)
              a[r[t]].resetDynamic();
            this._attributesNeedDynamicReset = !1;
          }
          if (!0 === this._attributesNeedRefresh) {
            for (t = this.attributeCount - 1; t >= 0; --t)
              a[r[t]].forceUpdateAll();
            (this._attributesNeedRefresh = !1),
              (this._attributesNeedDynamicReset = !0);
          }
        }
      }),
      (t.dispose = function () {
        return this.geometry.dispose(), this.material.dispose(), this;
      }),
      e
    );
  })();
class rg extends Object3D {
  constructor(e, t) {
    super(),
      publicField(this, "update", () => {
        this._system.update(this._clock.getDelta());
      }),
      publicField(this, "createSnow", () =>
        new yl().load(Hm("assets/textures/sky/others/snow.png"))
      ),
      publicField(
        this,
        "createEmitter",
        () =>
          new ng({
            maxAge: { value: 10 },
            position: {
              value: new Vector3(0, 100, 150),
              spread: new Vector3(1e3, 1e3, 500),
            },
            acceleration: {
              value: new Vector3(0, 0, -10),
              spread: new Vector3(3, 3, 0),
            },
            velocity: {
              value: new Vector3(0, 0, -10),
              spread: new Vector3(5, 5, 0),
            },
            size: { value: 10 },
            particleCount: 1e4,
          })
      ),
      (this._renderer = e),
      (this._camera = t),
      (this._clock = new Ul());
    const i = (this._system = new sg({
        texture: { value: this.createSnow() },
        maxParticleCount: 1e4,
      })),
      n = (this._emitter = this.createEmitter(t, e));
    i.addEmitter(n), this.add(i.mesh);
  }
  dispose() {}
}
class ag extends Object3D {
  constructor(e, t) {
    super(),
      publicField(this, "update", () => {
        this._system.update(this._clock.getDelta());
      }),
      publicField(this, "createRain", () =>
        new yl().load(Hm("assets/textures/sky/others/trace_01.png"))
      ),
      publicField(
        this,
        "createEmitter",
        () =>
          new ng({
            maxAge: { value: 10 },
            position: {
              value: new Vector3(0, 100, 250),
              spread: new Vector3(1e3, 1e3, 500),
            },
            acceleration: {
              value: new Vector3(0, 0, -50),
              spread: new Vector3(3, 3, 0),
            },
            velocity: {
              value: new Vector3(0, 10, -50),
              spread: new Vector3(3, 3, 0),
            },
            size: { value: 60 },
            particleCount: 2e4,
          })
      ),
      (this._clock = new Ul());
    const i = (this._system = new sg({
        texture: { value: this.createRain() },
        maxParticleCount: 2e4,
      })),
      n = (this._emitter = this.createEmitter(t, e));
    i.addEmitter(n), this.add(i.mesh);
  }
  dispose() {}
}
class og extends Object3D {
  constructor(e) {
    super(),
      publicField(this, "_engine"),
      publicField(this, "_sky"),
      publicField(this, "_snow"),
      publicField(this, "_rain"),
      publicField(this, "_weather", ""),
      publicField(this, "_currentConverageTextureType", null),
      publicField(this, "_tCoverageIntensity", null),
      publicField(this, "_skyGroundColorBlue", new Color(1657983)),
      publicField(this, "_skyGroundColorGray", new Color(11184810)),
      publicField(this, "_weatherChangedListeners", []),
      publicField(this, "_sunLightScale", 0.5),
      publicField(this, "_skyLightScale", 1),
      publicField(this, "transitionDuration", 1e3),
      publicField(this, "_transitionStartTime", 0),
      publicField(this, "_transitionStartState", {}),
      publicField(this, "_transitionEndState", {}),
      publicField(this, "_inTransition", !1),
      publicField(this, "_modifyCount", 0),
      publicField(this, "handleBeforeRender", (e) => {
        if (this._snow) {
          const e = this._engine.camera.position;
          this._snow.position.copy(e), this._snow.update();
        }
        if (this._rain) {
          const e = this._engine.camera.position;
          this._rain.position.copy(e), this._rain.update();
        }
        if (
          (this._modifyCount > 0 &&
            ((this._modifyCount = 0),
            (this._transitionStartTime = Date.now()),
            (this._inTransition = !0),
            (this._transitionStartState = {
              sunIntensityScale:
                this._sky.sunIntensityScale / this._sunLightScale,
              cloudIntensity: this._sky.cloudIntensity,
              skyLightIntensity:
                this._sky.skyLightIntensity / this._skyLightScale,
              coverageIntensity:
                this._engine.rendering.composition.coverageIntensity,
              fogDensity: this._engine.rendering.fog.density,
              mixGrayFactor: this._sky.mixGrayFactor,
            })),
          this._inTransition)
        ) {
          const t =
            (Date.now() - this._transitionStartTime) / this.transitionDuration;
          t > 1 && (this._inTransition = !1),
            this._updateWeatherTransitionState(t),
            e.requestRender();
        }
      }),
      publicField(this, "_updateWeatherTransitionState", (e) => {
        e < 0 && (e = 0), e > 1 && (e = 1);
        const t = this._transitionStartState,
          i = this._transitionEndState;
        (this._sky.sunIntensityScale =
          ze.lerp(t.sunIntensityScale, i.sunIntensityScale, e) *
          this._sunLightScale),
          (this._sky.skyLightIntensity =
            ze.lerp(t.skyLightIntensity, i.skyLightIntensity, e) *
            this._skyLightScale),
          (this._sky.cloudIntensity = ze.lerp(
            t.cloudIntensity,
            i.cloudIntensity,
            e
          )),
          (this._engine.rendering.fog.density = ze.lerp(
            t.fogDensity,
            i.fogDensity,
            e
          )),
          (this._sky.mixGrayFactor = ze.lerp(
            t.mixGrayFactor,
            i.mixGrayFactor,
            e
          )),
          (this._engine.rendering.composition.coverageIntensity = ze.lerp(
            t.coverageIntensity,
            i.coverageIntensity,
            e
          ));
      }),
      publicField(this, "beforeRemoveFromEngine", (e) => {
        (this._sky.sunIntensityScale = 1),
          (this._sky.skyLightIntensity = 0.5),
          (this._sky.cloudIntensity = 0.2),
          (this._sky.mixGrayFactor = 0),
          (this._engine.rendering.fog.density = 0),
          (this._engine.rendering.composition.coverageIntensity = 0),
          e.removePrepareRenderListener(this.handleBeforeRender);
      }),
      (this._sky = e);
  }
  get weather() {
    return this._weather;
  }
  set weather(e) {
    if (e && e !== this._weather) {
      (this._weather = e), this.updateWeather(e);
      for (const t of this._weatherChangedListeners) t(e);
    }
  }
  afterAddToEngine(e) {
    (this._engine = e),
      e.addPrepareRenderListener(this.handleBeforeRender),
      this.updateWeather(this._weather);
  }
  getCoverageTexture(e) {
    if (
      null === this._tCoverageIntensity ||
      e !== this._currentConverageTextureType
    ) {
      this._tCoverageIntensity && this._tCoverageIntensity.dispose();
      let t =
        "assets/textures/realistic/TexturesCom_Snow_Plain_3x3_512_noise.jpg";
      "rain" === e &&
        (t =
          "assets/textures/realistic/TexturesCom_Ground_MudWet_512_roughness.jpg"),
        (this._tCoverageIntensity = new yl().load(Hm(t), () => {
          this._engine.requestRender();
        }));
    }
    return this._tCoverageIntensity;
  }
  updateWeather(e) {
    const t = this._engine;
    let i = 1,
      n = 0.2,
      s = 0.5,
      r = 0,
      a = null,
      o = 0,
      l = 0,
      h = !1,
      c = !1;
    if (
      ((this._transitionStartState = {
        sunIntensityScale: this._sky.sunIntensityScale / this._sunLightScale,
        cloudIntensity: this._sky.cloudIntensity,
        skyLightIntensity: this._sky.skyLightIntensity / this._skyLightScale,
        coverageIntensity: this._engine.rendering.composition.coverageIntensity,
        fogDensity: this._engine.rendering.fog.density,
        mixGrayFactor: this._sky.mixGrayFactor,
      }),
      (this._transitionEndState = this._transitionStartState),
      "clear" === e)
    )
      (i = 1.5), (n = 0), (s = 0.8), (o = 0), (l = 0.1);
    else if ("partlyCloudy" === e)
      (i = 1.3), (n = 0.7), (s = 0.9), (o = 0.05), (l = 0.2);
    else if ("cloudy" === e) (i = 0), (n = 1.2), (s = 1), (o = 0.5), (l = 0.3);
    else if ("overcast" === e)
      (i = 0), (n = 1.8), (s = 0.4), (o = 0.75), (l = 0.4);
    else if ("foggy" === e) (i = 0), (n = 0), (s = 0.4), (o = 1), (l = 1);
    else if ("rainy" === e)
      (i = 0), (n = 0), (s = 0.4), (c = !0), (o = 1), (l = 0.5);
    else {
      if ("snowy" !== e) return;
      (i = 0),
        (n = 0),
        (s = 0.4),
        (r = 1),
        (a = this.getCoverageTexture("snow")),
        (h = !0),
        (o = 1),
        (l = 0.5);
    }
    if (
      ((this._transitionEndState = {
        sunIntensityScale: i,
        cloudIntensity: n,
        skyLightIntensity: s,
        coverageIntensity: r,
        fogDensity: l,
        mixGrayFactor: o,
      }),
      (this.tCoverageIntensity = a),
      this._sky.isStaticSky &&
        (["overcast", "foggy", "rainy", "snowy"].includes(e)
          ? (this._sky.weather = "overcast")
          : (this._sky.weather = e)),
      h)
    ) {
      if (!this._snow) {
        const e = (this._snow = new rg(t.renderer, t.camera));
        this.add(e);
      }
    } else
      this._snow &&
        (this.remove(this._snow), this._snow.dispose(), (this._snow = null));
    if (c) {
      if (!this._rain) {
        const e = (this._rain = new ag(t.renderer, t.camera));
        this.add(e);
      }
    } else
      this._rain &&
        (this.remove(this._rain), this._rain.dispose(), (this._rain = null));
    this.transitionDuration <= 0
      ? this._updateWeatherTransitionState(1)
      : ((this._transitionStartTime = Date.now()),
        (this._inTransition = !0),
        t.requestRender());
  }
  addWeatherChangedListener(e) {
    -1 === this._weatherChangedListeners.indexOf(e) &&
      this._weatherChangedListeners.push(e);
  }
  removeWeatherChangedListener(e) {
    const t = this._weatherChangedListeners.indexOf(e);
    -1 !== t && this._weatherChangedListeners.splice(t, 1);
  }
  get sunIntensityScale() {
    return this._transitionEndState.sunIntensityScale;
  }
  set sunIntensityScale(e) {
    this._modifyCount++, (this._transitionEndState.sunIntensityScale = e);
  }
  get cloudIntensity() {
    return this._transitionEndState.cloudIntensity;
  }
  set cloudIntensity(e) {
    this._modifyCount++, (this._transitionEndState.cloudIntensity = e);
  }
  get skyLightIntensity() {
    return this._transitionEndState.skyLightIntensity;
  }
  set skyLightIntensity(e) {
    this._modifyCount++, (this._transitionEndState.skyLightIntensity = e);
  }
  get groundColor() {
    return this._sky.groundColor;
  }
  set groundColor(e) {
    this._sky.groundColor = e;
  }
  get mixGrayFactor() {
    return this._transitionEndState.mixGrayFactor;
  }
  set mixGrayFactor(e) {
    this._modifyCount++, (this._transitionEndState.mixGrayFactor = e);
  }
  get coverageIntensity() {
    return this._transitionEndState.coverageIntensity;
  }
  set coverageIntensity(e) {
    this._modifyCount++, (this._transitionEndState.coverageIntensity = e);
  }
  get tCoverageIntensity() {
    return this._engine.rendering.composition.tCoverageIntensity;
  }
  set tCoverageIntensity(e) {
    this._engine.rendering.composition.tCoverageIntensity = e;
  }
  get tRelectionEnhancement() {
    return this._engine.rendering.ssr.tEnhancement;
  }
  set tRelectionEnhancement(e) {
    this._engine.rendering.ssr.tEnhancement = e;
  }
  set fogDensity(e) {
    this._modifyCount++, (this._transitionEndState.fogDensity = e);
  }
  get fogDensity() {
    return this._transitionEndState.fogDensity;
  }
  get skyLightScale() {
    return this._skyLightScale;
  }
  set skyLightScale(e) {
    this._skyLightScale = e;
  }
  get sunLightScale() {
    return this._sunLightScale;
  }
  set sunLightScale(e) {
    this._sunLightScale = e;
  }
}
class lg {
  constructor(e) {
    publicField(this, "_lastTextureRequirementsKey", -1),
      publicField(this, "_inited", !1),
      publicField(this, "_useFastEmissiveMethod", !0),
      (this._rendering = e);
  }
  beginFrame() {
    if (!this._inited) return this._init(), void (this._inited = !0);
    this._rendering.main.requirements.isTextureRequirementsChanged() &&
      this._onTextureRequirementsChanged();
  }
  updateRenderTargetSamples(e) {}
  _onTextureRequirementsChanged() {
    this.dispose(), this._init();
  }
  _init() {}
  render() {}
  endFrame() {}
  dispose() {}
  get useFastEmissiveMethod() {
    return this._useFastEmissiveMethod;
  }
  set useFastEmissiveMethod(e) {
    this._useFastEmissiveMethod = e;
  }
}
const hg = {
    name: "CopyShader",
    uniforms: { tDiffuse: { value: null }, opacity: { value: 1 } },
    vertexShader:
      "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader:
      "\n\n\t\tuniform float opacity;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\t\t\tgl_FragColor = opacity * texel;\n\n\n\t\t}",
  },
  cg = {
    name: "GammaCorrectionShader",
    uniforms: { tDiffuse: { value: null } },
    vertexShader:
      "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader:
      "\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 tex = texture2D( tDiffuse, vUv );\n\n\t\t\tgl_FragColor = LinearTosRGB( tex );\n\n\t\t}",
  };
class ug {
  constructor() {
    (this.isPass = !0),
      (this.enabled = !0),
      (this.needsSwap = !0),
      (this.clear = !1),
      (this.renderToScreen = !1);
  }
  setSize() {}
  render() {
    console.error("THREE.Pass: .render() must be implemented in derived pass.");
  }
  dispose() {}
}
const dg = new ns(-1, 1, 1, -1, 0, 1),
  pg = new rn();
pg.setAttribute("position", new Ki([-1, 3, 0, -1, -1, 0, 3, -1, 0], 3)),
  pg.setAttribute("uv", new Ki([0, 2, 0, 0, 2, 0], 2));
class fg {
  constructor(e) {
    this._mesh = new En(pg, e);
  }
  dispose() {
    this._mesh.geometry.dispose();
  }
  render(e) {
    e.render(this._mesh, dg);
  }
  get material() {
    return this._mesh.material;
  }
  set material(e) {
    this._mesh.material = e;
  }
}
class mg extends lg {
  _init() {
    this._rendering.main, this._onTextureRequirementsChanged();
  }
  beginFrame() {
    if (!this._inited) return this._init(), void (this._inited = !0);
    this._rendering.main.requirements.isTextureRequirementsChanged() &&
      this._onTextureRequirementsChanged();
  }
  _onTextureRequirementsChanged() {
    const e = this._rendering,
      t = e.resolution,
      i = e.pixelRatio;
    e.main.requirements.needsEmissiveTexture
      ? (this._emissiveRenderTarget = new ut(t.x * i, t.y * i))
      : this._disposeEmissiveRenderTarget();
  }
  render() {
    const e = this._rendering,
      t = e.stats,
      i = e.main,
      n = e.renderer,
      s = e.camera,
      r = e.scene,
      a = i.requirements;
    if (((n.extraProgramCacheKey = ""), this.renderTarget)) {
      if (!this._sceneRenderTarget) {
        const t = e.resolution,
          i = e.pixelRatio,
          n = (this._tDepth = new xa());
        a.enableStencilBuffer && ((n.format = j), (n.type = V)),
          (this._sceneRenderTarget = new ut(t.x * i, t.y * i)),
          (this._sceneRenderTarget.depthTexture = n);
        const s = e.main.features.antialias;
        this._sceneRenderTarget.samples =
          s.enabled && "msaa" === s.method ? 4 : 0;
      }
      n.setRenderTarget(this._sceneRenderTarget);
    } else
      n.setRenderTarget(null),
        this._sceneRenderTarget &&
          (this._sceneRenderTarget.dispose(), (this._sceneRenderTarget = null));
    if (
      (t.beginTimeStatsItem("renderScene"),
      n.render(r, s),
      t.endTimeStatsItem("renderScene"),
      this.renderTarget)
    ) {
      this._fsQuad ||
        (this._fsQuad = new fg(
          new ShaderMaterial({
            name: hg.name,
            vertexShader: hg.vertexShader,
            fragmentShader: hg.fragmentShader,
            uniforms: {
              tDiffuse: { value: this._sceneRenderTarget.texture },
              opacity: { value: 1 },
            },
          })
        ));
      const e = this._fsQuad.material;
      n.outputColorSpace === me
        ? e.name === hg.name &&
          ((e.name = cg.name),
          (e.vertexShader = cg.vertexShader),
          (e.fragmentShader = cg.fragmentShader),
          (e.needsUpdate = !0))
        : e.name === cg.name &&
          ((e.name = hg.name),
          (e.vertexShader = hg.vertexShader),
          (e.fragmentShader = hg.fragmentShader),
          (e.needsUpdate = !0)),
        n.setRenderTarget(this.renderTarget),
        this._fsQuad.render(n);
    } else this._fsQuad && (this._fsQuad.dispose(), (this._fsQuad = null));
    if (a.needsEmissiveTexture) {
      n.extraProgramCacheKey = "emissive";
      const e = new Set(),
        i = new Set();
      let a = null;
      r.traverseVisible((t) => {
        if (((a = t.material), a)) {
          if (this._useFastEmissiveMethod && !this._isEmissiveMaterial(a))
            return (t.visible = !1), void e.add(t);
          a.defines || (a.defines = {}),
            (a.defines.MVT_MODE_EMISSIVE = !0),
            i.add(t);
        }
      }),
        this._useFastEmissiveMethod
          ? (this._emissiveRenderTarget.depthTexture =
              this._sceneRenderTarget.depthTexture)
          : this._emissiveRenderTarget.depthTexture &&
            (this._emissiveRenderTarget.depthTexture = null),
        t.beginTimeStatsItem("renderEmissiveTexture"),
        n.setRenderTarget(this._emissiveRenderTarget);
      const o = n.autoClear;
      this._useFastEmissiveMethod && ((n.autoClear = !1), n.clear(!0, !1, !0));
      const l = r.background;
      (r.background = null),
        n.render(r, s),
        (r.background = l),
        (n.autoClear = o),
        t.endTimeStatsItem("renderEmissiveTexture");
      for (const t of i) t.material.defines.MVT_MODE_EMISSIVE = !1;
      if (this._useFastEmissiveMethod) for (const t of e) t.visible = !0;
      n.extraProgramCacheKey = "";
    }
  }
  updateRenderTargetSamples(e) {
    const t = this._sceneRenderTarget;
    t && (t.samples = e);
  }
  _isBlackColor(e) {
    return 0 === e.r && 0 === e.g && 0 === e.b;
  }
  _isEmissiveMaterial(e) {
    return (
      !e.disableEmissive &&
      (!(!e.isShaderMaterial && !e.isRawShaderMaterial) ||
        (e.isMeshBasicMaterial
          ? e.emissive && !this._isBlackColor(e.emissive)
          : e.isMeshStandardMaterial ||
            e.isMeshPhongMaterial ||
            e.isMeshLambertMaterial ||
            e.isMeshToonMaterial
          ? (e.emissive && !this._isBlackColor(e.emissive)) || !!e.emissiveMap
          : void 0))
    );
  }
  _disposeEmissiveRenderTarget() {
    this._emissiveRenderTarget &&
      (this._sceneRenderTarget &&
        this._emissiveRenderTarget.depthTexture ===
          this._sceneRenderTarget.depthTexture &&
        (this._emissiveRenderTarget.depthTexture = null),
      this._emissiveRenderTarget.dispose(),
      (this._emissiveRenderTarget = null));
  }
  dispose() {
    const e = this._rendering.stats;
    e.removeTimeStatsItem("renderScene"),
      e.removeTimeStatsItem("renderEmissiveTexture"),
      this._disposeEmissiveRenderTarget(),
      this._fsQuad && (this._fsQuad.dispose(), (this._fsQuad = null));
  }
  get emissiveTexture() {
    return this._emissiveRenderTarget && this._emissiveRenderTarget.texture;
  }
  get depthTexture() {
    return this._sceneRenderTarget && this._sceneRenderTarget.depthTexture;
  }
  get diffuseTexture() {
    return this._sceneRenderTarget && this._sceneRenderTarget.texture;
  }
}
class gg extends lg {
  _init() {
    const e = this._rendering,
      t = e.resolution,
      i = e.main.requirements;
    let n = 1,
      s = {},
      r = "";
    i.needsEmissiveTexture &&
      ((s.emissive = n), (r += `#define MVT_MRT_OUT_EMISSIVE ${n}\n`), n++),
      i.needsNormalTexture &&
        ((s.normal = n), (r += `#define MVT_MRT_OUT_NORMAL ${n}\n`), n++),
      i.needsMetallicRoughTexture &&
        ((s.metallicRough = n),
        (r += `#define MVT_MRT_OUT_METALLICROUGH ${n}\n`),
        n++),
      (this._textureChannelNameMap = s),
      (r += "#include <mvt_mrt_output_pars_fragment>\n"),
      (this._fragBeforeMainStart = r),
      (this._fragBeforeMainEnd = "#include <mvt_mrt_output_fragment>\n");
    const a = e.main.features.antialias,
      o = (this._mainMrt = new ft(t.x * e.pixelRatio, t.y * e.pixelRatio, n, {
        samples: a.enabled && "msaa" === a.method ? 4 : 0,
      })),
      l = (this._tDepth = new xa());
    i.enableStencilBuffer &&
      ((l.format = j), (l.type = V), (o.stencilBuffer = !0)),
      (o.depthTexture = l),
      (o.depthBuffer = !0);
    for (let h = 0, c = o.texture.length; h < c; h++)
      (o.texture[h].minFilter = R),
        (o.texture[h].magFilter = R),
        (o.texture[h].format = Q);
    (o.texture.isTexture = !0),
      this._fsQuad ||
        (this._fsQuad = new fg(
          new ShaderMaterial({
            name: hg.name,
            vertexShader: hg.vertexShader,
            fragmentShader: hg.fragmentShader,
            uniforms: {
              tDiffuse: { value: o.texture[0] },
              opacity: { value: 1 },
            },
          })
        ));
  }
  render() {
    const e = this._rendering,
      t = e.stats,
      i = e.renderer,
      n = e.main.requirements;
    (i.extraProgramCacheKey = "mrt-" + n.currentTextureRequirementsKey),
      i.setRenderTarget(this._mainMrt),
      t.beginTimeStatsItem("renderMRTScene"),
      i.render(e.scene, e.camera),
      t.endTimeStatsItem("renderMRTScene"),
      (i.extraProgramCacheKey = "");
    const s = this._fsQuad.material;
    i.outputColorSpace === me
      ? s.name === hg.name &&
        ((s.name = cg.name),
        (s.vertexShader = cg.vertexShader),
        (s.fragmentShader = cg.fragmentShader),
        (s.needsUpdate = !0))
      : s.name === cg.name &&
        ((s.name = hg.name),
        (s.vertexShader = hg.vertexShader),
        (s.fragmentShader = hg.fragmentShader),
        (s.needsUpdate = !0)),
      i.setRenderTarget(this.renderTarget),
      this._fsQuad.render(i);
  }
  updateRenderTargetSamples(e) {
    this._mainMrt.samples = e;
  }
  modifyFragmentShader(e) {
    return Nm(e, this._fragBeforeMainStart, null, this._fragBeforeMainEnd);
  }
  dispose() {
    this._rendering.stats.removeTimeStatsItem("renderMRTScene"),
      this._tDepth && (this._tDepth.dispose(), (this._tDepth = null)),
      this._mainMrt && (this._mainMrt.dispose(), (this._mainMrt = null)),
      this._fsQuad && (this._fsQuad.dispose(), (this._fsQuad = null));
  }
  get emissiveTexture() {
    return (
      this._mainMrt &&
      this._mainMrt.texture[this._textureChannelNameMap.emissive]
    );
  }
  get normalTexture() {
    return (
      this._mainMrt && this._mainMrt.texture[this._textureChannelNameMap.normal]
    );
  }
  get metallicRoughTexture() {
    return (
      this._mainMrt &&
      this._mainMrt.texture[this._textureChannelNameMap.metallicRough]
    );
  }
  get depthTexture() {
    return this._tDepth;
  }
  get diffuseTexture() {
    return this._mainMrt && this._mainMrt.texture[0];
  }
}
class _g {
  constructor(e) {
    publicField(this, "needsEmissiveTexture", !1),
      publicField(this, "needsNormalTexture", !1),
      publicField(this, "needsDepthTexture", !1),
      publicField(this, "needsMetallicRoughTexture", !1),
      publicField(this, "enableStencilBuffer", !1),
      publicField(this, "_lastTextureRequirementsKey", -1),
      publicField(this, "_currentTextureRequirementsKey", -1),
      (this._rendering = e),
      (this._renderingMain = e.main);
  }
  beginFrame() {
    this._resetTextureRequirements(),
      this._updateRequirements(),
      (this._currentTextureRequirementsKey =
        this._updateTextureRequirementsKey());
  }
  _updateRequirements() {
    const e = this._renderingMain,
      t = e.features,
      i = e.postprocessings;
    t.updateReqirements(this), i.updateReqirements(this);
  }
  _resetTextureRequirements() {
    (this.needsEmissiveTexture = !1),
      (this.needsNormalTexture = !1),
      (this.needsDepthTexture = !1),
      (this.needsMetallicRoughTexture = !1),
      (this.enableStencilBuffer = !1);
  }
  _updateTextureRequirementsKey() {
    let e = 0;
    return (
      this.needsEmissiveTexture && (e |= 1),
      this.needsNormalTexture && (e |= 2),
      this.needsDepthTexture && (e |= 4),
      this.needsMetallicRoughTexture && (e |= 8),
      this.enableStencilBuffer && (e |= 16),
      e
    );
  }
  isTextureRequirementsChanged() {
    return (
      this._lastTextureRequirementsKey !== this._currentTextureRequirementsKey
    );
  }
  endFrame() {
    this._lastTextureRequirementsKey = this._currentTextureRequirementsKey;
  }
  get currentTextureRequirementsKey() {
    return this._currentTextureRequirementsKey;
  }
}
class vg extends ug {
  constructor(e, t) {
    super(),
      (this.textureID = void 0 !== t ? t : "tDiffuse"),
      e instanceof ShaderMaterial
        ? ((this.uniforms = e.uniforms), (this.material = e))
        : e &&
          ((this.uniforms = In.clone(e.uniforms)),
          (this.material = new ShaderMaterial({
            name: void 0 !== e.name ? e.name : "unspecified",
            defines: Object.assign({}, e.defines),
            uniforms: this.uniforms,
            vertexShader: e.vertexShader,
            fragmentShader: e.fragmentShader,
          }))),
      (this.fsQuad = new fg(this.material));
  }
  render(e, t, i) {
    this.uniforms[this.textureID] &&
      (this.uniforms[this.textureID].value = i.texture),
      (this.fsQuad.material = this.material),
      this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(t),
          this.clear &&
            e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
          this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class Ag extends ug {
  constructor(e, t) {
    super(),
      (this.scene = e),
      (this.camera = t),
      (this.clear = !0),
      (this.needsSwap = !1),
      (this.inverse = !1);
  }
  render(e, t, i) {
    const n = e.getContext(),
      s = e.state;
    let r, a;
    s.buffers.color.setMask(!1),
      s.buffers.depth.setMask(!1),
      s.buffers.color.setLocked(!0),
      s.buffers.depth.setLocked(!0),
      this.inverse ? ((r = 0), (a = 1)) : ((r = 1), (a = 0)),
      s.buffers.stencil.setTest(!0),
      s.buffers.stencil.setOp(n.REPLACE, n.REPLACE, n.REPLACE),
      s.buffers.stencil.setFunc(n.ALWAYS, r, 4294967295),
      s.buffers.stencil.setClear(a),
      s.buffers.stencil.setLocked(!0),
      e.setRenderTarget(i),
      this.clear && e.clear(),
      e.render(this.scene, this.camera),
      e.setRenderTarget(t),
      this.clear && e.clear(),
      e.render(this.scene, this.camera),
      s.buffers.color.setLocked(!1),
      s.buffers.depth.setLocked(!1),
      s.buffers.color.setMask(!0),
      s.buffers.depth.setMask(!0),
      s.buffers.stencil.setLocked(!1),
      s.buffers.stencil.setFunc(n.EQUAL, 1, 4294967295),
      s.buffers.stencil.setOp(n.KEEP, n.KEEP, n.KEEP),
      s.buffers.stencil.setLocked(!0);
  }
}
class yg extends ug {
  constructor() {
    super(), (this.needsSwap = !1);
  }
  render(e) {
    e.state.buffers.stencil.setLocked(!1), e.state.buffers.stencil.setTest(!1);
  }
}
class xg {
  constructor(e, t) {
    if (
      ((this.renderer = e),
      (this._pixelRatio = e.getPixelRatio()),
      void 0 === t)
    ) {
      const i = e.getSize(new Vector2());
      (this._width = i.width),
        (this._height = i.height),
        ((t = new ut(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio,
          {
            type: G,
          }
        )).texture.name = "EffectComposer.rt1");
    } else (this._width = t.width), (this._height = t.height);
    (this.renderTarget1 = t),
      (this.renderTarget2 = t.clone()),
      (this.renderTarget2.texture.name = "EffectComposer.rt2"),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2),
      (this.renderToScreen = !0),
      (this.passes = []),
      (this.copyPass = new vg(hg)),
      (this.copyPass.material.blending = 0),
      (this.clock = new Ul());
  }
  swapBuffers() {
    const e = this.readBuffer;
    (this.readBuffer = this.writeBuffer), (this.writeBuffer = e);
  }
  addPass(e) {
    this.passes.push(e),
      e.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  insertPass(e, t) {
    this.passes.splice(t, 0, e),
      e.setSize(
        this._width * this._pixelRatio,
        this._height * this._pixelRatio
      );
  }
  removePass(e) {
    const t = this.passes.indexOf(e);
    -1 !== t && this.passes.splice(t, 1);
  }
  isLastEnabledPass(e) {
    for (let t = e + 1; t < this.passes.length; t++)
      if (this.passes[t].enabled) return !1;
    return !0;
  }
  render(e) {
    void 0 === e && (e = this.clock.getDelta());
    const t = this.renderer.getRenderTarget();
    let i = !1;
    for (let n = 0, s = this.passes.length; n < s; n++) {
      const t = this.passes[n];
      if (!1 !== t.enabled) {
        if (
          ((t.renderToScreen =
            this.renderToScreen && this.isLastEnabledPass(n)),
          t.render(this.renderer, this.writeBuffer, this.readBuffer, e, i),
          t.needsSwap)
        ) {
          if (i) {
            const t = this.renderer.getContext(),
              i = this.renderer.state.buffers.stencil;
            i.setFunc(t.NOTEQUAL, 1, 4294967295),
              this.copyPass.render(
                this.renderer,
                this.writeBuffer,
                this.readBuffer,
                e
              ),
              i.setFunc(t.EQUAL, 1, 4294967295);
          }
          this.swapBuffers();
        }
        void 0 !== Ag &&
          (t instanceof Ag ? (i = !0) : t instanceof yg && (i = !1));
      }
    }
    this.renderer.setRenderTarget(t);
  }
  reset(e) {
    if (void 0 === e) {
      const t = this.renderer.getSize(new Vector2());
      (this._pixelRatio = this.renderer.getPixelRatio()),
        (this._width = t.width),
        (this._height = t.height),
        (e = this.renderTarget1.clone()).setSize(
          this._width * this._pixelRatio,
          this._height * this._pixelRatio
        );
    }
    this.renderTarget1.dispose(),
      this.renderTarget2.dispose(),
      (this.renderTarget1 = e),
      (this.renderTarget2 = e.clone()),
      (this.writeBuffer = this.renderTarget1),
      (this.readBuffer = this.renderTarget2);
  }
  setSize(e, t) {
    (this._width = e), (this._height = t);
    const i = this._width * this._pixelRatio,
      n = this._height * this._pixelRatio;
    this.renderTarget1.setSize(i, n), this.renderTarget2.setSize(i, n);
    for (let s = 0; s < this.passes.length; s++) this.passes[s].setSize(i, n);
  }
  setPixelRatio(e) {
    (this._pixelRatio = e), this.setSize(this._width, this._height);
  }
  dispose() {
    this.renderTarget1.dispose(),
      this.renderTarget2.dispose(),
      this.copyPass.dispose();
  }
}
class bg {
  constructor(e) {
    publicField(this, "_postprocessings", []),
      publicField(this, "_validCount", 0),
      publicField(this, "_composer", null),
      publicField(this, "_samples", 0),
      (this._rendering = e);
  }
  beginFrame() {
    this._updatePostprocessings();
  }
  _updatePostprocessings() {
    let e = 0;
    for (let i = 0, n = this._postprocessings.length; i < n; i++) {
      this._postprocessings[i].enabled && e++;
    }
    this._validCount = e;
    const t = this._rendering;
    if (e > 0) {
      if (!this._composer) {
        const e = t.resolution,
          i = t.pixelRatio;
        (this._firstDepthTexture = new xa()),
          (this._postprocessingRenderTarget1 = new ut(e.x * i, e.y * i, {
            type: G,
            samples: this._samples,
          })),
          (this._postprocessingRenderTarget1.depthTexture =
            this._firstDepthTexture),
          (this._composer = new xg(
            t.renderer,
            this._postprocessingRenderTarget1
          )),
          this._composer.setSize(e.x, e.y),
          this._composer.setPixelRatio(i);
      }
      (this._composer.passes = this._postprocessings),
        this._composer.readBuffer !== this._postprocessingRenderTarget1 &&
          this._composer.swapBuffers();
    } else
      this._composer && (this._composer.dispose(), (this._composer = null));
  }
  add(e) {
    -1 === this._postprocessings.indexOf(e) &&
      ((e.rendering = this._rendering), this._postprocessings.push(e)),
      this._postprocessings.sort(
        (e, t) => (e.renderOrder || 0) - (t.renderOrder || 0)
      );
  }
  remove(e) {
    const t = this._postprocessings.indexOf(e);
    -1 !== t && this._postprocessings.splice(t, 1);
  }
  render() {
    if (this._composer) {
      const e = this._rendering;
      this._composer.renderer = e.renderer;
      const t = e.stats;
      t.beginTimeStatsItem("postprocessingRender"),
        this._composer.render(),
        t.endTimeStatsItem("postprocessingRender");
    }
  }
  updateReqirements(e) {
    for (const t of this._postprocessings)
      t.enabled &&
        (t.needsEmissiveTexture && (e.needsEmissiveTexture = !0),
        t.needsNormalTexture && (e.needsNormalTexture = !0),
        t.needsDepthTexture && (e.needsDepthTexture = !0),
        t.needsMetallicRoughTexture && (e.needsMetallicRoughTexture = !0),
        t.enableStencilBuffer && (e.enableStencilBuffer = !0));
  }
  updateRenderTargetSamples(e) {
    (this._samples = e),
      this._composer &&
        ((this._composer.renderTarget1.samples = e),
        (this._composer.renderTarget2.samples = e));
  }
  endFrame() {}
  dispose() {
    this._postprocessingRenderTarget1 &&
      (this._postprocessingRenderTarget1.dispose(),
      (this._postprocessingRenderTarget1 = null));
  }
  get renderTarget1() {
    return this._postprocessingRenderTarget1;
  }
  get validCount() {
    return this._validCount;
  }
}
const Eg = {
  shaderID: "luminosityHighPass",
  uniforms: {
    tDiffuse: { value: null },
    luminosityThreshold: { value: 1 },
    smoothWidth: { value: 1 },
    defaultColor: { value: new Color(0) },
    defaultOpacity: { value: 0 },
  },
  vertexShader:
    "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
  fragmentShader:
    "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform vec3 defaultColor;\n\t\tuniform float defaultOpacity;\n\t\tuniform float luminosityThreshold;\n\t\tuniform float smoothWidth;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec4 texel = texture2D( tDiffuse, vUv );\n\n\t\t\tvec3 luma = vec3( 0.299, 0.587, 0.114 );\n\n\t\t\tfloat v = dot( texel.xyz, luma );\n\n\t\t\tvec4 outputColor = vec4( defaultColor.rgb, defaultOpacity );\n\n\t\t\tfloat alpha = smoothstep( luminosityThreshold, luminosityThreshold + smoothWidth, v );\n\n\t\t\tgl_FragColor = mix( outputColor, texel, alpha );\n\n\t\t}",
};
class Sg extends ug {
  constructor(e, t, i, n) {
    super(),
      (this.strength = void 0 !== t ? t : 1),
      (this.radius = i),
      (this.threshold = n),
      (this.resolution =
        void 0 !== e ? new Vector2(e.x, e.y) : new Vector2(256, 256)),
      (this.clearColor = new Color(0, 0, 0)),
      (this.renderTargetsHorizontal = []),
      (this.renderTargetsVertical = []),
      (this.nMips = 5);
    let s = Math.round(this.resolution.x / 2),
      r = Math.round(this.resolution.y / 2);
    (this.renderTargetBright = new ut(s, r, { type: G })),
      (this.renderTargetBright.texture.name = "UnrealBloomPass.bright"),
      (this.renderTargetBright.texture.generateMipmaps = !1);
    for (let h = 0; h < this.nMips; h++) {
      const e = new ut(s, r, { type: G });
      (e.texture.name = "UnrealBloomPass.h" + h),
        (e.texture.generateMipmaps = !1),
        this.renderTargetsHorizontal.push(e);
      const t = new ut(s, r, { type: G });
      (t.texture.name = "UnrealBloomPass.v" + h),
        (t.texture.generateMipmaps = !1),
        this.renderTargetsVertical.push(t),
        (s = Math.round(s / 2)),
        (r = Math.round(r / 2));
    }
    const a = Eg;
    (this.highPassUniforms = In.clone(a.uniforms)),
      (this.highPassUniforms.luminosityThreshold.value = n),
      (this.highPassUniforms.smoothWidth.value = 0.01),
      (this.materialHighPassFilter = new ShaderMaterial({
        uniforms: this.highPassUniforms,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader,
      })),
      (this.separableBlurMaterials = []);
    const o = [3, 5, 7, 9, 11];
    (s = Math.round(this.resolution.x / 2)),
      (r = Math.round(this.resolution.y / 2));
    for (let h = 0; h < this.nMips; h++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(o[h])),
        (this.separableBlurMaterials[h].uniforms.invSize.value = new Vector2(
          1 / s,
          1 / r
        )),
        (s = Math.round(s / 2)),
        (r = Math.round(r / 2));
    (this.compositeMaterial = this.getCompositeMaterial(this.nMips)),
      (this.compositeMaterial.uniforms.blurTexture1.value =
        this.renderTargetsVertical[0].texture),
      (this.compositeMaterial.uniforms.blurTexture2.value =
        this.renderTargetsVertical[1].texture),
      (this.compositeMaterial.uniforms.blurTexture3.value =
        this.renderTargetsVertical[2].texture),
      (this.compositeMaterial.uniforms.blurTexture4.value =
        this.renderTargetsVertical[3].texture),
      (this.compositeMaterial.uniforms.blurTexture5.value =
        this.renderTargetsVertical[4].texture),
      (this.compositeMaterial.uniforms.bloomStrength.value = t),
      (this.compositeMaterial.uniforms.bloomRadius.value = 0.1);
    (this.compositeMaterial.uniforms.bloomFactors.value = [
      1, 0.8, 0.6, 0.4, 0.2,
    ]),
      (this.bloomTintColors = [
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
      ]),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors);
    const l = hg;
    (this.copyUniforms = In.clone(l.uniforms)),
      (this.blendMaterial = new ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: l.vertexShader,
        fragmentShader: l.fragmentShader,
        blending: 2,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0,
      })),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this._oldClearColor = new Color()),
      (this.oldClearAlpha = 1),
      (this.basic = new Oi()),
      (this.fsQuad = new fg(null));
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
    for (let e = 0; e < this.separableBlurMaterials.length; e++)
      this.separableBlurMaterials[e].dispose();
    this.compositeMaterial.dispose(),
      this.blendMaterial.dispose(),
      this.basic.dispose(),
      this.fsQuad.dispose();
  }
  setSize(e, t) {
    let i = Math.round(e / 2),
      n = Math.round(t / 2);
    this.renderTargetBright.setSize(i, n);
    for (let s = 0; s < this.nMips; s++)
      this.renderTargetsHorizontal[s].setSize(i, n),
        this.renderTargetsVertical[s].setSize(i, n),
        (this.separableBlurMaterials[s].uniforms.invSize.value = new Vector2(
          1 / i,
          1 / n
        )),
        (i = Math.round(i / 2)),
        (n = Math.round(n / 2));
  }
  render(e, t, i, n, s) {
    e.getClearColor(this._oldClearColor),
      (this.oldClearAlpha = e.getClearAlpha());
    const r = e.autoClear;
    (e.autoClear = !1),
      e.setClearColor(this.clearColor, 0),
      s && e.state.buffers.stencil.setTest(!1),
      this.renderToScreen &&
        ((this.fsQuad.material = this.basic),
        (this.basic.map = i.texture),
        e.setRenderTarget(null),
        e.clear(),
        this.fsQuad.render(e)),
      (this.highPassUniforms.tDiffuse.value = i.texture),
      (this.highPassUniforms.luminosityThreshold.value = this.threshold),
      (this.fsQuad.material = this.materialHighPassFilter),
      e.setRenderTarget(this.renderTargetBright),
      e.clear(),
      this.fsQuad.render(e);
    let a = this.renderTargetBright;
    for (let o = 0; o < this.nMips; o++)
      (this.fsQuad.material = this.separableBlurMaterials[o]),
        (this.separableBlurMaterials[o].uniforms.colorTexture.value =
          a.texture),
        (this.separableBlurMaterials[o].uniforms.direction.value =
          Sg.BlurDirectionX),
        e.setRenderTarget(this.renderTargetsHorizontal[o]),
        e.clear(),
        this.fsQuad.render(e),
        (this.separableBlurMaterials[o].uniforms.colorTexture.value =
          this.renderTargetsHorizontal[o].texture),
        (this.separableBlurMaterials[o].uniforms.direction.value =
          Sg.BlurDirectionY),
        e.setRenderTarget(this.renderTargetsVertical[o]),
        e.clear(),
        this.fsQuad.render(e),
        (a = this.renderTargetsVertical[o]);
    (this.fsQuad.material = this.compositeMaterial),
      (this.compositeMaterial.uniforms.bloomStrength.value = this.strength),
      (this.compositeMaterial.uniforms.bloomRadius.value = this.radius),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors),
      e.setRenderTarget(this.renderTargetsHorizontal[0]),
      e.clear(),
      this.fsQuad.render(e),
      (this.fsQuad.material = this.blendMaterial),
      (this.copyUniforms.tDiffuse.value =
        this.renderTargetsHorizontal[0].texture),
      s && e.state.buffers.stencil.setTest(!0),
      this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(i), this.fsQuad.render(e)),
      e.setClearColor(this._oldClearColor, this.oldClearAlpha),
      (e.autoClear = r);
  }
  getSeperableBlurMaterial(e) {
    const t = [];
    for (let i = 0; i < e; i++)
      t.push((0.39894 * Math.exp((-0.5 * i * i) / (e * e))) / e);
    return new ShaderMaterial({
      defines: { KERNEL_RADIUS: e },
      uniforms: {
        colorTexture: { value: null },
        invSize: { value: new Vector2(0.5, 0.5) },
        direction: { value: new Vector2(0.5, 0.5) },
        gaussianCoefficients: { value: t },
      },
      vertexShader:
        "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
      fragmentShader:
        "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 invSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float gaussianCoefficients[KERNEL_RADIUS];\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tfloat weightSum = gaussianCoefficients[0];\n\t\t\t\t\tvec3 diffuseSum = texture2D( colorTexture, vUv ).rgb * weightSum;\n\t\t\t\t\tfor( int i = 1; i < KERNEL_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = float(i);\n\t\t\t\t\t\tfloat w = gaussianCoefficients[i];\n\t\t\t\t\t\tvec2 uvOffset = direction * invSize * x;\n\t\t\t\t\t\tvec3 sample1 = texture2D( colorTexture, vUv + uvOffset ).rgb;\n\t\t\t\t\t\tvec3 sample2 = texture2D( colorTexture, vUv - uvOffset ).rgb;\n\t\t\t\t\t\tdiffuseSum += (sample1 + sample2) * w;\n\t\t\t\t\t\tweightSum += 2.0 * w;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n\t\t\t\t}",
    });
  }
  getCompositeMaterial(e) {
    return new ShaderMaterial({
      defines: { NUM_MIPS: e },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 },
      },
      vertexShader:
        "varying vec2 vUv;\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
      fragmentShader:
        "varying vec2 vUv;\n\t\t\t\tuniform sampler2D blurTexture1;\n\t\t\t\tuniform sampler2D blurTexture2;\n\t\t\t\tuniform sampler2D blurTexture3;\n\t\t\t\tuniform sampler2D blurTexture4;\n\t\t\t\tuniform sampler2D blurTexture5;\n\t\t\t\tuniform float bloomStrength;\n\t\t\t\tuniform float bloomRadius;\n\t\t\t\tuniform float bloomFactors[NUM_MIPS];\n\t\t\t\tuniform vec3 bloomTintColors[NUM_MIPS];\n\n\t\t\t\tfloat lerpBloomFactor(const in float factor) {\n\t\t\t\t\tfloat mirrorFactor = 1.2 - factor;\n\t\t\t\t\treturn mix(factor, mirrorFactor, bloomRadius);\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tgl_FragColor = bloomStrength * ( lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n\t\t\t\t\t\tlerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n\t\t\t\t}",
    });
  }
}
(Sg.BlurDirectionX = new Vector2(1, 0)),
  (Sg.BlurDirectionY = new Vector2(0, 1));
const Cg = {
  uniforms: { tDiffuse: { value: null }, toneMappingExposure: { value: 1 } },
  vertexShader:
    "\n\t\tprecision highp float;\n\n\t\tuniform mat4 modelViewMatrix;\n\t\tuniform mat4 projectionMatrix;\n\n\t\tattribute vec3 position;\n\t\tattribute vec2 uv;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
  fragmentShader:
    "\n\t\n\t\tprecision highp float;\n\n\t\tuniform sampler2D tDiffuse;\n\n\t\t" +
    qn.tonemapping_pars_fragment +
    qn.colorspace_pars_fragment +
    "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tgl_FragColor = texture2D( tDiffuse, vUv );\n\n\t\t\t// tone mapping\n\n\t\t\t#ifdef LINEAR_TONE_MAPPING\n\n\t\t\t\tgl_FragColor.rgb = LinearToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( REINHARD_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ReinhardToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( CINEON_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = OptimizedCineonToneMapping( gl_FragColor.rgb );\n\n\t\t\t#elif defined( ACES_FILMIC_TONE_MAPPING )\n\n\t\t\t\tgl_FragColor.rgb = ACESFilmicToneMapping( gl_FragColor.rgb );\n\n\t\t\t#endif\n\n\t\t\t// color space\n\n\t\t\t#ifdef SRGB_COLOR_SPACE\n\n\t\t\t\tgl_FragColor = LinearTosRGB( gl_FragColor );\n\n\t\t\t#endif\n\n\t\t}",
};
class Mg extends ug {
  constructor() {
    super();
    const e = Cg;
    (this.uniforms = In.clone(e.uniforms)),
      (this.material = new Go({
        uniforms: this.uniforms,
        vertexShader: e.vertexShader,
        fragmentShader: e.fragmentShader,
      })),
      (this.fsQuad = new fg(this.material)),
      (this._outputColorSpace = null),
      (this._toneMapping = null);
  }
  render(e, t, i) {
    (this.uniforms.tDiffuse.value = i.texture),
      (this.uniforms.toneMappingExposure.value = e.toneMappingExposure),
      (this._outputColorSpace === e.outputColorSpace &&
        this._toneMapping === e.toneMapping) ||
        ((this._outputColorSpace = e.outputColorSpace),
        (this._toneMapping = e.toneMapping),
        (this.material.defines = {}),
        this._outputColorSpace == me &&
          (this.material.defines.SRGB_COLOR_SPACE = ""),
        this._toneMapping === v
          ? (this.material.defines.LINEAR_TONE_MAPPING = "")
          : this._toneMapping === A
          ? (this.material.defines.REINHARD_TONE_MAPPING = "")
          : this._toneMapping === y
          ? (this.material.defines.CINEON_TONE_MAPPING = "")
          : this._toneMapping === x &&
            (this.material.defines.ACES_FILMIC_TONE_MAPPING = ""),
        (this.material.needsUpdate = !0)),
      !0 === this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(t),
          this.clear &&
            e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
          this.fsQuad.render(e));
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class wg extends ug {
  constructor(e, t) {
    super();
    const i = hg;
    (this.map = e),
      (this.opacity = void 0 !== t ? t : 1),
      (this.uniforms = In.clone(i.uniforms)),
      (this.material = new ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: i.vertexShader,
        fragmentShader: i.fragmentShader,
        depthTest: !1,
        depthWrite: !1,
        premultipliedAlpha: !0,
      })),
      (this.needsSwap = !1),
      (this.fsQuad = new fg(null));
  }
  render(e, t, i) {
    const n = e.autoClear;
    (e.autoClear = !1),
      (this.fsQuad.material = this.material),
      (this.uniforms.opacity.value = this.opacity),
      (this.uniforms.tDiffuse.value = this.map),
      (this.material.transparent = this.opacity < 1),
      e.setRenderTarget(this.renderToScreen ? null : i),
      this.clear && e.clear(),
      this.fsQuad.render(e),
      (e.autoClear = n);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class Tg {
  constructor(e, t) {
    publicField(this, "enabled", !1),
      publicField(this, "name", ""),
      (this._options = t),
      (this._rendering = e);
  }
  beginFrame() {}
  render() {}
  endFrame() {}
}
const Ig =
    "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}",
  Rg =
    "#define GLSLIFY 1\nuniform sampler2D baseTexture;\nuniform sampler2D bloomTexture;\n\nvarying vec2 vUv;\n\nvoid main() {\n\n    // gl_FragColor = texture2D( bloomTexture, vUv );\n    // gl_FragColor = ( texture2D( baseTexture, vUv ) + vec4( 1.0 ) * texture2D( bloomTexture, vUv ) );\n    vec4 base_color = texture2D(baseTexture, vUv);\n    vec4 bloom_color = texture2D(bloomTexture, vUv);\n\n    float lum = 0.21 * bloom_color.r + 0.71 * bloom_color.g + 0.07 * bloom_color.b;\n    gl_FragColor = vec4(base_color.rgb + bloom_color.rgb, max(base_color.a, lum));\n}";
class Pg extends Tg {
  constructor() {
    super(...arguments),
      publicField(this, "name", "bloom"),
      publicField(this, "_lastEnabled", !1),
      publicField(this, "_strength", 1),
      publicField(this, "_threshold", 0),
      publicField(this, "_radius", 0),
      publicField(this, "needsEmissiveTexture", !0);
  }
  beginFrame() {
    this._lastEnabled === this.enabled
      ? this.enabled
      : this.enabled
      ? this._init()
      : this.dispose();
  }
  _init() {
    const e = this._rendering,
      t = e.resolution,
      i = e.main,
      n = e.pixelRatio;
    (this._bloomRenderTarget = new ut(t.x * n, t.y * n, { type: G })),
      (this._bloomRenderPass = new Sg(
        t,
        this._strength,
        this._radius,
        this._threshold
      ));
    const s = (this._bloomComposer = new xg(
      e.renderer,
      this._bloomRenderTarget
    ));
    (s.renderToScreen = !1), s.setSize(t.x, t.y), s.setPixelRatio(n);
    const r = (this._texturePass = new wg());
    s.addPass(r), s.addPass(this._bloomRenderPass);
    const a = new Mg();
    s.addPass(a);
    const o = (this._bloomMixPass = new vg(
      new ShaderMaterial({
        uniforms: {
          baseTexture: { value: null },
          bloomTexture: { value: s.renderTarget2.texture },
        },
        vertexShader: Ig,
        fragmentShader: Rg,
        defines: {},
      }),
      "baseTexture"
    ));
    (o.renderOrder = 100), i.postprocessings.add(o), i.useMRT;
  }
  afterRender() {
    if (this.enabled) {
      const e = this._rendering,
        t = e.main,
        i = e.stats;
      this._texturePass.map = t.sceneRendering.emissiveTexture;
      const n = this._bloomComposer;
      (n.renderer = e.renderer),
        n.renderTarget2 !== this._bloomRenderTarget && n.swapBuffers();
      const s = e.renderer.toneMapping;
      (e.renderer.toneMapping = A),
        i.beginTimeStatsItem("renderBloomComposer"),
        n.render(),
        i.endTimeStatsItem("renderBloomComposer"),
        (e.renderer.toneMapping = s);
    }
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    if (
      (this._rendering.stats.removeTimeStatsItem("renderBloomComposer"),
      this._bloomRenderPass)
    ) {
      this._rendering.main.postprocessings.remove(this._bloomMixPass),
        this._bloomRenderPass.dispose(),
        (this._bloomRenderPass = null);
    }
  }
  get strength() {
    return this._strength;
  }
  set strength(e) {
    (this._strength = e),
      this._bloomRenderPass && (this._bloomRenderPass.strength = e);
  }
  get radius() {
    return this._radius;
  }
  set radius(e) {
    (this._radius = e),
      this._bloomRenderPass && (this._bloomRenderPass.radius = e);
  }
  get threshold() {
    return this._threshold;
  }
  set threshold(e) {
    (this._threshold = e),
      this._bloomRenderPass && (this._bloomRenderPass.threshold = e);
  }
}
class Dg extends ug {
  constructor() {
    super();
    const e = hg;
    (this.uniforms = {
      tDiffuse: { value: null },
      textureInfos: { value: null },
      maps: { value: null },
    }),
      (this._lastTextureCount = 1),
      (this.material = new ShaderMaterial({
        defines: { MVT_TEXTURE_COUNT: 1 },
        uniforms: this.uniforms,
        vertexShader: e.vertexShader,
        fragmentShader:
          "\nstruct TextureInfo {\n    vec2 offset;\n    vec2 scale;\n};\nuniform sampler2D maps[MVT_TEXTURE_COUNT];\nuniform sampler2D tDiffuse;\nvarying vec2 vUv;\n\nuniform TextureInfo textureInfos[MVT_TEXTURE_COUNT];\n\nvoid addTextureColor(sampler2D map, TextureInfo textureInfo) {\n    vec2 transformedUv = (vUv - textureInfo.offset) * textureInfo.scale;\n    if (transformedUv.x >= 0.0 && transformedUv.x <= 1.0 && transformedUv.y >= 0.0 && transformedUv.y <= 1.0) {\n        // gl_FragColor += texture2D(map, transformedUv);\n        vec4 sampleColor = texture2D(map, transformedUv);\n        gl_FragColor.rgb = mix(sampleColor.rgb, gl_FragColor.rgb, 1.0 - sampleColor.a);\n        gl_FragColor.a += sampleColor.a;\n        // gl_FragColor = sampleColor + gl_FragColor;\n    }\n}\nvoid main() {\n\n    gl_FragColor = texture2D(tDiffuse, vUv);\n    // gl_FragColor = vec4(0.5, 0, 0, 0.5);\n    #if MVT_TEXTURE_COUNT > 0\n        addTextureColor(maps[0], textureInfos[0]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 1\n        addTextureColor(maps[1], textureInfos[1]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 2\n        addTextureColor(maps[2], textureInfos[2]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 3\n        addTextureColor(maps[3], textureInfos[3]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 4\n        addTextureColor(maps[4], textureInfos[4]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 5\n        addTextureColor(maps[5], textureInfos[5]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 6\n        addTextureColor(maps[6], textureInfos[6]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 7\n        addTextureColor(maps[7], textureInfos[7]);\n    #endif\n\n    #if MVT_TEXTURE_COUNT > 8\n        addTextureColor(maps[8], textureInfos[8]);\n    #endif\n}\n",
        depthTest: !1,
        depthWrite: !1,
      })),
      (this.needsSwap = !0),
      (this.fsQuad = new fg(null));
  }
  render(e, t, i) {
    const n = e.autoClear;
    (e.autoClear = !1),
      (this.fsQuad.material = this.material),
      (this.material.uniforms.tDiffuse.value = i.texture),
      e.setRenderTarget(this.renderToScreen ? null : t),
      e.clear(),
      this.fsQuad.render(e),
      (e.autoClear = n);
  }
  updateTextures(e, t) {
    e.length === t.length
      ? ((this.uniforms.maps.value = e),
        (this.uniforms.textureInfos.value = t),
        this._lastTextureCount !== t.length &&
          ((this.material.defines.MVT_TEXTURE_COUNT = t.length),
          (this.material.needsUpdate = !0),
          (this._lastTextureCount = t.length)))
      : console.warn("textures and infos length must be equal");
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class Lg extends Tg {
  constructor() {
    super(...arguments),
      publicField(this, "name", "stats"),
      publicField(this, "_lastEnabled", !1),
      publicField(this, "_canvasWidth", 600),
      publicField(this, "_canvasHeight", 320),
      publicField(this, "_canvasPadding", 10),
      publicField(this, "_lastUpdateTime", 0);
  }
  beginFrame() {
    this._lastEnabled === this.enabled
      ? this.enabled && this._updateTexture()
      : this.enabled
      ? this._init()
      : this.dispose();
  }
  _init() {
    const e = this._rendering,
      t = e.pixelRatio,
      i = (this._canvas = document.createElement("canvas"));
    (this._context = i.getContext("2d")),
      (i.width = this._canvasWidth * t),
      (i.height = this._canvasHeight * t),
      (this._texture = new CanvasTexture(i)),
      (this._texture.generateMipmaps = !1);
    const n = (this._renderPass = new Dg());
    (n.renderOrder = 10100),
      (n.material.uniforms.textureInfos.value = [
        { offset: [0.2, 0.2], scale: [2.5, 2.5] },
      ]),
      (n.material.uniforms.maps.value = [this._texture]),
      e.main.postprocessings.add(this._renderPass);
  }
  _updateTexture() {
    const e = this._rendering,
      t = e.renderState;
    if (t.time - this._lastUpdateTime < 100) return;
    this._lastUpdateTime = t.time;
    const i = e.renderer,
      n = e.stats,
      s = this._context,
      r = e.pixelRatio;
    n.beginTimeStatsItem("updateStatsTexture"),
      s.save(),
      s.scale(r, r),
      s.clearRect(0, 0, this._canvasWidth, this._canvasHeight),
      (s.fillStyle = "rgba(0, 0, 0, .6)"),
      s.fillRect(0, 0, this._canvasWidth, this._canvasHeight),
      (s.font = "14px sans-serif"),
      (s.textAlign = "right"),
      (s.fillStyle = "rgb(220,220,220)");
    const a = n.getSortedTimeStatsItems(),
      o = Math.min(a.length, 10);
    let l = this._canvasPadding + 100,
      h = this._canvasPadding + 20;
    s.fillText("average", l + 150, h),
      s.fillText("lastValue", l + 230, h),
      s.fillText("count", l + 310, h),
      s.fillText("total", l + 450, h),
      (s.strokeStyle = "rgb(130,130,130)");
    for (let m = 0; m < o; m++) {
      (l = this._canvasPadding + 100), (h = this._canvasPadding + 50 + 20 * m);
      const e = a[m];
      s.fillText(e.name, l + 50, h),
        s.fillText(e.average.toFixed(2), l + 150, h),
        s.fillText(e.lastValue.toFixed(2), l + 230, h),
        s.fillText(e.count.toFixed(0), l + 310, h),
        s.fillText(e.total.toFixed(2), l + 450, h),
        (h += 5),
        s.beginPath(),
        s.moveTo(this._canvasPadding, h),
        s.lineTo(this._canvasWidth - this._canvasPadding, h),
        s.stroke();
    }
    const c = i.info;
    (s.font = "13px sans-serif"),
      (s.textAlign = "left"),
      (l = this._canvasPadding),
      (h = 270),
      s.fillText("frame: " + c.render.frame, l, h),
      (l += 160),
      s.fillText("calls: " + c.render.calls, l, h),
      (l += 160),
      s.fillText("triangles: " + c.render.triangles, l, h),
      (l += 160),
      s.fillText("points: " + c.render.points, l, h),
      (l = this._canvasPadding),
      (h += 20),
      s.fillText("lines: " + c.render.lines, l, h),
      (l += 160),
      s.fillText("geometries: " + c.memory.geometries, l, h),
      (l += 160),
      s.fillText("textures: " + c.memory.textures, l, h),
      (l += 160),
      s.fillText("programs: " + c.programs.length, l, h),
      (l = this._canvasPadding),
      (h += 20),
      s.fillText("postprocessing: " + e.main.postprocessings.validCount, l, h);
    const u = e.main.features.features;
    let d = "";
    for (const m of u) m.enabled && (d += m.name + " ");
    (l += 160),
      s.fillText("features: " + d, l, h),
      s.restore(),
      n.endTimeStatsItem("updateStatsTexture"),
      (this._texture.needsUpdate = !0);
    const p = e.resolution,
      f = this._renderPass;
    (f.material.uniforms.textureInfos.value[0].offset = [
      0.5 - this._canvasWidth / 2 / p.x,
      0.5 - this._canvasHeight / 2 / p.y,
    ]),
      (f.material.uniforms.textureInfos.value[0].scale = [
        1 / (this._canvasWidth / p.x),
        1 / (this._canvasHeight / p.y),
      ]);
  }
  afterRender() {}
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    const e = this._rendering;
    e.stats.removeTimeStatsItem("updateStatsTexture"),
      e.main.postprocessings.remove(this._renderPass),
      this._renderPass && this._renderPass.dispose(),
      this._texture && this._texture.dispose();
  }
}
const Fg = [
  [-4, -7],
  [-7, -5],
  [-3, -5],
  [-5, -4],
  [-1, -4],
  [-2, -2],
  [-6, -1],
  [-4, 0],
  [-7, 1],
  [-1, 2],
  [-6, 3],
  [-3, 3],
  [-7, 6],
  [-3, 6],
  [-5, 7],
  [-1, 7],
  [5, -7],
  [1, -6],
  [6, -5],
  [4, -4],
  [2, -3],
  [7, -2],
  [1, -1],
  [4, -1],
  [2, 1],
  [6, 2],
  [0, 4],
  [4, 4],
  [2, 5],
  [7, 5],
  [5, 6],
  [3, 7],
];
class Ng extends ug {
  constructor() {
    super();
    const e = hg;
    (this.uniforms = { tDiffuse: { value: null }, opacity: { value: 1 } }),
      (this._accumulateIndex = 0),
      (this.material = new ShaderMaterial({
        uniforms: this.uniforms,
        vertexShader: e.vertexShader,
        fragmentShader: e.fragmentShader,
        depthTest: !1,
        depthWrite: !1,
      })),
      (this.needsSwap = !0),
      (this.fsQuad = new fg(null));
  }
  render(e, t, i) {
    let n = !1;
    this._holdRenderTarget ||
      ((n = !0),
      (this._holdRenderTarget = new ut(i.width, i.height, {
        depthBuffer: !1,
      }))),
      this._sampleRenderTarget ||
        (this._sampleRenderTarget = new ut(i.width, i.height, {
          depthBuffer: !1,
        }));
    const s = e.autoClear;
    (e.autoClear = !1), (this.fsQuad.material = this.material);
    const r = n ? 1 : this._accumulateIndex / 32,
      a = this.uniforms;
    e.setRenderTarget(this._sampleRenderTarget),
      e.clear(),
      r < 1 &&
        ((a.tDiffuse.value = this._holdRenderTarget.texture),
        (a.opacity.value = 1 - r),
        this.fsQuad.render(e)),
      r > 0 &&
        ((a.tDiffuse.value = i.texture),
        (a.opacity.value = r),
        this.fsQuad.render(e)),
      e.setRenderTarget(this._holdRenderTarget),
      e.clear(),
      (a.tDiffuse.value = this._sampleRenderTarget.texture),
      (a.opacity.value = 1),
      this.fsQuad.render(e),
      e.setRenderTarget(this.renderToScreen ? null : t),
      e.clear(),
      this.fsQuad.render(e),
      (e.autoClear = s);
    const o = this.rendering.camera,
      l = Fg[this._accumulateIndex];
    o.setViewOffset(
      i.width,
      i.height,
      0.0625 * l[0],
      0.0625 * l[1],
      i.width,
      i.height
    ),
      this._accumulateIndex++,
      this._accumulateIndex > 31 && (this._accumulateIndex = 0);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
const Bg = {
  uniforms: {
    tDiffuse: { value: null },
    resolution: { value: new Vector2(1 / 1024, 1 / 512) },
  },
  vertexShader:
    "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
  fragmentShader:
    "\n\tprecision highp float;\n\n\tuniform sampler2D tDiffuse;\n\n\tuniform vec2 resolution;\n\n\tvarying vec2 vUv;\n\n\t// FXAA 3.11 implementation by NVIDIA, ported to WebGL by Agost Biro (biro@archilogic.com)\n\n\t//----------------------------------------------------------------------------------\n\t// File:        es3-keplerFXAAassetsshaders/FXAA_DefaultES.frag\n\t// SDK Version: v3.00\n\t// Email:       gameworks@nvidia.com\n\t// Site:        http://developer.nvidia.com/\n\t//\n\t// Copyright (c) 2014-2015, NVIDIA CORPORATION. All rights reserved.\n\t//\n\t// Redistribution and use in source and binary forms, with or without\n\t// modification, are permitted provided that the following conditions\n\t// are met:\n\t//  * Redistributions of source code must retain the above copyright\n\t//    notice, this list of conditions and the following disclaimer.\n\t//  * Redistributions in binary form must reproduce the above copyright\n\t//    notice, this list of conditions and the following disclaimer in the\n\t//    documentation and/or other materials provided with the distribution.\n\t//  * Neither the name of NVIDIA CORPORATION nor the names of its\n\t//    contributors may be used to endorse or promote products derived\n\t//    from this software without specific prior written permission.\n\t//\n\t// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY\n\t// EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n\t// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR\n\t// PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR\n\t// CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,\n\t// EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,\n\t// PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n\t// PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY\n\t// OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n\t// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n\t// OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n\t//\n\t//----------------------------------------------------------------------------------\n\n\t#ifndef FXAA_DISCARD\n\t\t\t//\n\t\t\t// Only valid for PC OpenGL currently.\n\t\t\t// Probably will not work when FXAA_GREEN_AS_LUMA = 1.\n\t\t\t//\n\t\t\t// 1 = Use discard on pixels which don't need AA.\n\t\t\t//     For APIs which enable concurrent TEX+ROP from same surface.\n\t\t\t// 0 = Return unchanged color on pixels which don't need AA.\n\t\t\t//\n\t\t\t#define FXAA_DISCARD 0\n\t#endif\n\n\t/*--------------------------------------------------------------------------*/\n\t#define FxaaTexTop(t, p) texture2D(t, p, -100.0)\n\t#define FxaaTexOff(t, p, o, r) texture2D(t, p + (o * r), -100.0)\n\t/*--------------------------------------------------------------------------*/\n\n\t#define NUM_SAMPLES 5\n\n\t// assumes colors have premultipliedAlpha, so that the calculated color contrast is scaled by alpha\n\tfloat contrast( vec4 a, vec4 b ) {\n\t\t\tvec4 diff = abs( a - b );\n\t\t\treturn max( max( max( diff.r, diff.g ), diff.b ), diff.a );\n\t}\n\n\t/*============================================================================\n\n\t\t\t\t\t\t\t\t\tFXAA3 QUALITY - PC\n\n\t============================================================================*/\n\n\t/*--------------------------------------------------------------------------*/\n\tvec4 FxaaPixelShader(\n\t\t\tvec2 posM,\n\t\t\tsampler2D tex,\n\t\t\tvec2 fxaaQualityRcpFrame,\n\t\t\tfloat fxaaQualityEdgeThreshold,\n\t\t\tfloat fxaaQualityinvEdgeThreshold\n\t) {\n\t\t\tvec4 rgbaM = FxaaTexTop(tex, posM);\n\t\t\tvec4 rgbaS = FxaaTexOff(tex, posM, vec2( 0.0, 1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaE = FxaaTexOff(tex, posM, vec2( 1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaN = FxaaTexOff(tex, posM, vec2( 0.0,-1.0), fxaaQualityRcpFrame.xy);\n\t\t\tvec4 rgbaW = FxaaTexOff(tex, posM, vec2(-1.0, 0.0), fxaaQualityRcpFrame.xy);\n\t\t\t// . S .\n\t\t\t// W M E\n\t\t\t// . N .\n\n\t\t\tbool earlyExit = max( max( max(\n\t\t\t\t\tcontrast( rgbaM, rgbaN ),\n\t\t\t\t\tcontrast( rgbaM, rgbaS ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaE ) ),\n\t\t\t\t\tcontrast( rgbaM, rgbaW ) )\n\t\t\t\t\t< fxaaQualityEdgeThreshold;\n\t\t\t// . 0 .\n\t\t\t// 0 0 0\n\t\t\t// . 0 .\n\n\t\t\t#if (FXAA_DISCARD == 1)\n\t\t\t\t\tif(earlyExit) FxaaDiscard;\n\t\t\t#else\n\t\t\t\t\tif(earlyExit) return rgbaM;\n\t\t\t#endif\n\n\t\t\tfloat contrastN = contrast( rgbaM, rgbaN );\n\t\t\tfloat contrastS = contrast( rgbaM, rgbaS );\n\t\t\tfloat contrastE = contrast( rgbaM, rgbaE );\n\t\t\tfloat contrastW = contrast( rgbaM, rgbaW );\n\n\t\t\tfloat relativeVContrast = ( contrastN + contrastS ) - ( contrastE + contrastW );\n\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\tbool horzSpan = relativeVContrast > 0.;\n\t\t\t// . 1 .\n\t\t\t// 0 0 0\n\t\t\t// . 1 .\n\n\t\t\t// 45 deg edge detection and corners of objects, aka V/H contrast is too similar\n\t\t\tif( abs( relativeVContrast ) < .3 ) {\n\t\t\t\t\t// locate the edge\n\t\t\t\t\tvec2 dirToEdge;\n\t\t\t\t\tdirToEdge.x = contrastE > contrastW ? 1. : -1.;\n\t\t\t\t\tdirToEdge.y = contrastS > contrastN ? 1. : -1.;\n\t\t\t\t\t// . 2 .      . 1 .\n\t\t\t\t\t// 1 0 2  ~=  0 0 1\n\t\t\t\t\t// . 1 .      . 0 .\n\n\t\t\t\t\t// tap 2 pixels and see which ones are \"outside\" the edge, to\n\t\t\t\t\t// determine if the edge is vertical or horizontal\n\n\t\t\t\t\tvec4 rgbaAlongH = FxaaTexOff(tex, posM, vec2( dirToEdge.x, -dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongH = contrast( rgbaM, rgbaAlongH );\n\t\t\t\t\t// . 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 H\n\n\t\t\t\t\tvec4 rgbaAlongV = FxaaTexOff(tex, posM, vec2( -dirToEdge.x, dirToEdge.y ), fxaaQualityRcpFrame.xy);\n\t\t\t\t\tfloat matchAlongV = contrast( rgbaM, rgbaAlongV );\n\t\t\t\t\t// V 1 .\n\t\t\t\t\t// 0 0 1\n\t\t\t\t\t// . 0 .\n\n\t\t\t\t\trelativeVContrast = matchAlongV - matchAlongH;\n\t\t\t\t\trelativeVContrast *= fxaaQualityinvEdgeThreshold;\n\n\t\t\t\t\tif( abs( relativeVContrast ) < .3 ) { // 45 deg edge\n\t\t\t\t\t\t\t// 1 1 .\n\t\t\t\t\t\t\t// 0 0 1\n\t\t\t\t\t\t\t// . 0 1\n\n\t\t\t\t\t\t\t// do a simple blur\n\t\t\t\t\t\t\treturn mix(\n\t\t\t\t\t\t\t\t\trgbaM,\n\t\t\t\t\t\t\t\t\t(rgbaN + rgbaS + rgbaE + rgbaW) * .25,\n\t\t\t\t\t\t\t\t\t.4\n\t\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\thorzSpan = relativeVContrast > 0.;\n\t\t\t}\n\n\t\t\tif(!horzSpan) rgbaN = rgbaW;\n\t\t\tif(!horzSpan) rgbaS = rgbaE;\n\t\t\t// . 0 .      1\n\t\t\t// 1 0 1  ->  0\n\t\t\t// . 0 .      1\n\n\t\t\tbool pairN = contrast( rgbaM, rgbaN ) > contrast( rgbaM, rgbaS );\n\t\t\tif(!pairN) rgbaN = rgbaS;\n\n\t\t\tvec2 offNP;\n\t\t\toffNP.x = (!horzSpan) ? 0.0 : fxaaQualityRcpFrame.x;\n\t\t\toffNP.y = ( horzSpan) ? 0.0 : fxaaQualityRcpFrame.y;\n\n\t\t\tbool doneN = false;\n\t\t\tbool doneP = false;\n\n\t\t\tfloat nDist = 0.;\n\t\t\tfloat pDist = 0.;\n\n\t\t\tvec2 posN = posM;\n\t\t\tvec2 posP = posM;\n\n\t\t\tint iterationsUsed = 0;\n\t\t\tint iterationsUsedN = 0;\n\t\t\tint iterationsUsedP = 0;\n\t\t\tfor( int i = 0; i < NUM_SAMPLES; i++ ) {\n\t\t\t\t\titerationsUsed = i;\n\n\t\t\t\t\tfloat increment = float(i + 1);\n\n\t\t\t\t\tif(!doneN) {\n\t\t\t\t\t\t\tnDist += increment;\n\t\t\t\t\t\t\tposN = posM + offNP * nDist;\n\t\t\t\t\t\t\tvec4 rgbaEndN = FxaaTexTop(tex, posN.xy);\n\t\t\t\t\t\t\tdoneN = contrast( rgbaEndN, rgbaM ) > contrast( rgbaEndN, rgbaN );\n\t\t\t\t\t\t\titerationsUsedN = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(!doneP) {\n\t\t\t\t\t\t\tpDist += increment;\n\t\t\t\t\t\t\tposP = posM - offNP * pDist;\n\t\t\t\t\t\t\tvec4 rgbaEndP = FxaaTexTop(tex, posP.xy);\n\t\t\t\t\t\t\tdoneP = contrast( rgbaEndP, rgbaM ) > contrast( rgbaEndP, rgbaN );\n\t\t\t\t\t\t\titerationsUsedP = i;\n\t\t\t\t\t}\n\n\t\t\t\t\tif(doneN || doneP) break;\n\t\t\t}\n\n\n\t\t\tif ( !doneP && !doneN ) return rgbaM; // failed to find end of edge\n\n\t\t\tfloat dist = min(\n\t\t\t\t\tdoneN ? float( iterationsUsedN ) / float( NUM_SAMPLES - 1 ) : 1.,\n\t\t\t\t\tdoneP ? float( iterationsUsedP ) / float( NUM_SAMPLES - 1 ) : 1.\n\t\t\t);\n\n\t\t\t// hacky way of reduces blurriness of mostly diagonal edges\n\t\t\t// but reduces AA quality\n\t\t\tdist = pow(dist, .5);\n\n\t\t\tdist = 1. - dist;\n\n\t\t\treturn mix(\n\t\t\t\t\trgbaM,\n\t\t\t\t\trgbaN,\n\t\t\t\t\tdist * .5\n\t\t\t);\n\t}\n\n\tvoid main() {\n\t\t\tconst float edgeDetectionQuality = .2;\n\t\t\tconst float invEdgeDetectionQuality = 1. / edgeDetectionQuality;\n\n\t\t\tgl_FragColor = FxaaPixelShader(\n\t\t\t\t\tvUv,\n\t\t\t\t\ttDiffuse,\n\t\t\t\t\tresolution,\n\t\t\t\t\tedgeDetectionQuality, // [0,1] contrast needed, otherwise early discard\n\t\t\t\t\tinvEdgeDetectionQuality\n\t\t\t);\n\n\t}\n\t",
};
class kg extends Tg {
  constructor(e, t) {
    super(e, t),
      publicField(this, "name", "AA"),
      publicField(this, "_method", "msaa"),
      publicField(this, "_lastMethod", "msaa"),
      publicField(this, "_lastEnabled", !1),
      publicField(this, "_lastUseMRT", !1),
      (this.enabled = t.enabled),
      (this._method = t.method);
  }
  beginFrame() {
    this._lastEnabled === this.enabled
      ? this.enabled &&
        this._lastMethod !== this._method &&
        (this._disableOldMethod(), this._enableNewMethod())
      : this.enabled
      ? this._enableNewMethod()
      : this._disableOldMethod();
  }
  _disableOldMethod() {
    const e = this._lastMethod,
      t = this._rendering;
    "msaa" === e
      ? (t.updateContextParameters({ antialias: !1 }),
        t.main.postprocessings.updateRenderTargetSamples(0),
        t.main.sceneRendering.updateRenderTargetSamples(0))
      : "fxaa" === e
      ? (this._fxaaPass && t.main.postprocessings.remove(this._fxaaPass),
        (this._fxaaPass = null))
      : "taa" === e &&
        (this._taaPass && t.main.postprocessings.remove(this._taaPass),
        (this._taaPass = null));
  }
  _enableNewMethod() {
    const e = this._method,
      t = this._rendering;
    if ("msaa" === e)
      t.updateContextParameters({ antialias: !0 }),
        t.main.postprocessings.updateRenderTargetSamples(4),
        t.main.sceneRendering.updateRenderTargetSamples(4);
    else if ("fxaa" === e) {
      const e = (this._fxaaPass = new vg(Bg));
      (e.renderOrder = 10050), t.main.postprocessings.add(e);
    } else if ("taa" === e) {
      const e = (this._taaPass = new Ng());
      (e.rendering = t), (e.renderOrder = 10050), t.main.postprocessings.add(e);
    }
  }
  afterRender() {}
  endFrame() {
    (this._lastEnabled = this.enabled), (this._lastMethod = this._method);
  }
  dispose() {
    this.enabled && "msaa" !== this._method && this._disableOldMethod();
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
}
class Og extends Tg {
  constructor() {
    super(...arguments),
      publicField(this, "name", "bufferView"),
      publicField(this, "_lastEnabled", !1);
  }
  beginFrame() {
    this._lastEnabled === this.enabled ||
      (this.enabled ? this._init() : this.dispose());
  }
  _init() {
    const e = this._rendering,
      t = (this._renderPass = new Dg());
    (t.renderOrder = 10900),
      (t.material.uniforms.textureInfos.value = [
        { offset: [0.2, 0.2], scale: [2.5, 2.5] },
      ]),
      (t.material.uniforms.maps.value = []),
      e.main.postprocessings.add(this._renderPass);
  }
  afterRender() {
    if (!this.enabled) return;
    const e = [],
      t = this._rendering.main.sceneRendering;
    t.diffuseTexture && e.push(t.diffuseTexture),
      t.emissiveTexture && e.push(t.emissiveTexture),
      t.normalTexture && e.push(t.normalTexture),
      t.depthTexture && e.push(t.depthTexture),
      t.metallicRoughTexture && e.push(t.metallicRoughTexture);
    const i = [];
    for (let n = 0; n < e.length; n++)
      i.push({ offset: [0.25 * n, 0.25 * Math.floor(n / 4)], scale: [4, 4] });
    this._renderPass.updateTextures(e, i);
  }
  endFrame() {
    this._lastEnabled = this.enabled;
  }
  dispose() {
    this._rendering.main.postprocessings.remove(this._renderPass),
      this._renderPass && this._renderPass.dispose();
  }
}
class Ug {
  constructor(e = Math) {
    (this.grad3 = [
      [1, 1, 0],
      [-1, 1, 0],
      [1, -1, 0],
      [-1, -1, 0],
      [1, 0, 1],
      [-1, 0, 1],
      [1, 0, -1],
      [-1, 0, -1],
      [0, 1, 1],
      [0, -1, 1],
      [0, 1, -1],
      [0, -1, -1],
    ]),
      (this.grad4 = [
        [0, 1, 1, 1],
        [0, 1, 1, -1],
        [0, 1, -1, 1],
        [0, 1, -1, -1],
        [0, -1, 1, 1],
        [0, -1, 1, -1],
        [0, -1, -1, 1],
        [0, -1, -1, -1],
        [1, 0, 1, 1],
        [1, 0, 1, -1],
        [1, 0, -1, 1],
        [1, 0, -1, -1],
        [-1, 0, 1, 1],
        [-1, 0, 1, -1],
        [-1, 0, -1, 1],
        [-1, 0, -1, -1],
        [1, 1, 0, 1],
        [1, 1, 0, -1],
        [1, -1, 0, 1],
        [1, -1, 0, -1],
        [-1, 1, 0, 1],
        [-1, 1, 0, -1],
        [-1, -1, 0, 1],
        [-1, -1, 0, -1],
        [1, 1, 1, 0],
        [1, 1, -1, 0],
        [1, -1, 1, 0],
        [1, -1, -1, 0],
        [-1, 1, 1, 0],
        [-1, 1, -1, 0],
        [-1, -1, 1, 0],
        [-1, -1, -1, 0],
      ]),
      (this.p = []);
    for (let t = 0; t < 256; t++) this.p[t] = Math.floor(256 * e.random());
    this.perm = [];
    for (let t = 0; t < 512; t++) this.perm[t] = this.p[255 & t];
    this.simplex = [
      [0, 1, 2, 3],
      [0, 1, 3, 2],
      [0, 0, 0, 0],
      [0, 2, 3, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 3, 0],
      [0, 2, 1, 3],
      [0, 0, 0, 0],
      [0, 3, 1, 2],
      [0, 3, 2, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 3, 2, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [1, 2, 0, 3],
      [0, 0, 0, 0],
      [1, 3, 0, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 3, 0, 1],
      [2, 3, 1, 0],
      [1, 0, 2, 3],
      [1, 0, 3, 2],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 3, 1],
      [0, 0, 0, 0],
      [2, 1, 3, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [2, 0, 1, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 0, 1, 2],
      [3, 0, 2, 1],
      [0, 0, 0, 0],
      [3, 1, 2, 0],
      [2, 1, 0, 3],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [0, 0, 0, 0],
      [3, 1, 0, 2],
      [0, 0, 0, 0],
      [3, 2, 0, 1],
      [3, 2, 1, 0],
    ];
  }
  dot(e, t, i) {
    return e[0] * t + e[1] * i;
  }
  dot3(e, t, i, n) {
    return e[0] * t + e[1] * i + e[2] * n;
  }
  dot4(e, t, i, n, s) {
    return e[0] * t + e[1] * i + e[2] * n + e[3] * s;
  }
  noise(e, t) {
    let i, n, s;
    const r = (e + t) * (0.5 * (Math.sqrt(3) - 1)),
      a = Math.floor(e + r),
      o = Math.floor(t + r),
      l = (3 - Math.sqrt(3)) / 6,
      h = (a + o) * l,
      c = e - (a - h),
      u = t - (o - h);
    let d, p;
    c > u ? ((d = 1), (p = 0)) : ((d = 0), (p = 1));
    const f = c - d + l,
      m = u - p + l,
      g = c - 1 + 2 * l,
      _ = u - 1 + 2 * l,
      v = 255 & a,
      A = 255 & o,
      y = this.perm[v + this.perm[A]] % 12,
      x = this.perm[v + d + this.perm[A + p]] % 12,
      b = this.perm[v + 1 + this.perm[A + 1]] % 12;
    let E = 0.5 - c * c - u * u;
    E < 0 ? (i = 0) : ((E *= E), (i = E * E * this.dot(this.grad3[y], c, u)));
    let S = 0.5 - f * f - m * m;
    S < 0 ? (n = 0) : ((S *= S), (n = S * S * this.dot(this.grad3[x], f, m)));
    let C = 0.5 - g * g - _ * _;
    return (
      C < 0 ? (s = 0) : ((C *= C), (s = C * C * this.dot(this.grad3[b], g, _))),
      70 * (i + n + s)
    );
  }
  noise3d(e, t, i) {
    let n, s, r, a;
    const o = (e + t + i) * (1 / 3),
      l = Math.floor(e + o),
      h = Math.floor(t + o),
      c = Math.floor(i + o),
      u = 1 / 6,
      d = (l + h + c) * u,
      p = e - (l - d),
      f = t - (h - d),
      m = i - (c - d);
    let g, _, v, A, y, x;
    p >= f
      ? f >= m
        ? ((g = 1), (_ = 0), (v = 0), (A = 1), (y = 1), (x = 0))
        : p >= m
        ? ((g = 1), (_ = 0), (v = 0), (A = 1), (y = 0), (x = 1))
        : ((g = 0), (_ = 0), (v = 1), (A = 1), (y = 0), (x = 1))
      : f < m
      ? ((g = 0), (_ = 0), (v = 1), (A = 0), (y = 1), (x = 1))
      : p < m
      ? ((g = 0), (_ = 1), (v = 0), (A = 0), (y = 1), (x = 1))
      : ((g = 0), (_ = 1), (v = 0), (A = 1), (y = 1), (x = 0));
    const b = p - g + u,
      E = f - _ + u,
      S = m - v + u,
      C = p - A + 2 * u,
      M = f - y + 2 * u,
      w = m - x + 2 * u,
      T = p - 1 + 0.5,
      I = f - 1 + 0.5,
      R = m - 1 + 0.5,
      P = 255 & l,
      D = 255 & h,
      L = 255 & c,
      F = this.perm[P + this.perm[D + this.perm[L]]] % 12,
      N = this.perm[P + g + this.perm[D + _ + this.perm[L + v]]] % 12,
      B = this.perm[P + A + this.perm[D + y + this.perm[L + x]]] % 12,
      k = this.perm[P + 1 + this.perm[D + 1 + this.perm[L + 1]]] % 12;
    let O = 0.6 - p * p - f * f - m * m;
    O < 0
      ? (n = 0)
      : ((O *= O), (n = O * O * this.dot3(this.grad3[F], p, f, m)));
    let U = 0.6 - b * b - E * E - S * S;
    U < 0
      ? (s = 0)
      : ((U *= U), (s = U * U * this.dot3(this.grad3[N], b, E, S)));
    let z = 0.6 - C * C - M * M - w * w;
    z < 0
      ? (r = 0)
      : ((z *= z), (r = z * z * this.dot3(this.grad3[B], C, M, w)));
    let G = 0.6 - T * T - I * I - R * R;
    return (
      G < 0
        ? (a = 0)
        : ((G *= G), (a = G * G * this.dot3(this.grad3[k], T, I, R))),
      32 * (n + s + r + a)
    );
  }
  noise4d(e, t, i, n) {
    const s = this.grad4,
      r = this.simplex,
      a = this.perm,
      o = (Math.sqrt(5) - 1) / 4,
      l = (5 - Math.sqrt(5)) / 20;
    let h, c, u, d, p;
    const f = (e + t + i + n) * o,
      m = Math.floor(e + f),
      g = Math.floor(t + f),
      _ = Math.floor(i + f),
      v = Math.floor(n + f),
      A = (m + g + _ + v) * l,
      y = e - (m - A),
      x = t - (g - A),
      b = i - (_ - A),
      E = n - (v - A),
      S =
        (y > x ? 32 : 0) +
        (y > b ? 16 : 0) +
        (x > b ? 8 : 0) +
        (y > E ? 4 : 0) +
        (x > E ? 2 : 0) +
        (b > E ? 1 : 0),
      C = r[S][0] >= 3 ? 1 : 0,
      M = r[S][1] >= 3 ? 1 : 0,
      w = r[S][2] >= 3 ? 1 : 0,
      T = r[S][3] >= 3 ? 1 : 0,
      I = r[S][0] >= 2 ? 1 : 0,
      R = r[S][1] >= 2 ? 1 : 0,
      P = r[S][2] >= 2 ? 1 : 0,
      D = r[S][3] >= 2 ? 1 : 0,
      L = r[S][0] >= 1 ? 1 : 0,
      F = r[S][1] >= 1 ? 1 : 0,
      N = r[S][2] >= 1 ? 1 : 0,
      B = r[S][3] >= 1 ? 1 : 0,
      k = y - C + l,
      O = x - M + l,
      U = b - w + l,
      z = E - T + l,
      G = y - I + 2 * l,
      V = x - R + 2 * l,
      Q = b - P + 2 * l,
      H = E - D + 2 * l,
      j = y - L + 3 * l,
      W = x - F + 3 * l,
      q = b - N + 3 * l,
      X = E - B + 3 * l,
      Y = y - 1 + 4 * l,
      K = x - 1 + 4 * l,
      Z = b - 1 + 4 * l,
      J = E - 1 + 4 * l,
      $ = 255 & m,
      ee = 255 & g,
      te = 255 & _,
      ie = 255 & v,
      ne = a[$ + a[ee + a[te + a[ie]]]] % 32,
      se = a[$ + C + a[ee + M + a[te + w + a[ie + T]]]] % 32,
      re = a[$ + I + a[ee + R + a[te + P + a[ie + D]]]] % 32,
      ae = a[$ + L + a[ee + F + a[te + N + a[ie + B]]]] % 32,
      oe = a[$ + 1 + a[ee + 1 + a[te + 1 + a[ie + 1]]]] % 32;
    let le = 0.6 - y * y - x * x - b * b - E * E;
    le < 0
      ? (h = 0)
      : ((le *= le), (h = le * le * this.dot4(s[ne], y, x, b, E)));
    let he = 0.6 - k * k - O * O - U * U - z * z;
    he < 0
      ? (c = 0)
      : ((he *= he), (c = he * he * this.dot4(s[se], k, O, U, z)));
    let ce = 0.6 - G * G - V * V - Q * Q - H * H;
    ce < 0
      ? (u = 0)
      : ((ce *= ce), (u = ce * ce * this.dot4(s[re], G, V, Q, H)));
    let ue = 0.6 - j * j - W * W - q * q - X * X;
    ue < 0
      ? (d = 0)
      : ((ue *= ue), (d = ue * ue * this.dot4(s[ae], j, W, q, X)));
    let de = 0.6 - Y * Y - K * K - Z * Z - J * J;
    return (
      de < 0
        ? (p = 0)
        : ((de *= de), (p = de * de * this.dot4(s[oe], Y, K, Z, J))),
      27 * (h + c + u + d + p)
    );
  }
}
new Vector2(), new Matrix4(), new Matrix4();
const zg = {
    uniforms: {
      tDiffuse: { value: null },
      resolution: { value: new Vector2() },
    },
    vertexShader:
      "varying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader:
      "uniform sampler2D tDiffuse;\n\n\t\tuniform vec2 resolution;\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvec2 texelSize = ( 1.0 / resolution );\n\t\t\tfloat result = 0.0;\n\n\t\t\tfor ( int i = - 2; i <= 2; i ++ ) {\n\n\t\t\t\tfor ( int j = - 2; j <= 2; j ++ ) {\n\n\t\t\t\t\tvec2 offset = ( vec2( float( i ), float( j ) ) ) * texelSize;\n\t\t\t\t\tresult += texture2D( tDiffuse, vUv + offset ).r;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tgl_FragColor = vec4( vec3( result / ( 5.0 * 5.0 ) ), 1.0 );\n\n\t\t}",
  },
  Gg = {
    defines: { PERSPECTIVE_CAMERA: 1, KERNEL_SIZE: 32 },
    uniforms: {
      tDiffuse: { value: null },
      tNormal: { value: null },
      tDepth: { value: null },
      tNoise: { value: null },
      kernel: { value: null },
      cameraNear: { value: null },
      cameraFar: { value: null },
      resolution: { value: new Vector2() },
      cameraProjectionMatrix: { value: new Matrix4() },
      cameraInverseProjectionMatrix: { value: new Matrix4() },
      kernelRadius: { value: 0.1 },
      minDistance: { value: 1e-4 },
      maxDistance: { value: 1e3 },
      intensity: { value: 1 },
    },
    vertexShader:
      "\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\tvUv = uv;\n\n\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n\t\t}",
    fragmentShader:
      "\n\n\t\tuniform sampler2D tDiffuse;\n\t\tuniform sampler2D tNormal;\n\t\tuniform sampler2D tDepth;\n\t\tuniform sampler2D tNoise;\n\n\t\tuniform vec3 kernel[ KERNEL_SIZE ];\n\n\t\tuniform vec2 resolution;\n\n\t\tuniform float cameraNear;\n\t\tuniform float cameraFar;\n\t\tuniform mat4 cameraProjectionMatrix;\n\t\tuniform mat4 cameraInverseProjectionMatrix;\n\n\t\tuniform float kernelRadius;\n\t\tuniform float minDistance; // avoid artifacts caused by neighbour fragments with minimal depth difference\n\t\tuniform float maxDistance; // avoid the influence of fragments which are too far away\n        uniform float intensity;\n\t\tvarying vec2 vUv;\n\n\t\t#include <packing>\n\n        float linearize_depth(in float depth){\n            float a = cameraFar / (cameraFar - cameraNear);\n            float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n            return a + b / depth;\n        }\n        \n        float reconstruct_depth(const in vec2 uv){\n            float depth = texture2D(tDepth, uv).x;\n            return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n        }\n        \n        float getDepth(vec2 uv) {\n            #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n                return linearize_depth(reconstruct_depth(uv));\n            #else\n                return texture2D(tDepth, uv).x;\n            #endif\n        }\n\t\t// float getDepth( const in vec2 screenPosition ) {\n\n\t\t// \treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t// }\n\n\t\tfloat getLinearDepth( const in vec2 screenPosition ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\t// float fragCoordZ = texture2D( tDepth, screenPosition ).x;\n                float fragCoordZ = getDepth(screenPosition);\n\t\t\t\tfloat viewZ = perspectiveDepthToViewZ( fragCoordZ, cameraNear, cameraFar );\n\t\t\t\treturn viewZToOrthographicDepth( viewZ, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn texture2D( tDepth, screenPosition ).x;\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tfloat getViewZ( const in float depth ) {\n\n\t\t\t#if PERSPECTIVE_CAMERA == 1\n\n\t\t\t\treturn perspectiveDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#else\n\n\t\t\t\treturn orthographicDepthToViewZ( depth, cameraNear, cameraFar );\n\n\t\t\t#endif\n\n\t\t}\n\n\t\tvec3 getViewPosition( const in vec2 screenPosition, const in float depth, const in float viewZ ) {\n\n\t\t\tfloat clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n\n\t\t\tvec4 clipPosition = vec4( ( vec3( screenPosition, depth ) - 0.5 ) * 2.0, 1.0 );\n\n\t\t\tclipPosition *= clipW; // unprojection.\n\n\t\t\treturn ( cameraInverseProjectionMatrix * clipPosition ).xyz;\n\n\t\t}\n\n\t\tvec3 getViewNormal( const in vec2 screenPosition ) {\n\n\t\t\treturn unpackRGBToNormal( texture2D( tNormal, screenPosition ).xyz );\n\n\t\t}\n\n\t\tvoid main() {\n\n            vec3 sampleNormal = texture2D( tNormal, vUv ).xyz;\n            if (length(sampleNormal) < 0.5) {\n                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);\n                return;\n            }\n            vec3 viewNormal = unpackRGBToNormal(sampleNormal);\n            \n\t\t\tfloat depth = getDepth( vUv );\n\t\t\tfloat viewZ = getViewZ( depth );\n            // float depth = texture2D( tDepth, vUv ).x;\n            // float logDepthBufFC = 2.0 / ( log( cameraFar + 1.0 ) / log(2.0) );\n            // float viewZ = -1.0 * (exp2(depth / (logDepthBufFC * 0.5)) - 1.0);\n\n\t\t\tvec3 viewPosition = getViewPosition( vUv, depth, viewZ );\n\t\t\t\n\t\t\tvec2 noiseScale = vec2( resolution.x / 4.0, resolution.y / 4.0 );\n\t\t\tvec3 random = vec3( texture2D( tNoise, vUv * noiseScale ).r );\n\n\t\t\t// compute matrix used to reorient a kernel vector\n\n\t\t\tvec3 tangent = normalize( random - viewNormal * dot( random, viewNormal ) );\n\t\t\tvec3 bitangent = cross( viewNormal, tangent );\n\t\t\tmat3 kernelMatrix = mat3( tangent, bitangent, viewNormal );\n\n\t\t float occlusion = 0.0;\n\n\t\t for ( int i = 0; i < KERNEL_SIZE; i ++ ) {\n\n\t\t\t\tvec3 sampleVector = kernelMatrix * kernel[ i ]; // reorient sample vector in view space\n\t\t\t\tvec3 samplePoint = viewPosition + ( sampleVector * kernelRadius ); // calculate sample point\n\n\t\t\t\tvec4 samplePointNDC = cameraProjectionMatrix * vec4( samplePoint, 1.0 );\n                // project point and calculate NDC\n\t\t\t\tsamplePointNDC /= samplePointNDC.w;\n\n\t\t\t\tvec2 samplePointUv = samplePointNDC.xy * 0.5 + 0.5; // compute uv coordinates\n\n\t\t\t\tfloat realDepth = getLinearDepth( samplePointUv ); // get linear depth from depth texture\n\t\t\t\tfloat sampleDepth = viewZToOrthographicDepth( samplePoint.z, cameraNear, cameraFar );\n\n                // realDepth = getDepth(samplePointUv);\n                // // realDepth = reconstruct_depth(samplePointUv);\n                // sampleDepth = viewZToPerspectiveDepth(samplePoint.z, cameraNear, cameraFar);\n\n                // sampleDepth = log2(sampleDepth + 1.0) / log2(cameraFar + 1.0);\n                // compute linear depth of the sample view Z value\n\t\t\t\tfloat delta = sampleDepth - realDepth;\n\n\t\t\t\tif ( delta > minDistance && delta < maxDistance ) {\n                // if ( delta > 0.00001 && delta < 0.0001) {\n                    // if fragment is before sample point, increase occlusion\n\n                    // occlusion += 1.0;\n\t\t\t\t\tocclusion += 1.0 * length(sampleVector) * intensity;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tocclusion = clamp( occlusion / float( KERNEL_SIZE ), 0.0, 1.0 );\n\n\t\t\tgl_FragColor = vec4( vec3((1.0 - occlusion) ), 1.0 );\n\n\t\t}",
  };
class Vg extends ug {
  constructor(e, t) {
    super(),
      (this.width = void 0 !== e ? e : 512),
      (this.height = void 0 !== t ? t : 512),
      (this.clear = !0),
      (this.kernelRadius = 0.5),
      (this.kernelSize = 32),
      (this.kernel = []),
      (this.noiseTexture = null),
      (this.intensity = 1),
      (this.minDistance = 1e-5),
      (this.maxDistance = 1e-4),
      this.generateSampleKernel(),
      this.generateRandomKernelRotations(),
      (this.ssaoMaterial = new ShaderMaterial({
        defines: Object.assign({}, Gg.defines),
        uniforms: In.clone(Gg.uniforms),
        vertexShader: Gg.vertexShader,
        fragmentShader: Gg.fragmentShader,
        blending: 0,
      })),
      (this.ssaoMaterial.uniforms.tNoise.value = this.noiseTexture),
      (this.ssaoMaterial.uniforms.kernel.value = this.kernel),
      (this.blurMaterial = new ShaderMaterial({
        defines: Object.assign({}, zg.defines),
        uniforms: In.clone(zg.uniforms),
        vertexShader: zg.vertexShader,
        fragmentShader: zg.fragmentShader,
      })),
      (this.copyMaterial = new ShaderMaterial({
        uniforms: In.clone(hg.uniforms),
        vertexShader: hg.vertexShader,
        fragmentShader: hg.fragmentShader,
        transparent: !0,
        depthTest: !1,
        depthWrite: !1,
        blendSrc: 208,
        blendDst: d,
        blendEquation: u,
        blendSrcAlpha: 206,
        blendDstAlpha: d,
        blendEquationAlpha: u,
      })),
      (this.fsQuad = new fg(null)),
      (this.originalClearColor = new Color()),
      (this.needsNormalTexture = !0),
      (this.needsDepthTexture = !0);
  }
  dispose() {
    this.ssaoRenderTarget.dispose(),
      this.blurRenderTarget.dispose(),
      this.normalMaterial.dispose(),
      this.blurMaterial.dispose(),
      this.copyMaterial.dispose(),
      this.depthRenderMaterial.dispose(),
      this.fsQuad.dispose();
  }
  render(e, t, i) {
    !1 === e.capabilities.isWebGL2 && (this.noiseTexture.format = 1024),
      this.ssaoRenderTarget ||
        (this.ssaoRenderTarget = new ut(i.width, i.height, { type: G })),
      this.blurRenderTarget ||
        (this.blurRenderTarget = new ut(i.width, i.height, { type: G }));
    const n = this.rendering,
      s = n.main.sceneRendering.normalTexture,
      r = n.main.sceneRendering.depthTexture;
    (this.ssaoMaterial.uniforms.tDiffuse.value = i.texture),
      (this.ssaoMaterial.uniforms.tNormal.value = s),
      (this.ssaoMaterial.uniforms.tDepth.value = r),
      (this.ssaoMaterial.uniforms.cameraNear.value = n.camera.near),
      (this.ssaoMaterial.uniforms.cameraFar.value = n.camera.far),
      this.ssaoMaterial.uniforms.resolution.value.set(i.width, i.height),
      this.ssaoMaterial.uniforms.cameraProjectionMatrix.value.copy(
        n.camera.projectionMatrix
      ),
      this.ssaoMaterial.uniforms.cameraInverseProjectionMatrix.value.copy(
        n.camera.projectionMatrixInverse
      ),
      (this.ssaoMaterial.uniforms.kernelRadius.value = this.kernelRadius),
      (this.ssaoMaterial.uniforms.minDistance.value = this.minDistance),
      (this.ssaoMaterial.uniforms.maxDistance.value = this.maxDistance),
      (this.ssaoMaterial.uniforms.intensity.value = this.intensity),
      this.renderPass(e, this.ssaoMaterial, this.ssaoRenderTarget),
      this.blurMaterial.uniforms.resolution.value.set(i.width, i.height),
      (this.blurMaterial.uniforms.tDiffuse.value =
        this.ssaoRenderTarget.texture),
      this.renderPass(e, this.blurMaterial, this.blurRenderTarget),
      (this.copyMaterial.uniforms.tDiffuse.value = i.texture),
      (this.copyMaterial.blending = 0),
      this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t),
      (this.copyMaterial.uniforms.tDiffuse.value =
        this.blurRenderTarget.texture),
      (this.copyMaterial.blending = 5),
      this.renderPass(e, this.copyMaterial, this.renderToScreen ? null : t);
  }
  renderPass(e, t, i, n, s) {
    e.getClearColor(this.originalClearColor);
    const r = e.getClearAlpha(),
      a = e.autoClear;
    e.setRenderTarget(i),
      (e.autoClear = !1),
      null != n && (e.setClearColor(n), e.setClearAlpha(s || 0), e.clear()),
      (this.fsQuad.material = t),
      this.fsQuad.render(e),
      (e.autoClear = a),
      e.setClearColor(this.originalClearColor),
      e.setClearAlpha(r);
  }
  setSize(e, t) {
    (this.width = e),
      (this.height = t),
      this.ssaoRenderTarget.setSize(e, t),
      this.blurRenderTarget.setSize(e, t);
  }
  generateSampleKernel() {
    const e = this.kernelSize,
      t = this.kernel;
    for (let i = 0; i < e; i++) {
      const n = new Vector3();
      (n.x = 2 * Math.random() - 1),
        (n.y = 2 * Math.random() - 1),
        (n.z = Math.random()),
        n.normalize();
      let s = i / e;
      (s = ze.lerp(0.1, 1, s * s)), n.multiplyScalar(s), t.push(n);
    }
  }
  generateRandomKernelRotations() {
    const e = new Ug(),
      t = new Float32Array(16);
    for (let i = 0; i < 16; i++) {
      const n = 2 * Math.random() - 1,
        s = 2 * Math.random() - 1,
        r = 0;
      t[i] = e.noise3d(n, s, r);
    }
    (this.noiseTexture = new Va(t, 4, 4, W, z)),
      (this.noiseTexture.wrapS = w),
      (this.noiseTexture.wrapT = w),
      (this.noiseTexture.needsUpdate = !0);
  }
}
class Qg extends Tg {
  constructor(e, t) {
    super(e, t),
      publicField(this, "name", "AO"),
      publicField(this, "_method", "ssao"),
      publicField(this, "_ssaoKernelRadius", 0.5),
      publicField(this, "_ssaoMinDistance", 1e-5),
      publicField(this, "_ssaoMaxDistance", 1e-4),
      publicField(this, "_ssaoIntensity", 1),
      publicField(this, "_lastMethod", "ssao"),
      publicField(this, "_lastEnabled", !1),
      (this.enabled = t.enabled),
      (this._method = t.method);
  }
  beginFrame() {
    this._lastEnabled === this.enabled
      ? this.enabled &&
        this._lastMethod !== this._method &&
        (this._disableOldMethod(), this._enableNewMethod())
      : this.enabled
      ? this._enableNewMethod()
      : this._disableOldMethod();
  }
  _disableOldMethod() {
    const e = this._lastMethod,
      t = this._rendering;
    "ssao" === e &&
      (this._ssaoPass && t.main.postprocessings.remove(this._ssaoPass),
      (this._ssaoPass = null));
  }
  _enableNewMethod() {
    const e = this._method,
      t = this._rendering;
    if ("ssao" === e) {
      const e = (this._ssaoPass = new Vg());
      (e.kernelRadius = this._ssaoKernelRadius),
        (e.minDistance = this._ssaoMinDistance),
        (e.maxDistance = this._ssaoMaxDistance),
        (e.intensity = this._ssaoIntensity),
        (e.renderOrder = 900),
        (e.rendering = t),
        t.main.postprocessings.add(e);
    }
  }
  afterRender() {}
  endFrame() {
    (this._lastEnabled = this.enabled), (this._lastMethod = this._method);
  }
  dispose() {
    this.enabled && this._disableOldMethod();
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
  get ssaoKernelRadius() {
    return this._ssaoKernelRadius;
  }
  set ssaoKernelRadius(e) {
    (this._ssaoKernelRadius = e),
      this._ssaoPass && (this._ssaoPass.kernelRadius = e);
  }
  get ssaoMinDistance() {
    return this._ssaoMinDistance;
  }
  set ssaoMinDistance(e) {
    (this._ssaoMinDistance = e),
      this._ssaoPass && (this._ssaoPass.minDistance = e);
  }
  get ssaoMaxDistance() {
    return this._ssaoMaxDistance;
  }
  set ssaoMaxDistance(e) {
    (this._ssaoMaxDistance = e),
      this._ssaoPass && (this._ssaoPass.maxDistance = e);
  }
  get ssaoIntensity() {
    return this._ssaoIntensity;
  }
  set ssaoIntensity(e) {
    (this._ssaoIntensity = e), this._ssaoPass && (this._ssaoPass.intensity = e);
  }
}
var Hg = { exports: {} },
  jg = { exports: {} },
  Wg = function (e) {
    return (
      !(!e || "string" == typeof e) &&
      (e instanceof Array ||
        Array.isArray(e) ||
        (e.length >= 0 &&
          (e.splice instanceof Function ||
            (Object.getOwnPropertyDescriptor(e, e.length - 1) &&
              "String" !== e.constructor.name))))
    );
  },
  qg = Array.prototype.concat,
  Xg = Array.prototype.slice,
  Yg = (jg.exports = function (e) {
    for (var t = [], i = 0, n = e.length; i < n; i++) {
      var s = e[i];
      Wg(s) ? (t = qg.call(t, Xg.call(s))) : t.push(s);
    }
    return t;
  });
Yg.wrap = function (e) {
  return function () {
    return e(Yg(arguments));
  };
};
var Kg = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  },
  Zg = jg.exports,
  Jg = Object.hasOwnProperty,
  $g = Object.create(null);
for (var e_ in Kg) Jg.call(Kg, e_) && ($g[Kg[e_]] = e_);
var t_ = (Hg.exports = { to: {}, get: {} });
function i_(e, t, i) {
  return Math.min(Math.max(t, e), i);
}
function n_(e) {
  var t = Math.round(e).toString(16).toUpperCase();
  return t.length < 2 ? "0" + t : t;
}
(t_.get = function (e) {
  var t, i;
  switch (e.substring(0, 3).toLowerCase()) {
    case "hsl":
      (t = t_.get.hsl(e)), (i = "hsl");
      break;
    case "hwb":
      (t = t_.get.hwb(e)), (i = "hwb");
      break;
    default:
      (t = t_.get.rgb(e)), (i = "rgb");
  }
  return t ? { model: i, value: t } : null;
}),
  (t_.get.rgb = function (e) {
    if (!e) return null;
    var t,
      i,
      n,
      s = [0, 0, 0, 1];
    if ((t = e.match(/^#([a-f0-9]{6})([a-f0-9]{2})?$/i))) {
      for (n = t[2], t = t[1], i = 0; i < 3; i++) {
        var r = 2 * i;
        s[i] = parseInt(t.slice(r, r + 2), 16);
      }
      n && (s[3] = parseInt(n, 16) / 255);
    } else if ((t = e.match(/^#([a-f0-9]{3,4})$/i))) {
      for (n = (t = t[1])[3], i = 0; i < 3; i++)
        s[i] = parseInt(t[i] + t[i], 16);
      n && (s[3] = parseInt(n + n, 16) / 255);
    } else if (
      (t = e.match(
        /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/
      ))
    ) {
      for (i = 0; i < 3; i++) s[i] = parseInt(t[i + 1], 0);
      t[4] &&
        (t[5] ? (s[3] = 0.01 * parseFloat(t[4])) : (s[3] = parseFloat(t[4])));
    } else {
      if (
        !(t = e.match(
          /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/
        ))
      )
        return (t = e.match(/^(\w+)$/))
          ? "transparent" === t[1]
            ? [0, 0, 0, 0]
            : Jg.call(Kg, t[1])
            ? (((s = Kg[t[1]])[3] = 1), s)
            : null
          : null;
      for (i = 0; i < 3; i++) s[i] = Math.round(2.55 * parseFloat(t[i + 1]));
      t[4] &&
        (t[5] ? (s[3] = 0.01 * parseFloat(t[4])) : (s[3] = parseFloat(t[4])));
    }
    for (i = 0; i < 3; i++) s[i] = i_(s[i], 0, 255);
    return (s[3] = i_(s[3], 0, 1)), s;
  }),
  (t_.get.hsl = function (e) {
    if (!e) return null;
    var t = e.match(
      /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/
    );
    if (t) {
      var i = parseFloat(t[4]);
      return [
        ((parseFloat(t[1]) % 360) + 360) % 360,
        i_(parseFloat(t[2]), 0, 100),
        i_(parseFloat(t[3]), 0, 100),
        i_(isNaN(i) ? 1 : i, 0, 1),
      ];
    }
    return null;
  }),
  (t_.get.hwb = function (e) {
    if (!e) return null;
    var t = e.match(
      /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/
    );
    if (t) {
      var i = parseFloat(t[4]);
      return [
        ((parseFloat(t[1]) % 360) + 360) % 360,
        i_(parseFloat(t[2]), 0, 100),
        i_(parseFloat(t[3]), 0, 100),
        i_(isNaN(i) ? 1 : i, 0, 1),
      ];
    }
    return null;
  }),
  (t_.to.hex = function () {
    var e = Zg(arguments);
    return (
      "#" +
      n_(e[0]) +
      n_(e[1]) +
      n_(e[2]) +
      (e[3] < 1 ? n_(Math.round(255 * e[3])) : "")
    );
  }),
  (t_.to.rgb = function () {
    var e = Zg(arguments);
    return e.length < 4 || 1 === e[3]
      ? "rgb(" +
          Math.round(e[0]) +
          ", " +
          Math.round(e[1]) +
          ", " +
          Math.round(e[2]) +
          ")"
      : "rgba(" +
          Math.round(e[0]) +
          ", " +
          Math.round(e[1]) +
          ", " +
          Math.round(e[2]) +
          ", " +
          e[3] +
          ")";
  }),
  (t_.to.rgb.percent = function () {
    var e = Zg(arguments),
      t = Math.round((e[0] / 255) * 100),
      i = Math.round((e[1] / 255) * 100),
      n = Math.round((e[2] / 255) * 100);
    return e.length < 4 || 1 === e[3]
      ? "rgb(" + t + "%, " + i + "%, " + n + "%)"
      : "rgba(" + t + "%, " + i + "%, " + n + "%, " + e[3] + ")";
  }),
  (t_.to.hsl = function () {
    var e = Zg(arguments);
    return e.length < 4 || 1 === e[3]
      ? "hsl(" + e[0] + ", " + e[1] + "%, " + e[2] + "%)"
      : "hsla(" + e[0] + ", " + e[1] + "%, " + e[2] + "%, " + e[3] + ")";
  }),
  (t_.to.hwb = function () {
    var e = Zg(arguments),
      t = "";
    return (
      e.length >= 4 && 1 !== e[3] && (t = ", " + e[3]),
      "hwb(" + e[0] + ", " + e[1] + "%, " + e[2] + "%" + t + ")"
    );
  }),
  (t_.to.keyword = function (e) {
    return $g[e.slice(0, 3)];
  });
const s_ = {
    aliceblue: [240, 248, 255],
    antiquewhite: [250, 235, 215],
    aqua: [0, 255, 255],
    aquamarine: [127, 255, 212],
    azure: [240, 255, 255],
    beige: [245, 245, 220],
    bisque: [255, 228, 196],
    black: [0, 0, 0],
    blanchedalmond: [255, 235, 205],
    blue: [0, 0, 255],
    blueviolet: [138, 43, 226],
    brown: [165, 42, 42],
    burlywood: [222, 184, 135],
    cadetblue: [95, 158, 160],
    chartreuse: [127, 255, 0],
    chocolate: [210, 105, 30],
    coral: [255, 127, 80],
    cornflowerblue: [100, 149, 237],
    cornsilk: [255, 248, 220],
    crimson: [220, 20, 60],
    cyan: [0, 255, 255],
    darkblue: [0, 0, 139],
    darkcyan: [0, 139, 139],
    darkgoldenrod: [184, 134, 11],
    darkgray: [169, 169, 169],
    darkgreen: [0, 100, 0],
    darkgrey: [169, 169, 169],
    darkkhaki: [189, 183, 107],
    darkmagenta: [139, 0, 139],
    darkolivegreen: [85, 107, 47],
    darkorange: [255, 140, 0],
    darkorchid: [153, 50, 204],
    darkred: [139, 0, 0],
    darksalmon: [233, 150, 122],
    darkseagreen: [143, 188, 143],
    darkslateblue: [72, 61, 139],
    darkslategray: [47, 79, 79],
    darkslategrey: [47, 79, 79],
    darkturquoise: [0, 206, 209],
    darkviolet: [148, 0, 211],
    deeppink: [255, 20, 147],
    deepskyblue: [0, 191, 255],
    dimgray: [105, 105, 105],
    dimgrey: [105, 105, 105],
    dodgerblue: [30, 144, 255],
    firebrick: [178, 34, 34],
    floralwhite: [255, 250, 240],
    forestgreen: [34, 139, 34],
    fuchsia: [255, 0, 255],
    gainsboro: [220, 220, 220],
    ghostwhite: [248, 248, 255],
    gold: [255, 215, 0],
    goldenrod: [218, 165, 32],
    gray: [128, 128, 128],
    green: [0, 128, 0],
    greenyellow: [173, 255, 47],
    grey: [128, 128, 128],
    honeydew: [240, 255, 240],
    hotpink: [255, 105, 180],
    indianred: [205, 92, 92],
    indigo: [75, 0, 130],
    ivory: [255, 255, 240],
    khaki: [240, 230, 140],
    lavender: [230, 230, 250],
    lavenderblush: [255, 240, 245],
    lawngreen: [124, 252, 0],
    lemonchiffon: [255, 250, 205],
    lightblue: [173, 216, 230],
    lightcoral: [240, 128, 128],
    lightcyan: [224, 255, 255],
    lightgoldenrodyellow: [250, 250, 210],
    lightgray: [211, 211, 211],
    lightgreen: [144, 238, 144],
    lightgrey: [211, 211, 211],
    lightpink: [255, 182, 193],
    lightsalmon: [255, 160, 122],
    lightseagreen: [32, 178, 170],
    lightskyblue: [135, 206, 250],
    lightslategray: [119, 136, 153],
    lightslategrey: [119, 136, 153],
    lightsteelblue: [176, 196, 222],
    lightyellow: [255, 255, 224],
    lime: [0, 255, 0],
    limegreen: [50, 205, 50],
    linen: [250, 240, 230],
    magenta: [255, 0, 255],
    maroon: [128, 0, 0],
    mediumaquamarine: [102, 205, 170],
    mediumblue: [0, 0, 205],
    mediumorchid: [186, 85, 211],
    mediumpurple: [147, 112, 219],
    mediumseagreen: [60, 179, 113],
    mediumslateblue: [123, 104, 238],
    mediumspringgreen: [0, 250, 154],
    mediumturquoise: [72, 209, 204],
    mediumvioletred: [199, 21, 133],
    midnightblue: [25, 25, 112],
    mintcream: [245, 255, 250],
    mistyrose: [255, 228, 225],
    moccasin: [255, 228, 181],
    navajowhite: [255, 222, 173],
    navy: [0, 0, 128],
    oldlace: [253, 245, 230],
    olive: [128, 128, 0],
    olivedrab: [107, 142, 35],
    orange: [255, 165, 0],
    orangered: [255, 69, 0],
    orchid: [218, 112, 214],
    palegoldenrod: [238, 232, 170],
    palegreen: [152, 251, 152],
    paleturquoise: [175, 238, 238],
    palevioletred: [219, 112, 147],
    papayawhip: [255, 239, 213],
    peachpuff: [255, 218, 185],
    peru: [205, 133, 63],
    pink: [255, 192, 203],
    plum: [221, 160, 221],
    powderblue: [176, 224, 230],
    purple: [128, 0, 128],
    rebeccapurple: [102, 51, 153],
    red: [255, 0, 0],
    rosybrown: [188, 143, 143],
    royalblue: [65, 105, 225],
    saddlebrown: [139, 69, 19],
    salmon: [250, 128, 114],
    sandybrown: [244, 164, 96],
    seagreen: [46, 139, 87],
    seashell: [255, 245, 238],
    sienna: [160, 82, 45],
    silver: [192, 192, 192],
    skyblue: [135, 206, 235],
    slateblue: [106, 90, 205],
    slategray: [112, 128, 144],
    slategrey: [112, 128, 144],
    snow: [255, 250, 250],
    springgreen: [0, 255, 127],
    steelblue: [70, 130, 180],
    tan: [210, 180, 140],
    teal: [0, 128, 128],
    thistle: [216, 191, 216],
    tomato: [255, 99, 71],
    turquoise: [64, 224, 208],
    violet: [238, 130, 238],
    wheat: [245, 222, 179],
    white: [255, 255, 255],
    whitesmoke: [245, 245, 245],
    yellow: [255, 255, 0],
    yellowgreen: [154, 205, 50],
  },
  r_ = {};
for (const xN of Object.keys(s_)) r_[s_[xN]] = xN;
const a_ = {
  rgb: { channels: 3, labels: "rgb" },
  hsl: { channels: 3, labels: "hsl" },
  hsv: { channels: 3, labels: "hsv" },
  hwb: { channels: 3, labels: "hwb" },
  cmyk: { channels: 4, labels: "cmyk" },
  xyz: { channels: 3, labels: "xyz" },
  lab: { channels: 3, labels: "lab" },
  lch: { channels: 3, labels: "lch" },
  hex: { channels: 1, labels: ["hex"] },
  keyword: { channels: 1, labels: ["keyword"] },
  ansi16: { channels: 1, labels: ["ansi16"] },
  ansi256: { channels: 1, labels: ["ansi256"] },
  hcg: { channels: 3, labels: ["h", "c", "g"] },
  apple: { channels: 3, labels: ["r16", "g16", "b16"] },
  gray: { channels: 1, labels: ["gray"] },
};
var o_ = a_;
for (const xN of Object.keys(a_)) {
  if (!("channels" in a_[xN]))
    throw new Error("missing channels property: " + xN);
  if (!("labels" in a_[xN]))
    throw new Error("missing channel labels property: " + xN);
  if (a_[xN].labels.length !== a_[xN].channels)
    throw new Error("channel and label counts mismatch: " + xN);
  const { channels: e, labels: t } = a_[xN];
  delete a_[xN].channels,
    delete a_[xN].labels,
    Object.defineProperty(a_[xN], "channels", { value: e }),
    Object.defineProperty(a_[xN], "labels", { value: t });
}
(a_.rgb.hsl = function (e) {
  const t = e[0] / 255,
    i = e[1] / 255,
    n = e[2] / 255,
    s = Math.min(t, i, n),
    r = Math.max(t, i, n),
    a = r - s;
  let o, l;
  r === s
    ? (o = 0)
    : t === r
    ? (o = (i - n) / a)
    : i === r
    ? (o = 2 + (n - t) / a)
    : n === r && (o = 4 + (t - i) / a),
    (o = Math.min(60 * o, 360)),
    o < 0 && (o += 360);
  const h = (s + r) / 2;
  return (
    (l = r === s ? 0 : h <= 0.5 ? a / (r + s) : a / (2 - r - s)),
    [o, 100 * l, 100 * h]
  );
}),
  (a_.rgb.hsv = function (e) {
    let t, i, n, s, r;
    const a = e[0] / 255,
      o = e[1] / 255,
      l = e[2] / 255,
      h = Math.max(a, o, l),
      c = h - Math.min(a, o, l),
      u = function (e) {
        return (h - e) / 6 / c + 0.5;
      };
    return (
      0 === c
        ? ((s = 0), (r = 0))
        : ((r = c / h),
          (t = u(a)),
          (i = u(o)),
          (n = u(l)),
          a === h
            ? (s = n - i)
            : o === h
            ? (s = 1 / 3 + t - n)
            : l === h && (s = 2 / 3 + i - t),
          s < 0 ? (s += 1) : s > 1 && (s -= 1)),
      [360 * s, 100 * r, 100 * h]
    );
  }),
  (a_.rgb.hwb = function (e) {
    const t = e[0],
      i = e[1];
    let n = e[2];
    const s = a_.rgb.hsl(e)[0],
      r = (1 / 255) * Math.min(t, Math.min(i, n));
    return (
      (n = 1 - (1 / 255) * Math.max(t, Math.max(i, n))), [s, 100 * r, 100 * n]
    );
  }),
  (a_.rgb.cmyk = function (e) {
    const t = e[0] / 255,
      i = e[1] / 255,
      n = e[2] / 255,
      s = Math.min(1 - t, 1 - i, 1 - n);
    return [
      100 * ((1 - t - s) / (1 - s) || 0),
      100 * ((1 - i - s) / (1 - s) || 0),
      100 * ((1 - n - s) / (1 - s) || 0),
      100 * s,
    ];
  }),
  (a_.rgb.keyword = function (e) {
    const t = r_[e];
    if (t) return t;
    let i,
      n = 1 / 0;
    for (const a of Object.keys(s_)) {
      const t =
        ((r = s_[a]),
        ((s = e)[0] - r[0]) ** 2 + (s[1] - r[1]) ** 2 + (s[2] - r[2]) ** 2);
      t < n && ((n = t), (i = a));
    }
    var s, r;
    return i;
  }),
  (a_.keyword.rgb = function (e) {
    return s_[e];
  }),
  (a_.rgb.xyz = function (e) {
    let t = e[0] / 255,
      i = e[1] / 255,
      n = e[2] / 255;
    (t = t > 0.04045 ? ((t + 0.055) / 1.055) ** 2.4 : t / 12.92),
      (i = i > 0.04045 ? ((i + 0.055) / 1.055) ** 2.4 : i / 12.92),
      (n = n > 0.04045 ? ((n + 0.055) / 1.055) ** 2.4 : n / 12.92);
    return [
      100 * (0.4124 * t + 0.3576 * i + 0.1805 * n),
      100 * (0.2126 * t + 0.7152 * i + 0.0722 * n),
      100 * (0.0193 * t + 0.1192 * i + 0.9505 * n),
    ];
  }),
  (a_.rgb.lab = function (e) {
    const t = a_.rgb.xyz(e);
    let i = t[0],
      n = t[1],
      s = t[2];
    (i /= 95.047),
      (n /= 100),
      (s /= 108.883),
      (i = i > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116),
      (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116),
      (s = s > 0.008856 ? s ** (1 / 3) : 7.787 * s + 16 / 116);
    return [116 * n - 16, 500 * (i - n), 200 * (n - s)];
  }),
  (a_.hsl.rgb = function (e) {
    const t = e[0] / 360,
      i = e[1] / 100,
      n = e[2] / 100;
    let s, r, a;
    if (0 === i) return (a = 255 * n), [a, a, a];
    s = n < 0.5 ? n * (1 + i) : n + i - n * i;
    const o = 2 * n - s,
      l = [0, 0, 0];
    for (let h = 0; h < 3; h++)
      (r = t + (1 / 3) * -(h - 1)),
        r < 0 && r++,
        r > 1 && r--,
        (a =
          6 * r < 1
            ? o + 6 * (s - o) * r
            : 2 * r < 1
            ? s
            : 3 * r < 2
            ? o + (s - o) * (2 / 3 - r) * 6
            : o),
        (l[h] = 255 * a);
    return l;
  }),
  (a_.hsl.hsv = function (e) {
    const t = e[0];
    let i = e[1] / 100,
      n = e[2] / 100,
      s = i;
    const r = Math.max(n, 0.01);
    (n *= 2), (i *= n <= 1 ? n : 2 - n), (s *= r <= 1 ? r : 2 - r);
    return [
      t,
      100 * (0 === n ? (2 * s) / (r + s) : (2 * i) / (n + i)),
      100 * ((n + i) / 2),
    ];
  }),
  (a_.hsv.rgb = function (e) {
    const t = e[0] / 60,
      i = e[1] / 100;
    let n = e[2] / 100;
    const s = Math.floor(t) % 6,
      r = t - Math.floor(t),
      a = 255 * n * (1 - i),
      o = 255 * n * (1 - i * r),
      l = 255 * n * (1 - i * (1 - r));
    switch (((n *= 255), s)) {
      case 0:
        return [n, l, a];
      case 1:
        return [o, n, a];
      case 2:
        return [a, n, l];
      case 3:
        return [a, o, n];
      case 4:
        return [l, a, n];
      case 5:
        return [n, a, o];
    }
  }),
  (a_.hsv.hsl = function (e) {
    const t = e[0],
      i = e[1] / 100,
      n = e[2] / 100,
      s = Math.max(n, 0.01);
    let r, a;
    a = (2 - i) * n;
    const o = (2 - i) * s;
    return (
      (r = i * s),
      (r /= o <= 1 ? o : 2 - o),
      (r = r || 0),
      (a /= 2),
      [t, 100 * r, 100 * a]
    );
  }),
  (a_.hwb.rgb = function (e) {
    const t = e[0] / 360;
    let i = e[1] / 100,
      n = e[2] / 100;
    const s = i + n;
    let r;
    s > 1 && ((i /= s), (n /= s));
    const a = Math.floor(6 * t),
      o = 1 - n;
    (r = 6 * t - a), 0 != (1 & a) && (r = 1 - r);
    const l = i + r * (o - i);
    let h, c, u;
    switch (a) {
      default:
      case 6:
      case 0:
        (h = o), (c = l), (u = i);
        break;
      case 1:
        (h = l), (c = o), (u = i);
        break;
      case 2:
        (h = i), (c = o), (u = l);
        break;
      case 3:
        (h = i), (c = l), (u = o);
        break;
      case 4:
        (h = l), (c = i), (u = o);
        break;
      case 5:
        (h = o), (c = i), (u = l);
    }
    return [255 * h, 255 * c, 255 * u];
  }),
  (a_.cmyk.rgb = function (e) {
    const t = e[0] / 100,
      i = e[1] / 100,
      n = e[2] / 100,
      s = e[3] / 100;
    return [
      255 * (1 - Math.min(1, t * (1 - s) + s)),
      255 * (1 - Math.min(1, i * (1 - s) + s)),
      255 * (1 - Math.min(1, n * (1 - s) + s)),
    ];
  }),
  (a_.xyz.rgb = function (e) {
    const t = e[0] / 100,
      i = e[1] / 100,
      n = e[2] / 100;
    let s, r, a;
    return (
      (s = 3.2406 * t + -1.5372 * i + -0.4986 * n),
      (r = -0.9689 * t + 1.8758 * i + 0.0415 * n),
      (a = 0.0557 * t + -0.204 * i + 1.057 * n),
      (s = s > 0.0031308 ? 1.055 * s ** (1 / 2.4) - 0.055 : 12.92 * s),
      (r = r > 0.0031308 ? 1.055 * r ** (1 / 2.4) - 0.055 : 12.92 * r),
      (a = a > 0.0031308 ? 1.055 * a ** (1 / 2.4) - 0.055 : 12.92 * a),
      (s = Math.min(Math.max(0, s), 1)),
      (r = Math.min(Math.max(0, r), 1)),
      (a = Math.min(Math.max(0, a), 1)),
      [255 * s, 255 * r, 255 * a]
    );
  }),
  (a_.xyz.lab = function (e) {
    let t = e[0],
      i = e[1],
      n = e[2];
    (t /= 95.047),
      (i /= 100),
      (n /= 108.883),
      (t = t > 0.008856 ? t ** (1 / 3) : 7.787 * t + 16 / 116),
      (i = i > 0.008856 ? i ** (1 / 3) : 7.787 * i + 16 / 116),
      (n = n > 0.008856 ? n ** (1 / 3) : 7.787 * n + 16 / 116);
    return [116 * i - 16, 500 * (t - i), 200 * (i - n)];
  }),
  (a_.lab.xyz = function (e) {
    let t, i, n;
    (i = (e[0] + 16) / 116), (t = e[1] / 500 + i), (n = i - e[2] / 200);
    const s = i ** 3,
      r = t ** 3,
      a = n ** 3;
    return (
      (i = s > 0.008856 ? s : (i - 16 / 116) / 7.787),
      (t = r > 0.008856 ? r : (t - 16 / 116) / 7.787),
      (n = a > 0.008856 ? a : (n - 16 / 116) / 7.787),
      (t *= 95.047),
      (i *= 100),
      (n *= 108.883),
      [t, i, n]
    );
  }),
  (a_.lab.lch = function (e) {
    const t = e[0],
      i = e[1],
      n = e[2];
    let s;
    (s = (360 * Math.atan2(n, i)) / 2 / Math.PI), s < 0 && (s += 360);
    return [t, Math.sqrt(i * i + n * n), s];
  }),
  (a_.lch.lab = function (e) {
    const t = e[0],
      i = e[1],
      n = (e[2] / 360) * 2 * Math.PI;
    return [t, i * Math.cos(n), i * Math.sin(n)];
  }),
  (a_.rgb.ansi16 = function (e, t = null) {
    const [i, n, s] = e;
    let r = null === t ? a_.rgb.hsv(e)[2] : t;
    if (((r = Math.round(r / 50)), 0 === r)) return 30;
    let a =
      30 +
      ((Math.round(s / 255) << 2) |
        (Math.round(n / 255) << 1) |
        Math.round(i / 255));
    return 2 === r && (a += 60), a;
  }),
  (a_.hsv.ansi16 = function (e) {
    return a_.rgb.ansi16(a_.hsv.rgb(e), e[2]);
  }),
  (a_.rgb.ansi256 = function (e) {
    const t = e[0],
      i = e[1],
      n = e[2];
    if (t === i && i === n)
      return t < 8
        ? 16
        : t > 248
        ? 231
        : Math.round(((t - 8) / 247) * 24) + 232;
    return (
      16 +
      36 * Math.round((t / 255) * 5) +
      6 * Math.round((i / 255) * 5) +
      Math.round((n / 255) * 5)
    );
  }),
  (a_.ansi16.rgb = function (e) {
    let t = e % 10;
    if (0 === t || 7 === t)
      return e > 50 && (t += 3.5), (t = (t / 10.5) * 255), [t, t, t];
    const i = 0.5 * (1 + ~~(e > 50));
    return [
      (1 & t) * i * 255,
      ((t >> 1) & 1) * i * 255,
      ((t >> 2) & 1) * i * 255,
    ];
  }),
  (a_.ansi256.rgb = function (e) {
    if (e >= 232) {
      const t = 10 * (e - 232) + 8;
      return [t, t, t];
    }
    let t;
    e -= 16;
    return [
      (Math.floor(e / 36) / 5) * 255,
      (Math.floor((t = e % 36) / 6) / 5) * 255,
      ((t % 6) / 5) * 255,
    ];
  }),
  (a_.rgb.hex = function (e) {
    const t = (
      ((255 & Math.round(e[0])) << 16) +
      ((255 & Math.round(e[1])) << 8) +
      (255 & Math.round(e[2]))
    )
      .toString(16)
      .toUpperCase();
    return "000000".substring(t.length) + t;
  }),
  (a_.hex.rgb = function (e) {
    const t = e.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
    if (!t) return [0, 0, 0];
    let i = t[0];
    3 === t[0].length &&
      (i = i
        .split("")
        .map((e) => e + e)
        .join(""));
    const n = parseInt(i, 16);
    return [(n >> 16) & 255, (n >> 8) & 255, 255 & n];
  }),
  (a_.rgb.hcg = function (e) {
    const t = e[0] / 255,
      i = e[1] / 255,
      n = e[2] / 255,
      s = Math.max(Math.max(t, i), n),
      r = Math.min(Math.min(t, i), n),
      a = s - r;
    let o, l;
    return (
      (o = a < 1 ? r / (1 - a) : 0),
      (l =
        a <= 0
          ? 0
          : s === t
          ? ((i - n) / a) % 6
          : s === i
          ? 2 + (n - t) / a
          : 4 + (t - i) / a),
      (l /= 6),
      (l %= 1),
      [360 * l, 100 * a, 100 * o]
    );
  }),
  (a_.hsl.hcg = function (e) {
    const t = e[1] / 100,
      i = e[2] / 100,
      n = i < 0.5 ? 2 * t * i : 2 * t * (1 - i);
    let s = 0;
    return n < 1 && (s = (i - 0.5 * n) / (1 - n)), [e[0], 100 * n, 100 * s];
  }),
  (a_.hsv.hcg = function (e) {
    const t = e[1] / 100,
      i = e[2] / 100,
      n = t * i;
    let s = 0;
    return n < 1 && (s = (i - n) / (1 - n)), [e[0], 100 * n, 100 * s];
  }),
  (a_.hcg.rgb = function (e) {
    const t = e[0] / 360,
      i = e[1] / 100,
      n = e[2] / 100;
    if (0 === i) return [255 * n, 255 * n, 255 * n];
    const s = [0, 0, 0],
      r = (t % 1) * 6,
      a = r % 1,
      o = 1 - a;
    let l = 0;
    switch (Math.floor(r)) {
      case 0:
        (s[0] = 1), (s[1] = a), (s[2] = 0);
        break;
      case 1:
        (s[0] = o), (s[1] = 1), (s[2] = 0);
        break;
      case 2:
        (s[0] = 0), (s[1] = 1), (s[2] = a);
        break;
      case 3:
        (s[0] = 0), (s[1] = o), (s[2] = 1);
        break;
      case 4:
        (s[0] = a), (s[1] = 0), (s[2] = 1);
        break;
      default:
        (s[0] = 1), (s[1] = 0), (s[2] = o);
    }
    return (
      (l = (1 - i) * n),
      [255 * (i * s[0] + l), 255 * (i * s[1] + l), 255 * (i * s[2] + l)]
    );
  }),
  (a_.hcg.hsv = function (e) {
    const t = e[1] / 100,
      i = t + (e[2] / 100) * (1 - t);
    let n = 0;
    return i > 0 && (n = t / i), [e[0], 100 * n, 100 * i];
  }),
  (a_.hcg.hsl = function (e) {
    const t = e[1] / 100,
      i = (e[2] / 100) * (1 - t) + 0.5 * t;
    let n = 0;
    return (
      i > 0 && i < 0.5
        ? (n = t / (2 * i))
        : i >= 0.5 && i < 1 && (n = t / (2 * (1 - i))),
      [e[0], 100 * n, 100 * i]
    );
  }),
  (a_.hcg.hwb = function (e) {
    const t = e[1] / 100,
      i = t + (e[2] / 100) * (1 - t);
    return [e[0], 100 * (i - t), 100 * (1 - i)];
  }),
  (a_.hwb.hcg = function (e) {
    const t = e[1] / 100,
      i = 1 - e[2] / 100,
      n = i - t;
    let s = 0;
    return n < 1 && (s = (i - n) / (1 - n)), [e[0], 100 * n, 100 * s];
  }),
  (a_.apple.rgb = function (e) {
    return [(e[0] / 65535) * 255, (e[1] / 65535) * 255, (e[2] / 65535) * 255];
  }),
  (a_.rgb.apple = function (e) {
    return [(e[0] / 255) * 65535, (e[1] / 255) * 65535, (e[2] / 255) * 65535];
  }),
  (a_.gray.rgb = function (e) {
    return [(e[0] / 100) * 255, (e[0] / 100) * 255, (e[0] / 100) * 255];
  }),
  (a_.gray.hsl = function (e) {
    return [0, 0, e[0]];
  }),
  (a_.gray.hsv = a_.gray.hsl),
  (a_.gray.hwb = function (e) {
    return [0, 100, e[0]];
  }),
  (a_.gray.cmyk = function (e) {
    return [0, 0, 0, e[0]];
  }),
  (a_.gray.lab = function (e) {
    return [e[0], 0, 0];
  }),
  (a_.gray.hex = function (e) {
    const t = 255 & Math.round((e[0] / 100) * 255),
      i = ((t << 16) + (t << 8) + t).toString(16).toUpperCase();
    return "000000".substring(i.length) + i;
  }),
  (a_.rgb.gray = function (e) {
    return [((e[0] + e[1] + e[2]) / 3 / 255) * 100];
  });
const l_ = o_;
function h_(e) {
  const t = (function () {
      const e = {},
        t = Object.keys(l_);
      for (let i = t.length, n = 0; n < i; n++)
        e[t[n]] = { distance: -1, parent: null };
      return e;
    })(),
    i = [e];
  for (t[e].distance = 0; i.length; ) {
    const e = i.pop(),
      n = Object.keys(l_[e]);
    for (let s = n.length, r = 0; r < s; r++) {
      const s = n[r],
        a = t[s];
      -1 === a.distance &&
        ((a.distance = t[e].distance + 1), (a.parent = e), i.unshift(s));
    }
  }
  return t;
}
function c_(e, t) {
  return function (i) {
    return t(e(i));
  };
}
function u_(e, t) {
  const i = [t[e].parent, e];
  let n = l_[t[e].parent][e],
    s = t[e].parent;
  for (; t[s].parent; )
    i.unshift(t[s].parent), (n = c_(l_[t[s].parent][s], n)), (s = t[s].parent);
  return (n.conversion = i), n;
}
const d_ = o_,
  p_ = function (e) {
    const t = h_(e),
      i = {},
      n = Object.keys(t);
    for (let s = n.length, r = 0; r < s; r++) {
      const e = n[r];
      null !== t[e].parent && (i[e] = u_(e, t));
    }
    return i;
  },
  f_ = {};
Object.keys(d_).forEach((e) => {
  (f_[e] = {}),
    Object.defineProperty(f_[e], "channels", { value: d_[e].channels }),
    Object.defineProperty(f_[e], "labels", { value: d_[e].labels });
  const t = p_(e);
  Object.keys(t).forEach((i) => {
    const n = t[i];
    (f_[e][i] = (function (e) {
      const t = function (...t) {
        const i = t[0];
        if (null == i) return i;
        i.length > 1 && (t = i);
        const n = e(t);
        if ("object" == typeof n)
          for (let e = n.length, s = 0; s < e; s++) n[s] = Math.round(n[s]);
        return n;
      };
      return "conversion" in e && (t.conversion = e.conversion), t;
    })(n)),
      (f_[e][i].raw = (function (e) {
        const t = function (...t) {
          const i = t[0];
          return null == i ? i : (i.length > 1 && (t = i), e(t));
        };
        return "conversion" in e && (t.conversion = e.conversion), t;
      })(n));
  });
});
var m_ = f_;
const g_ = Hg.exports,
  __ = m_,
  v_ = ["keyword", "gray", "hex"],
  A_ = {};
for (const xN of Object.keys(__)) A_[[...__[xN].labels].sort().join("")] = xN;
const y_ = {};
function x_(e, t) {
  if (!(this instanceof x_)) return new x_(e, t);
  if ((t && t in v_ && (t = null), t && !(t in __)))
    throw new Error("Unknown model: " + t);
  let i, n;
  if (null == e)
    (this.model = "rgb"), (this.color = [0, 0, 0]), (this.valpha = 1);
  else if (e instanceof x_)
    (this.model = e.model),
      (this.color = [...e.color]),
      (this.valpha = e.valpha);
  else if ("string" == typeof e) {
    const t = g_.get(e);
    if (null === t) throw new Error("Unable to parse color from string: " + e);
    (this.model = t.model),
      (n = __[this.model].channels),
      (this.color = t.value.slice(0, n)),
      (this.valpha = "number" == typeof t.value[n] ? t.value[n] : 1);
  } else if (e.length > 0) {
    (this.model = t || "rgb"), (n = __[this.model].channels);
    const i = Array.prototype.slice.call(e, 0, n);
    (this.color = C_(i, n)), (this.valpha = "number" == typeof e[n] ? e[n] : 1);
  } else if ("number" == typeof e)
    (this.model = "rgb"),
      (this.color = [(e >> 16) & 255, (e >> 8) & 255, 255 & e]),
      (this.valpha = 1);
  else {
    this.valpha = 1;
    const t = Object.keys(e);
    "alpha" in e &&
      (t.splice(t.indexOf("alpha"), 1),
      (this.valpha = "number" == typeof e.alpha ? e.alpha : 0));
    const n = t.sort().join("");
    if (!(n in A_))
      throw new Error(
        "Unable to parse color from object: " + JSON.stringify(e)
      );
    this.model = A_[n];
    const { labels: s } = __[this.model],
      r = [];
    for (i = 0; i < s.length; i++) r.push(e[s[i]]);
    this.color = C_(r);
  }
  if (y_[this.model])
    for (n = __[this.model].channels, i = 0; i < n; i++) {
      const e = y_[this.model][i];
      e && (this.color[i] = e(this.color[i]));
    }
  (this.valpha = Math.max(0, Math.min(1, this.valpha))),
    Object.freeze && Object.freeze(this);
}
x_.prototype = {
  toString() {
    return this.string();
  },
  toJSON() {
    return this[this.model]();
  },
  string(e) {
    let t = this.model in g_.to ? this : this.rgb();
    t = t.round("number" == typeof e ? e : 1);
    const i = 1 === t.valpha ? t.color : [...t.color, this.valpha];
    return g_.to[t.model](i);
  },
  percentString(e) {
    const t = this.rgb().round("number" == typeof e ? e : 1),
      i = 1 === t.valpha ? t.color : [...t.color, this.valpha];
    return g_.to.rgb.percent(i);
  },
  array() {
    return 1 === this.valpha ? [...this.color] : [...this.color, this.valpha];
  },
  object() {
    const e = {},
      { channels: t } = __[this.model],
      { labels: i } = __[this.model];
    for (let n = 0; n < t; n++) e[i[n]] = this.color[n];
    return 1 !== this.valpha && (e.alpha = this.valpha), e;
  },
  unitArray() {
    const e = this.rgb().color;
    return (
      (e[0] /= 255),
      (e[1] /= 255),
      (e[2] /= 255),
      1 !== this.valpha && e.push(this.valpha),
      e
    );
  },
  unitObject() {
    const e = this.rgb().object();
    return (
      (e.r /= 255),
      (e.g /= 255),
      (e.b /= 255),
      1 !== this.valpha && (e.alpha = this.valpha),
      e
    );
  },
  round(e) {
    return (
      (e = Math.max(e || 0, 0)),
      new x_([...this.color.map(b_(e)), this.valpha], this.model)
    );
  },
  alpha(e) {
    return void 0 !== e
      ? new x_([...this.color, Math.max(0, Math.min(1, e))], this.model)
      : this.valpha;
  },
  red: E_("rgb", 0, S_(255)),
  green: E_("rgb", 1, S_(255)),
  blue: E_("rgb", 2, S_(255)),
  hue: E_(
    ["hsl", "hsv", "hsl", "hwb", "hcg"],
    0,
    (e) => ((e % 360) + 360) % 360
  ),
  saturationl: E_("hsl", 1, S_(100)),
  lightness: E_("hsl", 2, S_(100)),
  saturationv: E_("hsv", 1, S_(100)),
  value: E_("hsv", 2, S_(100)),
  chroma: E_("hcg", 1, S_(100)),
  gray: E_("hcg", 2, S_(100)),
  white: E_("hwb", 1, S_(100)),
  wblack: E_("hwb", 2, S_(100)),
  cyan: E_("cmyk", 0, S_(100)),
  magenta: E_("cmyk", 1, S_(100)),
  yellow: E_("cmyk", 2, S_(100)),
  black: E_("cmyk", 3, S_(100)),
  x: E_("xyz", 0, S_(95.047)),
  y: E_("xyz", 1, S_(100)),
  z: E_("xyz", 2, S_(108.833)),
  l: E_("lab", 0, S_(100)),
  a: E_("lab", 1),
  b: E_("lab", 2),
  keyword(e) {
    return void 0 !== e ? new x_(e) : __[this.model].keyword(this.color);
  },
  hex(e) {
    return void 0 !== e ? new x_(e) : g_.to.hex(this.rgb().round().color);
  },
  hexa(e) {
    if (void 0 !== e) return new x_(e);
    const t = this.rgb().round().color;
    let i = Math.round(255 * this.valpha)
      .toString(16)
      .toUpperCase();
    return 1 === i.length && (i = "0" + i), g_.to.hex(t) + i;
  },
  rgbNumber() {
    const e = this.rgb().color;
    return ((255 & e[0]) << 16) | ((255 & e[1]) << 8) | (255 & e[2]);
  },
  luminosity() {
    const e = this.rgb().color,
      t = [];
    for (const [i, n] of e.entries()) {
      const e = n / 255;
      t[i] = e <= 0.04045 ? e / 12.92 : ((e + 0.055) / 1.055) ** 2.4;
    }
    return 0.2126 * t[0] + 0.7152 * t[1] + 0.0722 * t[2];
  },
  contrast(e) {
    const t = this.luminosity(),
      i = e.luminosity();
    return t > i ? (t + 0.05) / (i + 0.05) : (i + 0.05) / (t + 0.05);
  },
  level(e) {
    const t = this.contrast(e);
    return t >= 7 ? "AAA" : t >= 4.5 ? "AA" : "";
  },
  isDark() {
    const e = this.rgb().color;
    return (2126 * e[0] + 7152 * e[1] + 722 * e[2]) / 1e4 < 128;
  },
  isLight() {
    return !this.isDark();
  },
  negate() {
    const e = this.rgb();
    for (let t = 0; t < 3; t++) e.color[t] = 255 - e.color[t];
    return e;
  },
  lighten(e) {
    const t = this.hsl();
    return (t.color[2] += t.color[2] * e), t;
  },
  darken(e) {
    const t = this.hsl();
    return (t.color[2] -= t.color[2] * e), t;
  },
  saturate(e) {
    const t = this.hsl();
    return (t.color[1] += t.color[1] * e), t;
  },
  desaturate(e) {
    const t = this.hsl();
    return (t.color[1] -= t.color[1] * e), t;
  },
  whiten(e) {
    const t = this.hwb();
    return (t.color[1] += t.color[1] * e), t;
  },
  blacken(e) {
    const t = this.hwb();
    return (t.color[2] += t.color[2] * e), t;
  },
  grayscale() {
    const e = this.rgb().color,
      t = 0.3 * e[0] + 0.59 * e[1] + 0.11 * e[2];
    return x_.rgb(t, t, t);
  },
  fade(e) {
    return this.alpha(this.valpha - this.valpha * e);
  },
  opaquer(e) {
    return this.alpha(this.valpha + this.valpha * e);
  },
  rotate(e) {
    const t = this.hsl();
    let i = t.color[0];
    return (i = (i + e) % 360), (i = i < 0 ? 360 + i : i), (t.color[0] = i), t;
  },
  mix(e, t) {
    if (!e || !e.rgb)
      throw new Error(
        'Argument to "mix" was not a Color instance, but rather an instance of ' +
          typeof e
      );
    const i = e.rgb(),
      n = this.rgb(),
      s = void 0 === t ? 0.5 : t,
      r = 2 * s - 1,
      a = i.alpha() - n.alpha(),
      o = ((r * a == -1 ? r : (r + a) / (1 + r * a)) + 1) / 2,
      l = 1 - o;
    return x_.rgb(
      o * i.red() + l * n.red(),
      o * i.green() + l * n.green(),
      o * i.blue() + l * n.blue(),
      i.alpha() * s + n.alpha() * (1 - s)
    );
  },
};
for (const xN of Object.keys(__)) {
  if (v_.includes(xN)) continue;
  const { channels: e } = __[xN];
  (x_.prototype[xN] = function (...e) {
    return this.model === xN
      ? new x_(this)
      : e.length > 0
      ? new x_(e, xN)
      : new x_(
          [
            ...((t = __[this.model][xN].raw(this.color)),
            Array.isArray(t) ? t : [t]),
            this.valpha,
          ],
          xN
        );
    var t;
  }),
    (x_[xN] = function (...t) {
      let i = t[0];
      return "number" == typeof i && (i = C_(t, e)), new x_(i, xN);
    });
}
function b_(e) {
  return function (t) {
    return (function (e, t) {
      return Number(e.toFixed(t));
    })(t, e);
  };
}
function E_(e, t, i) {
  e = Array.isArray(e) ? e : [e];
  for (const n of e) (y_[n] || (y_[n] = []))[t] = i;
  return (
    (e = e[0]),
    function (n) {
      let s;
      return void 0 !== n
        ? (i && (n = i(n)), (s = this[e]()), (s.color[t] = n), s)
        : ((s = this[e]().color[t]), i && (s = i(s)), s);
    }
  );
}
function S_(e) {
  return function (t) {
    return Math.max(0, Math.min(e, t));
  };
}
function C_(e, t) {
  for (let i = 0; i < t; i++) "number" != typeof e[i] && (e[i] = 0);
  return e;
}
const M_ = x_;

function colorToVec4(e) {
  if (!e) return new Vector4();
  if (e.isColor) return [e.r, e.g, e.b, 1];
  const t = colorToArr4(e);
  return new Vector4(t[0], t[1], t[2], t[3]);
}
function colorToVec3(e) {
  if (!e) return new Vector3();
  const t = colorToArr4(e);
  return new Vector3(t[0], t[1], t[2]);
}

// TODO
function colorToArr4(e) {
  if (!e) return [1, 1, 1, 1];
  const t = M_(e),
    i = t.unitArray();

  return [i[0], i[1], i[2], i[3] || t.valpha];
}

function colorToArr3(e) {
  if (!e) return [1, 1, 1];
  const t = M_(e).unitArray();
  return [t[0], t[1], t[2]];
}
const P_ = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        colorToVec4: colorToVec4,
        colorToVec3: colorToVec3,
        colorToArr4: colorToArr4,
        colorToArr3: colorToArr3,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  ),
  D_ = { mvt_emissive: { value: null }, mvt_emissiveIntensity: { value: 1 } },
  L_ = {
    selectedObjectColor: { value: [1, 1, 0, 0.5] },
    selectedObjectIndex: { value: -1 },
    selectedObjectColorMode: { value: 0 },
  },
  F_ = { keepSize: { value: !1 }, zoomUnits: { value: 1 } },
  N_ = (e, t = []) => {
    for (let i of t)
      Object.defineProperty(e, i, {
        get: function () {
          return this.uniforms[i].value;
        },
        set: function (e) {
          this.uniforms[i].value = e;
        },
      });
  },
  B_ = (e, t = []) => {
    for (let i of t)
      Object.defineProperty(e, i, {
        get: function () {
          return this.uniforms[i].value;
        },
        set: function (e) {
          this.uniforms[i].value = colorToVec4(e);
        },
      });
  },
  k_ = (e, t = []) => {
    for (let [i, n, s] of t)
      Object.defineProperty(e, i, {
        get: function () {
          return this.uniforms[n].value;
        },
        set: function (e) {
          this.uniforms[n].value = s ? s(e) : e;
        },
      });
  },
  O_ = (e, t = []) => {
    for (let [i, n] of t)
      Object.defineProperty(e, i, {
        get: function () {
          return !!this.defines[n];
        },
        set: function (e) {
          this[i] !== e &&
            (e ? (this.defines[n] = !0) : delete this.defines[n],
            (this.needsUpdate = !0));
        },
      });
  },
  U_ = (e) => {
    Object.defineProperties(e, {
      selectedObjectColor: {
        get: function () {
          return this.uniforms.selectedObjectColor.value;
        },
        set: function (e) {
          this.uniforms.selectedObjectColor.value = e;
        },
      },
      selectedObjectColorMode: {
        get: function () {
          return this.uniforms.selectedObjectColorMode.value;
        },
        set: function (e) {
          this.uniforms.selectedObjectColorMode.value = e;
        },
      },
      selectedObjectIndex: {
        get: function () {
          return this.uniforms.selectedObjectIndex.value;
        },
        set: function (e) {
          this.uniforms.selectedObjectIndex.value = e;
        },
      },
      selective: {
        get: function () {
          return !!this.defines.MVT_ENABLE_SELECTIVE;
        },
        set: function (e) {
          this.selective !== e &&
            (e
              ? (this.defines.MVT_ENABLE_SELECTIVE = !0)
              : delete this.defines.MVT_ENABLE_SELECTIVE,
            (this.needsUpdate = !0));
        },
      },
    });
  },
  z_ = (e) => {
    Object.defineProperties(e, {
      keepSize: {
        get: function () {
          return this.uniforms.keepSize.value;
        },
        set: function (e) {
          this.uniforms.keepSize.value = e;
        },
      },
      zoomUnits: {
        get: function () {
          return this.uniforms.zoomUnits.value;
        },
        set: function (e) {
          this.uniforms.zoomUnits.value = e;
        },
      },
      zoomUnitsUniform: {
        get: function () {
          return this.uniforms.zoomUnits;
        },
        set: function (e) {
          this.uniforms.zoomUnits = e;
        },
      },
    });
  },
  G_ = (e) => {
    Object.defineProperties(e, {
      emissiveEnabled: {
        get: function () {
          return this.defines.MVT_EMISSIVE_UNIFORM || !1;
        },
        set: function (e) {
          e
            ? (this.defines.MVT_EMISSIVE_UNIFORM = !0)
            : delete this.defines.MVT_EMISSIVE_UNIFORM;
        },
      },
      emissive: {
        get: function () {
          return this.uniforms.mvt_emissive.value;
        },
        set: function (e) {
          e
            ? (this.defines.MVT_EMISSIVE_COLOR = !0)
            : delete this.defines.MVT_EMISSIVE_COLOR,
            (this.uniforms.mvt_emissive.value = e);
        },
      },
      emissiveIntensity: {
        get: function () {
          return this.uniforms.mvt_emissiveIntensity.value;
        },
        set: function (e) {
          this.uniforms.mvt_emissiveIntensity.value = e;
        },
      },
    });
  },
  V_ = (e) => {
    const t = (e && e.source && e.source.data && e.source.data.height) || null;
    if (null === t) return null;
    const i = Math.log2(t) - 2,
      n = 1 / t;
    return {
      texelWidth: 1 / (3 * Math.max(Math.pow(2, i), 112)),
      texelHeight: n,
      maxMip: i,
    };
  },
  Q_ = {
    tDiffuse: { value: null },
    tNormal: { value: null },
    tMetalness: { value: null },
    tEnhancement: { value: null },
    tEnhancementScale: { value: new Vector2(20, 20) },
    tDepth: { value: null },
    cameraNear: { value: null },
    cameraFar: { value: null },
    resolution: { value: new Vector2() },
    cameraProjectionMatrix: { value: new Matrix4() },
    cameraInverseProjectionMatrix: { value: new Matrix4() },
    mvt_viewInverseMatrix: { value: new Matrix4() },
    mvt_normalInverseMatrix: { value: new Matrix3() },
    opacity: { value: 0.5 },
    maxDistance: { value: 180 },
    cameraRange: { value: 0 },
    thickness: { value: 0.018 },
    logDepthBufFC: { value: 1 },
    threshold: { value: 0.6 },
  };
class H_ extends ShaderMaterial {
  constructor(e) {
    super(),
      (this.vertexShader =
        "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}"),
      (this.fragmentShader =
        'precision highp sampler2D;\n#define GLSLIFY 1\nvarying vec2 vUv;\nuniform sampler2D tDepth;\nuniform sampler2D tNormal;\nuniform sampler2D tMetalness;\nuniform sampler2D tDiffuse;\n\n#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)\nuniform sampler2D tEnhancement;\nuniform vec2 tEnhancementScale;\nuniform mat4 mvt_viewInverseMatrix;\nuniform mat3 mvt_normalInverseMatrix;\n#endif\n\nuniform float cameraRange;\nuniform vec2 resolution;\nuniform float opacity;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform float maxDistance;\nuniform float thickness;\nuniform mat4 cameraProjectionMatrix;\nuniform mat4 cameraInverseProjectionMatrix;\nuniform float threshold; // 控制反射最低阈值，低于此致的不计算，可提高性能\n\n#include <packing>\nfloat pointToLineDistance(vec3 x0, vec3 x1, vec3 x2) {\n    //x0: point, x1: linePointA, x2: linePointB\n    //https://mathworld.wolfram.com/Point-LineDistance3-Dimensional.html\n    return length(cross(x0 - x1, x0 - x2)) / length(x2 - x1);\n}\nfloat pointPlaneDistance(vec3 point, vec3 planePoint, vec3 planeNormal) {\n    // https://mathworld.wolfram.com/Point-PlaneDistance.html\n    //// https://en.wikipedia.org/wiki/Plane_(geometry)\n    //// http://paulbourke.net/geometry/pointlineplane/\n    float a = planeNormal.x, b = planeNormal.y, c = planeNormal.z;\n    float x0 = point.x, y0 = point.y, z0 = point.z;\n    float x = planePoint.x, y = planePoint.y, z = planePoint.z;\n    float d = -(a * x + b * y + c * z);\n    float distance = (a * x0 + b * y0 + c * z0 + d) / sqrt(a * a + b * b + c * c);\n    return distance;\n}\n// https://stackoverflow.com/questions/40373184/world-space-position-from-logarithmic-depth-buffer\nfloat linearize_depth(in float depth) {\n    float a = cameraFar / (cameraFar - cameraNear);\n    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n    return a + b / depth;\n}\n\nfloat reconstruct_depth(const in vec2 uv) {\n    float depth = texture2D(tDepth, uv).x;\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat getDepth(const in vec2 uv) {\n    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n    return linearize_depth(reconstruct_depth(uv)); //exp2(logDepth * 2.0 / logDepthBufFC) - 1.0;\n    #else\n    return texture2D(tDepth, uv).x;\n    #endif\n\n}\nfloat getViewZ(const in float depth) {\n    #ifdef PERSPECTIVE_CAMERA\n    return perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    #else\n    return orthographicDepthToViewZ(depth, cameraNear, cameraFar);\n    #endif\n}\nvec3 getViewPosition(const in vec2 uv, const in float depth/*clip space*/, const in float clipW) {\n    vec4 clipPosition = vec4((vec3(uv, depth) - 0.5) * 2.0, 1.0);//ndc\n    clipPosition *= clipW; //clip\n    return (cameraInverseProjectionMatrix * clipPosition).xyz;//view\n}\n#if defined(MVT_SSR_USE_ENHANCEMENT_MAP)\nvec3 getWorldPositionFromDepth(float depth) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);\n    vec4 viewSpacePosition = cameraInverseProjectionMatrix * clipSpacePosition;\n    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;\n    return worldSpacePosition.xyz / worldSpacePosition.w;\n}\n#endif\nvec3 getViewNormal(const in vec2 uv) {\n    return unpackRGBToNormal(texture2D(tNormal, uv).xyz);\n}\nvec2 viewPositionToXY(vec3 viewPosition) {\n    vec2 xy;\n    vec4 clip = cameraProjectionMatrix * vec4(viewPosition, 1);\n    xy = clip.xy;//clip\n    float clipW = clip.w;\n    xy /= clipW;//NDC\n    xy = (xy + 1.) / 2.;//uv\n    xy *= resolution;//screen\n    return xy;\n}\nvoid main() {\n\n    gl_FragColor = texture2D(tDiffuse, vUv);\n   \n    vec3 sampleNormal = texture2D(tNormal, vUv).xyz;\n    if (length(sampleNormal) < 0.9) {\n        return;\n    }\n\n    vec3 viewNormal = unpackRGBToNormal(sampleNormal);\n    float depth = getDepth(vUv);\n    #ifdef SELECTIVE\n    // 完全没反射的表面直接剔除\n    float intensity = texture2D(tMetalness, vUv).x;\n\n    #if defined(MVT_SSR_USE_ENHANCEMENT_MAP)\n        float dirAlpha = dot(viewNormal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));\n        if (dirAlpha > 0.5) {\n            vec3 worldSpacePosition = getWorldPositionFromDepth(depth);\n            vec2 enhancementUv = vec2(mod(worldSpacePosition.x, tEnhancementScale.x) / tEnhancementScale.x, \n                    mod(worldSpacePosition.y, tEnhancementScale.y) / tEnhancementScale.y);\n            float enhancement = texture2D(tEnhancement, enhancementUv).x;\n            intensity += (1.0 - enhancement);\n        }\n        // gl_FragColor = vec4(enhancement, 0.0, 0.0, 1.0);\n        // return;\n    #endif\n\n         \n    if(intensity < threshold)\n        return;\n    intensity -= threshold;\n    intensity *= 1.0 / (1.0 - threshold);\n    #endif\n\n    \n    float viewZ = getViewZ(depth);\n    // z值已经超过相机远端距离\n    if(-viewZ >= cameraFar)\n        return;\n\n    float clipW = cameraProjectionMatrix[2][3] * viewZ + cameraProjectionMatrix[3][3];\n    // 相机视图下的当前片元坐标\n    vec3 viewPosition = getViewPosition(vUv, depth, clipW);\n\n    // 起点的屏幕坐标\n    vec2 d0 = gl_FragCoord.xy;\n    vec2 d1;\n\n    #ifdef PERSPECTIVE_CAMERA\n    // 入射光方向，相机在原点，方向即为坐标的单位向量\n    vec3 viewIncidentDir = normalize(viewPosition);\n    // 反射光方向\n    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);\n    #else\n    vec3 viewIncidentDir = vec3(0, 0, -1);\n    vec3 viewReflectDir = reflect(viewIncidentDir, viewNormal);\n    #endif\n\n    // 反射光线最长距离由输入的最大反射距离和入射角决定\n    float maxReflectRayLen = maxDistance / dot(-viewIncidentDir, viewNormal);\n    // dot(a,b)==length(a)*length(b)*cos(theta) // https://www.mathsisfun.com/algebra/vectors-dot-product.html\n    // if(a.isNormalized&&b.isNormalized) dot(a,b)==cos(theta)\n    // maxDistance/maxReflectRayLen=cos(theta)\n    // maxDistance/maxReflectRayLen==dot(a,b)\n    // maxReflectRayLen==maxDistance/dot(a,b)\n\n    // 反射最远距离下的坐标点\n    vec3 d1viewPosition = viewPosition + viewReflectDir * maxReflectRayLen;\n    #ifdef PERSPECTIVE_CAMERA\n    if(d1viewPosition.z > -cameraNear) {\n            //https://tutorial.math.lamar.edu/Classes/CalcIII/EqnsOfLines.aspx\n        // 应该是处理反射点溢出相机视野外的情况\n        float t = (-cameraNear - viewPosition.z) / viewReflectDir.z;\n        d1viewPosition = viewPosition + viewReflectDir * t;\n    }\n    #endif\n    // 反射最远点在屏幕上的位置\n    d1 = viewPositionToXY(d1viewPosition);\n\n    // 屏幕像素距离\n    float totalLen = length(d1 - d0);\n    float xLen = d1.x - d0.x;\n    float yLen = d1.y - d0.y;\n    // 最大步数取xy方向较大的一个方向，每次步进一个像素\n    float totalStep = max(abs(xLen), abs(yLen));\n    // x方向每次步进的大小\n    float xSpan = xLen / totalStep;\n    // y方向每次步进的大小\n    float ySpan = yLen / totalStep;\n    // 步进次数最大是屏幕对角线距离（应该是横向或者纵向的最大值），实际次数要远小于这个\n    for(float i = 0.; i < float(MAX_STEP); i += 4.0) {\n        if(i >= totalStep)\n            break;\n        // march到的当前屏幕像素\n        vec2 xy = vec2(d0.x + i * xSpan, d0.y + i * ySpan);\n        // 跑到屏幕外march失败\n        if(xy.x < 0. || xy.x > resolution.x || xy.y < 0. || xy.y > resolution.y)\n            break;\n        // 当前百分比\n        float s = length(xy - d0) / totalLen;\n        // 当前uv\n        vec2 uv = xy / resolution;\n        // 计算当前点的各项参数，和一开始一样\n        float d = getDepth(uv);\n        float vZ = getViewZ(d);\n        // gl_FragColor = vec4(-vZ / 1000., 0.0, 0.0, 1.0);\n        // return;\n        if(-vZ >= cameraFar)\n            continue;\n        float cW = cameraProjectionMatrix[2][3] * vZ + cameraProjectionMatrix[3][3];\n        // 得到当前点的viewposition\n        vec3 vP = getViewPosition(uv, d, cW);\n\n        // 得到当前反射线的z\n        #ifdef PERSPECTIVE_CAMERA\n            // https://comp.nus.edu.sg/~lowkl/publications/lowk_persp_interp_techrep.pdf\n        float recipVPZ = 1. / viewPosition.z;\n        float viewReflectRayZ = 1. / (recipVPZ + s * (1. / d1viewPosition.z - recipVPZ));\n        #else\n        float viewReflectRayZ = viewPosition.z + s * (d1viewPosition.z - viewPosition.z);\n        #endif\n\n        // if(viewReflectRayZ>vZ) continue; // will cause "npm run make-screenshot webgl_postprocessing_ssr" high probability hang.\n        // https://github.com/mrdoob/three.js/pull/21539#issuecomment-821061164\n        // 反射线的z小于当前点的z,否则就是被遮挡住了\n        if(viewReflectRayZ <= vZ) {\n\n            bool hit;\n            #ifdef INFINITE_THICK\n            hit = true;\n            #else\n            // 点到射线的距离\n            float away = pointToLineDistance(vP, viewPosition, d1viewPosition);\n\n            // minThickness没看懂，和横向邻接点的viewx差值，大约代表了此处一个像素和实际距离的比例，乘3.0？\n            float minThickness;\n            vec2 xyNeighbor = xy;\n            xyNeighbor.x += 1.;\n            vec2 uvNeighbor = xyNeighbor / resolution;\n            vec3 vPNeighbor = getViewPosition(uvNeighbor, d, cW);\n            minThickness = vPNeighbor.x - vP.x;\n            minThickness *= 3.;\n            float tk = max(minThickness, thickness);\n            // 当距离小于阈值时才算是真正相交\n            hit = away <= tk;\n            #endif\n\n            if(hit) {\n                vec3 vN = getViewNormal(uv);\n                // 相交到物体的反面了，march无效\n                if(dot(viewReflectDir, vN) >= 0.)\n                    continue;\n                float distance = pointPlaneDistance(vP, viewPosition, viewNormal);\n                // march距离超过最大\n                if(distance > maxDistance)\n                    break;\n                float op = opacity;\n                // 随着距离减弱反射，防止反射突然消失\n                #ifdef DISTANCE_ATTENUATION\n                float ratio = 1. - (distance / maxDistance);\n                float attenuation = ratio * ratio;\n                op = opacity * attenuation;\n                #endif\n                // 菲涅尔反射定律，与视野角度偏离越大，颜色权重越大\n                #ifdef FRESNEL\n                float fresnelCoe = (dot(viewIncidentDir, viewReflectDir) + 1.) / 2.;\n                op *= fresnelCoe;\n                #endif\n                // 读取反射颜色赋给当前片元\n                gl_FragColor = texture2D(tDiffuse, vUv);\n                vec4 reflectColor = texture2D(tDiffuse, uv);\n                reflectColor.a = op;\n                #ifdef SELECTIVE\n                reflectColor.a *= intensity;\n                #endif\n                gl_FragColor.rgb = mix(gl_FragColor.rgb, reflectColor.rgb, reflectColor.a);\n                // gl_FragColor = vec4(1.0, 0, 0, 1.0);\n                return;\n                \n                // break;\n            }\n        }\n    }\n    // gl_FragColor = texture2D(tDiffuse, vUv);\n}'),
      (this.uniforms = In.clone(Q_)),
      (this.defines = {
        MAX_STEP: 0,
        PERSPECTIVE_CAMERA: !0,
        DISTANCE_ATTENUATION: !0,
        FRESNEL: !0,
        INFINITE_THICK: !1,
        SELECTIVE: !1,
      }),
      N_(this, [
        "tDiffuse",
        "tNormal",
        "tDepth",
        "tMetalness",
        "cameraNear",
        "cameraFar",
        "threshold",
        "thickness",
        "opacity",
        "tEnhancementScale",
      ]),
      O_(this, []),
      Object.defineProperties(this, {
        tEnhancement: {
          get: function () {
            return this.uniforms.tEnhancement.value;
          },
          set: function (e) {
            e
              ? ((this.uniforms.tEnhancement.value = e),
                (this.defines.MVT_SSR_USE_ENHANCEMENT_MAP = !0))
              : ((this.uniforms.tEnhancement.value = null),
                delete this.defines.MVT_SSR_USE_ENHANCEMENT_MAP);
          },
        },
      }),
      this.setValues(e);
  }
  dispose() {
    let e = ["tEnhancement", "tDiffuse", "tNormal", "tDepth", "tMetalness"];
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      this.uniforms[i] &&
        this.uniforms[i].value &&
        this.uniforms[i].value.dispose();
    }
    super.dispose();
  }
}
class j_ extends ug {
  constructor() {
    super();
    const e = (this.material = new H_());
    (e.defines.DISTANCE_ATTENUATION = !0),
      (e.defines.SELECTIVE = !0),
      (this.fsQuad = new fg(null)),
      (this.needsSwap = !0),
      (this.needsMetallicRoughTexture = !0),
      (this.needsNormalTexture = !0),
      (this.needsDepthTexture = !0);
  }
  render(e, t, i) {
    const n = this.rendering,
      s = n.main.sceneRendering,
      r = n.camera,
      a = this.material;
    (a.uniforms.tDiffuse.value = i.texture),
      (a.uniforms.tDepth.value = s.depthTexture),
      (a.uniforms.tNormal.value = s.normalTexture),
      (a.uniforms.tMetalness.value = s.metallicRoughTexture);
    const o = new Vector2(i.width, i.height);
    (a.uniforms.resolution.value = o),
      (a.defines.MAX_STEP = Math.min(512, Math.sqrt(o.x * o.x + o.y * o.y))),
      a.uniforms.cameraProjectionMatrix.value.copy(r.projectionMatrix),
      a.uniforms.cameraInverseProjectionMatrix.value.copy(
        r.projectionMatrixInverse
      ),
      a.uniforms.mvt_viewInverseMatrix.value.copy(r.matrixWorld),
      a.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(
        r.matrixWorldInverse
      ),
      (a.uniforms.cameraNear.value = r.near),
      (a.uniforms.cameraFar.value = r.far),
      (this.fsQuad.material = a),
      e.setRenderTarget(this.renderToScreen ? null : t),
      e.clear(),
      this.fsQuad.render(e);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class W_ extends Tg {
  constructor(e, t) {
    super(e, t),
      publicField(this, "name", "reflection"),
      publicField(this, "_method", "ssr"),
      publicField(this, "_lastMethod", "ssr"),
      publicField(this, "_lastEnabled", !1),
      (this.enabled = t.enabled),
      (this._method = t.method);
  }
  beginFrame() {
    this._lastEnabled === this.enabled
      ? this.enabled &&
        this._lastMethod !== this._method &&
        (this._disableOldMethod(), this._enableNewMethod())
      : this.enabled
      ? this._enableNewMethod()
      : this._disableOldMethod();
  }
  _disableOldMethod() {
    const e = this._lastMethod,
      t = this._rendering;
    "ssr" === e &&
      (this._ssrPass && t.main.postprocessings.remove(this._ssrPass),
      (this._ssrPass = null));
  }
  _enableNewMethod() {
    const e = this._method,
      t = this._rendering;
    if ("ssr" === e) {
      const e = (this._ssrPass = new j_());
      (e.renderOrder = 800), (e.rendering = t), t.main.postprocessings.add(e);
    }
  }
  afterRender() {}
  endFrame() {
    (this._lastEnabled = this.enabled), (this._lastMethod = this._method);
  }
  dispose() {
    this.enabled && this._disableOldMethod();
  }
  get method() {
    return this._method;
  }
  set method(e) {
    this._method = e;
  }
}
class q_ {
  constructor(e, t) {
    publicField(this, "_features", []),
      (this._rendering = e),
      (this._bloom = new Pg(this._rendering)),
      this._features.push(this._bloom),
      (this._antialias = new kg(this._rendering, t.antialias)),
      this._features.push(this._antialias),
      (this._ao = new Qg(this._rendering, t.ao)),
      this._features.push(this._ao),
      (this._reflection = new W_(this._rendering, t.reflection)),
      this._features.push(this._reflection),
      (this._bufferView = new Og(this._rendering)),
      this._features.push(this._bufferView),
      (this._stats = new Lg(this._rendering)),
      this._features.push(this._stats);
  }
  beginFrame() {
    for (const e of this._features) e.beginFrame();
  }
  afterRender() {
    for (const e of this._features) e.afterRender && e.afterRender();
  }
  endFrame() {
    for (const e of this._features) e.endFrame();
  }
  updateReqirements(e) {
    for (const t of this._features)
      t.enabled &&
        (t.needsEmissiveTexture && (e.needsEmissiveTexture = !0),
        t.needsNormalTexture && (e.needsNormalTexture = !0),
        t.needsDepthTexture && (e.needsDepthTexture = !0),
        t.needsMetallicRoughTexture && (e.needsMetallicRoughTexture = !0));
  }
  get ao() {
    return this._ao;
  }
  get bloom() {
    return this._bloom;
  }
  get stats() {
    return this._stats;
  }
  get bufferView() {
    return this._bufferView;
  }
  get antialias() {
    return this._antialias;
  }
  get reflection() {
    return this._reflection;
  }
  get features() {
    return this._features;
  }
}
class X_ {
  constructor(e, t) {
    publicField(this, "_rendering"),
      publicField(this, "_requirements"),
      publicField(this, "_useMRT", !1),
      publicField(this, "_lastUseMRT", null),
      publicField(this, "_sceneRendering"),
      publicField(this, "_features"),
      publicField(this, "_postprocessings"),
      (e._main = this),
      (this._rendering = e),
      (this._requirements = new _g(e)),
      (this._features = new q_(e, t.features)),
      (this._postprocessings = new bg(e)),
      (e.postprocessings = this._postprocessings),
      (e.features = this._features);
  }
  beginFrame() {
    const e = this._rendering;
    if (e.isUseMRTChanged || !this._sceneRendering) {
      let t = !0;
      this._sceneRendering &&
        ((t = this._sceneRendering.useFastEmissiveMethod),
        this._sceneRendering.dispose()),
        e.useMRT
          ? (this._sceneRendering = new gg(this._rendering))
          : (this._sceneRendering = new mg(this._rendering)),
        (this._sceneRendering.useFastEmissiveMethod = t);
    }
    this._features.beginFrame(),
      this._requirements.beginFrame(),
      this._sceneRendering.beginFrame(),
      this._postprocessings.beginFrame();
  }
  render() {
    const e = this._sceneRendering,
      t = this._features,
      i = this._postprocessings;
    let n = null;
    i.validCount > 0 && (n = i.renderTarget1),
      (e.renderTarget = n),
      e.render(),
      t.afterRender(),
      i.validCount > 0 && i.render();
  }
  endFrame() {
    this._requirements.endFrame(),
      this._features.endFrame(),
      this._sceneRendering.endFrame(),
      this._postprocessings.endFrame();
  }
  setSize(e, t) {
    this._rendering;
  }
  get sceneRendering() {
    return this._sceneRendering;
  }
  get useFastEmissiveMethod() {
    return this._sceneRendering.useFastEmissiveMethod;
  }
  set useFastEmissiveMethod(e) {
    this._sceneRendering.useFastEmissiveMethod = e;
  }
  get antialias() {
    return !0;
  }
  get rendering() {
    return this._rendering;
  }
  get requirements() {
    return this._requirements;
  }
  get features() {
    return this._features;
  }
  get postprocessings() {
    return this._postprocessings;
  }
}
class Y_ {
  constructor(e) {
    publicField(this, "_rendering"), (this._rendering = e);
  }
  get enabled() {
    return this._rendering.renderer.shadowMap.enabled;
  }
  set enabled(e) {
    this._rendering.renderer.shadowMap.enabled = e;
  }
}
class K_ {
  constructor(e) {
    publicField(this, "_needsCreate", !1),
      publicField(this, "_fogStartFactor", 0.5),
      publicField(this, "_rendering"),
      publicField(this, "_enabled", !1),
      publicField(this, "_density", 1),
      publicField(this, "_color", new Color(16777215)),
      publicField(this, "_skyColorStartFactor", 0.5),
      publicField(this, "_altitudeBottom", 0),
      publicField(this, "_altitudeTop", 1e3),
      publicField(this, "createFog", () => {
        const e = this._rendering;
        if (e.useMrt) {
          const t = e.composition;
          (t.useFog = !0),
            (t.fogDensity = this._density),
            (t.fogSkyColorStartFactor = this._skyColorStartFactor),
            (t.fogAltitudeTop = this._altitudeTop),
            (t.fogAltitudeBottom = this._altitudeBottom);
        } else {
          e.scene.fog = new Ma(this._color, 1, 1e3);
        }
      }),
      publicField(this, "destoryFog", () => {
        const e = this._rendering;
        if (e.useMrt) {
          e.composition.useFog = !1;
        } else {
          e.scene.fog = null;
        }
      }),
      (this._rendering = e);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    e !== this._enabled &&
      ((this._enabled = e), e ? (this._needsCreate = !0) : this.destoryFog());
  }
  set color(e) {
    this._color = e;
    const t = this._rendering,
      i = t.useMrt;
    if (this._enabled)
      if (i) {
        t.composition.fogColor = e;
      } else t.scene.fog && (t.scene.fog.color = e);
  }
  get color() {
    return this._color;
  }
  get density() {
    return this._density;
  }
  set density(e) {
    this._density = e;
    const t = this._rendering,
      i = t.useMrt;
    if (this._enabled)
      if (i) {
        t.composition.fogDensity = this._density;
      } else t.scene.fog && (t.scene.fog.density = e);
  }
  get skyColorStartFactor() {
    return this._skyColorStartFactor;
  }
  set skyColorStartFactor(e) {
    this._skyColorStartFactor = e;
    const t = this._rendering,
      i = t.useMrt;
    if (this._enabled && i) {
      t.composition.fogSkyColorStartFactor = this._skyColorStartFactor;
    }
  }
  get altitudeTop() {
    return this._altitudeTop;
  }
  set altitudeTop(e) {
    this._altitudeTop = e;
    const t = this._rendering,
      i = t.useMrt;
    if (this._enabled && i) {
      t.composition.fogAltitudeTop = this._altitudeTop;
    }
  }
  get altitudeBottom() {
    return this._altitudeBottom;
  }
  set altitudeBottom(e) {
    this._altitudeBottom = e;
    const t = this._rendering,
      i = t.useMrt;
    if (this._enabled && i) {
      t.composition.fogAltitudeBottom = this._altitudeBottom;
    }
  }
  render() {
    if (this._enabled)
      if (
        (this._needsCreate &&
          ((this._needsCreate = !1),
          this.createFog(),
          this._rendering.requestRender()),
        this._rendering.useMrt)
      )
        this._rendering.scene.fog &&
          ((this._rendering.scene.fog = null), this._rendering.requestRender());
      else {
        let e = this._rendering.scene.fog;
        e ||
          (this.createFog(),
          (e = this._rendering.scene.fog),
          this._rendering.requestRender());
        const t = this._rendering.camera.far;
        (e.near = this._fogStartFactor * t), (e.far = t);
      }
  }
}
class Z_ extends ug {
  constructor(e, t, i = null, n = null, s = null) {
    super(),
      (this.scene = e),
      (this.camera = t),
      (this.overrideMaterial = i),
      (this.clearColor = n),
      (this.clearAlpha = s),
      (this.clear = !0),
      (this.clearDepth = !1),
      (this.needsSwap = !1),
      (this._oldClearColor = new Color());
  }
  render(e, t, i) {
    const n = e.autoClear;
    let s, r;
    (e.autoClear = !1),
      null !== this.overrideMaterial &&
        ((r = this.scene.overrideMaterial),
        (this.scene.overrideMaterial = this.overrideMaterial)),
      null !== this.clearColor &&
        (e.getClearColor(this._oldClearColor),
        e.setClearColor(this.clearColor)),
      null !== this.clearAlpha &&
        ((s = e.getClearAlpha()), e.setClearAlpha(this.clearAlpha)),
      1 == this.clearDepth && e.clearDepth(),
      e.setRenderTarget(this.renderToScreen ? null : i),
      !0 === this.clear &&
        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil),
      e.render(this.scene, this.camera),
      null !== this.clearColor && e.setClearColor(this._oldClearColor),
      null !== this.clearAlpha && e.setClearAlpha(s),
      null !== this.overrideMaterial && (this.scene.overrideMaterial = r),
      (e.autoClear = n);
  }
}
class J_ extends ug {
  constructor(e, t, i, n) {
    super(),
      (this.strength = void 0 !== t ? t : 1),
      (this.radius = i),
      (this.threshold = n),
      (this.resolution =
        void 0 !== e ? new Vector2(e.x, e.y) : new Vector2(256, 256)),
      (this.clearColor = new Color(0, 0, 0));
    const s = { minFilter: L, magFilter: L, format: Q, type: G };
    (this.renderTargetsHorizontal = []),
      (this.renderTargetsVertical = []),
      (this.nMips = 5);
    let r = Math.round(this.resolution.x / 2),
      a = Math.round(this.resolution.y / 2);
    (this.renderTargetBright = new ut(r, a, s)),
      (this.renderTargetBright.texture.name = "UnrealBloomPass.bright"),
      (this.renderTargetBright.texture.generateMipmaps = !1);
    for (let c = 0; c < this.nMips; c++) {
      const e = new ut(r, a, s);
      (e.texture.name = "UnrealBloomPass.h" + c),
        (e.texture.generateMipmaps = !1),
        this.renderTargetsHorizontal.push(e);
      const t = new ut(r, a, s);
      (t.texture.name = "UnrealBloomPass.v" + c),
        (t.texture.generateMipmaps = !1),
        this.renderTargetsVertical.push(t),
        (r = Math.round(r / 2)),
        (a = Math.round(a / 2));
    }
    void 0 === Eg &&
      console.error("THREE.UnrealBloomPass relies on LuminosityHighPassShader");
    const o = Eg;
    (this.highPassUniforms = In.clone(o.uniforms)),
      (this.highPassUniforms.luminosityThreshold.value = n),
      (this.highPassUniforms.smoothWidth.value = 0.01),
      (this.materialHighPassFilter = new ShaderMaterial({
        uniforms: this.highPassUniforms,
        vertexShader: o.vertexShader,
        fragmentShader: o.fragmentShader,
        defines: {},
      })),
      (this.separableBlurMaterials = []);
    const l = [3, 5, 7, 9, 11];
    (r = Math.round(this.resolution.x / 2)),
      (a = Math.round(this.resolution.y / 2));
    for (let c = 0; c < this.nMips; c++)
      this.separableBlurMaterials.push(this.getSeperableBlurMaterial(l[c])),
        (this.separableBlurMaterials[c].uniforms.texSize.value = new Vector2(
          r,
          a
        )),
        (r = Math.round(r / 2)),
        (a = Math.round(a / 2));
    (this.compositeMaterial = this.getCompositeMaterial(this.nMips)),
      (this.compositeMaterial.uniforms.blurTexture1.value =
        this.renderTargetsVertical[0].texture),
      (this.compositeMaterial.uniforms.blurTexture2.value =
        this.renderTargetsVertical[1].texture),
      (this.compositeMaterial.uniforms.blurTexture3.value =
        this.renderTargetsVertical[2].texture),
      (this.compositeMaterial.uniforms.blurTexture4.value =
        this.renderTargetsVertical[3].texture),
      (this.compositeMaterial.uniforms.blurTexture5.value =
        this.renderTargetsVertical[4].texture),
      (this.compositeMaterial.uniforms.bloomStrength.value = t),
      (this.compositeMaterial.uniforms.bloomRadius.value = 0.1),
      (this.compositeMaterial.needsUpdate = !0);
    (this.compositeMaterial.uniforms.bloomFactors.value = [
      1, 0.8, 0.6, 0.4, 0.2,
    ]),
      (this.bloomTintColors = [
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
        new Vector3(1, 1, 1),
      ]),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors),
      void 0 === hg &&
        console.error("THREE.UnrealBloomPass relies on CopyShader");
    const h = hg;
    (this.copyUniforms = In.clone(h.uniforms)),
      (this.copyUniforms.opacity.value = 1),
      (this.materialCopy = new ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: h.vertexShader,
        fragmentShader: h.fragmentShader,
        blending: 2,
        depthTest: !1,
        depthWrite: !1,
        transparent: !0,
      })),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this._oldClearColor = new Color()),
      (this.oldClearAlpha = 1),
      (this.basic = new Oi()),
      (this.fsQuad = new fg(null));
  }
  dispose() {
    for (let e = 0; e < this.renderTargetsHorizontal.length; e++)
      this.renderTargetsHorizontal[e].dispose();
    for (let e = 0; e < this.renderTargetsVertical.length; e++)
      this.renderTargetsVertical[e].dispose();
    this.renderTargetBright.dispose();
  }
  setSize(e, t) {
    let i = Math.round(e / 2),
      n = Math.round(t / 2);
    this.renderTargetBright.setSize(i, n);
    for (let s = 0; s < this.nMips; s++)
      this.renderTargetsHorizontal[s].setSize(i, n),
        this.renderTargetsVertical[s].setSize(i, n),
        (this.separableBlurMaterials[s].uniforms.texSize.value = new Vector2(
          i,
          n
        )),
        (i = Math.round(i / 2)),
        (n = Math.round(n / 2));
  }
  render(e, t, i, n, s) {
    e.getClearColor(this._oldClearColor),
      (this.oldClearAlpha = e.getClearAlpha());
    const r = e.autoClear;
    (e.autoClear = !1),
      e.setClearColor(this.clearColor, 0),
      s && e.state.buffers.stencil.setTest(!1),
      this.renderToScreen &&
        ((this.fsQuad.material = this.basic),
        (this.basic.map = i.texture),
        e.setRenderTarget(null),
        e.clear(),
        this.fsQuad.render(e)),
      (this.highPassUniforms.tDiffuse.value = i.texture),
      (this.highPassUniforms.luminosityThreshold.value = this.threshold),
      (this.fsQuad.material = this.materialHighPassFilter),
      e.setRenderTarget(this.renderTargetBright),
      e.clear(),
      this.fsQuad.render(e);
    let a = this.renderTargetBright;
    for (let o = 0; o < this.nMips; o++)
      (this.fsQuad.material = this.separableBlurMaterials[o]),
        (this.separableBlurMaterials[o].uniforms.colorTexture.value =
          a.texture),
        (this.separableBlurMaterials[o].uniforms.direction.value =
          J_.BlurDirectionX),
        e.setRenderTarget(this.renderTargetsHorizontal[o]),
        e.clear(),
        this.fsQuad.render(e),
        (this.separableBlurMaterials[o].uniforms.colorTexture.value =
          this.renderTargetsHorizontal[o].texture),
        (this.separableBlurMaterials[o].uniforms.direction.value =
          J_.BlurDirectionY),
        e.setRenderTarget(this.renderTargetsVertical[o]),
        e.clear(),
        this.fsQuad.render(e),
        (a = this.renderTargetsVertical[o]);
    (this.fsQuad.material = this.compositeMaterial),
      (this.compositeMaterial.uniforms.bloomStrength.value = this.strength),
      (this.compositeMaterial.uniforms.bloomRadius.value = this.radius),
      (this.compositeMaterial.uniforms.bloomTintColors.value =
        this.bloomTintColors),
      e.setRenderTarget(this.renderTargetsHorizontal[0]),
      e.clear(),
      this.fsQuad.render(e),
      (this.fsQuad.material = this.materialCopy),
      (this.copyUniforms.tDiffuse.value =
        this.renderTargetsHorizontal[0].texture),
      s && e.state.buffers.stencil.setTest(!0),
      this.renderToScreen
        ? (e.setRenderTarget(null), this.fsQuad.render(e))
        : (e.setRenderTarget(i), this.fsQuad.render(e)),
      e.setClearColor(this._oldClearColor, this.oldClearAlpha),
      (e.autoClear = r);
  }
  getSeperableBlurMaterial(e) {
    return new ShaderMaterial({
      defines: { KERNEL_RADIUS: e, SIGMA: e },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new Vector2(0.5, 0.5) },
        direction: { value: new Vector2(0.5, 0.5) },
      },
      vertexShader:
        "varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }",
      fragmentShader:
        "#include <common>\n                varying vec2 vUv;\n                uniform sampler2D colorTexture;\n                uniform vec2 texSize;\n                uniform vec2 direction;\n                float gaussianPdf(in float x, in float sigma) {\n                    return 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n                }\n                void main() {\n                    vec2 invSize = 1.0 / texSize;                    float fSigma = float(SIGMA);                    float weightSum = gaussianPdf(0.0, fSigma);                    float alphaSum = 0.0;                    vec3 diffuseSum = texture2D( colorTexture, vUv).rgb * weightSum;                    for( int i = 1; i < KERNEL_RADIUS; i ++ ) {                        float x = float(i);                        float w = gaussianPdf(x, fSigma);                        vec2 uvOffset = direction * invSize * x;                        vec4 sample1 = texture2D( colorTexture, vUv + uvOffset);                        vec4 sample2 = texture2D( colorTexture, vUv - uvOffset);                        diffuseSum += (sample1.rgb + sample2.rgb) * w;                        alphaSum += (sample1.a + sample2.a) * w;                        weightSum += 2.0 * w;                    }                    gl_FragColor = vec4(diffuseSum/weightSum, 1.0);\n                }",
    });
  }
  getCompositeMaterial(e) {
    return new ShaderMaterial({
      defines: { NUM_MIPS: e },
      uniforms: {
        blurTexture1: { value: null },
        blurTexture2: { value: null },
        blurTexture3: { value: null },
        blurTexture4: { value: null },
        blurTexture5: { value: null },
        dirtTexture: { value: null },
        bloomStrength: { value: 1 },
        bloomFactors: { value: null },
        bloomTintColors: { value: null },
        bloomRadius: { value: 0 },
      },
      vertexShader:
        "varying vec2 vUv;\n                void main() {\n                    vUv = uv;\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n                }",
      fragmentShader:
        "varying vec2 vUv;\n                uniform sampler2D blurTexture1;\n                uniform sampler2D blurTexture2;\n                uniform sampler2D blurTexture3;\n                uniform sampler2D blurTexture4;\n                uniform sampler2D blurTexture5;\n                uniform sampler2D dirtTexture;\n                uniform float bloomStrength;\n                uniform float bloomRadius;\n                uniform float bloomFactors[NUM_MIPS];\n                uniform vec3 bloomTintColors[NUM_MIPS];\n                float lerpBloomFactor(const in float factor) {\n                    float mirrorFactor = 1.2 - factor;\n                    return mix(factor, mirrorFactor, bloomRadius);\n                }\n                void main() {\n                    gl_FragColor = bloomStrength *\n                    (lerpBloomFactor(bloomFactors[0]) * vec4(bloomTintColors[0], 1.0) * texture2D(blurTexture1, vUv) +\n                    lerpBloomFactor(bloomFactors[1]) * vec4(bloomTintColors[1], 1.0) * texture2D(blurTexture2, vUv) +\n                    lerpBloomFactor(bloomFactors[2]) * vec4(bloomTintColors[2], 1.0) * texture2D(blurTexture3, vUv) +\n                    lerpBloomFactor(bloomFactors[3]) * vec4(bloomTintColors[3], 1.0) * texture2D(blurTexture4, vUv) +\n                    lerpBloomFactor(bloomFactors[4]) * vec4(bloomTintColors[4], 1.0) * texture2D(blurTexture5, vUv) );\n                }",
    });
  }
}
(J_.BlurDirectionX = new Vector2(1, 0)),
  (J_.BlurDirectionY = new Vector2(0, 1));
const $_ = new Color(),
  ev = new Color(0);
let tv = 0;
class iv {
  constructor(e) {
    publicField(this, "_rendering"),
      publicField(this, "_strength", 3),
      publicField(this, "_threshold", 0),
      publicField(this, "_radius", 0.5),
      publicField(this, "_needsSetTexture", !1),
      publicField(this, "_enabled", !1),
      publicField(this, "_renderPass", null),
      publicField(this, "_useMrt", !1),
      publicField(this, "setPresetMaterialToEmissiveWhenNotMrt", (e) => {
        void 0 === e.isEmissive &&
          (e.isMeshStandardMaterial ||
            e.isMeshPhongMaterial ||
            e.isMeshBasicMaterial ||
            e.isLineBasicMaterial) &&
          Object.defineProperty(e, "isEmissive", {
            get: function () {
              return (
                (this.userData._shader &&
                  this.userData._shader.uniforms.isEmissive &&
                  this.userData._shader.uniforms.isEmissive.value) ||
                !1
              );
            },
            set: function (e) {
              this.userData._shader &&
                this.userData._shader.uniforms.isEmissive &&
                (this.userData._shader.uniforms.isEmissive.value = e);
            },
          }),
          void 0 === e.isEmissive &&
            (e.isMeshBasicMaterial || e.isLineBasicMaterial) &&
            Object.defineProperty(e, "emissive", {
              get: function () {
                return (
                  (this.userData._shader &&
                    this.userData._shader.uniforms.isEmissive &&
                    this.userData._shader.uniforms.isEmissive.value) ||
                  new Color(0)
                );
              },
              set: function (e) {
                this.userData._shader &&
                  this.userData._shader.uniforms.isEmissive &&
                  (this.userData._shader.uniforms.isEmissive.value = e);
              },
            }),
          e.isMeshStandardMaterial || e.isMeshPhongMaterial
            ? (e.onBeforeCompile = (t) => {
                (t.uniforms.isEmissive = { value: e.isEmissive || !1 }),
                  (e.userData._shader = t);
              })
            : (e.isMeshBasicMaterial || e.isLineBasicMaterial) &&
              (e.onBeforeCompile = (t) => {
                (t.uniforms.isEmissive = { value: e.isEmissive || !1 }),
                  (t.uniforms.emissive = { value: e.emissive || new Color(0) }),
                  (e.userData._shader = t);
              });
      }),
      (this._rendering = e);
  }
  get useMrt() {
    return this._useMrt;
  }
  set useMrt(e) {
    e !== this._useMrt && (this.dispose(), (this._useMrt = e));
  }
  set enabled(e) {
    (e = !!e) !== this._enabled && ((this._enabled = e), e || this.dispose());
  }
  get enabled() {
    return this._enabled;
  }
  _init() {
    const e = this._rendering,
      t = e.resolution,
      i = new Vector2(t.x, t.y),
      n = e.pixelRatio;
    if (
      ((this._bloomRenderTarget = new ut(i.x * n, i.y * n, { type: G })),
      this.useMrt)
    )
      (this._bloomCopyQuad = new fg(
        new ShaderMaterial({
          vertexShader: hg.vertexShader,
          fragmentShader: hg.fragmentShader,
          uniforms: { tDiffuse: { value: e.main.tEmissive } },
        })
      )),
        (this._renderPass = new J_(
          i,
          this._strength,
          this._radius,
          this._threshold
        )),
        (e.composition.tBloom = this._bloomRenderTarget.texture);
    else {
      this._renderPass = new J_(
        i,
        this._strength,
        this._radius,
        this._threshold
      );
      const t = (this._bloomComposer = new xg(
        e.renderer,
        this._bloomRenderTarget
      ));
      t.renderToScreen = !1;
      const n = new Z_(e.scene, e.camera, null),
        s = (this._finalPass = new vg(
          new ShaderMaterial({
            uniforms: {
              baseTexture: { value: null },
              bloomTexture: { value: t.renderTarget2.texture },
            },
            vertexShader: Ig,
            fragmentShader: Rg,
            defines: {},
          }),
          "baseTexture"
        ));
      (s.needsSwap = !0),
        (s.renderOrder = -100),
        t.addPass(n),
        t.addPass(this._renderPass);
      const r = new Mg(A);
      t.addPass(r),
        t.addPass(new vg(hg)),
        e.postprocessing.addPass(this._finalPass),
        e.postprocessing._enabled &&
          !e.postprocessing._renderComposer &&
          (e.postprocessing._init(), e.main.render());
    }
  }
  render() {
    if (!this._enabled) return;
    this._enabled && !this._renderPass && this._init();
    const e = this._rendering;
    if (!this._useMrt) {
      const e = this._rendering.scene;
      return (
        e.traverse((e) => {
          e.material && (e.material.isEmissive = !0);
        }),
        this._bloomComposer.render(),
        void e.traverse((e) => {
          e.material && (e.material.isEmissive = !1);
        })
      );
    }
    e.main.tEmissive;
    const t = e.renderer;
    t.setRenderTarget(this._bloomRenderTarget),
      t.getClearColor($_),
      (tv = t.getClearAlpha()),
      t.setClearColor(ev),
      t.setClearAlpha(0),
      t.clear(),
      t.setClearColor($_),
      t.setClearAlpha(tv),
      this._bloomCopyQuad.render(t),
      this._renderPass.render(e.renderer, null, this._bloomRenderTarget);
  }
  dispose() {
    (this._rendering.composition.tBloom = null),
      this._finalPass &&
        this._rendering.postprocessing &&
        this._rendering.postprocessing.removePass(this._finalPass),
      this._bloomComposer &&
        (this._bloomComposer.dispose(), (this._bloomComposer = null)),
      this._renderPass &&
        (this._renderPass.dispose(), (this._renderPass = null)),
      this._bloomRenderTarget &&
        (this._bloomRenderTarget.dispose(), (this._bloomRenderTarget = null));
  }
  getTextures() {
    const e = [];
    return (
      this._bloomRenderTarget && e.push(this._bloomRenderTarget.texture), e
    );
  }
  setSize(e, t) {
    this._rendering,
      this._bloomRenderTarget && this._bloomRenderTarget.setSize(e, t);
  }
  get tBloom() {
    return (this._bloomRenderTarget && this._bloomRenderTarget.texture) || null;
  }
  get strength() {
    return this._strength;
  }
  set strength(e) {
    (this._strength = e), this._renderPass && (this._renderPass.strength = e);
  }
  get radius() {
    return this._radius;
  }
  set radius(e) {
    (this._radius = e), this._renderPass && (this._renderPass.radius = e);
  }
  get threshold() {
    return this._threshold;
  }
  set threshold(e) {
    (this._threshold = e), this._renderPass && (this._renderPass.threshold = e);
  }
}
class nv extends ug {
  constructor(
    e,
    { tDiffuse: t, tDepth: i, tNormal: n, tMetalness: s, resolution: r }
  ) {
    super();
    const a = (this.material = new H_());
    (a.uniforms.tDiffuse.value = t),
      (a.uniforms.tDepth.value = i),
      (a.uniforms.tNormal.value = n),
      (a.uniforms.tMetalness.value = s),
      (a.uniforms.resolution.value = r),
      (a.defines.MAX_STEP = Math.sqrt(r.x * r.x + r.y * r.y)),
      (a.defines.DISTANCE_ATTENUATION = !0),
      (a.defines.SELECTIVE = !0),
      (this.renderTarget = e),
      (this.fsQuad = new fg(null));
  }
  render(e, t) {
    const i = this.material;
    i.uniforms.cameraProjectionMatrix.value.copy(t.projectionMatrix),
      i.uniforms.cameraInverseProjectionMatrix.value.copy(
        t.projectionMatrixInverse
      ),
      i.uniforms.mvt_viewInverseMatrix.value.copy(t.matrixWorld),
      i.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(
        t.matrixWorldInverse
      ),
      (i.uniforms.cameraNear.value = t.near),
      (i.uniforms.cameraFar.value = t.far),
      (this.fsQuad.material = i),
      e.setRenderTarget(this.renderTarget),
      this.fsQuad.render(e);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
class sv {
  constructor(e) {
    publicField(this, "_rendering"),
      publicField(this, "_enabled", !1),
      publicField(this, "_renderPass", null),
      publicField(this, "_threshold", 0.5),
      publicField(this, "_thickness", 0.018),
      publicField(this, "_opacity", 0.5),
      publicField(this, "_useMrt", !1),
      (this._rendering = e);
  }
  get useMrt() {
    return this._useMrt;
  }
  set useMrt(e) {
    e !== this._useMrt && ((this._useMrt = e), e || this.dispose());
  }
  set enabled(e) {
    (e = !!e) !== this._enabled && ((this._enabled = e), e || this.dispose());
  }
  get enabled() {
    return this._enabled;
  }
  _init() {
    const e = this._rendering,
      t = e.resolution,
      i = (this._ssrRenderTarget = new ut(t.x, t.y, {})),
      n = (this._renderPass = new nv(i, {
        tDiffuse: e.main.tDiffuse,
        tNormal: e.main.tNormal,
        tMetalness: e.main.tSpecular,
        tDepth: e.main.tDepth,
        resolution: t,
      }));
    (n.material.threshold = this._threshold),
      (n.material.thickness = this._thickness),
      (n.material.opacity = this._opacity),
      (e.composition.tReflection = i.texture);
  }
  render() {
    if (!this._enabled || !this._useMrt) return;
    this._enabled && !this._renderPass && this._init();
    const e = this._rendering;
    this._renderPass.render(e.renderer, e.camera);
  }
  dispose() {
    (this._rendering.composition.tReflection = null),
      this._renderPass &&
        (this._renderPass.dispose(), (this._renderPass = null)),
      this._ssrRenderTarget &&
        (this._ssrRenderTarget.dispose(), (this._ssrRenderTarget = null));
  }
  getTextures() {
    const e = [];
    return this._ssrRenderTarget && e.push(this._ssrRenderTarget.texture), e;
  }
  setSize(e, t) {
    this._ssrRenderTarget && this._ssrRenderTarget.setSize(e, t);
  }
  get tReflection() {
    return (this._ssrRenderTarget && this._ssrRenderTarget.texture) || null;
  }
  get threshold() {
    return this._threshold;
  }
  set threshold(e) {
    (this._threshold = e),
      this._renderPass && (this._renderPass.material.threshold = e);
  }
  get thickness() {
    return this._thickness;
  }
  set thickness(e) {
    (this._thickness = e),
      this._renderPass && (this._renderPass.material.thickness = e);
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e) {
    (this._opacity = e),
      this._renderPass && (this._renderPass.material.opacity = e);
  }
  set tEnhancement(e) {
    this._renderPass && (this._renderPass.material.tEnhancement = e);
  }
  get tEnhancement() {
    return this._renderPass ? this._renderPass.material.tEnhancement : null;
  }
  set tEnhancementScale(e) {
    this._renderPass && (this._renderPass.material.tEnhancementScale = e);
  }
  get tEnhancementScale() {
    return this._renderPass
      ? this._renderPass.material.tEnhancementScale
      : null;
  }
}
const rv = {
  tDiffuse: { value: null },
  tBloom: { value: null },
  tNormal: { value: null },
  tReflection: { value: null },
  tDepth: { value: null },
  tEnv: { value: null },
  tCount: { value: 0 },
  tDebug1: { value: null },
  tDebug2: { value: null },
  tDebug3: { value: null },
  tDebug4: { value: null },
  debugDimension: { value: new Vector2(0.25, 0.2) },
  debugOffset: { value: new Vector2(0, 0) },
  mvt_normalInverseMatrix: { value: new Matrix3() },
  mvt_projectionInverseMatrix: { value: new Matrix4() },
  mvt_viewInverseMatrix: { value: new Matrix4() },
  mvt_projectionMatrix: { value: new Matrix4() },
  coverageColor: { value: new Color(16777215) },
  coverageSacle: { value: new Vector2(20, 20) },
  coverageIntensity: { value: 0 },
  tCoverageIntensity: { value: null },
  resolution: { value: [1, 1] },
  cameraNear: { value: 1 },
  cameraFar: { value: 100 },
  logDepthBufFC: { value: 1 },
  fogColor: { value: new Color(16777215) },
  fogDensity: { value: 1 },
  fogAltitudeBottom: { value: 0 },
  fogAltitudeTop: { value: 1e3 },
  fogSkyColorStartFactor: { value: 0.3 },
  adjustBrightnessFactor: { value: 0 },
  adjustContrastFactor: { value: 0 },
  adjustSaturationFactor: { value: 0 },
};
class av extends ShaderMaterial {
  constructor(e) {
    super(),
      (this.vertexShader =
        "#define GLSLIFY 1\n// attribute vec3 position;\n// attribute vec2 uv;\nvarying vec2 vUv;\n// uniform mat4 modelViewMatrix;\n// uniform mat4 projectionMatrix;\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}"),
      (this.fragmentShader =
        "precision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\n#include <common>\n#include <packing>\n#include <cube_uv_reflection_fragment>\n\nuniform sampler2D tDiffuse;\nuniform sampler2D tNormal;\nuniform sampler2D tDepth;\n\n#if defined(MVT_POST_ENABLE_BLOOM)\n    uniform sampler2D tBloom;\n#endif\n\n#if defined(MVT_POST_ENABLE_REFLECTION)\n    uniform sampler2D tReflection;\n#endif\n\n#if defined(MVT_POST_ENABLE_COVERAGE)\n    #if defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)\n        uniform sampler2D tCoverageIntensity; \n    #endif\n    uniform vec2 coverageSacle;\n    uniform float coverageIntensity;\n    // 覆盖层颜色\n    uniform vec3 coverageColor;\n#endif\n\n// 加前缀防止被three.js本身变量覆盖\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat3 mvt_normalInverseMatrix;\nuniform mat4 mvt_projectionMatrix;\nuniform mat4 mvt_projectionInverseMatrix;\nuniform mat4 mvt_viewInverseMatrix;\n\n#if defined(MVT_POST_USE_FOG)\n    uniform vec3 fogColor;\n    uniform float fogDensity;\n    uniform float fogSkyColorStartFactor;\n    uniform float fogAltitudeBottom;\n    uniform float fogAltitudeTop;\n#endif\n\n#if defined(ENVMAP_TYPE_CUBE_UV)\n    uniform sampler2D tEnv;\n#elif defined(ENVMAP_TYPE_CUBE)\n    uniform samplerCube tEnv;\n#endif\n\n#ifdef MVT_POST_ENABLE_COLOR_ADJUST\n    uniform float adjustBrightnessFactor;\n    uniform float adjustContrastFactor; \n    uniform float adjustSaturationFactor; \n#endif\n\n#ifdef MVT_MRT_POST_DEBUG\n    uniform vec2 debugDimension;\n    uniform vec2 debugOffset;\n    uniform int tCount;\n    uniform sampler2D tDebug1;\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 1\n        uniform sampler2D tDebug2;\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 2\n        uniform sampler2D tDebug3;\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 3\n        uniform sampler2D tDebug4;\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 4\n        uniform sampler2D tDebug5;\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 5\n        uniform sampler2D tDebug6;\n    #endif\n#endif\n\nvarying vec2 vUv;\n\nfloat linearize_depth(in float depth){\n    float a = cameraFar / (cameraFar - cameraNear);\n    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n    return a + b / depth;\n}\n\nfloat reconstruct_depth(const in vec2 uv){\n    float depth = texture2D(tDepth, uv).x;\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat getDepth(vec2 uv) {\n    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n        return linearize_depth(reconstruct_depth(uv));\n    #else\n        return texture2D(tDepth, uv).x;\n    #endif\n}\nvec3 getWorldPositionFromDepth(float depth) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(vUv * 2.0 - 1.0, z, 1.0);\n\n    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];\n    // clipSpacePosition *= clipW;\n    vec4 viewSpacePosition = mvt_projectionInverseMatrix * clipSpacePosition;\n    \n    // viewSpacePosition /= viewSpacePosition.w;\n    // return viewSpacePosition.xyz;\n    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;\n\n    return worldSpacePosition.xyz / worldSpacePosition.w;\n}\n\nfloat getNoramlLength(vec3 normal) {\n    if (normal.x < 0. || normal.y < 0. || normal.z < 0.) {\n        return 0.;\n    }\n    return length(normal);\n}\nvoid renderOutputColor() {\n    vec4 outColor = texture2D(tDiffuse, vUv);\n\n    // bloom\n    #if defined(MVT_POST_ENABLE_BLOOM)\n    vec4 bloom_color = texture2D(tBloom, vUv);\n    float lum = 0.21 * bloom_color.r + 0.71 * bloom_color.g + 0.07 * bloom_color.b;\n    outColor = vec4(outColor.rgb + bloom_color.rgb, max(outColor.a, lum));\n    #endif\n\n    // reflection\n    #if defined(MVT_POST_ENABLE_REFLECTION)\n    vec4 reflectionColor = texture2D( tReflection, vUv );\n    outColor.xyz = mix(outColor.xyz, reflectionColor.xyz, reflectionColor.w);\n    #endif\n\n    vec4 viewNormal = texture2D(tNormal, vUv);\n    vec3 normal = unpackRGBToNormal(viewNormal.xyz);\n    float normalLength = getNoramlLength(normal);\n    \n    #if (defined(MVT_POST_ENABLE_COVERAGE) && defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)) || defined(MVT_POST_USE_FOG)\n        float depth = getDepth(vUv);\n        vec3 worldSpacePosition = getWorldPositionFromDepth(depth);\n    #endif\n\n    #if defined(MVT_POST_ENABLE_COVERAGE)\n    if (coverageIntensity > 0.0 && normalLength > 0.5) {\n        float dirAlpha = dot(normal * mvt_normalInverseMatrix, vec3(0.0, 0.0, 1.0));\n        if (dirAlpha > 0.2) {\n            float coverageAlpha = clamp(0.0, 1.0, dirAlpha) * coverageIntensity;\n            vec3 coverageFinalColor = vec3(coverageColor);\n            #if defined(MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP)\n                \n                vec2 coverageUv = vec2(mod(worldSpacePosition.x, coverageSacle.x) / coverageSacle.x, \n                    mod(worldSpacePosition.y, coverageSacle.y) / coverageSacle.y);\n                coverageAlpha *= texture2D(tCoverageIntensity, coverageUv).x;\n            #endif\n            // outColor.xyz = vec3(coverageAlpha, 0.0, 0.0);\n            outColor.xyz = mix(outColor.xyz, coverageFinalColor, coverageAlpha);\n        }\n    }\n    #endif\n\n    #if defined(MVT_POST_USE_FOG)\n        vec3 cameraPosition = mvt_viewInverseMatrix[3].xyz;\n        if (cameraPosition.z < 5000.) {\n            float fogFactorMultiplier = clamp((5000. - cameraPosition.z) / 2000., 0., 1.);\n            float fogDepth = texture2D(tDepth, vUv).x;\n            float fogHeight = fogAltitudeTop - fogAltitudeBottom;\n            float fogHeightRatio = (clamp(worldSpacePosition.z, fogAltitudeBottom, fogAltitudeTop) - fogAltitudeBottom) / fogHeight;\n            // 混合大气雾，只混合除去天空的部分\n            // if (normalLength > 0.00001) {\n                #if defined(ENVMAP_TYPE_CUBE_UV) || defined(ENVMAP_TYPE_CUBE)\n                    vec3 worldViewDir = normalize(worldSpacePosition.xyz - cameraPosition);\n                    // worldViewDir.z = clamp(worldSpacePosition.z / 1000.0, 0.0, 0.2);\n                    // worldViewDir = reflect(worldViewDir, vec3(0.0, 0.0, 1.0));\n                    #if defined(ENVMAP_TYPE_CUBE_UV)\n                        vec3 skyColor = textureCubeUV(tEnv, worldViewDir, 0.0).xyz;\n                    #else\n                        vec3 skyColor = textureCube(tEnv, worldViewDir).xyz;\n                    #endif\n                    float skyColorDepth = 1.0 - fogSkyColorStartFactor;\n                    float skyColrFactor = clamp(fogDepth - fogSkyColorStartFactor, 0.0, skyColorDepth) / skyColorDepth;\n                    skyColrFactor = skyColrFactor * skyColrFactor * skyColrFactor;\n                    skyColrFactor *= 1.0 - fogHeightRatio;\n                    outColor.xyz = mix(outColor.xyz, skyColor, skyColrFactor * fogFactorMultiplier);\n\n                    // outColor.xyz = vec3(abs(normal.xyz)); //vec3(0.0, 0.0, normalLength);\n                    // outColor.xyz = vec3(mod(worldSpacePosition.x, 1000.0), mod(worldSpacePosition.y, 1000.0), 0.0);\n                    // outColor.xyz = skyColor;\n                    // skyColor = vec3(0.0, 0.0, 1.0);\n                    // outColor.xyz = vec3(clamp(fogDepth - 0.95, 0.0, 0.05) * 20.0, 0.0, 0.0);\n                    // fogCompseColor = mix(fogColor, skyColor, clamp(fogDepth - 0.5, 0.0, 0.5) * 2.0);\n                    // fogCompseColor = mix(fogCompseColor, fogColor, clamp(fogDensity - 0.5, 0.0, 1.0));\n                #endif\n            // }\n            float fogFactor = 1.0 - exp( - fogDensity * fogDensity * fogDepth * fogDepth );\n            // fogFactor *= clamp(worldSpacePosition.z, 1.0, 0.0);\n            // 高度衰减系数\n            float heightAttenuation = fogHeightRatio;\n            heightAttenuation = clamp(heightAttenuation - (fogDensity - 0.5), 0.0, 1.0);\n            fogFactor = clamp(fogFactor - heightAttenuation, 0.0, 1.0);\n            // vec3 fogCompseColor = vec3(fogColor);\n            // #if defined(ENVMAP_TYPE_CUBE_UV) || defined(ENVMAP_TYPE_CUBE)\n            //     vec3 worldViewDir = normalize(worldSpacePosition.xyz - mvt_viewInverseMatrix[3].xyz);\n            //     worldViewDir.z = clamp(worldSpacePosition.z / 1000.0, 0.0, 0.2);\n            //     // worldViewDir = reflect(worldViewDir, vec3(0.0, 0.0, 1.0));\n            //     #if defined(ENVMAP_TYPE_CUBE_UV)\n            //         vec3 skyColor = textureCubeUV(tEnv, worldViewDir, 0.0).xyz;\n            //     #else\n            //         vec3 skyColor = textureCube(tEnv, worldViewDir).xyz;\n            //     #endif\n            //     // skyColor = vec3(0.0, 0.0, 1.0);\n            //     fogCompseColor = mix(fogColor, skyColor, clamp(fogDepth - 0.5, 0.0, 0.5) * 2.0);\n            //     fogCompseColor = mix(fogCompseColor, fogColor, clamp(fogDensity - 0.5, 0.0, 1.0));\n            // #endif\n            \n            // outColor.xyz = skyColor;\n            outColor.xyz = mix(outColor.xyz, fogColor, fogFactor * fogFactorMultiplier);\n        }\n    #endif\n\n    #ifdef MVT_POST_ENABLE_COLOR_ADJUST\n        // https://www.w3.org/TR/WCAG21/#dfn-relative-luminance\n        vec3 grayscale = vec3(dot(outColor.xyz,  vec3(0.2126, 0.7152, 0.0722)));\n        outColor.xyz = mix(grayscale, outColor.xyz, 1.0 + adjustSaturationFactor);\n\n        outColor.xyz = 0.5 + (1.0 + adjustContrastFactor) * (outColor.xyz - 0.5);\n        outColor.xyz = outColor.xyz + adjustBrightnessFactor;\n    #endif\n\n    gl_FragColor = outColor;\n}\n\n#ifdef MVT_MRT_POST_DEBUG\nvoid renderDebugColor(float u, float v) {\n    vec4 color;\n    \n    if (u < 1.0) {\n        color = texture2D(tDebug1, vec2(mod(u, 1.0), v));\n    }\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 1\n    else if (u < 2.0) {\n        color = texture2D(tDebug2, vec2(mod(u, 1.0), v));\n    }\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 2\n    else if (u < 3.0) {\n        color = texture2D(tDebug3, vec2(mod(u, 1.0), v));\n    }\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 3\n    else if (u < 4.0) {\n        color = texture2D(tDebug4, vec2(mod(u, 1.0), v));\n    }\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 4\n    else if (u < 5.0) {\n        color = texture2D(tDebug5, vec2(mod(u, 1.0), v));\n    }\n    #endif\n    #if MVT_POST_DEBUG_TEXTURE_COUNT > 5\n    else if (u < 6.0) {\n        color = texture2D(tDebug6, vec2(mod(u, 1.0), v));\n    }\n    #endif\n\n    gl_FragColor = color;\n}\n#endif\n\nvoid main() {\n\n    #ifdef MVT_MRT_POST_DEBUG\n        float u = (debugOffset.x + vUv.x) / debugDimension.x;\n        float v = (debugOffset.y + vUv.y) / debugDimension.y;\n        if (v >= 0.0 && v <= 1.0 && u >= 0.0 && u <= 1.0 * float(tCount)) {\n            renderDebugColor(u, v);\n        }\n        else {\n            renderOutputColor();\n        }\n    #else\n        renderOutputColor();\n    #endif\n    // #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}"),
      (this.uniforms = In.clone(rv)),
      (this.defines = {
        MVT_POST_ENABLE_BLOOM: !1,
        MVT_POST_DEBUG_TEXTURE_COUNT: 0,
        MVT_POST_USE_FOG: !1,
        MVT_POST_ENABLE_COLOR_ADJUST: !1,
        CUBEUV_TEXEL_WIDTH: 0.0003255208333333333,
        CUBEUV_TEXEL_HEIGHT: 0.000244140625,
        CUBEUV_MAX_MIP: "10.0",
      }),
      N_(this, [
        "tDiffuse",
        "tNormal",
        "tDepth",
        "debugDimension",
        "debugOffset",
        "fogColor",
        "fogDensity",
        "fogAltitudeBottom",
        "fogAltitudeTop",
        "fogSkyColorStartFactor",
        "adjustBrightnessFactor",
        "adjustContrastFactor",
        "adjustSaturationFactor",
      ]),
      Object.defineProperties(this, {
        tBloom: {
          get: function () {
            return this.uniforms.tBloom.value;
          },
          set: function (e) {
            e
              ? ((this.uniforms.tBloom.value = e),
                (this.defines.MVT_POST_ENABLE_BLOOM = !0))
              : ((this.uniforms.tBloom.value = null),
                delete this.defines.MVT_POST_ENABLE_BLOOM),
              (this.needsUpdate = !0);
          },
        },
        tReflection: {
          get: function () {
            return this.uniforms.tReflection.value;
          },
          set: function (e) {
            e
              ? ((this.uniforms.tReflection.value = e),
                (this.defines.MVT_POST_ENABLE_REFLECTION = !0))
              : ((this.uniforms.tReflection.value = null),
                delete this.defines.MVT_POST_ENABLE_REFLECTION),
              (this.needsUpdate = !0);
          },
        },
        coverageIntensity: {
          get: function () {
            return this.uniforms.coverageIntensity.value;
          },
          set: function (e) {
            (this.uniforms.coverageIntensity.value = e),
              e > 0
                ? (this.defines.MVT_POST_ENABLE_COVERAGE = !0)
                : delete this.defines.MVT_POST_ENABLE_COVERAGE,
              ((0 === e && this._lastCoverageIntensity > 0) ||
                (e > 0 && 0 === this._lastCoverageIntensity)) &&
                (this.needsUpdate = !0),
              (this._lastCoverageIntensity = e);
          },
        },
        tCoverageIntensity: {
          get: function () {
            return this.uniforms.tCoverageIntensity.value;
          },
          set: function (e) {
            e
              ? ((this.uniforms.tCoverageIntensity.value = e),
                (this.defines.MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP = !0))
              : ((this.uniforms.tCoverageIntensity.value = null),
                delete this.defines.MVT_POST_ENABLE_COVERAGE_INDENSITY_MAP),
              (this.needsUpdate = !0);
          },
        },
        debugTextures: {
          get: function () {
            return null;
          },
          set: function (e) {
            if (Array.isArray(e)) {
              this.defines.MVT_MRT_POST_DEBUG = !0;
              const t = e.length;
              (this.uniforms.tCount.value = t),
                (this.defines.MVT_POST_DEBUG_TEXTURE_COUNT = t),
                (this.uniforms.tDebug1.value = e[0] || null),
                (this.uniforms.tDebug2.value = e[1] || null),
                (this.uniforms.tDebug3.value = e[2] || null),
                (this.uniforms.tDebug4.value = e[3] || null);
            } else
              delete this.defines.MVT_MRT_POST_DEBUG,
                (this.defines.MVT_POST_DEBUG_TEXTURE_COUNT = 0),
                (this.uniforms.tCount.value = 0),
                (this.uniforms.tDebug1.value = null),
                (this.uniforms.tDebug2.value = null),
                (this.uniforms.tDebug3.value = null),
                (this.uniforms.tDebug4.value = null);
            this.needsUpdate = !0;
          },
        },
        useFog: {
          get: function () {
            return this.defines.MVT_POST_USE_FOG || !1;
          },
          set: function (e) {
            e !== !!this.defines.MVT_POST_USE_FOG &&
              (e
                ? (this.defines.MVT_POST_USE_FOG = !0)
                : delete this.defines.MVT_POST_USE_FOG,
              (this.needsUpdate = !0));
          },
        },
        tEnv: {
          get: function () {
            return this.uniforms.tEnv.value;
          },
          set: function (e) {
            if (e !== this.uniforms.tEnv.value) {
              if (e)
                if (e.mapping === M) {
                  (this.defines.ENVMAP_TYPE_CUBE_UV = !0),
                    delete this.defines.ENVMAP_TYPE_CUBE;
                  const t = V_(e);
                  t &&
                    ((this.defines.CUBEUV_TEXEL_WIDTH = t.texelWidth),
                    (this.defines.CUBEUV_TEXEL_HEIGHT = t.texelHeight),
                    (this.defines.CUBEUV_MAX_MIP = t.maxMip + ".0"));
                } else
                  (this.defines.ENVMAP_TYPE_CUBE = !0),
                    delete this.defines.ENVMAP_TYPE_CUBE_UV;
              else
                delete this.defines.ENVMAP_TYPE_CUBE,
                  delete this.defines.ENVMAP_TYPE_CUBE_UV;
              (this.uniforms.tEnv.value = e), (this.needsUpdate = !0);
            }
          },
        },
        colorAdjustEnabled: {
          get: function () {
            return this.defines.MVT_POST_ENABLE_COLOR_ADJUST;
          },
          set: function (e) {
            e !== this.defines.MVT_POST_ENABLE_COLOR_ADJUST &&
              (e
                ? (this.defines.MVT_POST_ENABLE_COLOR_ADJUST = !0)
                : delete this.defines.MVT_POST_ENABLE_COLOR_ADJUST,
              (this.needsUpdate = !0));
          },
        },
      }),
      this.setValues(e);
  }
  dispose() {
    let e = [
      "tEnv",
      "tDiffuse",
      "tNormal",
      "tDepth",
      "tBloom",
      "tReflection",
      "tCoverageIntensity",
      "tDebug1",
      "tDebug2",
      "tDebug3",
      "tDebug4",
      "tDebug5",
      "tDebug6",
    ];
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      this.uniforms[i] &&
        this.uniforms[i].value &&
        this.uniforms[i].value.dispose();
    }
    super.dispose();
  }
}
class ov extends ug {
  constructor({
    tDiffuse: e,
    tDepth: t,
    tNormal: i,
    tMetalness: n,
    tBloom: s,
    tReflection: r,
  }) {
    super();
    const a = (this.material = new av());
    (this.tBloom = s),
      (this.tReflection = r),
      (a.uniforms.tDiffuse.value = e),
      (a.uniforms.tDepth.value = t),
      (a.uniforms.tNormal.value = i),
      (this.fsQuad = new fg(null)),
      (this.renderTarget = null);
  }
  render(e, t, i) {
    const n = this.material;
    n.uniforms.mvt_normalInverseMatrix.value.getNormalMatrix(
      t.matrixWorldInverse
    ),
      n.uniforms.mvt_projectionInverseMatrix.value.copy(
        t.projectionMatrixInverse
      ),
      n.uniforms.mvt_projectionMatrix.value.copy(t.projectionMatrix),
      n.uniforms.mvt_viewInverseMatrix.value.copy(t.matrixWorld),
      (n.uniforms.cameraNear.value = t.near),
      (n.uniforms.cameraFar.value = t.far),
      (n.tEnv = i.environment),
      (this.fsQuad.material = n),
      e.setRenderTarget(this.renderTarget),
      this.fsQuad.render(e);
  }
  dispose() {
    this.material.dispose(),
      (this.material = null),
      this.fsQuad.dispose(),
      (this.fsQuad = null);
  }
  get tBloom() {
    return this.material.tBloom;
  }
  set tBloom(e) {
    this.material.tBloom = e;
  }
  get tReflection() {
    return this.material.tReflection;
  }
  set tReflection(e) {
    this.material.tReflection = e;
  }
}
class lv {
  constructor(e) {
    publicField(this, "_enabled", !0),
      publicField(this, "_rendering"),
      publicField(this, "_renderPass"),
      publicField(this, "_tDiffuse"),
      publicField(this, "_tDepth"),
      publicField(this, "_tNormal"),
      publicField(this, "_tSpecular"),
      publicField(this, "_tBloom"),
      publicField(this, "_tReflection"),
      publicField(this, "_useMrt", !1),
      (this._rendering = e);
  }
  get useMrt() {
    return this._useMrt;
  }
  set useMrt(e) {
    e !== this._useMrt && ((this._useMrt = e), e || this.dispose());
  }
  set enabled(e) {
    (e = !!e) !== this._enabled && ((this._enabled = e), e || this.dispose());
  }
  get enabled() {
    return this._enabled;
  }
  _init() {
    const e = this._rendering;
    (this._tDiffuse = e.main.tDiffuse),
      (this._tDepth = e.main.tDepth),
      (this._tNormal = e.main.tNormal),
      (this._tSpecular = e.main.tSpecular),
      (this._tBloom = e.bloom.tBloom),
      (this._tReflection = e.ssr.tReflection),
      (this._renderPass = new ov({
        tDiffuse: this._tDiffuse,
        tNormal: this._tNormal,
        tDepth: this._tDepth,
        tBloom: this._tBloom,
        tReflection: this._tReflection,
        tSpecular: this._tSpecular,
      })),
      (this.colorAdjustEnabled = e.colorAdjust.enabled),
      (this.adjustBrightnessFactor = e.colorAdjust.brightness),
      (this.adjustContrastFactor = e.colorAdjust.contrast),
      (this.adjustSaturationFactor = e.colorAdjust.saturation);
  }
  render() {
    if (!this._enabled || !this._useMrt) return;
    this._enabled && !this._renderPass && this._init();
    const e = this._rendering;
    e.postprocessing.enabled && e.postprocessing.composer
      ? (this._renderPass.renderTarget = e.postprocessing.composer.readBuffer)
      : (this._renderPass.renderTarget = null),
      this._renderPass.render(e.renderer, e.camera, e.scene);
  }
  dispose() {
    this._renderPass && (this._renderPass.dispose(), (this._renderPass = null));
  }
  set debugTextures(e) {
    this._renderPass && (this._renderPass.material.debugTextures = e);
  }
  set tDiffuse(e) {
    (this._tDiffuse = e), this._renderPass && (this._renderPass.tDiffuse = e);
  }
  set tDepth(e) {
    (this._tDepth = e), this._renderPass && (this._renderPass.tDepth = e);
  }
  set tNormal(e) {
    (this._tNormal = e), this._renderPass && (this._renderPass.tNormal = e);
  }
  set tBloom(e) {
    (this._tBloom = e), this._renderPass && (this._renderPass.tBloom = e);
  }
  set tReflection(e) {
    (this._tReflection = e),
      this._renderPass && (this._renderPass.tReflection = e);
  }
  set tSpecular(e) {
    (this._tSpecular = e), this._renderPass && (this._renderPass.tSpecular = e);
  }
  set coverageIntensity(e) {
    this._renderPass && (this._renderPass.material.coverageIntensity = e);
  }
  get coverageIntensity() {
    return (
      (this._renderPass && this._renderPass.material.coverageIntensity) || 0
    );
  }
  set tCoverageIntensity(e) {
    this._renderPass && (this._renderPass.material.tCoverageIntensity = e);
  }
  get tCoverageIntensity() {
    return (
      this._renderPass && null | this._renderPass.material.tCoverageIntensity
    );
  }
  get debugDimension() {
    return (
      (this._renderPass && this._renderPass.material.debugDimension) || {
        x: 0,
        y: 0,
      }
    );
  }
  get debugOffset() {
    return (
      (this._renderPass && this._renderPass.material.debugOffset) || {
        x: 0,
        y: 0,
      }
    );
  }
  get tEnv() {
    return (this._renderPass && this._renderPass.material.tEnv) || null;
  }
  set tEnv(e) {
    this.renderPass && (this._renderPass.material.tEnv = e);
  }
  get useFog() {
    return (this._renderPass && this._renderPass.material.useFog) || !1;
  }
  set useFog(e) {
    this._renderPass && (this._renderPass.material.useFog = e);
  }
  get fogDensity() {
    return (this._renderPass && this._renderPass.material.fogDensity) || 0;
  }
  set fogDensity(e) {
    this._renderPass && (this._renderPass.material.fogDensity = e);
  }
  get adjustBrightnessFactor() {
    return (
      (this._renderPass && this._renderPass.material.adjustBrightnessFactor) ||
      0
    );
  }
  set adjustBrightnessFactor(e) {
    this._renderPass && (this._renderPass.material.adjustBrightnessFactor = e);
  }
  get colorAdjustEnabled() {
    return (
      (this._renderPass && this._renderPass.material.colorAdjustEnabled) || !1
    );
  }
  set colorAdjustEnabled(e) {
    this._renderPass && (this._renderPass.material.colorAdjustEnabled = !!e);
  }
  get adjustContrastFactor() {
    return (
      (this._renderPass && this._renderPass.material.adjustContrastFactor) || 0
    );
  }
  set adjustContrastFactor(e) {
    this._renderPass && (this._renderPass.material.adjustContrastFactor = e);
  }
  get adjustSaturationFactor() {
    return (
      (this._renderPass && this._renderPass.material.adjustSaturationFactor) ||
      0
    );
  }
  set adjustSaturationFactor(e) {
    this._renderPass && (this._renderPass.material.adjustSaturationFactor = e);
  }
  get fogSkyColorStartFactor() {
    return (
      (this._renderPass && this._renderPass.material.fogSkyColorStartFactor) ||
      0
    );
  }
  set fogSkyColorStartFactor(e) {
    this._renderPass && (this._renderPass.material.fogSkyColorStartFactor = e);
  }
  get fogAltitudeBottom() {
    return (
      (this._renderPass && this._renderPass.material.fogAltitudeBottom) || 0
    );
  }
  set fogAltitudeBottom(e) {
    this._renderPass && (this._renderPass.material.fogAltitudeBottom = e);
  }
  get fogAltitudeTop() {
    return (this._renderPass && this._renderPass.material.fogAltitudeTop) || 0;
  }
  set fogAltitudeTop(e) {
    this._renderPass && (this._renderPass.material.fogAltitudeTop = e);
  }
}
class hv {
  constructor(e) {
    publicField(this, "_enabled", !1),
      publicField(this, "_useMrt", !1),
      publicField(this, "_rendering"),
      publicField(this, "_renderComposer"),
      publicField(this, "_passes", []),
      (this._rendering = e);
  }
  get useMrt() {
    return this._useMrt;
  }
  set useMrt(e) {
    e !== this._useMrt && (this._useMrt = e);
  }
  set enabled(e) {
    (e = !!e) !== this._enabled && ((this._enabled = e), e || this.dispose());
  }
  get enabled() {
    return this._enabled;
  }
  _init() {
    const e = this._rendering,
      t = e.renderer,
      i = e.resolution,
      n = new Vector2(i.x, i.y),
      s = e.pixelRatio,
      r = (this._postRenderTarget = new ut(n.x * s, n.y * s, {
        minFilter: R,
        magFilter: R,
        format: Q,
        stencilBuffer: !0,
        samples: 4,
      }));
    r.texture.name = "EffectComposer.rt1";
    const a = (this._renderComposer = new xg(t, r));
    a.setPixelRatio(s), a.setSize(n.x, n.y);
    const o = new vg(cg);
    (o.material.transparent = !0), a.addPass(o);
    for (let l = 0; l < this._passes.length; l++) {
      const e = this._passes[l];
      a.addPass(e);
    }
  }
  render() {
    if (!this._enabled) return;
    this._enabled && !this._renderComposer && this._init();
    const e = this._rendering;
    this.useMrt &&
      (this._setMrtUniforms("tDiffuse", e.main.tDiffuse),
      this._setMrtUniforms("tDepth", e.main.tDepth),
      this._setMrtUniforms("tNormal", e.main.tNormal),
      this._setMrtUniforms("tSpecular", e.main.tSpecular),
      this._setMrtUniforms("tBloom", e.bloom.tBloom),
      this._setMrtUniforms("tReflection", e.ssr.tReflection)),
      this._renderComposer.render();
  }
  _setMrtUniforms(e, t) {
    for (let i = 0; i < this._passes.length; i++) {
      const n = this._passes[i];
      if (n.material) {
        const i = n.material.uniforms;
        i[e] && (i[e].value = t);
      }
    }
  }
  dispose() {
    this._renderComposer &&
      (this._renderComposer.dispose(),
      (this._renderComposer = null),
      (this._postRenderTarget = null));
  }
  addPass(e) {
    if (
      (0 !== this._passes.length || this.enabled || (this.enabled = !0),
      e && !e.renderOrder && (e.renderOrder = 0),
      0 === this._passes.length)
    )
      return (
        this._passes.push(e),
        void (this._renderComposer && this._renderComposer.addPass(e))
      );
    for (let t = this._passes.length - 1; t >= 0; t--) {
      if (e.renderOrder >= this._passes[t].renderOrder) {
        this._passes.splice(t + 1, 0, e),
          this._renderComposer && this._renderComposer.insertPass(e, t + 2);
        break;
      }
      0 === t &&
        (this._passes.splice(t, 0, e),
        this._renderComposer && this._renderComposer.insertPass(e, t + 1));
    }
  }
  removePass(e) {
    const t = this._passes.indexOf(e);
    -1 !== t && (this._passes.splice(t, 1), this._renderComposer.removePass(e)),
      0 === this._passes.length && this.enabled && (this.enabled = !1);
  }
  get composer() {
    return this._renderComposer;
  }
}

class cv extends Object3D {
  constructor(e) {
    super(),
      publicField(this, "_enableRtc", !0),
      publicField(this, "_cachedRtc", [0, 0, 0]),
      publicField(this, "_receiveRaycast", !1),
      publicField(this, "makeMeshPositionOffset", (e) => {
        (this._cachedRtc = [e[0], e[1], e[2] || 0]), this.updateTransform();
      }),
      publicField(this, "makeGeometryOffsetPosition", (e, t) => {
        if (!this._enableRtc) return;
        const i = e.boundingSphere && e.boundingSphere.center;
        if (!i)
          return (this._cachedRtc = [0, 0, 0]), void this.updateTransform();
        const { x: n, y: s, z: r } = i;
        e.isCustomInstancedBufferGeometry
          ? this.makePostionArrayOffset(
              e.attributes.instancedPosition.array,
              n,
              s,
              r,
              t
            )
          : (this.makePostionArrayOffset(
              e.attributes.position.array,
              n,
              s,
              r,
              t
            ),
            e.attributes.position.array.length),
          e.computeBoundingSphere(),
          (this._cachedRtc = [n, s, r]),
          this.updateTransform();
      }),
      publicField(this, "makePostionArrayOffset", (e, t, i, n, s) => {
        if (!e || e.length < 3) return;
        let r = s || e;
        for (let a = 0, o = e.length - 2; a < o; a += 3)
          (e[a] = r[a] - t),
            (e[a + 1] = r[a + 1] - i),
            (e[a + 2] = r[a + 2] - n);
      }),
      publicField(this, "updateTransform", () => {
        const [e, t, i] = this._cachedRtc;
        this.position.set(e, t, i), this.updateMatrixWorld(!0);
      }),
      Object.defineProperties(this, {
        enableRtc: {
          get: function () {
            return this._enableRtc;
          },
          set: function (e) {
            this._enableRtc = e;
          },
        },
      });
  }
  defineGeometryProxyProperties(e = []) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      Object.defineProperty(this, i, {
        get: function () {
          return this.geometry[i];
        },
        set: function (e) {
          this.geometry[i] = e;
        },
      });
    }
  }
  defineMaterialProxyProperties(e = []) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      Object.defineProperty(this, i, {
        get: function () {
          return this.material[i];
        },
        set: function (e) {
          this.material[i] = e;
        },
      });
    }
  }
  raycast(e, t) {
    this.receiveRaycast && this.visible && super.raycast(e, t);
  }
  get receiveRaycast() {
    return this._receiveRaycast;
  }
  set receiveRaycast(e) {
    this._receiveRaycast = e;
  }
}

function uv(e) {
  var t,
    i = Math.PI / 180,
    n = 6378137,
    s = 20037508.342789244,
    r = [
      n *
        (Math.abs(e[0]) <= 180
          ? e[0]
          : e[0] - 360 * ((t = e[0]) < 0 ? -1 : t > 0 ? 1 : 0)) *
        i,
      n * Math.log(Math.tan(0.25 * Math.PI + 0.5 * e[1] * i)),
    ];
  return (
    r[0] > s && (r[0] = s),
    r[0] < -s && (r[0] = -s),
    r[1] > s && (r[1] = s),
    r[1] < -s && (r[1] = -s),
    r
  );
}

function dv(e) {
  var t = 180 / Math.PI,
    i = 6378137;
  return [
    (e[0] * t) / i,
    (0.5 * Math.PI - 2 * Math.atan(Math.exp(-e[1] / i))) * t,
  ];
}

function pv(e, t, i) {
  return Math.max(t, Math.min(i, e));
}

class fv {
  constructor(e = 0, t = 0) {
    (fv.prototype.isVector2 = !0), (this.x = e), (this.y = t);
  }
  get width() {
    return this.x;
  }
  set width(e) {
    this.x = e;
  }
  get height() {
    return this.y;
  }
  set height(e) {
    this.y = e;
  }
  set(e, t) {
    return (this.x = e), (this.y = t), this;
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), this;
  }
  addVectors(e, t) {
    return (this.x = e.x + t.x), (this.y = e.y + t.y), this;
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), this;
  }
  subVectors(e, t) {
    return (this.x = e.x - t.x), (this.y = e.y - t.y), this;
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), this;
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      n = e.elements;
    return (
      (this.x = n[0] * t + n[3] * i + n[6]),
      (this.y = n[1] * t + n[4] * i + n[7]),
      this
    );
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)), (this.y = Math.min(this.y, e.y)), this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)), (this.y = Math.max(this.y, e.y)), this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (this.x = Math.floor(this.x)), (this.y = Math.floor(this.y)), this;
  }
  ceil() {
    return (this.x = Math.ceil(this.x)), (this.y = Math.ceil(this.y)), this;
  }
  round() {
    return (this.x = Math.round(this.x)), (this.y = Math.round(this.y)), this;
  }
  roundToZero() {
    return (this.x = Math.trunc(this.x)), (this.y = Math.trunc(this.y)), this;
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y;
  }
  cross(e) {
    return this.x * e.y - this.y * e.x;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  angle() {
    return Math.atan2(-this.y, -this.x) + Math.PI;
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (0 === t) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(pv(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y;
    return t * t + i * i;
  }
  manhattanDistanceTo(e) {
    return Math.abs(this.x - e.x) + Math.abs(this.y - e.y);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (this.x += (e.x - this.x) * t), (this.y += (e.y - this.y) * t), this;
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i), (this.y = e.y + (t.y - e.y) * i), this
    );
  }
  equals(e) {
    return e.x === this.x && e.y === this.y;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), e;
  }
  fromBufferAttribute(e, t) {
    return (this.x = e.getX(t)), (this.y = e.getY(t)), this;
  }
  rotateAround(e, t) {
    const i = Math.cos(t),
      n = Math.sin(t),
      s = this.x - e.x,
      r = this.y - e.y;
    return (this.x = s * i - r * n + e.x), (this.y = s * n + r * i + e.y), this;
  }
  random() {
    return (this.x = Math.random()), (this.y = Math.random()), this;
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y;
  }
}
class mv {
  constructor(e = 0, t = 0, i = 0, n = 1) {
    (this.isQuaternion = !0),
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = n);
  }
  static slerpFlat(e, t, i, n, s, r, a) {
    let o = i[n + 0],
      l = i[n + 1],
      h = i[n + 2],
      c = i[n + 3];
    const u = s[r + 0],
      d = s[r + 1],
      p = s[r + 2],
      f = s[r + 3];
    if (0 === a)
      return (
        (e[t + 0] = o), (e[t + 1] = l), (e[t + 2] = h), void (e[t + 3] = c)
      );
    if (1 === a)
      return (
        (e[t + 0] = u), (e[t + 1] = d), (e[t + 2] = p), void (e[t + 3] = f)
      );
    if (c !== f || o !== u || l !== d || h !== p) {
      let e = 1 - a;
      const t = o * u + l * d + h * p + c * f,
        i = t >= 0 ? 1 : -1,
        n = 1 - t * t;
      if (n > Number.EPSILON) {
        const s = Math.sqrt(n),
          r = Math.atan2(s, t * i);
        (e = Math.sin(e * r) / s), (a = Math.sin(a * r) / s);
      }
      const s = a * i;
      if (
        ((o = o * e + u * s),
        (l = l * e + d * s),
        (h = h * e + p * s),
        (c = c * e + f * s),
        e === 1 - a)
      ) {
        const e = 1 / Math.sqrt(o * o + l * l + h * h + c * c);
        (o *= e), (l *= e), (h *= e), (c *= e);
      }
    }
    (e[t] = o), (e[t + 1] = l), (e[t + 2] = h), (e[t + 3] = c);
  }
  static multiplyQuaternionsFlat(e, t, i, n, s, r) {
    const a = i[n],
      o = i[n + 1],
      l = i[n + 2],
      h = i[n + 3],
      c = s[r],
      u = s[r + 1],
      d = s[r + 2],
      p = s[r + 3];
    return (
      (e[t] = a * p + h * c + o * d - l * u),
      (e[t + 1] = o * p + h * u + l * c - a * d),
      (e[t + 2] = l * p + h * d + a * u - o * c),
      (e[t + 3] = h * p - a * c - o * u - l * d),
      e
    );
  }
  get x() {
    return this._x;
  }
  set x(e) {
    (this._x = e), this._onChangeCallback();
  }
  get y() {
    return this._y;
  }
  set y(e) {
    (this._y = e), this._onChangeCallback();
  }
  get z() {
    return this._z;
  }
  set z(e) {
    (this._z = e), this._onChangeCallback();
  }
  get w() {
    return this._w;
  }
  set w(e) {
    (this._w = e), this._onChangeCallback();
  }
  set(e, t, i, n) {
    return (
      (this._x = e),
      (this._y = t),
      (this._z = i),
      (this._w = n),
      this._onChangeCallback(),
      this
    );
  }
  clone() {
    return new this.constructor(this._x, this._y, this._z, this._w);
  }
  copy(e) {
    return (
      (this._x = e.x),
      (this._y = e.y),
      (this._z = e.z),
      (this._w = e.w),
      this._onChangeCallback(),
      this
    );
  }
  setFromEuler(e, t) {
    const i = e._x,
      n = e._y,
      s = e._z,
      r = e._order,
      a = Math.cos,
      o = Math.sin,
      l = a(i / 2),
      h = a(n / 2),
      c = a(s / 2),
      u = o(i / 2),
      d = o(n / 2),
      p = o(s / 2);
    switch (r) {
      case "XYZ":
        (this._x = u * h * c + l * d * p),
          (this._y = l * d * c - u * h * p),
          (this._z = l * h * p + u * d * c),
          (this._w = l * h * c - u * d * p);
        break;
      case "YXZ":
        (this._x = u * h * c + l * d * p),
          (this._y = l * d * c - u * h * p),
          (this._z = l * h * p - u * d * c),
          (this._w = l * h * c + u * d * p);
        break;
      case "ZXY":
        (this._x = u * h * c - l * d * p),
          (this._y = l * d * c + u * h * p),
          (this._z = l * h * p + u * d * c),
          (this._w = l * h * c - u * d * p);
        break;
      case "ZYX":
        (this._x = u * h * c - l * d * p),
          (this._y = l * d * c + u * h * p),
          (this._z = l * h * p - u * d * c),
          (this._w = l * h * c + u * d * p);
        break;
      case "YZX":
        (this._x = u * h * c + l * d * p),
          (this._y = l * d * c + u * h * p),
          (this._z = l * h * p - u * d * c),
          (this._w = l * h * c - u * d * p);
        break;
      case "XZY":
        (this._x = u * h * c - l * d * p),
          (this._y = l * d * c - u * h * p),
          (this._z = l * h * p + u * d * c),
          (this._w = l * h * c + u * d * p);
        break;
      default:
        console.warn(
          "THREE.Quaternion: .setFromEuler() encountered an unknown order: " + r
        );
    }
    return !1 !== t && this._onChangeCallback(), this;
  }
  setFromAxisAngle(e, t) {
    const i = t / 2,
      n = Math.sin(i);
    return (
      (this._x = e.x * n),
      (this._y = e.y * n),
      (this._z = e.z * n),
      (this._w = Math.cos(i)),
      this._onChangeCallback(),
      this
    );
  }
  setFromRotationMatrix(e) {
    const t = e.elements,
      i = t[0],
      n = t[4],
      s = t[8],
      r = t[1],
      a = t[5],
      o = t[9],
      l = t[2],
      h = t[6],
      c = t[10],
      u = i + a + c;
    if (u > 0) {
      const e = 0.5 / Math.sqrt(u + 1);
      (this._w = 0.25 / e),
        (this._x = (h - o) * e),
        (this._y = (s - l) * e),
        (this._z = (r - n) * e);
    } else if (i > a && i > c) {
      const e = 2 * Math.sqrt(1 + i - a - c);
      (this._w = (h - o) / e),
        (this._x = 0.25 * e),
        (this._y = (n + r) / e),
        (this._z = (s + l) / e);
    } else if (a > c) {
      const e = 2 * Math.sqrt(1 + a - i - c);
      (this._w = (s - l) / e),
        (this._x = (n + r) / e),
        (this._y = 0.25 * e),
        (this._z = (o + h) / e);
    } else {
      const e = 2 * Math.sqrt(1 + c - i - a);
      (this._w = (r - n) / e),
        (this._x = (s + l) / e),
        (this._y = (o + h) / e),
        (this._z = 0.25 * e);
    }
    return this._onChangeCallback(), this;
  }
  setFromUnitVectors(e, t) {
    let i = e.dot(t) + 1;
    return (
      i < Number.EPSILON
        ? ((i = 0),
          Math.abs(e.x) > Math.abs(e.z)
            ? ((this._x = -e.y), (this._y = e.x), (this._z = 0), (this._w = i))
            : ((this._x = 0), (this._y = -e.z), (this._z = e.y), (this._w = i)))
        : ((this._x = e.y * t.z - e.z * t.y),
          (this._y = e.z * t.x - e.x * t.z),
          (this._z = e.x * t.y - e.y * t.x),
          (this._w = i)),
      this.normalize()
    );
  }
  angleTo(e) {
    return 2 * Math.acos(Math.abs(pv(this.dot(e), -1, 1)));
  }
  rotateTowards(e, t) {
    const i = this.angleTo(e);
    if (0 === i) return this;
    const n = Math.min(1, t / i);
    return this.slerp(e, n), this;
  }
  identity() {
    return this.set(0, 0, 0, 1);
  }
  invert() {
    return this.conjugate();
  }
  conjugate() {
    return (
      (this._x *= -1),
      (this._y *= -1),
      (this._z *= -1),
      this._onChangeCallback(),
      this
    );
  }
  dot(e) {
    return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w;
  }
  lengthSq() {
    return (
      this._x * this._x +
      this._y * this._y +
      this._z * this._z +
      this._w * this._w
    );
  }
  length() {
    return Math.sqrt(
      this._x * this._x +
        this._y * this._y +
        this._z * this._z +
        this._w * this._w
    );
  }
  normalize() {
    let e = this.length();
    return (
      0 === e
        ? ((this._x = 0), (this._y = 0), (this._z = 0), (this._w = 1))
        : ((e = 1 / e),
          (this._x = this._x * e),
          (this._y = this._y * e),
          (this._z = this._z * e),
          (this._w = this._w * e)),
      this._onChangeCallback(),
      this
    );
  }
  multiply(e) {
    return this.multiplyQuaternions(this, e);
  }
  premultiply(e) {
    return this.multiplyQuaternions(e, this);
  }
  multiplyQuaternions(e, t) {
    const i = e._x,
      n = e._y,
      s = e._z,
      r = e._w,
      a = t._x,
      o = t._y,
      l = t._z,
      h = t._w;
    return (
      (this._x = i * h + r * a + n * l - s * o),
      (this._y = n * h + r * o + s * a - i * l),
      (this._z = s * h + r * l + i * o - n * a),
      (this._w = r * h - i * a - n * o - s * l),
      this._onChangeCallback(),
      this
    );
  }
  slerp(e, t) {
    if (0 === t) return this;
    if (1 === t) return this.copy(e);
    const i = this._x,
      n = this._y,
      s = this._z,
      r = this._w;
    let a = r * e._w + i * e._x + n * e._y + s * e._z;
    if (
      (a < 0
        ? ((this._w = -e._w),
          (this._x = -e._x),
          (this._y = -e._y),
          (this._z = -e._z),
          (a = -a))
        : this.copy(e),
      a >= 1)
    )
      return (this._w = r), (this._x = i), (this._y = n), (this._z = s), this;
    const o = 1 - a * a;
    if (o <= Number.EPSILON) {
      const e = 1 - t;
      return (
        (this._w = e * r + t * this._w),
        (this._x = e * i + t * this._x),
        (this._y = e * n + t * this._y),
        (this._z = e * s + t * this._z),
        this.normalize(),
        this._onChangeCallback(),
        this
      );
    }
    const l = Math.sqrt(o),
      h = Math.atan2(l, a),
      c = Math.sin((1 - t) * h) / l,
      u = Math.sin(t * h) / l;
    return (
      (this._w = r * c + this._w * u),
      (this._x = i * c + this._x * u),
      (this._y = n * c + this._y * u),
      (this._z = s * c + this._z * u),
      this._onChangeCallback(),
      this
    );
  }
  slerpQuaternions(e, t, i) {
    return this.copy(e).slerp(t, i);
  }
  random() {
    const e = Math.random(),
      t = Math.sqrt(1 - e),
      i = Math.sqrt(e),
      n = 2 * Math.PI * Math.random(),
      s = 2 * Math.PI * Math.random();
    return this.set(
      t * Math.cos(n),
      i * Math.sin(s),
      i * Math.cos(s),
      t * Math.sin(n)
    );
  }
  equals(e) {
    return (
      e._x === this._x &&
      e._y === this._y &&
      e._z === this._z &&
      e._w === this._w
    );
  }
  fromArray(e, t = 0) {
    return (
      (this._x = e[t]),
      (this._y = e[t + 1]),
      (this._z = e[t + 2]),
      (this._w = e[t + 3]),
      this._onChangeCallback(),
      this
    );
  }
  toArray(e = [], t = 0) {
    return (
      (e[t] = this._x),
      (e[t + 1] = this._y),
      (e[t + 2] = this._z),
      (e[t + 3] = this._w),
      e
    );
  }
  fromBufferAttribute(e, t) {
    return (
      (this._x = e.getX(t)),
      (this._y = e.getY(t)),
      (this._z = e.getZ(t)),
      (this._w = e.getW(t)),
      this
    );
  }
  toJSON() {
    return this.toArray();
  }
  _onChange(e) {
    return (this._onChangeCallback = e), this;
  }
  _onChangeCallback() {}
  *[Symbol.iterator]() {
    yield this._x, yield this._y, yield this._z, yield this._w;
  }
}
class gv {
  constructor(e = 0, t = 0, i = 0) {
    (gv.prototype.isVector3 = !0), (this.x = e), (this.y = t), (this.z = i);
  }
  set(e, t, i) {
    return (
      void 0 === i && (i = this.z),
      (this.x = e),
      (this.y = t),
      (this.z = i),
      this
    );
  }
  setScalar(e) {
    return (this.x = e), (this.y = e), (this.z = e), this;
  }
  setX(e) {
    return (this.x = e), this;
  }
  setY(e) {
    return (this.y = e), this;
  }
  setZ(e) {
    return (this.z = e), this;
  }
  setComponent(e, t) {
    switch (e) {
      case 0:
        this.x = t;
        break;
      case 1:
        this.y = t;
        break;
      case 2:
        this.z = t;
        break;
      default:
        throw new Error("index is out of range: " + e);
    }
    return this;
  }
  getComponent(e) {
    switch (e) {
      case 0:
        return this.x;
      case 1:
        return this.y;
      case 2:
        return this.z;
      default:
        throw new Error("index is out of range: " + e);
    }
  }
  clone() {
    return new this.constructor(this.x, this.y, this.z);
  }
  copy(e) {
    return (this.x = e.x), (this.y = e.y), (this.z = e.z), this;
  }
  add(e) {
    return (this.x += e.x), (this.y += e.y), (this.z += e.z), this;
  }
  addScalar(e) {
    return (this.x += e), (this.y += e), (this.z += e), this;
  }
  addVectors(e, t) {
    return (
      (this.x = e.x + t.x), (this.y = e.y + t.y), (this.z = e.z + t.z), this
    );
  }
  addScaledVector(e, t) {
    return (this.x += e.x * t), (this.y += e.y * t), (this.z += e.z * t), this;
  }
  sub(e) {
    return (this.x -= e.x), (this.y -= e.y), (this.z -= e.z), this;
  }
  subScalar(e) {
    return (this.x -= e), (this.y -= e), (this.z -= e), this;
  }
  subVectors(e, t) {
    return (
      (this.x = e.x - t.x), (this.y = e.y - t.y), (this.z = e.z - t.z), this
    );
  }
  multiply(e) {
    return (this.x *= e.x), (this.y *= e.y), (this.z *= e.z), this;
  }
  multiplyScalar(e) {
    return (this.x *= e), (this.y *= e), (this.z *= e), this;
  }
  multiplyVectors(e, t) {
    return (
      (this.x = e.x * t.x), (this.y = e.y * t.y), (this.z = e.z * t.z), this
    );
  }
  applyEuler(e) {
    return this.applyQuaternion(vv.setFromEuler(e));
  }
  applyAxisAngle(e, t) {
    return this.applyQuaternion(vv.setFromAxisAngle(e, t));
  }
  applyMatrix3(e) {
    const t = this.x,
      i = this.y,
      n = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[3] * i + s[6] * n),
      (this.y = s[1] * t + s[4] * i + s[7] * n),
      (this.z = s[2] * t + s[5] * i + s[8] * n),
      this
    );
  }
  applyNormalMatrix(e) {
    return this.applyMatrix3(e).normalize();
  }
  applyMatrix4(e) {
    const t = this.x,
      i = this.y,
      n = this.z,
      s = e.elements,
      r = 1 / (s[3] * t + s[7] * i + s[11] * n + s[15]);
    return (
      (this.x = (s[0] * t + s[4] * i + s[8] * n + s[12]) * r),
      (this.y = (s[1] * t + s[5] * i + s[9] * n + s[13]) * r),
      (this.z = (s[2] * t + s[6] * i + s[10] * n + s[14]) * r),
      this
    );
  }
  applyQuaternion(e) {
    const t = this.x,
      i = this.y,
      n = this.z,
      s = e.x,
      r = e.y,
      a = e.z,
      o = e.w,
      l = o * t + r * n - a * i,
      h = o * i + a * t - s * n,
      c = o * n + s * i - r * t,
      u = -s * t - r * i - a * n;
    return (
      (this.x = l * o + u * -s + h * -a - c * -r),
      (this.y = h * o + u * -r + c * -s - l * -a),
      (this.z = c * o + u * -a + l * -r - h * -s),
      this
    );
  }
  project(e) {
    return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(
      e.projectionMatrix
    );
  }
  unproject(e) {
    return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(
      e.matrixWorld
    );
  }
  transformDirection(e) {
    const t = this.x,
      i = this.y,
      n = this.z,
      s = e.elements;
    return (
      (this.x = s[0] * t + s[4] * i + s[8] * n),
      (this.y = s[1] * t + s[5] * i + s[9] * n),
      (this.z = s[2] * t + s[6] * i + s[10] * n),
      this.normalize()
    );
  }
  divide(e) {
    return (this.x /= e.x), (this.y /= e.y), (this.z /= e.z), this;
  }
  divideScalar(e) {
    return this.multiplyScalar(1 / e);
  }
  min(e) {
    return (
      (this.x = Math.min(this.x, e.x)),
      (this.y = Math.min(this.y, e.y)),
      (this.z = Math.min(this.z, e.z)),
      this
    );
  }
  max(e) {
    return (
      (this.x = Math.max(this.x, e.x)),
      (this.y = Math.max(this.y, e.y)),
      (this.z = Math.max(this.z, e.z)),
      this
    );
  }
  clamp(e, t) {
    return (
      (this.x = Math.max(e.x, Math.min(t.x, this.x))),
      (this.y = Math.max(e.y, Math.min(t.y, this.y))),
      (this.z = Math.max(e.z, Math.min(t.z, this.z))),
      this
    );
  }
  clampScalar(e, t) {
    return (
      (this.x = Math.max(e, Math.min(t, this.x))),
      (this.y = Math.max(e, Math.min(t, this.y))),
      (this.z = Math.max(e, Math.min(t, this.z))),
      this
    );
  }
  clampLength(e, t) {
    const i = this.length();
    return this.divideScalar(i || 1).multiplyScalar(
      Math.max(e, Math.min(t, i))
    );
  }
  floor() {
    return (
      (this.x = Math.floor(this.x)),
      (this.y = Math.floor(this.y)),
      (this.z = Math.floor(this.z)),
      this
    );
  }
  ceil() {
    return (
      (this.x = Math.ceil(this.x)),
      (this.y = Math.ceil(this.y)),
      (this.z = Math.ceil(this.z)),
      this
    );
  }
  round() {
    return (
      (this.x = Math.round(this.x)),
      (this.y = Math.round(this.y)),
      (this.z = Math.round(this.z)),
      this
    );
  }
  roundToZero() {
    return (
      (this.x = Math.trunc(this.x)),
      (this.y = Math.trunc(this.y)),
      (this.z = Math.trunc(this.z)),
      this
    );
  }
  negate() {
    return (this.x = -this.x), (this.y = -this.y), (this.z = -this.z), this;
  }
  dot(e) {
    return this.x * e.x + this.y * e.y + this.z * e.z;
  }
  lengthSq() {
    return this.x * this.x + this.y * this.y + this.z * this.z;
  }
  length() {
    return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z);
  }
  manhattanLength() {
    return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z);
  }
  normalize() {
    return this.divideScalar(this.length() || 1);
  }
  setLength(e) {
    return this.normalize().multiplyScalar(e);
  }
  lerp(e, t) {
    return (
      (this.x += (e.x - this.x) * t),
      (this.y += (e.y - this.y) * t),
      (this.z += (e.z - this.z) * t),
      this
    );
  }
  lerpVectors(e, t, i) {
    return (
      (this.x = e.x + (t.x - e.x) * i),
      (this.y = e.y + (t.y - e.y) * i),
      (this.z = e.z + (t.z - e.z) * i),
      this
    );
  }
  cross(e) {
    return this.crossVectors(this, e);
  }
  crossVectors(e, t) {
    const i = e.x,
      n = e.y,
      s = e.z,
      r = t.x,
      a = t.y,
      o = t.z;
    return (
      (this.x = n * o - s * a),
      (this.y = s * r - i * o),
      (this.z = i * a - n * r),
      this
    );
  }
  projectOnVector(e) {
    const t = e.lengthSq();
    if (0 === t) return this.set(0, 0, 0);
    const i = e.dot(this) / t;
    return this.copy(e).multiplyScalar(i);
  }
  projectOnPlane(e) {
    return _v.copy(this).projectOnVector(e), this.sub(_v);
  }
  reflect(e) {
    return this.sub(_v.copy(e).multiplyScalar(2 * this.dot(e)));
  }
  angleTo(e) {
    const t = Math.sqrt(this.lengthSq() * e.lengthSq());
    if (0 === t) return Math.PI / 2;
    const i = this.dot(e) / t;
    return Math.acos(pv(i, -1, 1));
  }
  distanceTo(e) {
    return Math.sqrt(this.distanceToSquared(e));
  }
  distanceToSquared(e) {
    const t = this.x - e.x,
      i = this.y - e.y,
      n = this.z - e.z;
    return t * t + i * i + n * n;
  }
  manhattanDistanceTo(e) {
    return (
      Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    );
  }
  setFromSpherical(e) {
    return this.setFromSphericalCoords(e.radius, e.phi, e.theta);
  }
  setFromSphericalCoords(e, t, i) {
    const n = Math.sin(t) * e;
    return (
      (this.x = n * Math.sin(i)),
      (this.y = Math.cos(t) * e),
      (this.z = n * Math.cos(i)),
      this
    );
  }
  setFromCylindrical(e) {
    return this.setFromCylindricalCoords(e.radius, e.theta, e.y);
  }
  setFromCylindricalCoords(e, t, i) {
    return (
      (this.x = e * Math.sin(t)), (this.y = i), (this.z = e * Math.cos(t)), this
    );
  }
  setFromMatrixPosition(e) {
    const t = e.elements;
    return (this.x = t[12]), (this.y = t[13]), (this.z = t[14]), this;
  }
  setFromMatrixScale(e) {
    const t = this.setFromMatrixColumn(e, 0).length(),
      i = this.setFromMatrixColumn(e, 1).length(),
      n = this.setFromMatrixColumn(e, 2).length();
    return (this.x = t), (this.y = i), (this.z = n), this;
  }
  setFromMatrixColumn(e, t) {
    return this.fromArray(e.elements, 4 * t);
  }
  setFromMatrix3Column(e, t) {
    return this.fromArray(e.elements, 3 * t);
  }
  setFromEuler(e) {
    return (this.x = e._x), (this.y = e._y), (this.z = e._z), this;
  }
  setFromColor(e) {
    return (this.x = e.r), (this.y = e.g), (this.z = e.b), this;
  }
  equals(e) {
    return e.x === this.x && e.y === this.y && e.z === this.z;
  }
  fromArray(e, t = 0) {
    return (this.x = e[t]), (this.y = e[t + 1]), (this.z = e[t + 2]), this;
  }
  toArray(e = [], t = 0) {
    return (e[t] = this.x), (e[t + 1] = this.y), (e[t + 2] = this.z), e;
  }
  fromBufferAttribute(e, t) {
    return (
      (this.x = e.getX(t)), (this.y = e.getY(t)), (this.z = e.getZ(t)), this
    );
  }
  random() {
    return (
      (this.x = Math.random()),
      (this.y = Math.random()),
      (this.z = Math.random()),
      this
    );
  }
  randomDirection() {
    const e = 2 * (Math.random() - 0.5),
      t = Math.random() * Math.PI * 2,
      i = Math.sqrt(1 - e ** 2);
    return (
      (this.x = i * Math.cos(t)), (this.y = i * Math.sin(t)), (this.z = e), this
    );
  }
  *[Symbol.iterator]() {
    yield this.x, yield this.y, yield this.z;
  }
}
const _v = new gv(),
  vv = new mv();
function Av(e, t, i = 2e-7) {
  return yv(e, t) < i;
}
function yv(e, t) {
  return Math.sqrt(
    Math.pow(e[0] - t[0], 2) +
      Math.pow(e[1] - t[1], 2) +
      Math.pow((e[2] || 0) - (t[2] || 0), 2)
  );
}
function xv(e, t, i) {
  return e + (t - e) * i;
}
function bv(e, t, i) {
  return [
    e[0] + (t[0] - e[0]) * i,
    e[1] + (t[1] - e[1]) * i,
    e[2] + (t[2] - e[2]) * i,
  ];
}
function Ev(e, t) {
  let i = new fv();
  return i.fromArray([t[0] - e[0], t[1] - e[1]]), i.normalize(), i;
}
function Sv(e) {
  return new fv(-e.y, e.x);
}
function Cv(e, t) {
  let i = new fv();
  return i.addVectors(e, t), i.normalize(), Sv(i);
}
function Mv(e, t, i) {
  const [n, s, r] = e,
    a = s[0] - n[0],
    o = s[1] - n[1],
    l = Math.atan(o / a),
    h = l + Math.PI / 2,
    c = [n[0] + a * (1 - r), n[1] + o * (1 - r)],
    u = [0, c[1] - Math.tan(h) * c[0]],
    [d, p, f] = t,
    m = p[0] - d[0],
    g = p[1] - d[1],
    _ = Math.atan(g / m) + Math.PI / 2,
    v = [d[0] + m * f, d[1] + g * f],
    A = [0, v[1] - Math.tan(_) * v[0]],
    y = (function (e, t, i, n) {
      let s = (t.y - e.y) * (n.x - i.x) - (e.x - t.x) * (i.y - n.y);
      return (
        0 !== s && {
          x:
            ((t.x - e.x) * (n.x - i.x) * (i.y - e.y) +
              (t.y - e.y) * (n.x - i.x) * e.x -
              (n.y - i.y) * (t.x - e.x) * i.x) /
            s,
          y:
            -(
              (t.y - e.y) * (n.y - i.y) * (i.x - e.x) +
              (t.x - e.x) * (n.y - i.y) * e.y -
              (n.x - i.x) * (t.y - e.y) * i.y
            ) / s,
        }
      );
    })(
      { x: u[0], y: u[1] },
      { x: c[0], y: c[1] },
      { x: A[0], y: A[1] },
      { x: v[0], y: v[1] }
    );
  let x, b;
  if (y) {
    const e = y.x - c[0],
      t = y.y - c[1],
      r = Math.sqrt(e * e + t * t),
      a = new gv(y.x, y.y),
      o = new gv(c[0], c[1]),
      h = new gv(v[0], v[1]),
      u = new gv().subVectors(a, o).normalize(),
      f = new gv().subVectors(a, h).normalize().angleTo(u),
      m = new fv()
        .subVectors(new fv(s[0], s[1]), new fv(n[0], n[1]))
        .normalize(),
      g = new fv()
        .subVectors(new fv(p[0], p[1]), new fv(d[0], d[1]))
        .normalize();
    let _ = 0;
    switch (
      (m.angle() < Math.PI / 2
        ? (_ = 1)
        : m.angle() < Math.PI
        ? (_ = 2)
        : m.angle() < 1.5 * Math.PI
        ? (_ = 3)
        : m.angle() < 2 * Math.PI && (_ = 4),
      _)
    ) {
      case 1:
        if (g.angle() > m.angle() && g.angle() < m.negate().angle()) {
          const e = Math.abs(l) + (i * f) / 2,
            t = r * Math.sin(e),
            n = r * Math.cos(e);
          (x = [y.x + t, y.y - n]), (b = [t, -n]);
        } else {
          const e = Math.PI / 2 - Math.abs(l) + (i * f) / 2,
            t = r * Math.cos(e),
            n = r * Math.sin(e);
          (x = [y.x - t, y.y + n]), (b = [t, -n]);
        }
        break;
      case 2:
        if (g.angle() > m.angle() && g.angle() < m.negate().angle()) {
          const e = Math.PI / 2 - Math.abs(l) + (i * f) / 2,
            t = r * Math.cos(e),
            n = r * Math.sin(e);
          (x = [y.x + t, y.y + n]), (b = [t, n]);
        } else {
          const e = Math.abs(l) + (i * f) / 2,
            t = r * Math.sin(e),
            n = r * Math.cos(e);
          (x = [y.x - t, y.y - n]), (b = [t, n]);
        }
        break;
      case 3:
        if (g.angle() < m.angle() && g.angle() > m.negate().angle()) {
          const e = Math.PI / 2 - Math.abs(l) + (i * f) / 2,
            t = r * Math.cos(e),
            n = r * Math.sin(e);
          (x = [y.x + t, y.y - n]), (b = [-t, n]);
        } else {
          const e = Math.abs(l) + (i * f) / 2,
            t = r * Math.sin(e),
            n = r * Math.cos(e);
          (x = [y.x - t, y.y + n]), (b = [-t, n]);
        }
        break;
      case 4:
        if (g.angle() < m.angle() && g.angle() > m.negate().angle()) {
          const e = Math.abs(l) + (i * f) / 2,
            t = r * Math.sin(e),
            n = r * Math.cos(e);
          (x = [y.x + t, y.y + n]), (b = [-t, -n]);
        } else {
          const e = Math.PI / 2 - Math.abs(l) + (i * f) / 2,
            t = r * Math.cos(e),
            n = r * Math.sin(e);
          (x = [y.x - t, y.y - n]), (b = [-t, -n]);
        }
    }
  }
  return { point: x, center: y, interPointA: c, interPointB: v, direction: b };
}
function wv(e) {
  return !isNaN(e) && null !== e && !Array.isArray(e);
}
function Tv() {}
function Iv(e, t) {
  for (let i in t) e[i] = t[i];
}
function Rv(e, t) {
  (this.lng = e), (this.lat = t);
}
function Pv(e, t) {
  (this.x = e), (this.y = t);
}
Iv(Rv.prototype, {
  equals: function (e) {
    return this.lat === e.lat && this.lng === e.lng;
  },
  clone: function () {
    return new Rv(this.lat, this.lng);
  },
  getLngSpan: function (e) {
    let t = this.lng,
      i = Math.abs(e - t);
    return i > 180 && (i = 360 - i), i;
  },
  sub: function (e) {
    return new Rv(this.lat - e.lat, this.lng - e.lng);
  },
  toString: function () {
    return "Point";
  },
}),
  Iv(Tv, {
    EARTHRADIUS: 6370996.81,
    MCBAND: [12890594.86, 8362377.87, 5591021, 3481989.83, 1678043.12, 0],
    LLBAND: [75, 60, 45, 30, 15, 0],
    MC2LL: [
      [
        1.410526172116255e-8, 898305509648872e-20, -1.9939833816331,
        200.9824383106796, -187.2403703815547, 91.6087516669843,
        -23.38765649603339, 2.57121317296198, -0.03801003308653, 17337981.2,
      ],
      [
        -7.435856389565537e-9, 8983055097726239e-21, -0.78625201886289,
        96.32687599759846, -1.85204757529826, -59.36935905485877,
        47.40033549296737, -16.50741931063887, 2.28786674699375, 10260144.86,
      ],
      [
        -3.030883460898826e-8, 898305509983578e-20, 0.30071316287616,
        59.74293618442277, 7.357984074871, -25.38371002664745,
        13.45380521110908, -3.29883767235584, 0.32710905363475, 6856817.37,
      ],
      [
        -1.981981304930552e-8, 8983055099779535e-21, 0.03278182852591,
        40.31678527705744, 0.65659298677277, -4.44255534477492,
        0.85341911805263, 0.12923347998204, -0.04625736007561, 4482777.06,
      ],
      [
        3.09191371068437e-9, 8983055096812155e-21, 6995724062e-14,
        23.10934304144901, -0.00023663490511, -0.6321817810242,
        -0.00663494467273, 0.03430082397953, -0.00466043876332, 2555164.4,
      ],
      [
        2.890871144776878e-9, 8983055095805407e-21, -3.068298e-8,
        7.47137025468032, -353937994e-14, -0.02145144861037, -1234426596e-14,
        0.00010322952773, -323890364e-14, 826088.5,
      ],
    ],
    LL2MC: [
      [
        -0.0015702102444, 111320.7020616939, 0x60e374c3105a3, -0x24bb4115e2e164,
        0x5cc55543bb0ae8, -0x7ce070193f3784, 0x5e7ca61ddf8150,
        -0x261a578d8b24d0, 0x665d60f3742ca, 82.5,
      ],
      [
        0.0008277824516172526, 111320.7020463578, 647795574.6671607,
        -4082003173.641316, 10774905663.51142, -15171875531.51559,
        12053065338.62167, -5124939663.577472, 913311935.9512032, 67.5,
      ],
      [
        0.00337398766765, 111320.7020202162, 4481351.045890365,
        -23393751.19931662, 79682215.47186455, -115964993.2797253,
        97236711.15602145, -43661946.33752821, 8477230.501135234, 52.5,
      ],
      [
        0.00220636496208, 111320.7020209128, 51751.86112841131,
        3796837.749470245, 992013.7397791013, -1221952.21711287,
        1340652.697009075, -620943.6990984312, 144416.9293806241, 37.5,
      ],
      [
        -0.0003441963504368392, 111320.7020576856, 278.2353980772752,
        2485758.690035394, 6070.750963243378, 54821.18345352118,
        9540.606633304236, -2710.55326746645, 1405.483844121726, 22.5,
      ],
      [
        -0.0003218135878613132, 111320.7020701615, 0.00369383431289,
        823725.6402795718, 0.46104986909093, 2351.343141331292,
        1.58060784298199, 8.77738589078284, 0.37238884252424, 7.45,
      ],
    ],
    getDistanceByMC: function (e, t) {
      if (!e || !t) return 0;
      let i, n, s, r;
      return (e = this.convertMC2LL(e))
        ? ((i = this.toRadians(e.lng)),
          (n = this.toRadians(e.lat)),
          (t = this.convertMC2LL(t))
            ? ((s = this.toRadians(t.lng)),
              (r = this.toRadians(t.lat)),
              this.getDistance(i, s, n, r))
            : 0)
        : 0;
    },
    getDistanceByLL: function (e, t) {
      if (!e || !t) return 0;
      let i, n, s, r;
      return (
        (e.lng = this.getLoop(e.lng, -180, 180)),
        (e.lat = this.getRange(e.lat, -74, 74)),
        (t.lng = this.getLoop(t.lng, -180, 180)),
        (t.lat = this.getRange(t.lat, -74, 74)),
        (i = this.toRadians(e.lng)),
        (s = this.toRadians(e.lat)),
        (n = this.toRadians(t.lng)),
        (r = this.toRadians(t.lat)),
        this.getDistance(i, n, s, r)
      );
    },
    convertMC2LL: function (e) {
      if (null == e) return new Rv(0, 0);
      if (e.lng < 180 && e.lng > -180 && e.lat < 90 && e.lat > -90) return e;
      let t, i;
      t = new Rv(Math.abs(e.lng), Math.abs(e.lat));
      for (let s = 0; s < this.MCBAND.length; s++)
        if (t.lat >= this.MCBAND[s]) {
          i = this.MC2LL[s];
          break;
        }
      let n = this.convertor(e, i);
      return (e = new Rv(n.lng.toFixed(6), n.lat.toFixed(6)));
    },
    convertLL2MC: function (e) {
      if (null == e) return new Rv(0, 0);
      if (e.lng > 180 || e.lng < -180 || e.lat > 90 || e.lat < -90) return e;
      let t, i;
      if (
        ((e.lng = this.getLoop(e.lng, -180, 180)),
        (e.lat = this.getRange(e.lat, -74, 74)),
        (t = new Rv(e.lng, e.lat)),
        window.BMAPGL_84)
      ) {
        var n = {},
          s = 6378137;
        n.lng = ((t.lng * Math.PI) / 180) * s;
        var r = (t.lat * Math.PI) / 180;
        return (
          (n.lat = 3189068.5 * Math.log((1 + Math.sin(r)) / (1 - Math.sin(r)))),
          new Rv(Number(n.lng), Number(n.lat))
        );
      }
      for (var a = 0; a < this.LLBAND.length; a++)
        if (t.lat >= this.LLBAND[a]) {
          i = this.LL2MC[a];
          break;
        }
      if (!i)
        for (a = 0; a < this.LLBAND.length; a++)
          if (t.lat <= -this.LLBAND[a]) {
            i = this.LL2MC[a];
            break;
          }
      let o = this.convertor(e, i);
      return (e = new Rv(Number(o.lng), Number(o.lat)));
    },
    convertor: function (e, t) {
      if (!e || !t) return;
      let i = t[0] + t[1] * Math.abs(e.lng),
        n = Math.abs(e.lat) / t[9],
        s =
          t[2] +
          t[3] * n +
          t[4] * n * n +
          t[5] * n * n * n +
          t[6] * n * n * n * n +
          t[7] * n * n * n * n * n +
          t[8] * n * n * n * n * n * n;
      return (i *= e.lng < 0 ? -1 : 1), (s *= e.lat < 0 ? -1 : 1), new Rv(i, s);
    },
    getDistance: function (e, t, i, n) {
      return (
        this.EARTHRADIUS *
        Math.acos(
          Math.sin(i) * Math.sin(n) +
            Math.cos(i) * Math.cos(n) * Math.cos(t - e)
        )
      );
    },
    toRadians: function (e) {
      return (Math.PI * e) / 180;
    },
    toDegrees: function (e) {
      return (180 * e) / Math.PI;
    },
    getRange: function (e, t, i) {
      return (
        null != t && (e = Math.max(e, t)), null != i && (e = Math.min(e, i)), e
      );
    },
    getLoop: function (e, t, i) {
      for (; e > i; ) e -= i - t;
      for (; e < t; ) e += i - t;
      return e;
    },
  }),
  Iv(Tv.prototype, {
    lngLatToMercator: function (e) {
      return Tv.convertLL2MC(e);
    },
    lngLatToPoint: function (e) {
      let t = Tv.convertLL2MC(e);
      return new Pv(t.lng, t.lat);
    },
    mercatorToLngLat: function (e) {
      return Tv.convertMC2LL(e);
    },
    pointToLngLat: function (e) {
      let t = new Rv(e.x, e.y);
      return Tv.convertMC2LL(t);
    },
    pointToPixel: function (e, t, i, n, s) {
      if (!e) return;
      e = this.lngLatToMercator(e, s);
      let r = this.getZoomUnits(t);
      return new Pv(
        Math.round((e.lng - i.lng) / r + n.width / 2),
        Math.round((i.lat - e.lat) / r + n.height / 2)
      );
    },
    pixelToPoint: function (e, t, i, n, s) {
      if (!e) return;
      let r = this.getZoomUnits(t),
        a = new Rv(
          i.lng + r * (e.x - n.width / 2),
          i.lat - r * (e.y - n.height / 2)
        );
      return this.mercatorToLngLat(a, s);
    },
    getZoomUnits: function (e) {
      return Math.pow(2, 18 - e);
    },
  });
const Dv = (e, t) => {
  if (e)
    if (0 === t) void 0 === e[2] && (e[2] = 0);
    else for (const i of e) Dv(i, t - 1);
};
function Lv(e, t) {
  if (!e) return [];
  let i = null;
  return (
    t && Fv(e, t), (i = e.features ? e.features : Array.isArray(e) ? e : [e]), i
  );
}
function Fv(e, t) {
  if (e)
    if ("FeatureCollection" === e.type || e.features) {
      const i = e.features;
      for (const e of i) Fv(e, t);
    } else if (Array.isArray(e)) {
      const i = e;
      for (const e of i) Fv(e, t);
    } else if ("Feature" === e.type || e.geometry) {
      if (!e.geometry) return;
      if (Array.isArray(e.geometry.coordinates)) {
        if (e.geometry[t]) return;
        kv(e);
        const i = Nv(e.geometry.coordinates, t);
        e.geometry[t] = i;
      }
    }
}
function Nv(e, t) {
  if (Array.isArray(e[0])) {
    const i = [];
    for (let n of e) i.push(Nv(n, t));
    return i;
  }
  if ("number" == typeof e[0] || "string" == typeof e[0]) return Bv(e, t);
}
function Bv(e, t) {
  if (!e) return [];
  let i = [];
  if (e[0] > 180 || e[0] < -180 || e[1] > 90 || e[1] < -90) i = [e[0], e[1]];
  else if ("_bmap_mercator" === t) {
    const t = Tv.convertLL2MC({ lng: e[0], lat: e[1] });
    (i[0] = t.lng), (i[1] = t.lat);
  } else i = uv(e);
  return void 0 !== e[2] ? (i[2] = e[2]) : (i[2] = 0), i;
}
function kv(e) {
  e.type || (e.type = "Feature");
  const t = e.geometry.type,
    i = {
      Point: 0,
      MultiPoint: 1,
      LineString: 1,
      MultiLineString: 2,
      Polygon: 2,
      MultiPolygon: 3,
    };
  return Object.keys(i).includes(t) && Dv(e.geometry.coordinates, i[t]), e;
}
function Ov(e, t) {
  if (!e.geometry) return [];
  if ("Point" === e.geometry.type) return [e];
  if ("MultiPoint" === e.geometry.type || "LineString" === e.geometry.type) {
    const i = [],
      { type: n, geometry: s, ...r } = e;
    for (let a = 0; a < e.geometry.coordinates.length; a++) {
      const n = e.geometry.coordinates[a];
      if (t) {
        const s = e.geometry[t][a];
        i.push({
          type: "Feature",
          geometry: { type: "Point", coordinates: n, [t]: s },
          ...r,
        });
      } else
        i.push({
          type: "Feature",
          geometry: { type: "Point", coordinates: n },
          ...r,
        });
    }
    return i;
  }
  return [];
}
function Uv(e, t) {
  if (!e.geometry) return [];
  if ("LineString" === e.geometry.type) return [e];
  if ("MultiLineString" === e.geometry.type || "Polygon" === e.geometry.type) {
    const i = [],
      { type: n, geometry: s, ...r } = e;
    for (let a = 0; a < e.geometry.coordinates.length; a++) {
      const n = e.geometry.coordinates[a];
      if (t) {
        const s = e.geometry[t][a];
        i.push({
          type: "Feature",
          geometry: { type: "LineString", coordinates: n, [t]: s },
          ...r,
        });
      } else
        i.push({
          type: "Feature",
          geometry: { type: "LineString", coordinates: n },
          ...r,
        });
    }
    return i;
  }
  return [];
}
function zv(e, t) {
  if (!e.geometry) return [];
  if ("Polygon" === e.geometry.type) return [e];
  if ("MultiPolygon" === e.geometry.type) {
    const i = [],
      { type: n, geometry: s, ...r } = e;
    for (let a = 0; a < e.geometry.coordinates.length; a++) {
      const n = e.geometry.coordinates[a];
      if (t) {
        const s = e.geometry[t][a];
        i.push({
          type: "Feature",
          geometry: { type: "Polygon", coordinates: n, [t]: s },
          ...r,
        });
      } else
        i.push({
          type: "Feature",
          geometry: { type: "Polygon", coordinates: n },
          ...r,
        });
    }
    return i;
  }
  return [];
}
function Gv(e) {
  let t = this.getGeoFeatures(e),
    i = [];
  for (let n = 0; n < t.length; n++) {
    const e = t[n],
      s = this.multiPolygonToPolygons(e);
    for (let t = 0; t < s.length; t++) {
      const e = s[t],
        n = this.multiLineStringToLineStrings(e);
      i.push(...n);
    }
  }
  return i;
}
function Vv(e, t, i) {
  if (null === e) return;
  let n,
    s,
    r,
    a,
    o,
    l,
    h,
    c,
    u = 0,
    d = 0,
    p = e.type,
    f = "FeatureCollection" === p,
    m = "Feature" === p,
    g = f ? e.features.length : 1;
  for (let _ = 0; _ < g; _++) {
    (h = f ? e.features[_].geometry : m ? e.geometry : e),
      (c = !!h && "GeometryCollection" === h.type),
      (o = c ? h.geometries.length : 1);
    for (let e = 0; e < o; e++) {
      let o = 0,
        p = 0;
      if (((a = c ? h.geometries[e] : h), null === a)) continue;
      l = a.coordinates;
      let f = a.type;
      switch (
        ((u = !i || ("Polygon" !== f && "MultiPolygon" !== f) ? 0 : 1), f)
      ) {
        case null:
          break;
        case "Point":
          if (!1 === t(l, d, _, o, p)) return !1;
          d++, o++;
          break;
        case "LineString":
        case "MultiPoint":
          for (n = 0; n < l.length; n++) {
            if (!1 === t(l[n], d, _, o, p)) return !1;
            d++, "MultiPoint" === f && o++;
          }
          "LineString" === f && o++;
          break;
        case "Polygon":
        case "MultiLineString":
          for (n = 0; n < l.length; n++) {
            for (s = 0; s < l[n].length - u; s++) {
              if (!1 === t(l[n][s], d, _, o, p)) return !1;
              d++;
            }
            "MultiLineString" === f && o++, "Polygon" === f && p++;
          }
          "Polygon" === f && o++;
          break;
        case "MultiPolygon":
          for (n = 0; n < l.length; n++) {
            for (p = 0, s = 0; s < l[n].length; s++) {
              for (r = 0; r < l[n][s].length - u; r++) {
                if (!1 === t(l[n][s][r], d, _, o, p)) return !1;
                d++;
              }
              p++;
            }
            o++;
          }
          break;
        case "GeometryCollection":
          for (n = 0; n < a.geometries.length; n++)
            if (!1 === Vv(a.geometries[n], t, i)) return !1;
          break;
        default:
          throw new Error("Unknown Geometry Type");
      }
    }
  }
}
function Qv(e, t) {
  let i,
    n,
    s,
    r,
    a,
    o,
    l,
    h,
    c,
    u,
    d = 0,
    p = "FeatureCollection" === e.type,
    f = "Feature" === e.type,
    m = p ? e.features.length : 1;
  for (i = 0; i < m; i++) {
    for (
      o = p ? e.features[i].geometry : f ? e.geometry : e,
        h = p ? e.features[i].properties : f ? e.properties : {},
        c = p ? e.features[i].bbox : f ? e.bbox : void 0,
        u = p ? e.features[i].id : f ? e.id : void 0,
        l = !!o && "GeometryCollection" === o.type,
        a = l ? o.geometries.length : 1,
        s = 0;
      s < a;
      s++
    )
      if (((r = l ? o.geometries[s] : o), null !== r))
        switch (r.type) {
          case "Point":
          case "LineString":
          case "MultiPoint":
          case "Polygon":
          case "MultiLineString":
          case "MultiPolygon":
            if (!1 === t(r, d, h, c, u)) return !1;
            break;
          case "GeometryCollection":
            for (n = 0; n < r.geometries.length; n++)
              if (!1 === t(r.geometries[n], d, h, c, u)) return !1;
            break;
          default:
            throw new Error("Unknown Geometry Type");
        }
      else if (!1 === t(null, d, h, c, u)) return !1;
    d++;
  }
}
function Hv(e, t) {
  if ("Feature" === e.type) t(e, 0);
  else if ("FeatureCollection" === e.type)
    for (let i = 0; i < e.features.length && !1 !== t(e.features[i], i); i++);
}
function jv(e, t, i) {
  let n = i;
  return (
    Qv(e, function (e, s, r, a, o) {
      n = 0 === s && void 0 === i ? e : t(n, e, s, r, a, o);
    }),
    n
  );
}
function Wv(e, t = {}) {
  if (null != e.bbox && !0 !== t.recompute) return e.bbox;
  const i = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
  return (
    Vv(e, (e) => {
      i[0] > e[0] && (i[0] = e[0]),
        i[1] > e[1] && (i[1] = e[1]),
        i[2] < e[0] && (i[2] = e[0]),
        i[3] < e[1] && (i[3] = e[1]);
    }),
    i
  );
}
function qv(e) {
  if (Array.isArray(e)) return e;
  if ("Feature" === e.type) {
    if (null !== e.geometry) return e.geometry.coordinates;
  } else if (e.coordinates) return e.coordinates;
  throw new Error(
    "coords must be GeoJSON Feature, Geometry Object or an Array"
  );
}
function Xv(e) {
  return "Feature" === e.type ? e.geometry : e;
}
function Yv(e, t) {
  return t[0] <= e[0] && t[1] <= e[1] && t[2] >= e[0] && t[3] >= e[1];
}
function Kv(e, t) {
  let i = 0,
    n = 0,
    s = 0,
    r = 0,
    a = 0,
    o = 0,
    l = 0,
    h = 0,
    c = null,
    u = null;
  const d = e[0],
    p = e[1],
    f = t.length;
  for (; i < f; i++) {
    n = 0;
    const f = t[i].length - 1,
      m = t[i];
    if (((c = m[0]), c[0] !== m[f][0] && c[1] !== m[f][1]))
      throw new Error("First and last coordinates in a ring must be the same");
    for (a = c[0] - d, o = c[1] - p; n < f; n++)
      if (
        ((u = m[n + 1]), (h = u[1] - p), (o < 0 && h < 0) || (o > 0 && h > 0))
      )
        (c = u), (o = h), (a = c[0] - d);
      else {
        if (((l = u[0] - e[0]), h > 0 && o <= 0)) {
          if (((r = a * h - l * o), r > 0)) s += 1;
          else if (0 === r) return 0;
        } else if (o > 0 && h <= 0) {
          if (((r = a * h - l * o), r < 0)) s += 1;
          else if (0 === r) return 0;
        } else if (0 === h && o < 0) {
          if (((r = a * h - l * o), 0 === r)) return 0;
        } else if (0 === o && h < 0) {
          if (((r = a * h - l * o), 0 === r)) return 0;
        } else if (0 === o && 0 === h) {
          if (l <= 0 && a >= 0) return 0;
          if (a <= 0 && l >= 0) return 0;
        }
        (c = u), (o = h), (a = l);
      }
  }
  return s % 2 != 0;
}
function Zv(e, t, i = {}) {
  if (!e) throw new Error("point is required");
  if (!t) throw new Error("polygon is required");
  const n = qv(e),
    s = Xv(t),
    r = s.type,
    a = t.bbox;
  let o = s.coordinates;
  if (a && !1 === Yv(n, a)) return !1;
  "Polygon" === r && (o = [o]);
  let l = !1;
  for (let h = 0; h < o.length; ++h) {
    const e = Kv(n, o[h]);
    if (0 === e) return !i.ignoreBoundary;
    e && (l = !0);
  }
  return l;
}
function Jv(e, t, i = {}) {
  const n = { type: "Feature" };
  return (
    (0 === i.id || i.id) && (n.id = i.id),
    i.bbox && (n.bbox = i.bbox),
    (n.properties = t || {}),
    (n.geometry = e),
    n
  );
}
function $v(e, t = {}) {
  const i = { type: "FeatureCollection" };
  return (
    t.id && (i.id = t.id), t.bbox && (i.bbox = t.bbox), (i.features = e), i
  );
}
function eA(e, t, i = {}) {
  if (!e) throw new Error("coordinates is required");
  if (!Array.isArray(e)) throw new Error("coordinates must be an Array");
  if (e.length < 2)
    throw new Error("coordinates must be at least 2 numbers long");
  if (!wv(e[0]) || !wv(e[1]))
    throw new Error("coordinates must contain numbers");
  return Jv({ type: "Point", coordinates: e }, t, i);
}
function tA(e, t, i = {}) {
  for (const n of e) {
    if (n.length < 4)
      throw new Error(
        "Each LinearRing of a Polygon must have 4 or more Positions."
      );
    if (n[n.length - 1].length !== n[0].length)
      throw new Error("First and last Position are not equivalent.");
    for (let e = 0; e < n[n.length - 1].length; e++)
      if (n[n.length - 1][e] !== n[0][e])
        throw new Error("First and last Position are not equivalent.");
  }
  return Jv({ type: "Polygon", coordinates: e }, t, i);
}
function iA(e) {
  return jv(
    e,
    (e, t) =>
      e +
      (function (e) {
        let t,
          i = 0;
        switch (e.type) {
          case "Polygon":
            return nA(e.coordinates);
          case "MultiPolygon":
            for (t = 0; t < e.coordinates.length; t++)
              i += nA(e.coordinates[t]);
            return i;
          case "Point":
          case "MultiPoint":
          case "LineString":
          case "MultiLineString":
            return 0;
        }
        return 0;
      })(t),
    0
  );
}
function nA(e) {
  let t = 0;
  if (e && e.length > 0) {
    t += Math.abs(sA(e[0]));
    for (let i = 1; i < e.length; i++) t -= Math.abs(sA(e[i]));
  }
  return t;
}
function sA(e) {
  let t,
    i,
    n,
    s,
    r,
    a,
    o,
    l = 0;
  const h = e.length;
  if (h > 2) {
    for (o = 0; o < h; o++)
      o === h - 2
        ? ((s = h - 2), (r = h - 1), (a = 0))
        : o === h - 1
        ? ((s = h - 1), (r = 0), (a = 1))
        : ((s = o), (r = o + 1), (a = o + 2)),
        (t = e[s]),
        (i = e[r]),
        (n = e[a]),
        (l +=
          (Tv.toRadians(n[0]) - Tv.toRadians(t[0])) *
          Math.sin(Tv.toRadians(i[1])));
    l = (6371008.8 * l * 6371008.8) / 2;
  }
  return l;
}
function rA(e, t = {}) {
  const i = Wv(e);
  return eA([(i[0] + i[2]) / 2, (i[1] + i[3]) / 2], t.properties, t);
}
const aA = Object.freeze(
  Object.defineProperty(
    {
      __proto__: null,
      getGeoFeatures: Lv,
      projectCoordinates: Nv,
      projectPointArr: Bv,
      unprojectPointArr: function (e, t) {
        if (!e) return [];
        let i = [];
        if (e[0] < 180 && e[0] > -180 && e[1] < 90 && e[1] > -90)
          i = [e[0], e[1]];
        else if ("_bmap_mercator" === t) {
          const t = Tv.convertMC2LL({ lng: e[0], lat: e[1] });
          (i[0] = t.lng), (i[1] = t.lat);
        } else i = dv(e);
        return void 0 !== e[2] ? (i[2] = e[2]) : (i[2] = 0), i;
      },
      fixFeature: kv,
      multiPointToPoints: Ov,
      multiLineStringToLineStrings: Uv,
      multiPolygonToPolygons: zv,
      convertLineString2Points: function (e) {
        let t = this.getGeoFeatures(e),
          i = [];
        for (let n = 0; n < t.length; n++) {
          const e = t[n],
            s = this.multiLineStringToLineStrings(e);
          for (let t = 0; t < s.length; t++) {
            const e = s[t],
              n = this.multiPointToPoints(e);
            i.push(...n);
          }
        }
        return i;
      },
      convertPolygon2LineString: Gv,
      coordEach: Vv,
      geomEach: Qv,
      featureEach: Hv,
      geomReduce: jv,
      getbbox: Wv,
      getCoord: qv,
      getGeom: Xv,
      inBBox: Yv,
      booleanPointInPolygon: Zv,
      feature: Jv,
      featureCollection: $v,
      coordToPoint: eA,
      coordToPolygon: tA,
      computeGeoJSONArea: iA,
      getcenter: rA,
    },
    Symbol.toStringTag,
    { value: "Module" }
  )
);
function oA(e, t = {}) {
  (this.position = e),
    (this.attributes = t),
    void 0 !== t.id && (this.id = t.id),
    (this._projection = []);
}
function lA(e, t, i, n, s) {
  return (
    (function (e, t) {
      const i = 1 - e;
      return i * i * i * t;
    })(e, t) +
    (function (e, t) {
      const i = 1 - e;
      return 3 * i * i * e * t;
    })(e, i) +
    (function (e, t) {
      return 3 * (1 - e) * e * e * t;
    })(e, n) +
    (function (e, t) {
      return e * e * e * t;
    })(e, s)
  );
}
oA.prototype.getProjection = function (e) {
  return (this._projection = Nv(this.position, e)), this._projection;
};
const hA = function (e, t) {
    let i = e[0],
      n = e[1];
    return [(3 * i + t[0]) / 4, (3 * n + t[1]) / 4];
  },
  cA = function (e, t) {
    let i = e[0],
      n = e[1],
      s = t[0],
      r = t[1];
    return Math.sqrt(Math.pow(i - s, 2) + Math.pow(n - r, 2));
  },
  uA = function (e, t, i = 1) {
    return [...hA(e, t), cA(e, t) / i];
  },
  dA = function (e, t, i, n, s) {
    let r = [];
    return (
      r.push(
        lA(e, t[0], i[0], n[0], s[0]),
        lA(e, t[1], i[1], n[1], s[1]),
        lA(e, t[2], i[2], n[2], s[2])
      ),
      r
    );
  };
function pA(e, t = 20) {
  const i = e[0],
    n = e[e.length - 1],
    s = uA(i, n, 2),
    r = uA(n, i, 2);
  let a = [];
  for (let o = 0; o <= t; o++) a.push(dA(o / t, i, s, r, n));
  return a;
}
class fA {
  constructor(e = {}) {
    publicField(this, "_projectionName"),
      publicField(this, "_objects", []),
      publicField(this, "_isLoading", !1),
      publicField(this, "_isLoaded", !1),
      publicField(this, "_url"),
      publicField(this, "_origin"),
      publicField(this, "_data", {}),
      publicField(this, "_userData", []),
      publicField(this, "_addCache", []),
      publicField(this, "_attributeMap", new Map()),
      publicField(this, "_needsUpdate", !0),
      publicField(this, "_templateDataLength", 0),
      publicField(this, "_idIndexMap", {}),
      publicField(this, "_indexIdMap", {}),
      publicField(this, "_isCurve", !1),
      (this.options = e),
      (this._id = e.id || new Date().valueOf());
  }
  async load(e) {
    if ((this._isLoaded && this.clear(), this._isLoading)) return this;
    if (((this._isLoading = !0), "string" == typeof e)) {
      let t = await fetch(e),
        i = await this._getFetchData(t);
      (this._url = e), (this._origin = i);
    } else "object" == typeof e && (this._origin = e);
    return (this._isLoading = !1), (this._isLoaded = !0), this;
  }
  async _getFetchData(e) {
    return e;
  }
  setAttribute(e, t) {
    return (
      t ? this._attributeMap.set(e, t) : this._attributeMap.set(e, e),
      (this.needsUpdate = !0),
      this
    );
  }
  setAttributes(e) {
    let t = Object.keys(e);
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      this._attributeMap.set(n, e[n]);
    }
    return (this.needsUpdate = !0), this;
  }
  removeAttribute(e) {
    return this._attributeMap.delete(e), (this.needsUpdate = !0), this;
  }
  removeAllAttributes() {
    return this._attributeMap.clear(), (this.needsUpdate = !0), this;
  }
  add(e) {
    if (e instanceof oA) {
      const t = e.id;
      if (void 0 !== t) {
        if (void 0 !== this._idIndexMap[t]) return this;
        const e = this._addCache.length;
        (this._indexIdMap[e] = t), (this._idIndexMap[t] = e);
      }
      this._addCache.push(e);
    } else if (e instanceof Array)
      for (let t = 0; t < e.length; t++) {
        const i = e[t];
        this.add(i);
      }
    return (this.needsUpdate = !0), this;
  }
  remove(e) {
    let t;
    if (
      (e instanceof oA || "[object Object]" === Array.prototype.toString.call(e)
        ? (t = e.id)
        : "string" == typeof e && (t = e),
      void 0 !== t)
    ) {
      const e = this._idIndexMap[t];
      if (void 0 === e) return void console.warn("remove fail1", e, t);
      const i = this._addCache.length - 1;
      if (e > i) return void console.warn("remove fail2", e, t);
      if (e < i) {
        const t = this._indexIdMap[i];
        (this._addCache[e] = this._addCache[i]),
          (this._indexIdMap[e] = t),
          (this._idIndexMap[t] = e);
      }
      delete this._idIndexMap[t],
        delete this._indexIdMap[i],
        (this._addCache.length = this._addCache.length - 1);
    }
    return (this.needsUpdate = !0), this;
  }
  get(e) {
    let t = {};
    if (
      this.data.position &&
      this.data.position.length &&
      void 0 !== e &&
      !(e >= this.data.position.length)
    ) {
      for (const i in this.data)
        if (Object.hasOwnProperty.call(this.data, i)) {
          const n = this.data[i];
          t[i] = n[e];
        }
      return t;
    }
  }
  getOriginDataIndex(e) {
    return [e, 0];
  }
  getOriginData(e) {
    return this._addCache[e];
  }
  exportToGeoJSON() {
    let e = [];
    this.originToFeatures(e);
    for (let t = 0; t < this._addCache.length; t++) {
      const i = this._addCache[t];
      e.push({
        type: "Feature",
        geometry: {
          type: this._getDataTypeByCoordinates(i.position),
          coordinates: i.position,
        },
        properties: i.attributes,
      });
    }
    return { type: "FeatureCollection", features: e };
  }
  originToFeatures(e) {
    return e;
  }
  update() {
    let e = { position: [], index: [] },
      t = [];
    for (const i of this._attributeMap.keys()) e[i] = [];
    if (
      (this._onProcessTemplateData(e, t),
      this._onProcessAddData(e, t),
      this._isCurve &&
        e.position.length > 0 &&
        Array.isArray(e.position[0]) &&
        Array.isArray(e.position[0][0]) &&
        !Array.isArray(e.position[0][0][0]))
    )
      for (let i = 0; i < e.position.length; i++) {
        const t = e.position[i];
        e.position[i] = pA(t);
      }
    (this.data = e), (this.userData = t), (this.needsUpdate = !1);
  }
  setData(e) {
    this.clear(),
      (this._isLoaded = !0),
      (this._origin = e),
      (this.needsUpdate = !0);
  }
  clear() {
    (this._isLoaded = !1),
      (this._url = void 0),
      (this._origin = void 0),
      (this._data = {}),
      (this._userData = []),
      (this._addCache = []),
      (this.needsUpdate = !0),
      (this._idIndexMap = {}),
      (this._indexIdMap = {}),
      this.onClear();
  }
  onClear() {}
  _onProcessTemplateData(e, t) {
    return e;
  }
  _onProcessAddData(e, t) {
    const i = this.projectionName,
      n = e.index[e.index.length - 1];
    this._templateDataLength = e.index.length;
    for (let s = 0; s < this._addCache.length; s++) {
      const r = this._addCache[s],
        a = r.getProjection(i);
      e.position.push(a),
        void 0 !== n ? e.index.push(n + s + 1) : e.index.push(s);
      let o = { position: a, index: void 0 !== n ? n + s + 1 : s };
      for (const t of this._attributeMap.keys()) {
        let i;
        r.attributes &&
        void 0 !== r.attributes[this._attributeMap.get(t)] &&
        null !== r.attributes[this._attributeMap.get(t)]
          ? (e[t].push(), (i = r.attributes[this._attributeMap.get(t)]))
          : this._attributeMap.get(t) instanceof Function &&
            (e[t].push(), (i = this._attributeMap.get(t)(r.attributes))),
          e[t].push(i),
          (o[t] = i);
      }
      t.push(o);
    }
  }
  _getDataType(e) {
    let t;
    return (
      /Point/.test(e)
        ? (t = "Point")
        : /LineString/.test(e)
        ? (t = "LineString")
        : /Polygon/.test(e) && (t = "Polygon"),
      t
    );
  }
  _getDataTypeByCoordinates(e) {
    let t;
    return (
      "number" == typeof e[0] || "string" == typeof e[0]
        ? (t = "Point")
        : e[0] instanceof Array &&
          ("number" == typeof e[0][0] || "string" == typeof e[0][0])
        ? (t = "LineString")
        : e[0] instanceof Array &&
          e[0][0] instanceof Array &&
          ("number" == typeof e[0][0][0] || "string" == typeof e[0][0][0]) &&
          (t = "Polygon"),
      t
    );
  }
  _onDecomposeFeature(e, t) {
    let i = (e) => [e];
    return (
      "Point" === e
        ? (i = Ov)
        : "LineString" === e
        ? (i = Uv)
        : "Polygon" === e && (i = zv),
      i(t, this.projectionName)
    );
  }
  dispose() {
    this.clear();
  }
  get size() {
    return (
      this.needsUpdate && this.update(),
      (this.data && this.data.position && this.data.position.length) || 0
    );
  }
  get data() {
    return this._data;
  }
  set data(e) {
    this._data = e;
  }
  get userData() {
    return this._userData;
  }
  set userData(e) {
    this._userData = e;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  get origin() {
    return this._origin;
  }
  get projectionName() {
    return this._projectionName;
  }
  set projectionName(e) {
    this._projectionName = e;
  }
  get objects() {
    return this._objects;
  }
  set objects(e) {
    this._objects = e;
  }
  get isCurve() {
    return this._isCurve;
  }
  set isCurve(e) {
    (this._isCurve = e), (this.needsUpdate = !0);
  }
}
class mA extends fA {
  constructor(e) {
    super(e), (this.type = "BufferDataSource");
  }
  getOriginData(e) {
    return e < this._templateDataLength && this.data.payload
      ? this.data.payload[e]
      : this._addCache[e - this._templateDataLength];
  }
  originToFeatures(e) {
    if (!this.data.payload) return e;
    for (let t = 0; t < this.data.payload.length; t++) {
      const i = this.data.payload[t],
        { position: n, index: s, ...r } = i;
      e.push({
        type: "Feature",
        geometry: { type: this._getDataTypeByCoordinates(n), coordinates: n },
        properties: r,
      });
    }
    return e;
  }
  _onProcessTemplateData(e, t) {
    let i = this._origin;
    if (i && i.position) {
      (e.position = i.position), (e.index = i.index);
      for (let n = 0; n < i.payload.length; n++) {
        const s = i.payload[n],
          r = { ...s };
        for (const t of this._attributeMap.keys())
          e[t] || (e[t] = []),
            (e[t] = e[t].concat(s[this._attributeMap.get(t)])),
            (r[t] = s[this._attributeMap.get(t)]);
        t.push(r);
      }
    }
    return e;
  }
}
class GeoObject extends cv {
  constructor() {
    super(...arguments),
      publicField(this, "isGeoObject", !0),
      publicField(this, "dataAutoUpdate", !0),
      publicField(this, "_parameters"),
      publicField(this, "_dataSource"),
      publicField(this, "_dataSourceUpdated"),
      publicField(this, "_needsUpdate"),
      publicField(this, "_zooms", [0, 100]),
      publicField(this, "_zoomVisibleCache"),
      publicField(this, "engine"),
      publicField(this, "_clampToGround"),
      publicField(this, "_renderMaterialOptions"),
      publicField(this, "_backMaterialOptions"),
      publicField(this, "_frontMaterialOptions"),
      publicField(this, "_terrain"),
      publicField(this, "_backObject"),
      publicField(this, "_frontObject"),
      publicField(this, "_renderObject"),
      publicField(this, "_VolumeClass"),
      publicField(this, "_volumeDataSource", new mA()),
      publicField(this, "getGeoFeatures", (e, t = !1) => {
        if (!e) return [];
        let i = null;
        return (
          t || this.map.projectGeoJSON(e),
          (i = e.features ? e.features : Array.isArray(e) ? e : [e]),
          i
        );
      }),
      publicField(this, "travelFeatureLineCoordinate", (e, t, i) => {
        const n = e.geometry;
        if (!n || !n[t] || !n.type) return;
        const s = n[t];
        if ("LineString" === n.type) i && i(s);
        else if ("MultiLineString" === n.type || "Polygon" === n.type)
          for (let r of s) i && i(r);
        else if ("MultiPolygon" === n.type)
          for (let r of s) for (let e of r) i && i(e);
      }),
      publicField(
        this,
        "travelLineCoordinates",
        (e, t = "coordinates", i, n = 0) => {
          if (Array.isArray(e) && i)
            for (let s = 0, r = e.length; s < r; s++) {
              const r = e[s],
                a = n + s,
                o = r.geometry;
              if (!o || !o[t] || !o.type) continue;
              const l = o[t];
              if ("LineString" === o.type) i && i(l, r, a);
              else if ("MultiLineString" === o.type || "Polygon" === o.type)
                for (let e of l) i && i(e, r, a);
              else if ("MultiPolygon" === o.type)
                for (let e of l) for (let t of e) i && i(t, r, a);
            }
        }
      ),
      publicField(
        this,
        "travelPolygonCoordinates",
        (e, t = "coordinates", i, n = 0) => {
          if (Array.isArray(e) && i)
            for (let s = 0, r = e.length; s < r; s++) {
              const r = e[s],
                a = n + s,
                o = r.geometry;
              if (!o || !o[t] || !o.type) continue;
              const l = o[t];
              if ("Polygon" === o.type) i && i(l, r, a);
              else if ("MultiPolygon" === o.type)
                for (let e of l) i && i(e, r, a);
              else if ("LineString" === o.type) i && i([l], r, a);
              else if ("MultiLineString" === o.type)
                for (let e of l) i && i([e], r, a);
            }
        }
      ),
      publicField(
        this,
        "travelPointCoordinates",
        (e, t = "coordinates", i, n = 0) => {
          if (Array.isArray(e) && i)
            for (let s = 0, r = e.length; s < r; s++) {
              const r = e[s],
                a = n + s,
                o = r.geometry;
              if (!o || !o[t] || !o.type) continue;
              const l = o[t];
              "Point" === o.type && i && i(l, r, a);
            }
        }
      ),
      publicField(this, "getPointsBounding", (e, t = "coordinates") => {
        let i = 1 / 0,
          n = 1 / 0,
          s = 1 / 0,
          r = -1 / 0,
          a = -1 / 0,
          o = -1 / 0;
        return (
          this.travelPointCoordinates(e, t, (e) => {
            const [t, l, h = 0] = e;
            t < i && (i = t),
              t > r && (r = t),
              l < n && (n = l),
              l > a && (a = l),
              h < s && (s = h),
              h > o && (o = h);
          }),
          isFinite(i) || (i = 0),
          isFinite(r) || (r = 0),
          isFinite(n) || (n = 0),
          isFinite(a) || (a = 0),
          isFinite(s) || (s = 0),
          isFinite(o) || (o = 0),
          [i, n, s, r, a, o]
        );
      });
  }
  get parameters() {
    return this._parameters;
  }
  set parameters(e) {
    this._parameters
      ? (this._parameters = { ...this._parameters, ...e })
      : (this._parameters = { ...this.getDefaultParams(), ...e });
  }
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(e) {
    this.setDataSource(e);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
  get zooms() {
    return this._zooms;
  }
  set zooms(e) {
    this._zooms = e;
  }
  get inZoomsRange() {
    const e = this.engine;
    return (
      !!e &&
      e.map.getZoom() >= this.zooms[0] &&
      e.map.getZoom() <= this.zooms[1]
    );
  }
  afterAddToEngine(e) {
    (this.engine = e),
      this.initObject(),
      this.isInstancedMesh && (this.material.defines.IS_INSTANCE = !0);
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  initObject() {}
  getDefaultParams() {
    return {};
  }
  getEntityByIndex(e) {
    const t = this.dataSource;
    if (!t) return;
    const i = {
        index: e,
        value: t.getOriginData(e),
        itemIndex: t.getOriginDataIndex(e),
        pairs: {},
      },
      n = t.data;
    for (const s of Object.keys(n)) i.pairs[s] = n[s][e];
    return i;
  }
  setDataSource(e) {
    if (!e && this._dataSource) {
      const e = this._dataSource.objects.indexOf(this);
      e > -1 && this._dataSource.splice(e, 1), (this._dataSource = null);
    }
    e.objects.indexOf(this) > -1 ||
      ((this._dataSource = e),
      (e.projectionName = this.engine.map.projectionCoordsName),
      e.objects.push(this),
      (this.needsUpdate = !0),
      this.engine.requestRender());
  }
  onBeforeScenePrepareRender(e, t, i, n) {
    if (
      this.dataSource &&
      (this.dataSource.needsUpdate &&
        (this.dataSource.update(), (this.needsUpdate = !0)),
      this.dataAutoUpdate &&
        this.needsUpdate &&
        this._enableCollision &&
        (e.rendering.collision.needsUpdate = !0),
      this.onBeforeScenePrepareRenderHook &&
        this.onBeforeScenePrepareRenderHook(e, t, i, n),
      this.clampToGround)
    ) {
      const t = this.getShadowVolumeOptions();
      this._volumeDataSource = this.createVolumeDataSource();
      const i = this._VolumeClass;
      this._backObject && this.engine.remove(this._backObject),
        (this._backObject = e.add(
          new i({ ...this._backMaterialOptions, ...t })
        )),
        this._frontObject && this.engine.remove(this._frontObject),
        (this._frontObject = e.add(
          new i({ ...this._frontMaterialOptions, ...t })
        )),
        this._renderObject && this.engine.remove(this._renderObject),
        (this._renderObject = e.add(
          new i({
            ...this._renderMaterialOptions,
            ...t,
            ...this.filterVolumeParamter(this.parameters),
          })
        )),
        (this._frontObject.dataSource = this._volumeDataSource),
        (this._backObject.dataSource = this._volumeDataSource),
        (this._renderObject.dataSource = this._volumeDataSource);
    }
  }
  onBeforeSceneRender(e, t, i, n) {
    this.dataSource &&
      (this.dataAutoUpdate && this.needsUpdate
        ? this.setData()
        : this.dataAutoUpdate && this._collisionUpdated
        ? (this.setData(), (this._collisionUpdated = !1))
        : this.geometry &&
          this.geometry.needsUpdate &&
          this.geometry.updateGeometry &&
          (this.geometry.updateGeometry(),
          this.afterGeometryUpdate && this.afterGeometryUpdate()),
      this.visible && !this.inZoomsRange
        ? ((this._zoomVisibleCache = this.visible), (this.visible = !1))
        : !this.visible &&
          this._zoomVisibleCache &&
          this.inZoomsRange &&
          ((this.visible = this._zoomVisibleCache),
          (this._zoomVisibleCache = void 0)),
      this.onBeforeSceneRenderHook && this.onBeforeSceneRenderHook(e, t, i, n));
  }
  setData() {}
  collisionTest(e) {
    return {};
  }
  createVolumeDataSource() {
    return this.dataSource;
  }
  specifiedVolumeClass() {
    this._VolumeClass = this.constructor;
  }
  filterVolumeParamter(e) {
    const t = [
      "opacity",
      "color",
      "vertexColors",
      "emissive",
      "mapSrc",
      "mapScale",
    ];
    let i = {};
    return (
      Object.keys(e)
        .filter((e) => t.includes(e))
        .forEach((t) => {
          i[t] = e[t];
        }),
      i
    );
  }
  onDispose() {}
  dispose() {
    if ((this.geometry && this.geometry.dispose(), this.material))
      if (Array.isArray(this.material))
        for (let e = 0; e < this.material.length; e++) {
          this.material[e].dispose();
        }
      else this.material.dispose();
    this.onDispose();
  }
  bindTerrain(e) {
    this._terrain = e;
  }
  initMaterialOptions() {
    (this._frontMaterialOptions = {
      side: h,
      depthWrite: !1,
      colorWrite: !1,
      stencilWrite: !0,
      stencilFunc: 519,
      stencilZFail: 34056,
      stencilZPass: Ae,
    }),
      (this._backMaterialOptions = {
        side: c,
        depthWrite: !1,
        colorWrite: !1,
        stencilWrite: !0,
        stencilFunc: 519,
        stencilZFail: 34055,
        stencilZPass: Ae,
      }),
      (this._renderMaterialOptions = {
        side: 2,
        stencilWrite: !0,
        stencilRef: 0,
        depthTest: !1,
        stencilFunc: 517,
        stencilZFail: 0,
        stencilFail: 0,
        stencilZPass: 0,
      });
  }
  getShadowVolumeOptions() {
    this.geometry.computeBoundingBox();
    const { min: e, max: t } = this.geometry.boundingBox,
      i = this.position;
    let n = new Vector2(e.x, e.y).add(i),
      s = new Vector2(t.x, t.y).add(i);
    const r = new nh(n, s);
    let [a, o] = this._terrain._intersectHeightRange(r);
    return {
      opacity: 0.4,
      extrude: !0,
      extrudeValue: o - a,
      zOffset: a,
      enableBottomFace: !0,
    };
  }
  get clampToGround() {
    return this._clampToGround;
  }
  set clampToGround(e) {
    this.clampToGround !== e &&
      ((this._clampToGround = e),
      e
        ? (this.initMaterialOptions(),
          this.specifiedVolumeClass(),
          (this.material.visible = !1))
        : (this._frontObject && this.engine.remove(this._frontObject),
          this._backObject && this.engine.remove(this._backObject),
          this._renderObject && this.engine.remove(this._renderObject),
          (this.material.visible = !0)));
  }
}

class Mesh extends GeoObject {
  constructor() {
    super(...arguments), publicField(this, "isMesh", !0);
  }
}

function vA(e) {
  let t = 0,
    i = 0;
  for (const a of e) (t += a.w * a.h), (i = Math.max(i, a.w));
  e.sort((e, t) => t.h - e.h);
  const n = [
    { x: 0, y: 0, w: Math.max(Math.ceil(Math.sqrt(t / 0.95)), i), h: 1 / 0 },
  ];
  let s = 0,
    r = 0;
  for (const a of e)
    for (let e = n.length - 1; e >= 0; e--) {
      const t = n[e];
      if (!(a.w > t.w || a.h > t.h)) {
        if (
          ((a.x = t.x),
          (a.y = t.y),
          (r = Math.max(r, a.y + a.h)),
          (s = Math.max(s, a.x + a.w)),
          a.w === t.w && a.h === t.h)
        ) {
          const t = n.pop();
          e < n.length && (n[e] = t);
        } else
          a.h === t.h
            ? ((t.x += a.w), (t.w -= a.w))
            : a.w === t.w
            ? ((t.y += a.h), (t.h -= a.h))
            : (n.push({ x: t.x + a.w, y: t.y, w: t.w - a.w, h: a.h }),
              (t.y += a.h),
              (t.h -= a.h));
        break;
      }
    }
  return { w: s, h: r, fill: t / (s * r) || 0 };
}
class CommonShaderMaterial extends ShaderMaterial {
  constructor(e) {
    super(),
      publicField(this, "isCommonShaderMaterial", !0),
      publicField(this, "setCommonUniforms", (e) => {
        for (const t of Object.keys(e)) this.uniforms[t] = e[t];
      }),
      this.setValues(e);
  }
}
const yA = In.merge([
  Xn.fog,
  L_,
  D_,
  {
    map: { value: null },
    pixelRatio: { value: 1 },
    lineHeight: { value: 14 },
    pixelOffsetX: { value: 0 },
    pixelOffsetY: { value: 0 },
    positionOffsetX: { value: 0 },
    positionOffsetZ: { value: 0 },
    positionOffsetY: { value: 0 },
    backgroundColor: { value: [1, 1, 0, 0] },
    uFlat: { value: !1 },
    opacity: { value: 1 },
    isEmissive: { value: !1 },
    uRotateZ: { value: 0 },
    keepSize: { value: !0 },
  },
]);
class DefaultTextMaterial extends CommonShaderMaterial {
  constructor(e) {
    super(),
      (this.type = "DefaultTextMaterial"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform float positionOffsetX;\nuniform float positionOffsetY;\nuniform float pixelOffsetX;\nuniform float pixelOffsetY;\nuniform float positionOffsetZ;\nuniform bool uFlat;\n\nattribute float pIndex;\nattribute vec2 wh;\n\n#ifdef MVT_USE_VERTEX_ROTATEZ\n    attribute float aRotateZ;\n# else\n    uniform float uRotateZ;\n#endif\n\nvarying vec2 vUv;\n#include <logdepthbuf_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvec3 transformCoord(vec3 coord, vec2 size, float corner, float rotateZ) {\n    float x = coord.x;\n    float y = coord.y;\n    if (corner == 1.0) {\n        x += -size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    } else if (corner == 2.0) {\n        x += size.x * cos(rotateZ) + size.y * sin(rotateZ);\n        y += size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else if (corner == 3.0) {\n        x += size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) - size.x * sin(rotateZ);\n    } else {\n        x += -size.x * cos(rotateZ) - size.y * sin(rotateZ);\n        y += -size.y * cos(rotateZ) + size.x * sin(rotateZ);\n    }\n    return vec3(x, y, coord.z);\n}\n\nvoid main() {\n    #include <mvt_selective_vertex>\n    // float x = position.x;\n    // float y = position.y;\n    vUv = uv;\n\n    float rotateZ;\n    #ifdef MVT_USE_VERTEX_ROTATEZ\n        rotateZ = aRotateZ;\n    # else\n        rotateZ = uRotateZ;\n    #endif\n\n    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));\n    if (uFlat) {\n        // viewMatrix[0]表示相机的右方向，不管相机如何倾斜tilt，法向量都指向正北方向，正好可以用来计算和文字的夹角\n        vec4 right = viewMatrix[0];\n        float theta = dot(vec2(sin(rotateZ), cos(rotateZ)), vec2(-right.y, right.x));\n        if (theta < 0.0) {\n            rotateZ += PI;\n        }\n        // TODO 支持offset\n        float hw = wh.x * 0.5;\n        float hh = wh.y * 0.5;\n        if (keepSize) {\n            float pixelSize = getPixelSize(worldPosition.xyz);\n            pixelSize = pixelSize * 2.0;\n            hw = hw * pixelSize;\n            hh = hh * pixelSize;\n        }\n\n        vec3 current = transformCoord(position.xyz, vec2(hw, hh), pIndex, -rotateZ);\n\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(current, 1.0);\n\n        // vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    }\n    else {\n        // gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + positionOffsetX * pixelSize, position.y + positionOffsetY * pixelSize, position.z + positionOffsetZ * pixelSize, 1.0);\n        worldPosition.x += positionOffsetX;\n        worldPosition.y += positionOffsetY;\n        worldPosition.z += positionOffsetZ;\n        vec4 pos = projectionMatrix * viewMatrix * worldPosition;\n       \n        vec3 screen = pos.xyz / pos.w;\n        \n        float hw = wh.x / resolution.x;\n        float hh = wh.y / resolution.y;\n        if (!keepSize) {\n            float pixelSize = getPixelSize(worldPosition.xyz);\n            pixelSize = pixelSize * 2.0;\n            hw = hw / pixelSize;\n            hh = hh / pixelSize;\n        }\n\n        vec3 current = transformCoord(screen.xyz, vec2(hw, hh), pIndex, -rotateZ);\n        gl_Position = vec4(current, 1.0);\n    }\n    #include <logdepthbuf_vertex>\n    // gl_PointSize = size * pixelRatio;\n    // vSize = size;\n    // vOffset = offset;\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D map;\nuniform vec4 backgroundColor;\nuniform float opacity;\nuniform float lineHeight;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n    // gl_FragColor = vec4(1., 0, 0, 1.);\n    gl_FragColor = texture2D(map, vec2(vUv.x, 1.0 - vUv.y));\n\n    if (backgroundColor.a > 0.0) {\n        gl_FragColor = mix(backgroundColor, gl_FragColor, gl_FragColor.a);\n    }\n\n    if (gl_FragColor.a == 0.0) {\n        discard;\n    }\n    gl_FragColor.a *= opacity;\n\n    #include <mvt_selective_fragment> \n    #include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n    \n}"),
      (this.isDefaultTextMaterial = !0),
      (this.transparent = !0),
      (this.depthTest = !1),
      (this.depthWrite = !1),
      Object.assign(this.uniforms, In.clone(yA)),
      U_(this),
      z_(this),
      N_(this, [
        "lineHeight",
        "pixelRatio",
        "map",
        "pixelOffsetX",
        "pixelOffsetY",
        "positionOffsetX",
        "positionOffsetY",
        "positionOffsetZ",
        "backgroundColor",
        "resolution",
        "opacity",
        "isEmissive",
      ]),
      k_(this, [
        ["flat", "uFlat"],
        ["rotateZ", "uRotateZ"],
      ]),
      O_(this, [["vertexRotateZs", "MVT_USE_VERTEX_ROTATEZ"]]),
      G_(this),
      (this.emissiveEnabled = !0),
      (this.emissive = [0, 0, 0]),
      this.setValues(e);
  }
}
let bA;
class EA extends Mesh {
  constructor(e) {
    super(e),
      publicField(this, "_fontSize"),
      publicField(this, "_fontFamily"),
      publicField(this, "_fillStyle"),
      publicField(this, "_padding"),
      publicField(this, "_strokeStyle"),
      publicField(this, "_shouldStroke"),
      publicField(this, "_collisionBoxCache", {}),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "cachedData", []),
      publicField(this, "drawingData"),
      publicField(this, "canvas"),
      publicField(this, "ctx"),
      publicField(this, "texture"),
      publicField(this, "matrixAutoUpdate", !0),
      publicField(this, "sortByStyle", (e) =>
        this.parameters.vertexStyles
          ? e.sort((e, t) => t.styleId - e.styleId)
          : e
      ),
      publicField(this, "getStrictStyleId", (e) => {
        if (this.parameters.vertexStyles) {
          let {
            fontSize: t,
            fontWeight: i,
            lineWidth: n,
            fillStyle: s = [],
            strokeStyle: r = [],
          } = e;
          return `${t}_${i}_${n}_${s[0]}_${s[1]}_${s[2]}_${s[3]}_${r[0]}_${r[1]}_${r[2]}_${r[3]}`;
        }
        return 0;
      }),
      publicField(this, "updateRenderingData", () => {
        const e = this.engine.rendering.pixelRatio,
          t = this.canvas,
          i = this.ctx,
          n = this._fontSize,
          s = this._fontFamily,
          r = this._fillStyle,
          a = this._padding,
          o = this.cachedData || [],
          l = vA(o);
        let h = l.w,
          c = l.h;
        (t.width = h * e),
          (t.height = c * e),
          i.save(),
          i.scale(e, e),
          (i.textBaseline = "top"),
          (i.fillStyle = r),
          this._shouldStroke &&
            ((i.strokeStyle = this._strokeStyle),
            this._lineWidth > 0 && (i.lineWidth = this._lineWidth)),
          (i.font = n + "px " + s),
          this.shadowColor &&
            ((i.shadowColor = this.shadowColor),
            (i.shadowOffsetX = this.shadowOffsetX || 0),
            (i.shadowOffsetY = this.shadowOffsetY || 0),
            (i.shadowBlur = this.shadowBlur || 0));
        const u = [],
          d = [],
          p = [],
          f = [],
          m = [],
          g = [],
          _ = [];
        let v = n;
        for (let y = 0, x = o.length; y < x; ++y) {
          const e = o[y],
            t = this.getStrictStyleId(e);
          if (this.parameters.vertexStyles && bA !== t) {
            bA = t;
            let {
              fontWeight: n,
              fontSize: r,
              fillStyle: a,
              strokeStyle: o,
              lineWidth: l,
            } = e;
            (i.font =
              n >= 10 && n % 10 == 0
                ? 10 * n + " " + r + "px " + s
                : r + "px " + s),
              (v = r),
              l > 0 &&
                ((i.lineWidth = l),
                (i.strokeStyle = "rgba(" + o.join(",") + ")")),
              (i.fillStyle = "rgba(" + a.join(",") + ")");
          }
          let n = e.text.split("\\");
          for (let s = 0; s < n.length; s++)
            (this._shouldStroke || this.parameters.vertexStyles) &&
              i.strokeText(n[s], e.x + a[0], e.y + a[1] + s * v),
              i.fillText(n[s], e.x + a[0], e.y + a[1] + s * v);
          const [r, l, A = 0] = e.position;
          u.push(r, l, A, r, l, A, r, l, A, r, l, A),
            p.push(0, 1, 2, 3),
            m.push(e.w, e.h, e.w, e.h, e.w, e.h, e.w, e.h);
          const x = 4 * y;
          f.push(x, x + 2, x + 1, x, x + 3, x + 2);
          const b = e.x / h,
            E = (e.x + e.w) / h,
            S = (e.y + e.h) / c,
            C = e.y / c;
          d.push(b, S, b, C, E, C, E, S),
            g.push(e.index, e.index, e.index, e.index),
            this.parameters.vertexRotateZs &&
              _.push(e.rotateZ, e.rotateZ, e.rotateZ, e.rotateZ);
        }
        i.restore();
        const A = this.geometry;
        A.setAttribute("position", new Ki(u, 3)),
          A.setAttribute("pIndex", new Ki(p, 1)),
          A.setAttribute("wh", new Ki(m, 2)),
          A.setAttribute("uv", new Ki(d, 2)),
          this.parameters.vertexRotateZs &&
            A.setAttribute("aRotateZ", new Ki(_, 1)),
          A.setIndex(f),
          A.computeBoundingSphere(),
          this.makeGeometryOffsetPosition(A, u),
          u.length > 0 &&
            (this.texture && this.texture.dispose(),
            (this.texture = new CanvasTexture(this.canvas)),
            (this.texture.minFilter = L),
            (this.texture.magFilter = L),
            (this.texture.generateMipmaps = !1),
            (this.material.uniforms.map.value = this.texture)),
          (this.needsUpdate = !1),
          (bA = null);
      }),
      (this.parameters = e),
      (this._fontSize =
        void 0 !== this.parameters.fontSize ? this.parameters.fontSize : 16),
      (this._fontFamily =
        void 0 !== this.parameters.fontFamily
          ? this.parameters.fontFamily
          : "Microsoft Yahei"),
      (this._fillStyle =
        void 0 !== this.parameters.fillStyle
          ? this.parameters.fillStyle
          : "#ff0"),
      (this._padding =
        void 0 !== this.parameters.padding ? this.parameters.padding : [2, 2]),
      (this.strokeStyle = this.parameters.strokeStyle),
      (this._lineWidth = this.parameters.lineWidth),
      (this.cachedData = []),
      (this.drawingData = []);
    const t = (this.canvas = document.createElement("canvas"));
    t.width = t.height = 1;
    const i = (this.ctx = t.getContext("2d"));
    (i.textAlign = "start"),
      (i.textBaseline = "top"),
      this.defineMaterialProxyProperties([
        "lineHeight",
        "map",
        "pixelOffsetX",
        "pixelOffsetY",
        "positionOffsetX",
        "positionOffsetY",
        "positionOffsetZ",
        "backgroundColor",
        "resolution",
        "opacity",
        "flat",
        "emissive",
        "keepSize",
      ]);
  }
  initObject() {
    let {
      padding: e,
      fillStyle: t,
      strokeStyle: i,
      lineWidth: n,
      fontSize: s,
      fontFamily: r,
      vertexStyles: a,
      ...o
    } = this.parameters;
    (this.geometry = new rn(this.parameters)),
      (this.material = new DefaultTextMaterial(o)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms),
      (this.texture = new CanvasTexture(this.canvas)),
      (this.texture.minFilter = L),
      (this.texture.magFilter = L),
      (this.texture.generateMipmaps = !1),
      (this.material.uniforms.map.value = this.texture);
  }
  setData() {
    this._enableCollision && this._collisionData
      ? ((this.cachedData = this.sortByStyle(this._collisionData)), (bA = null))
      : ((this.cachedData = this.sortByStyle(this.dataSource.userData).map(
          (e) => {
            let t = this.collisionTest(e);
            return { ...e, w: t.width, h: t.height };
          }
        )),
        (bA = null)),
      this.update();
  }
  update() {
    this.updateRenderingData();
  }
  collisionTest(e) {
    const t = this.ctx,
      i = this.engine.rendering.pixelRatio,
      n = this._fontSize,
      s = this._fontFamily,
      r = this._padding;
    t.save(), t.scale(i, i), (t.textBaseline = "top");
    let a = "";
    if (this.parameters.vertexStyles) {
      let { text: t, fontWeight: i, fontSize: n, lineWidth: s } = e;
      a += `${t}_${n}_${i}_${s}`;
    } else a += `${e.text}_${n}`;
    if (this._collisionBoxCache[a]) return this._collisionBoxCache[a];
    let o = n;
    const l = this.getStrictStyleId(e);
    if (this.parameters.vertexStyles && l !== bA) {
      let { fontWeight: i, fontSize: n, lineWidth: r } = e;
      (t.font =
        i >= 10 && i % 10 == 0 ? 10 * i + " " + n + "px " + s : n + "px " + s),
        (o = n),
        r > 0 && (t.lineWidth = r);
    } else t.font = n + "px " + s;
    let h = e.text.split("\\");
    const c = h.map((e) => t.measureText(e).width);
    let u = Math.max(...c),
      d = o * h.length;
    const p = u + 2 * r[0],
      f = d + 2 * r[1];
    return (
      t.restore(),
      (this._collisionBoxCache[a] = { width: p, height: f }),
      { width: p, height: f }
    );
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
  set fontSize(e) {
    this._fontSize !== e &&
      ((this._fontSize = e), (this._collisionBoxCache = {}));
  }
  get fontSize() {
    return this._fontSize;
  }
  set fontFamily(e) {
    this._fontFamily !== e &&
      ((this._fontFamily = e), (this._collisionBoxCache = {}));
  }
  get fontFamily() {
    return this._fontFamily;
  }
  set fillStyle(e) {
    this._fillStyle = e;
  }
  get fillStyle() {
    return this._fillStyle;
  }
  set strokeStyle(e) {
    (this._shouldStroke = !!e), (this._strokeStyle = e);
  }
  get strokeStyle() {
    return this._strokeStyle;
  }
  set lineWidth(e) {
    this._lineWidth = e;
  }
  get lineWidth() {
    return this._lineWidth;
  }
  set padding(e) {
    this._padding !== e &&
      ((this._padding = e), (this._collisionBoxCache = {}));
  }
  get padding() {
    return this._padding;
  }
}
class SA {
  constructor(e) {
    publicField(this, "_enabled", !1), (this._rendering = e);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    e !== this._enabled &&
      ((this._enabled = e), e ? this.init() : this.dispose());
  }
  init() {
    const e = (this._flatDataSource = new fA()),
      t = (this._flatText = this._rendering.add(
        new EA({
          fillStyle: "#fff",
          strokeStyle: "#000",
          flat: !0,
          vertexRotateZs: !0,
        })
      ));
    (t.renderOrder = 100),
      (t.maxRenderDepth = 0.999999),
      (t.dataSource = e),
      e.setAttribute("text", "text").setAttribute("rotateZ", "rotateZ");
    const i = (this._fixDataSource = new fA()),
      n = (this._fixText = this._rendering.add(
        new EA({
          fillStyle: "#000",
          strokeStyle: "#fff",
          fontFamily: "sans-serif",
          vertexStyles: !0,
        })
      ));
    (n.renderOrder = 100),
      (n.maxRenderDepth = 0.999999),
      (n.dataSource = i),
      i.setAttributes({
        text: "text",
        fontSize: "fontSize",
        fontWeight: "fontWeight",
        fillStyle: "fontRgba",
        strokeStyle: "haloRgba",
        lineWidth: "haloSize",
        styleId: "styleId",
      });
    const s = (this._labelDataSource = new fA()),
      r = (this._labelText = this._rendering.add(
        new EA({
          fillStyle: "#000",
          strokeStyle: "#fff",
          fontFamily: "sans-serif",
          flat: !0,
          vertexStyles: !0,
          vertexRotateZs: !0,
        })
      ));
    (r.renderOrder = 100),
      (r.maxRenderDepth = 0.999999),
      (r.dataSource = s),
      s.setAttributes({
        text: "text",
        fontSize: "fontSize",
        fontWeight: "fontWeight",
        fillStyle: "fontRgba",
        strokeStyle: "haloRgba",
        lineWidth: "haloSize",
        rotateZ: "rotateZ",
        styleId: "styleId",
      }),
      this._rendering.collision.add(n, { margin: [50, 50] }, "poi"),
      this._rendering.collision.add(r, { margin: [50, 50] }, "poi"),
      this._rendering.collision.add(t, { margin: [80, 80] }, "poi");
  }
  addLabel(e) {
    this.enabled || (this.enabled = !0);
    let t = e;
    if (
      !(e instanceof oA) &&
      "[object Object]" === Array.prototype.toString.call(e)
    ) {
      const { position: i, ...n } = e;
      t = new oA(i, n);
    }
    "flat" === e.type
      ? this._flatDataSource.add(t)
      : "labelp" === e.type
      ? this._labelDataSource.add(t)
      : this._fixDataSource.add(t);
  }
  addLabels(e) {
    for (const t of e) this.addLabel(t);
    this._rendering.requestRender();
  }
  removeLabel(e) {
    "flat" === e.type
      ? this._flatDataSource.remove(e)
      : "labelp" === e.type
      ? this._labelDataSource.remove(e)
      : this._fixDataSource.remove(e);
  }
  removeLabels(e) {
    for (const t of e) this.removeLabel(t);
    this._rendering.requestRender();
  }
  dispose() {
    this._rendering.collision.add(this._fixText, "poi"),
      this._rendering.collision.add(this._labelText, "poi"),
      this._rendering.collision.add(this._flatText, "poi"),
      this._rendering.remove(this._fixText),
      this._rendering.remove(this._flatText),
      this._rendering.remove(this._labelText);
  }
}
class CA {
  constructor(e) {
    publicField(this, "_needsCreate", !1),
      publicField(this, "_rendering"),
      publicField(this, "_enabled", !1),
      publicField(this, "_brightness", 0),
      publicField(this, "_saturation", 0),
      publicField(this, "_contrast", 0),
      publicField(this, "updateComposition", (e, t, i) => {
        this[e] = i;
        const n = this._rendering;
        if (n.useMrt) {
          n.composition[t] = i;
        }
      }),
      publicField(this, "createFog", () => {
        const e = this._rendering;
        if (e.useMrt) {
          const t = e.composition;
          (t.useFog = !0), (t.fogDensity = this._density);
        }
      }),
      publicField(this, "destory", () => {
        const e = this._rendering;
        if (e.useMrt) {
          e.composition.useFog = !1;
        }
      }),
      (this._rendering = e);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    e !== this._enabled &&
      ((this._enabled = e),
      this.updateComposition("_enabled", "colorAdjustEnabled", e),
      e ? (this._needsCreate = !0) : this.destory());
  }
  get brightness() {
    return this._brightness;
  }
  set brightness(e) {
    this.updateComposition("_brightness", "adjustBrightnessFactor", e);
  }
  get contrast() {
    return this._contrast;
  }
  set contrast(e) {
    this.updateComposition("_contrast", "adjustContrastFactor", e);
  }
  get saturation() {
    return this._saturation;
  }
  set saturation(e) {
    this.updateComposition("_saturation", "adjustSaturationFactor", e);
  }
  render() {}
}
function MA(e, t, i, n, s) {
  wA(e, t, i || 0, n || e.length - 1, s || IA);
}
function wA(e, t, i, n, s) {
  for (; n > i; ) {
    if (n - i > 600) {
      var r = n - i + 1,
        a = t - i + 1,
        o = Math.log(r),
        l = 0.5 * Math.exp((2 * o) / 3),
        h = 0.5 * Math.sqrt((o * l * (r - l)) / r) * (a - r / 2 < 0 ? -1 : 1);
      wA(
        e,
        t,
        Math.max(i, Math.floor(t - (a * l) / r + h)),
        Math.min(n, Math.floor(t + ((r - a) * l) / r + h)),
        s
      );
    }
    var c = e[t],
      u = i,
      d = n;
    for (TA(e, i, t), s(e[n], c) > 0 && TA(e, i, n); u < d; ) {
      for (TA(e, u, d), u++, d--; s(e[u], c) < 0; ) u++;
      for (; s(e[d], c) > 0; ) d--;
    }
    0 === s(e[i], c) ? TA(e, i, d) : TA(e, ++d, n),
      d <= t && (i = d + 1),
      t <= d && (n = d - 1);
  }
}
function TA(e, t, i) {
  var n = e[t];
  (e[t] = e[i]), (e[i] = n);
}
function IA(e, t) {
  return e < t ? -1 : e > t ? 1 : 0;
}
class RA {
  constructor(e = 9) {
    (this._maxEntries = Math.max(4, e)),
      (this._minEntries = Math.max(2, Math.ceil(0.4 * this._maxEntries))),
      this.clear();
  }
  all() {
    return this._all(this.data, []);
  }
  search(e) {
    let t = this.data;
    const i = [];
    if (!GA(e, t)) return i;
    const n = this.toBBox,
      s = [];
    for (; t; ) {
      for (let r = 0; r < t.children.length; r++) {
        const a = t.children[r],
          o = t.leaf ? n(a) : a;
        GA(e, o) &&
          (t.leaf ? i.push(a) : zA(e, o) ? this._all(a, i) : s.push(a));
      }
      t = s.pop();
    }
    return i;
  }
  collides(e) {
    let t = this.data;
    if (!GA(e, t)) return !1;
    const i = [];
    for (; t; ) {
      for (let n = 0; n < t.children.length; n++) {
        const s = t.children[n],
          r = t.leaf ? this.toBBox(s) : s;
        if (GA(e, r)) {
          if (t.leaf || zA(e, r)) return !0;
          i.push(s);
        }
      }
      t = i.pop();
    }
    return !1;
  }
  load(e) {
    if (!e || !e.length) return this;
    if (e.length < this._minEntries) {
      for (let t = 0; t < e.length; t++) this.insert(e[t]);
      return this;
    }
    let t = this._build(e.slice(), 0, e.length - 1, 0);
    if (this.data.children.length)
      if (this.data.height === t.height) this._splitRoot(this.data, t);
      else {
        if (this.data.height < t.height) {
          const e = this.data;
          (this.data = t), (t = e);
        }
        this._insert(t, this.data.height - t.height - 1, !0);
      }
    else this.data = t;
    return this;
  }
  insert(e) {
    return e && this._insert(e, this.data.height - 1), this;
  }
  clear() {
    return (this.data = VA([])), this;
  }
  remove(e, t) {
    if (!e) return this;
    let i = this.data;
    const n = this.toBBox(e),
      s = [],
      r = [];
    let a, o, l;
    for (; i || s.length; ) {
      if (
        (i || ((i = s.pop()), (o = s[s.length - 1]), (a = r.pop()), (l = !0)),
        i.leaf)
      ) {
        const n = PA(e, i.children, t);
        if (-1 !== n)
          return i.children.splice(n, 1), s.push(i), this._condense(s), this;
      }
      l || i.leaf || !zA(i, n)
        ? o
          ? (a++, (i = o.children[a]), (l = !1))
          : (i = null)
        : (s.push(i), r.push(a), (a = 0), (o = i), (i = i.children[0]));
    }
    return this;
  }
  toBBox(e) {
    return e;
  }
  compareMinX(e, t) {
    return e.minX - t.minX;
  }
  compareMinY(e, t) {
    return e.minY - t.minY;
  }
  toJSON() {
    return this.data;
  }
  fromJSON(e) {
    return (this.data = e), this;
  }
  _all(e, t) {
    const i = [];
    for (; e; )
      e.leaf ? t.push(...e.children) : i.push(...e.children), (e = i.pop());
    return t;
  }
  _build(e, t, i, n) {
    const s = i - t + 1;
    let r,
      a = this._maxEntries;
    if (s <= a) return (r = VA(e.slice(t, i + 1))), DA(r, this.toBBox), r;
    n ||
      ((n = Math.ceil(Math.log(s) / Math.log(a))),
      (a = Math.ceil(s / Math.pow(a, n - 1)))),
      (r = VA([])),
      (r.leaf = !1),
      (r.height = n);
    const o = Math.ceil(s / a),
      l = o * Math.ceil(Math.sqrt(a));
    QA(e, t, i, l, this.compareMinX);
    for (let h = t; h <= i; h += l) {
      const t = Math.min(h + l - 1, i);
      QA(e, h, t, o, this.compareMinY);
      for (let i = h; i <= t; i += o) {
        const s = Math.min(i + o - 1, t);
        r.children.push(this._build(e, i, s, n - 1));
      }
    }
    return DA(r, this.toBBox), r;
  }
  _chooseSubtree(e, t, i, n) {
    for (; n.push(t), !t.leaf && n.length - 1 !== i; ) {
      let i,
        n = 1 / 0,
        a = 1 / 0;
      for (let o = 0; o < t.children.length; o++) {
        const l = t.children[o],
          h = kA(l),
          c =
            ((s = e),
            (r = l),
            (Math.max(r.maxX, s.maxX) - Math.min(r.minX, s.minX)) *
              (Math.max(r.maxY, s.maxY) - Math.min(r.minY, s.minY)) -
              h);
        c < a
          ? ((a = c), (n = h < n ? h : n), (i = l))
          : c === a && h < n && ((n = h), (i = l));
      }
      t = i || t.children[0];
    }
    var s, r;
    return t;
  }
  _insert(e, t, i) {
    const n = i ? e : this.toBBox(e),
      s = [],
      r = this._chooseSubtree(n, this.data, t, s);
    for (
      r.children.push(e), FA(r, n);
      t >= 0 && s[t].children.length > this._maxEntries;

    )
      this._split(s, t), t--;
    this._adjustParentBBoxes(n, s, t);
  }
  _split(e, t) {
    const i = e[t],
      n = i.children.length,
      s = this._minEntries;
    this._chooseSplitAxis(i, s, n);
    const r = this._chooseSplitIndex(i, s, n),
      a = VA(i.children.splice(r, i.children.length - r));
    (a.height = i.height),
      (a.leaf = i.leaf),
      DA(i, this.toBBox),
      DA(a, this.toBBox),
      t ? e[t - 1].children.push(a) : this._splitRoot(i, a);
  }
  _splitRoot(e, t) {
    (this.data = VA([e, t])),
      (this.data.height = e.height + 1),
      (this.data.leaf = !1),
      DA(this.data, this.toBBox);
  }
  _chooseSplitIndex(e, t, i) {
    let n,
      s = 1 / 0,
      r = 1 / 0;
    for (let a = t; a <= i - t; a++) {
      const t = LA(e, 0, a, this.toBBox),
        o = LA(e, a, i, this.toBBox),
        l = UA(t, o),
        h = kA(t) + kA(o);
      l < s
        ? ((s = l), (n = a), (r = h < r ? h : r))
        : l === s && h < r && ((r = h), (n = a));
    }
    return n || i - t;
  }
  _chooseSplitAxis(e, t, i) {
    const n = e.leaf ? this.compareMinX : NA,
      s = e.leaf ? this.compareMinY : BA;
    this._allDistMargin(e, t, i, n) < this._allDistMargin(e, t, i, s) &&
      e.children.sort(n);
  }
  _allDistMargin(e, t, i, n) {
    e.children.sort(n);
    const s = this.toBBox,
      r = LA(e, 0, t, s),
      a = LA(e, i - t, i, s);
    let o = OA(r) + OA(a);
    for (let l = t; l < i - t; l++) {
      const t = e.children[l];
      FA(r, e.leaf ? s(t) : t), (o += OA(r));
    }
    for (let l = i - t - 1; l >= t; l--) {
      const t = e.children[l];
      FA(a, e.leaf ? s(t) : t), (o += OA(a));
    }
    return o;
  }
  _adjustParentBBoxes(e, t, i) {
    for (let n = i; n >= 0; n--) FA(t[n], e);
  }
  _condense(e) {
    for (let t, i = e.length - 1; i >= 0; i--)
      0 === e[i].children.length
        ? i > 0
          ? ((t = e[i - 1].children), t.splice(t.indexOf(e[i]), 1))
          : this.clear()
        : DA(e[i], this.toBBox);
  }
}
function PA(e, t, i) {
  if (!i) return t.indexOf(e);
  for (let n = 0; n < t.length; n++) if (i(e, t[n])) return n;
  return -1;
}
function DA(e, t) {
  LA(e, 0, e.children.length, t, e);
}
function LA(e, t, i, n, s) {
  s || (s = VA(null)),
    (s.minX = 1 / 0),
    (s.minY = 1 / 0),
    (s.maxX = -1 / 0),
    (s.maxY = -1 / 0);
  for (let r = t; r < i; r++) {
    const t = e.children[r];
    FA(s, e.leaf ? n(t) : t);
  }
  return s;
}
function FA(e, t) {
  return (
    (e.minX = Math.min(e.minX, t.minX)),
    (e.minY = Math.min(e.minY, t.minY)),
    (e.maxX = Math.max(e.maxX, t.maxX)),
    (e.maxY = Math.max(e.maxY, t.maxY)),
    e
  );
}
function NA(e, t) {
  return e.minX - t.minX;
}
function BA(e, t) {
  return e.minY - t.minY;
}
function kA(e) {
  return (e.maxX - e.minX) * (e.maxY - e.minY);
}
function OA(e) {
  return e.maxX - e.minX + (e.maxY - e.minY);
}
function UA(e, t) {
  const i = Math.max(e.minX, t.minX),
    n = Math.max(e.minY, t.minY),
    s = Math.min(e.maxX, t.maxX),
    r = Math.min(e.maxY, t.maxY);
  return Math.max(0, s - i) * Math.max(0, r - n);
}
function zA(e, t) {
  return (
    e.minX <= t.minX && e.minY <= t.minY && t.maxX <= e.maxX && t.maxY <= e.maxY
  );
}
function GA(e, t) {
  return (
    t.minX <= e.maxX && t.minY <= e.maxY && t.maxX >= e.minX && t.maxY >= e.minY
  );
}
function VA(e) {
  return {
    children: e,
    height: 1,
    leaf: !0,
    minX: 1 / 0,
    minY: 1 / 0,
    maxX: -1 / 0,
    maxY: -1 / 0,
  };
}
function QA(e, t, i, n, s) {
  const r = [t, i];
  for (; r.length; ) {
    if ((i = r.pop()) - (t = r.pop()) <= n) continue;
    const a = t + Math.ceil((i - t) / n / 2) * n;
    MA(e, a, t, i, s), r.push(t, a, a, i);
  }
}
const HA = new Matrix4();
class jA {
  constructor(e) {
    publicField(this, "_groupObjectMap", {}),
      publicField(this, "_groupDataMap", {}),
      publicField(this, "_objectDataMap", new Map()),
      publicField(this, "_needsUpdate", !1),
      publicField(this, "_restrictCount", 1e3),
      publicField(this, "_lastUpdateTime", 0),
      publicField(this, "_delayUpdateTime", 300),
      publicField(this, "_delayUpdateTimeHandler", null),
      publicField(this, "_margin", [0, 0]),
      publicField(this, "_maxRenderDepth", 1),
      publicField(this, "_lastZoom", 0),
      publicField(this, "_viewMatrixWorld", new Matrix4()),
      publicField(this, "_projectionMatrix", new Matrix4()),
      publicField(this, "_viewChanged", !0),
      (this._rendering = e);
  }
  add(e, t = {}, i = "_default") {
    e instanceof GeoObject
      ? e.dataSource
        ? (this._groupObjectMap[i] ||
            ((this._groupObjectMap[i] = []), (this._groupDataMap[i] = [])),
          this._groupObjectMap[i].push(e),
          (e._enableCollision = !0),
          (e._collisionOptions = t),
          e.dataSource.setAttribute("rank", "rank"))
        : console.error(
            "Object must have DataSource before it added to Collision!"
          )
      : console.error("Collison Test only work with GeoObject.");
  }
  remove(e, t = "_default") {
    if (!(e instanceof GeoObject))
      return void console.error("Collison Test only work with GeoObject.");
    let i = this._groupObjectMap[t].indexOf(e);
    i > -1
      ? (this._groupObjectMap[t].splice(i, 1),
        delete e._enableCollision,
        delete e._collisionOptions,
        delete e._collisionData,
        delete e._collisionUpdated,
        e.dataSource.removeAttribute("rank", "rank"))
      : console.error("remove error: cannot find object in this group.");
  }
  sortData() {
    let e = Object.keys(this._groupObjectMap);
    for (let t = 0; t < e.length; t++) {
      const i = e[t],
        n = this._groupObjectMap[i];
      for (let e = 0; e < n.length; e++) {
        const t = n[e];
        (t._collisionData = []), (t._collisionUpdated = !0);
        let i = t.dataSource.userData;
        for (let e = 0; e < i.length; e++) i[e]._objects = t.dataSource.objects;
      }
      this._groupDataMap[i] = [];
      for (let e = 0; e < n.length; e++) {
        const t = n[e];
        this._groupDataMap[i] = this._groupDataMap[i].concat(
          t.dataSource.userData
        );
      }
      this._groupDataMap[i] = this._groupDataMap[i]
        .sort(
          (e, t) =>
            t.rank - e.rank ||
            t.position[0] - e.position[0] ||
            t.position[1] - e.position[1]
        )
        .slice(0, this.restrictCount);
    }
    this._needsUpdate = !1;
  }
  update(e) {
    if (!Object.keys(this._groupDataMap).length) return;
    if (this._delayUpdateTimeHandler) return;
    const t = Date.now(),
      i = t - this._lastUpdateTime;
    i < this._delayUpdateTime
      ? (this._delayUpdateTimeHandler = setTimeout(() => {
          clearTimeout(this._delayUpdateTimeHandler),
            (this._delayUpdateTimeHandler = null),
            this._rendering.requestRender();
        }, this._delayUpdateTime - i + 1))
      : (this.needsUpdate
          ? (this.sortData(), this._collisionTest())
          : ((this._viewChanged =
              !e.viewMatrixWorld.equals(this._viewMatrixWorld) ||
              !e.projectionMatrix.equals(this._projectionMatrix)),
            this._viewChanged &&
              (this._collisionTest(),
              this._viewMatrixWorld.copy(e.viewMatrixWorld),
              this._projectionMatrix.copy(e.projectionMatrix))),
        (this._lastUpdateTime = t));
  }
  _collisionTest() {
    let e = Object.keys(this._groupDataMap);
    const t = this._rendering.camera;
    let i = HA.copy(this._rendering.renderState.viewMatrixWorldInverse),
      n = t.projectionMatrix;
    const s = this._rendering.resolution
        ? this._rendering.resolution.toArray()
        : [0, 0],
      [r, a] = s;
    if (isNaN(r) || r <= 0 || isNaN(a) || a <= 0)
      return console.warn("resolution is invalid"), !1;
    const o = this._objectDataMap;
    o.clear();
    for (let l = 0; l < e.length; l++) {
      const t = e[l],
        s = this._groupDataMap[t];
      if (!s) continue;
      const h = new RA();
      for (let e = 0; e < s.length; e++) {
        const t = s[e],
          l = t._objects,
          c = l.filter((e) => e._enableCollision)[0],
          [u, d, p] = t.position,
          f = new Vector4(u, d, p, 1);
        f.applyMatrix4(i).applyMatrix4(n), f.divideScalar(f.w);
        const m = ((f.x + 1) / 2) * r,
          g = ((1 - f.y) / 2) * a;
        if (f.z > this._maxRenderDepth) continue;
        let { width: _, height: v } = c.collisionTest(t);
        if (!_ || !v) continue;
        let A = _,
          y = v;
        if (c._collisionOptions.margin) {
          let e = c._collisionOptions.margin;
          "number" == typeof e && (e = [e, e]), (_ += e[0]), (v += e[1]);
        } else (_ += this.margin[0]), (v += this.margin[1]);
        const x = m - _ / 2,
          b = g - v / 2,
          E = x + _,
          S = b + v;
        if (E < 0 || S < 0 || x > r || b > a) continue;
        const C = { minX: x, minY: b, maxX: E, maxY: S };
        if (h.collides(C)) continue;
        h.insert(C);
        let M = { ...t, w: A, h: y };
        for (let e = 0; e < l.length; e++) {
          const t = l[e];
          o.get(t) || o.set(t, []);
          o.get(t).push(M);
        }
      }
    }
    Array.from(o.entries()).forEach(([e, t]) => {
      (e._collisionData && e._collisionData.length === t.length) ||
        ((e._collisionData = t), (e._collisionUpdated = !0));
    });
  }
  set margin(e) {
    "number" == typeof e
      ? (this._margin = [e, e])
      : e instanceof Array && (this._margin = e);
  }
  get margin() {
    return this._margin;
  }
  set maxRenderDepth(e) {
    this._maxRenderDepth = e;
  }
  set restrictCount(e) {
    this._restrictCount = e;
  }
  get restrictCount() {
    return this._restrictCount;
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
}
class WA {
  constructor(e) {
    publicField(this, "_rendering", null),
      publicField(this, "_mixer", null),
      publicField(this, "_customMixers", []),
      (this._rendering = e);
  }
  update(e) {
    this._mixer && this._mixer.update(e.deltaSeconds);
    for (const t of this._customMixers) t.update(e.deltaSeconds);
  }
  addMixer(e) {
    -1 === this._customMixers.indexOf(e) && this._customMixers.push(e);
  }
  removeMixer(e) {
    let t = this._customMixers.indexOf(e);
    -1 !== t && this._customMixers.splice(t, 1);
  }
  get mixer() {
    return (
      this._mixer || (this._mixer = new Zl(this._rendering.scene)), this._mixer
    );
  }
}
class qA {
  static createButton(e) {
    const t = document.createElement("button");
    function i() {
      (t.style.display = ""),
        (t.style.cursor = "auto"),
        (t.style.left = "calc(50% - 75px)"),
        (t.style.width = "150px"),
        (t.onmouseenter = null),
        (t.onmouseleave = null),
        (t.onclick = null);
    }
    function n(e) {
      (e.style.position = "absolute"),
        (e.style.bottom = "20px"),
        (e.style.padding = "12px 6px"),
        (e.style.border = "1px solid #fff"),
        (e.style.borderRadius = "4px"),
        (e.style.background = "rgba(0,0,0,0.1)"),
        (e.style.color = "#fff"),
        (e.style.font = "normal 13px sans-serif"),
        (e.style.textAlign = "center"),
        (e.style.opacity = "0.5"),
        (e.style.outline = "none"),
        (e.style.zIndex = "999");
    }
    if ("xr" in navigator)
      return (
        (t.id = "VRButton"),
        (t.style.display = "none"),
        n(t),
        navigator.xr
          .isSessionSupported("immersive-vr")
          .then(function (n) {
            n
              ? (function () {
                  let i = null;
                  async function n(n) {
                    n.addEventListener("end", s),
                      await e.xr.setSession(n),
                      (t.textContent = "EXIT VR"),
                      (i = n);
                  }
                  function s() {
                    i.removeEventListener("end", s),
                      (t.textContent = "ENTER VR"),
                      (i = null);
                  }
                  (t.style.display = ""),
                    (t.style.cursor = "pointer"),
                    (t.style.left = "calc(50% - 50px)"),
                    (t.style.width = "100px"),
                    (t.textContent = "ENTER VR"),
                    (t.onmouseenter = function () {
                      t.style.opacity = "1.0";
                    }),
                    (t.onmouseleave = function () {
                      t.style.opacity = "0.5";
                    }),
                    (t.onclick = function () {
                      if (null === i) {
                        const e = {
                          optionalFeatures: [
                            "local-floor",
                            "bounded-floor",
                            "hand-tracking",
                            "layers",
                          ],
                        };
                        navigator.xr.requestSession("immersive-vr", e).then(n);
                      } else i.end();
                    });
                })()
              : (i(), (t.textContent = "VR NOT SUPPORTED")),
              n && qA.xrSessionIsGranted && t.click();
          })
          .catch(function (e) {
            i(),
              console.warn(
                "Exception when trying to call xr.isSessionSupported",
                e
              ),
              (t.textContent = "VR NOT ALLOWED");
          }),
        t
      );
    {
      const e = document.createElement("a");
      return (
        !1 === window.isSecureContext
          ? ((e.href = document.location.href.replace(/^http:/, "https:")),
            (e.innerHTML = "WEBXR NEEDS HTTPS"))
          : ((e.href = "https://immersiveweb.dev/"),
            (e.innerHTML = "WEBXR NOT AVAILABLE")),
        (e.style.left = "calc(50% - 90px)"),
        (e.style.width = "180px"),
        (e.style.textDecoration = "none"),
        n(e),
        e
      );
    }
  }
  static registerSessionGrantedListener() {
    if ("xr" in navigator) {
      if (/WebXRViewer\//i.test(navigator.userAgent)) return;
      navigator.xr.addEventListener("sessiongranted", () => {
        qA.xrSessionIsGranted = !0;
      });
    }
  }
}
(qA.xrSessionIsGranted = !1), qA.registerSessionGrantedListener();
class XA {
  constructor(e) {
    publicField(this, "onSessionStart", () => {
      this.cameraGroup.rotation.set(Math.PI / 2, 0, 0);
    }),
      publicField(this, "onSessionEnd", () => {
        this.cameraGroup.rotation.set(0, 0, 0);
      }),
      (this._rendering = e);
  }
  init() {
    const e = this._rendering,
      t = e._renderer;
    if (e._useXR) {
      (e.useMrt = !1),
        (e.enableAnimationLoop = !0),
        (e.animationLoopFrameTime = 16),
        (e.autoOffsetRelativeCenter = !1);
      const i = e._engine.camera,
        n = (this.cameraGroup = new va());
      n.add(i),
        e._engine.add(n),
        document.body.appendChild(qA.createButton(t)),
        t.setAnimationLoop(e.render),
        (t.xr.enabled = !0),
        t.xr.addEventListener("sessionstart", this.onSessionStart),
        t.xr.addEventListener("sessionend", this.onSessionEnd);
    }
  }
  dispose() {
    const e = this._rendering._renderer;
    e.xr.removeEventListener("sessionstart", this.onSessionStart),
      e.xr.removeEventListener("sessionend", this.onSessionEnd);
  }
}
class YA {
  constructor(e) {
    publicField(this, "_lastValue", 0),
      publicField(this, "_count", 0),
      publicField(this, "_total", 0),
      publicField(this, "_beginTime", 0),
      publicField(this, "_name"),
      (this._name = e);
  }
  begin(e) {
    this._beginTime = e;
  }
  end(e) {
    (this._lastValue = e - this._beginTime),
      (this._total = this._total + this._lastValue),
      this._count++;
  }
  add(e) {
    (this._total += e), (this._lastValue = e), this._count++;
  }
  get total() {
    return this._total;
  }
  get count() {
    return this._count;
  }
  get average() {
    return 0 === this._count ? 0 : this._total / this._count;
  }
  get lastValue() {
    return this._lastValue;
  }
  get name() {
    return this._name;
  }
  get beginTime() {
    return this._beginTime;
  }
}
class KA {
  constructor() {
    publicField(this, "_timeStatsItem", {});
  }
  addTimeStatsItem(e) {
    const t = new YA(e);
    this._timeStatsItem[e] = t;
  }
  removeTimeStatsItem(e) {
    delete this._timeStatsItem[e];
  }
  beginTimeStatsItem(e, t) {
    this._timeStatsItem[e] || this.addTimeStatsItem(e),
      null == t && (t = performance.now()),
      this._timeStatsItem[e].begin(t);
  }
  endTimeStatsItem(e, t) {
    this._timeStatsItem[e] || this.addTimeStatsItem(e),
      null == t && (t = performance.now()),
      this._timeStatsItem[e].end(t);
  }
  addTimeStatsItemValue(e, t) {
    this._timeStatsItem[e] || this.addTimeStatsItem(e),
      this._timeStatsItem[e].add(t);
  }
  getSortedTimeStatsItems() {
    let e = Object.values(this._timeStatsItem);
    const t = performance.now();
    return (
      (e = e.filter((e) => t - e.beginTime < 5e3)),
      e.sort((e, t) => t.average - e.average),
      e
    );
  }
  printString() {
    let e = "Stas:\n";
    const t = this.getSortedTimeStatsItems();
    for (const i of t)
      e += `${i.name}:\n${i.average.toFixed(2)}\t ${i.lastValue.toFixed(2)}\t ${
        i.count
      }\t ${i.total.toFixed(2)}\n`;
    return e;
  }
}
class ZA {
  constructor() {
    publicField(this, "_time", 0),
      publicField(this, "_viewChanged", !1),
      publicField(this, "_viewMatrixWorld", new Matrix4()),
      publicField(this, "_viewMatrixWorldInverse", new Matrix4()),
      publicField(this, "_projectionMatrix", new Matrix4()),
      publicField(this, "_cameraMatrix", new Matrix4()),
      publicField(this, "_cameraMatrixInverse", new Matrix4()),
      publicField(this, "_cameraOffsetX", 0),
      publicField(this, "_cameraOffsetY", 0),
      publicField(this, "_frameCount", 0);
  }
  beginFrame(e, t) {
    (this._deltaTime = t - this._time),
      (this._deltaSeconds = this._deltaTime / 1e3),
      (this._time = t),
      this._frameCount++;
    const i = e.camera,
      n = i.matrixWorld,
      s = i.projectionMatrix;
    n.equals(this._viewMatrixWorld) && s.equals(this._projectionMatrix)
      ? (this._viewChanged = !1)
      : (this._viewChanged = !0),
      this._viewMatrixWorld.copy(i.matrixWorld),
      this._viewMatrixWorldInverse.copy(i.matrixWorldInverse),
      this._projectionMatrix.copy(i.projectionMatrix);
  }
  endFrame() {}
  updateCameraOffsetState(e, t, i) {
    this._cameraMatrix.copy(e.matrixWorld),
      this._cameraMatrixInverse.copy(e.matrixWorldInverse),
      (this._cameraOffsetX = t),
      (this._cameraOffsetY = i);
  }
  get time() {
    return this._time;
  }
  get viewChanged() {
    return this._viewChanged;
  }
  get viewMatrixWorld() {
    return this._viewMatrixWorld;
  }
  get viewMatrixWorldInverse() {
    return this._viewMatrixWorldInverse;
  }
  get projectionMatrix() {
    return this._projectionMatrix;
  }
  get cameraMatrix() {
    return this._cameraMatrix;
  }
  get cameraMatrixInverse() {
    return this._cameraMatrixInverse;
  }
  get cameraOffsetX() {
    return this._cameraOffsetX;
  }
  get cameraOffsetY() {
    return this._cameraOffsetY;
  }
  get deltaTime() {
    return this._deltaTime;
  }
  get deltaSeconds() {
    return this._deltaSeconds;
  }
  get frameCount() {
    return this._frameCount;
  }
}
const JA = (e) => e && "object" == typeof e && !Array.isArray(e),
  $A = (e, ...t) => {
    if (!t.length) return e;
    const i = t.shift();
    if (JA(e) && JA(i))
      for (const n in i)
        JA(i[n])
          ? (e[n] || Object.assign(e, { [n]: {} }), $A(e[n], i[n]))
          : Object.assign(e, { [n]: i[n] });
    return $A(e, ...t);
  };
new Matrix3();
class ey {
  constructor(e, t = {}) {
    publicField(this, "_engine"),
      publicField(this, "_outputEncoding"),
      publicField(this, "_enableAnimationLoop"),
      publicField(this, "_animationLoopFrameTime"),
      publicField(this, "_uniforms"),
      publicField(this, "_main"),
      publicField(this, "_shadow"),
      publicField(this, "_bloom"),
      publicField(this, "_ssr"),
      publicField(this, "_composition"),
      publicField(this, "_fog"),
      publicField(this, "_label"),
      publicField(this, "_colorAdjust"),
      publicField(this, "_renderState"),
      publicField(this, "_camera"),
      publicField(this, "_canvas"),
      publicField(this, "_context"),
      publicField(this, "_renderer"),
      publicField(this, "_scene"),
      publicField(this, "_weather"),
      publicField(this, "_useMRT", !1),
      publicField(this, "_isUseMRTChanged", !1),
      publicField(this, "_freezeUpdate", !1),
      publicField(this, "_isRunning", !1),
      publicField(this, "_needsRenderImmediately", !1),
      publicField(this, "_needsRenderNext", !1),
      publicField(this, "_beforeRenderListeners", []),
      publicField(this, "_prepareRenderListeners", []),
      publicField(this, "_startTime", 0),
      publicField(this, "_pixelRatio", window.devicePixelRatio),
      publicField(this, "_resolution"),
      publicField(this, "_sky", null),
      publicField(this, "_debugShaderType", 0),
      publicField(this, "_beforeScenePrepareRenderObjects", new Set()),
      publicField(this, "_beforeSceneRenderObjects", new Set()),
      publicField(this, "_onRenderModeChangedObjects", new Set()),
      publicField(this, "_useClip"),
      publicField(this, "_wireframe", !1),
      publicField(this, "_wireframeMaterial", null),
      publicField(this, "_autoOffsetRelativeCenter", !0),
      publicField(this, "_contextParameters", {
        alpha: !0,
        stencil: !0,
        antialias: !1,
        powerPreference: "high-performance",
        preserveDrawingBuffer: !1,
      }),
      publicField(this, "_needsReCreateRenderer", !1),
      publicField(this, "handleShaderBeforeResolve", (e, t, i) => {
        if (this._useMRT) {
          const e = this._renderer.getRenderTarget();
          e &&
            e.isWebGLMultipleRenderTargets &&
            (t = this.convertMrtSupportedFragment(t));
        } else t = this.convertNMrtSupportedFragment(t, i.shaderID);
        return (
          "basic" === i.shaderID &&
            (t = "#define BASIC\nuniform vec3 emissive;\n" + t),
          {
            vertexShader: (e = ((e) => {
              const t = "void main()",
                i = (e = e.replace(
                  t,
                  "#include <mvt_clip_pars_vertex>\n" + t
                )).indexOf(t),
                n = i + 11 + e.slice(i + 11).indexOf("{") + 1;
              return (
                e.slice(0, n) +
                "\n    #include <mvt_clip_vertex>\n" +
                e.slice(n)
              );
            })(e)),
            fragmentShader: (t = ((e) => {
              const t = "void main()",
                i = (e = e.replace(
                  t,
                  "#include <mvt_clip_pars_fragment>\n" + t
                )).indexOf(t),
                n = i + 11 + e.slice(i + 11).indexOf("{") + 1;
              return (
                e.slice(0, n) +
                "\n    #include <mvt_clip_fragment>\n" +
                e.slice(n)
              );
            })(t)),
          }
        );
      }),
      publicField(this, "handleShaderBeforeCompile", (e, t, i) => {
        if (
          ((e = Nm(
            e,
            "\nattribute float _tileEditableValue;\n",
            null,
            "\nif (_tileEditableValue == 1.0) {\n    gl_Position = vec4(-1.0, -1.0, -1.0, -1.0);\n}\n"
          )),
          this._useMRT)
        ) {
          const n = this._renderer.getRenderTarget();
          if (n && n.isWebGLMultipleRenderTargets) {
            i.isRawShaderMaterial &&
              i.glslVersion !== be &&
              ((e =
                [
                  "#version 300 es",
                  "precision mediump sampler2DArray;",
                  "#define attribute in",
                  "#define varying out",
                  "#define texture2D texture",
                ].join("\n") +
                "\n" +
                e),
              (t =
                [
                  "#version 300 es",
                  "#define varying in",
                  "layout(location = 0) out highp vec4 pc_fragColor;",
                  "#define gl_FragColor pc_fragColor",
                  "#define gl_FragDepthEXT gl_FragDepth",
                  "#define texture2D texture",
                  "#define textureCube texture",
                  "#define texture2DProj textureProj",
                  "#define texture2DLodEXT textureLod",
                  "#define texture2DProjLodEXT textureProjLod",
                  "#define textureCubeLodEXT textureLod",
                  "#define texture2DGradEXT textureGrad",
                  "#define texture2DProjGradEXT textureProjGrad",
                  "#define textureCubeGradEXT textureGrad",
                ].join("\n") +
                "\n" +
                t));
          }
        }
        return { vertexShader: e, fragmentShader: t };
      }),
      publicField(this, "convertMrtSupportedFragment", (e) =>
        this._main.sceneRendering.modifyFragmentShader(e)
      ),
      publicField(this, "convertNMrtSupportedFragment", (e, t) =>
        ((e) => {
          let t = e;
          t = t.replace(
            "void main() {",
            "#include <mvt_nmrt_output_pars_fragment>\nvoid main() {"
          );
          const i = t.lastIndexOf("}");
          return (
            (t = t.substring(0, i)),
            (t += "#include <mvt_nmrt_output_fragment>\n}"),
            t
          );
        })(e)
      ),
      publicField(this, "render", () => {
        if (!this._isRunning) return;
        this._useXR || requestAnimationFrame(this.render);
        const e = new Date().valueOf();
        if (
          ((this._needsRenderNext || this._enableAnimationLoop) &&
            this._animationLoopFrameTime < 17 &&
            (this._needsRenderImmediately = !0),
          !(
            this._needsRenderImmediately ||
            ((this._needsRenderNext || this._enableAnimationLoop) &&
              e - this.lastRenderTime >= this._animationLoopFrameTime)
          ))
        )
          return;
        let t = this._needsRenderImmediately
          ? 0
          : e - this.lastRenderTime - this._animationLoopFrameTime;
        t > this._animationLoopFrameTime - 16 &&
          (t = this._animationLoopFrameTime - 16),
          (this.lastRenderTime = e - t),
          (this._needsRenderImmediately = !1),
          (this._needsRenderNext = !1);
        const i = this._stats;
        i.beginTimeStatsItem("renderAll"),
          this.renderScene(e),
          i.endTimeStatsItem("renderAll");
      }),
      publicField(this, "scaleZAtCurrentPosition", () => {
        const e = this._engine.map,
          t = e.getScaleAt(e.getCenter2D());
        this.scene.scale.z = t;
      }),
      (this._engine = e);
    const i = (this._options = this.getInitialConfig(t));
    Object.assign(this._contextParameters, i.contextParameters),
      i.preserveDrawingBuffer &&
        (this._contextParameters.preserveDrawingBuffer = !0);
    const n = i.features.antialias;
    (this._contextParameters.antialias = n.enabled && "msaa" === n.method),
      (this._enableAnimationLoop = i.enableAnimationLoop || !1),
      (this._animationLoopFrameTime = i.animationLoopFrameTime || 16),
      (this._useMRT = i.useMRT || !1),
      (this._useXR = i.useXR || !1),
      (this._pixelRatio = i.pixelRatio || window.devicePixelRatio),
      (this._resolution = t.resolution),
      (this._uniforms = {
        time: { value: 0 },
        elapsedTime: { value: 0 },
        pixelRatio: { value: this._pixelRatio },
        zoomUnits: { value: 1 },
        resolution: { value: new Vector2(i.resolution.x, i.resolution.y) },
      }),
      Object.freeze(this._uniforms),
      (this._stats = new KA(this)),
      (this._main = new X_(this, i)),
      (this._shadow = new Y_(this)),
      (this._bloom = new iv(this)),
      (this._ssr = new sv(this)),
      (this._composition = new lv(this)),
      (this._fog = new K_(this)),
      (this._postprocessing = new hv(this)),
      (this._label = new SA(this)),
      (this._colorAdjust = new CA(this)),
      (this._collision = new jA(this)),
      (this._animation = new WA(this)),
      (this._xr = new XA(this)),
      (this._renderState = new ZA(this));
  }
  getInitialConfig(e) {
    const t = {
      useMRT: !1,
      enableAnimationLoop: !1,
      animationLoopFrameTime: 16,
      useXR: !1,
      pixelRatio: window.devicePixelRatio,
      features: {
        antialias: { enabled: !0, method: "msaa" },
        bloom: { enabled: !1, strength: 1, threshold: 0, radius: 0 },
        ao: { enabled: !1, method: "ssao" },
        reflection: { enabled: !1, method: "ssr" },
      },
    };
    return $A(t, e);
  }
  init() {
    const e = this._resolution;
    (this._camera = new Dn(35, e.x / e.y, 1, 100)).matrixAutoUpdate = !1;
    const t = (this._scene = new wa()),
      i = (this.objectsScene = new va()),
      n = (this.environmentScene = new va());
    t.add(i),
      t.add(n),
      (t.matrixWorldAutoUpdate = !1),
      this._createRenderer(),
      (this._uniforms.resolution.value[0] = e.x),
      (this._uniforms.resolution.value[1] = e.y),
      this._xr.init();
  }
  _createRenderer() {
    const e = this._resolution,
      n = this._engine;
    let s = !!this._renderer;
    s &&
      (n.map.releaseCanvas(),
      this._renderer.forceContextLoss(),
      this._renderer.dispose());
    const r = (this._canvas = document.createElement("canvas"));
    i(r, `${t}-canvas`),
      (r.style.position = "absolute"),
      (r.style.top = "0"),
      (r.style.left = "0"),
      (r.style.zIndex = "2");
    const a = (this._context = r.getContext("webgl2", this._contextParameters)),
      o = (this._renderer = new WebGLRenderer({
        canvas: r,
        context: a,
        logarithmicDepthBuffer: !0,
      }));
    o.setClearColor(16777215, 0),
      o.setPixelRatio(this._pixelRatio),
      o.setSize(e.x, e.y),
      (o.info.autoReset = !1),
      (this._renderer.extraProgramCacheKey = "0"),
      (o.onShaderBeforeResolve = this.handleShaderBeforeResolve),
      (o.onShaderBeforeCompile = this.handleShaderBeforeCompile),
      s && ((n.map._map.canvas = r), n.map.bindCanvas());
  }
  addBeforeRenderListener(e) {
    -1 === this._beforeRenderListeners.indexOf(e) &&
      this._beforeRenderListeners.push(e);
  }
  removeBeforeRenderListener(e) {
    const t = this._beforeRenderListeners.indexOf(e);
    t > -1 && this._beforeRenderListeners.splice(t, 1);
  }
  addPrepareRenderListener(e) {
    -1 === this._prepareRenderListeners.indexOf(e) &&
      this._prepareRenderListeners.push(e);
  }
  removePrepareRenderListener(e) {
    const t = this._prepareRenderListeners.indexOf(e);
    t > -1 && this._prepareRenderListeners.splice(t, 1);
  }
  add(e) {
    return (
      e.traverse((e) => {
        e.afterAddToEngine &&
          !e.__initInEngine &&
          ((e.__initInEngine = !0), e.afterAddToEngine(this._engine)),
          e instanceof Wm
            ? (this._sky = e)
            : e instanceof og && (this._weather = e),
          this.addBeforePrepareRenderObject(e),
          this.addBeforeRenderObject(e),
          this.addOnRenderModeChangeObject(e);
      }),
      e.__isEnvironment
        ? this.environmentScene.add(e)
        : this.objectsScene.add(e),
      (this._needsRenderImmediately = !0),
      e
    );
  }
  remove(e) {
    e.traverse((e) => {
      e.beforeRemoveFromEngine &&
        ((e.__initInEngine = void 0), e.beforeRemoveFromEngine(this._engine)),
        e instanceof Wm
          ? (this._sky = null)
          : e instanceof og && (this._weather = null),
        this.removeBeforeRenderObject(e),
        this.removeBeforePrepareRenderObject(e),
        this.removeOnRenderModeChangeObject(e);
    }),
      e.__isEnvironment
        ? this.environmentScene.remove(e)
        : this.objectsScene.remove(e),
      (this._needsRenderImmediately = !0);
  }
  addBeforePrepareRenderObject(e) {
    e.onBeforeScenePrepareRender &&
      this._beforeScenePrepareRenderObjects.add(e);
  }
  removeBeforePrepareRenderObject(e) {
    this._beforeScenePrepareRenderObjects.delete(e);
  }
  addBeforeRenderObject(e) {
    e.onBeforeSceneRender && this._beforeSceneRenderObjects.add(e);
  }
  removeBeforeRenderObject(e) {
    this._beforeSceneRenderObjects.delete(e);
  }
  addOnRenderModeChangeObject(e) {
    e.onRenderModeChanged && this._onRenderModeChangedObjects.add(e);
  }
  removeOnRenderModeChangeObject(e) {
    e.onRenderModeChanged && this._onRenderModeChangedObjects.delete(e);
  }
  startRenderLoop() {
    (this._isRunning = !0),
      (this._needsRenderImmediately = !0),
      (this._startTime = new Date().valueOf()),
      this.render();
  }
  stopRenderLoop() {
    this._isRunning = !1;
  }
  updateCamera() {
    this._engine.map.updateCamera();
  }
  requestRender() {
    this._needsRenderImmediately = !0;
  }
  renderScene(e) {
    const t = this._engine,
      i = this._stats;
    e || (e = new Date().valueOf()),
      (this._uniforms.time.value = e),
      (this._uniforms.elapsedTime.value = e - this._startTime),
      (this._uniforms.zoomUnits.value = this._engine.map.getZoomUnits()),
      this.camera._isLocked || this.updateCamera(),
      i.beginTimeStatsItem("updateRaycast"),
      t.event.executeMousemoveRaycast(),
      i.endTimeStatsItem("updateRaycast");
    const n = this._camera,
      s = this._scene,
      r = this._renderState;
    r.beginFrame(this, e),
      this._main.beginFrame(),
      this._needsReCreateRenderer &&
        ((this._needsReCreateRenderer = !1), this._createRenderer());
    r._viewChanged && n.dispatchEvent({ type: "viewchanged" }),
      i.beginTimeStatsItem("updateAnimation"),
      this._animation.update(r),
      i.endTimeStatsItem("updateAnimation");
    for (let d of this._prepareRenderListeners) d(this._engine, r);
    this._beforeScenePrepareRenderObjects.forEach((e) => {
      e.onBeforeScenePrepareRender(t, s, n, r);
    });
    const a = new Vector3(
      n.matrix.elements[12],
      n.matrix.elements[13],
      n.matrix.elements[14]
    );
    let o = 0,
      l = 0;
    const h = 1e3,
      c = Math.floor(a.x / h) * h,
      u = Math.floor(a.y / h) * h;
    (o = a.x - c),
      (l = a.y - u),
      this._autoOffsetRelativeCenter &&
        (n.position.set(o, l, a.z),
        n.updateMatrix(),
        n.updateMatrixWorld(),
        s.position.set(-c, -u, 0)),
      r.updateCameraOffsetState(n, c, u),
      s.updateMatrix(),
      s.updateMatrixWorld();
    this._renderer.info.reset(),
      i.beginTimeStatsItem("updateCollision"),
      this._collision.update(r),
      i.endTimeStatsItem("updateCollision"),
      this._beforeSceneRenderObjects.forEach((e) => {
        e.onBeforeSceneRender(t, s, n, r);
      });
    for (let d of this._beforeRenderListeners) d(this._engine, r);
    i.beginTimeStatsItem("updateNodeMaterials"),
      Fm.update(),
      i.endTimeStatsItem("updateNodeMaterials"),
      i.beginTimeStatsItem("renderMain"),
      this._main.render(),
      i.endTimeStatsItem("renderMain"),
      this._autoOffsetRelativeCenter &&
        (n.position.set(a.x, a.y, a.z),
        n.updateMatrix(),
        n.updateMatrixWorld(),
        s.position.set(0, 0, 0),
        s.updateMatrix(),
        s.updateMatrixWorld()),
      this._main.endFrame(),
      r.endFrame(this),
      (this._useMRTChanged = !1);
  }
  updateContextParameters(e) {
    const t = this._contextParameters;
    for (const i of Object.keys(e))
      t[i] !== e[i] && ((t[i] = e[i]), (this._needsReCreateRenderer = !0));
  }
  setResolution(e) {
    this._resolution.copy(e),
      this._uniforms.resolution.value.copy(e),
      this._renderer.setSize(e.x, e.y),
      this._main.setSize(e.x, e.y),
      this._bloom.setSize(e.x, e.y),
      this._ssr.setSize(e.x, e.y),
      (this._needsRenderNext = !0);
  }
  dispose() {
    this.stopRenderLoop(),
      this._wireframeMaterial && this._wireframeMaterial.dispose();
    const e = Array.from(this.objectsScene.children),
      t = Array.from(this.environmentScene.children);
    for (const n of e) this.remove(n), n.dispose && n.dispose();
    for (const n of t) this.remove(n), n.dispose && n.dispose();
    this._renderer.dispose();
    let i = this._context.getExtension("WEBGL_lose_context");
    i && i.loseContext();
  }
  get contextParameters() {
    return this._contextParameters;
  }
  get sky() {
    return this._sky;
  }
  get weather() {
    return this._weather;
  }
  get debugShaderType() {
    return this._debugShaderType;
  }
  set debugShaderType(e) {
    if (((this._debugShaderType = e), !this._useMRT)) return;
    e = parseInt(e, 10);
    const t = this._composition;
    if (e && 0 !== e)
      if (1 === e) t.debugTextures = this._main.getTextures();
      else if (2 === e) {
        const e = [];
        this.objectsScene.traverse((t) => {
          t.isLight && t.shadow && t.shadow.map && e.push(t.shadow.map.texture);
        }),
          (t.debugTextures = e);
      } else
        3 === e
          ? (t.debugTextures = this._bloom.getTextures())
          : 4 === e
          ? (t.debugTextures = this._ssr.getTextures())
          : 5 === e &&
            this._sky &&
            this._sky.getTextures &&
            (t.debugTextures = this._sky.getTextures());
    else t.debugTextures = null;
  }
  get isUseMRTChanged() {
    return this._useMRTChanged;
  }
  get useMrt() {
    return this.useMRT;
  }
  set useMrt(e) {
    this.useMRT = e;
  }
  get useMRT() {
    return this._useMRT;
  }
  set useMRT(e) {
    this._useMRT !== e && ((this._useMRT = e), (this._useMRTChanged = !0));
  }
  get main() {
    return this._main;
  }
  get shadow() {
    return this._shadow;
  }
  get bloom() {
    return this._main.features.bloom;
  }
  get ssr() {
    return this._ssr;
  }
  get composition() {
    return this._composition;
  }
  get fog() {
    return this._fog;
  }
  get postprocessing() {
    return this._postprocessing;
  }
  get label() {
    return this._label;
  }
  get colorAdjust() {
    return this._colorAdjust;
  }
  get renderState() {
    return this._renderState;
  }
  get stats() {
    return this._stats;
  }
  get collision() {
    return this._collision;
  }
  get animation() {
    return this._animation;
  }
  get xr() {
    return this._xr;
  }
  get enableAnimationLoop() {
    return this._enableAnimationLoop;
  }
  set enableAnimationLoop(e) {
    this._enableAnimationLoop = e;
  }
  get animationLoopFrameTime() {
    return this._animationLoopFrameTime;
  }
  set animationLoopFrameTime(e) {
    this._animationLoopFrameTime = e;
  }
  get resolution() {
    return this._resolution;
  }
  set resolution(e) {
    this._resolution = e;
  }
  get pixelRatio() {
    return this._pixelRatio;
  }
  set pixelRatio(e) {
    this._pixelRatio = e;
  }
  get outputEncoding() {
    return this._outputEncoding;
  }
  set outputEncoding(e) {
    this._outputEncoding = e;
  }
  get canvas() {
    return this._canvas;
  }
  get renderer() {
    return this._renderer;
  }
  get camera() {
    return this._camera;
  }
  get scene() {
    return this._scene;
  }
  get uniforms() {
    return this._uniforms;
  }
  set wireframe(e) {
    e
      ? ((this._wireframe = !0),
        this._wireframeMaterial ||
          (this._wireframeMaterial = new Oi({ color: 35071, wireframe: !0 })),
        (this._scene.overrideMaterial = this._wireframeMaterial))
      : ((this._wireframe = !1), (this._scene.overrideMaterial = null));
  }
  get wireframe() {
    return this._wireframe;
  }
  get autoOffsetRelativeCenter() {
    return this._autoOffsetRelativeCenter;
  }
  set autoOffsetRelativeCenter(e) {
    this._autoOffsetRelativeCenter = e;
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(e) {
    !!e !== this._freezeUpdate &&
      ((this._freezeUpdate = !!e),
      e ? this.stopRenderLoop() : this.startRenderLoop());
  }
}
class ty {
  constructor() {
    publicField(this, "isFlowEvent", !0);
  }
  execute() {}
}
class iy extends ty {
  constructor(e, t = 0) {
    super(),
      publicField(this, "_currentIndex", 0),
      publicField(this, "_callbacks", []),
      t > e.length - 1 && (t = e.length - 1),
      t < 0 && (t = 0),
      (this._currentIndex = t),
      Array.isArray(e)
        ? (this._callbacks = e)
        : console.warn("callbacks must be an array");
  }
  execute(e) {
    const t = this._callbacks[this._currentIndex];
    t && t(e, this._currentIndex),
      this._currentIndex++,
      this._currentIndex > this._callbacks.length - 1 &&
        (this._currentIndex = 0);
  }
}
const ny = class {
  constructor(e) {
    publicField(this, "_realtimePickEnabled", !1),
      publicField(this, "_mousePickNeedsUpdate", !1),
      publicField(this, "_mouse", new Vector2()),
      publicField(this, "_mousePosition", new Vector2()),
      publicField(this, "_eventMaps", {}),
      publicField(this, "_objectEvents", new Map()),
      publicField(this, "_raycaster", new $l()),
      publicField(this, "_mapPlane", new zn(new Vector3(0, 0, 1), 0)),
      publicField(this, "_tempVector3", new Vector3()),
      publicField(this, "_intersections"),
      publicField(this, "_defaultEventObject"),
      publicField(this, "_mousePickParams", null),
      publicField(this, "_lastMousePickIntersectParams", null),
      publicField(this, "_engine", null),
      publicField(this, "_pickEventNames", null),
      publicField(this, "_checkShouldEnableRealtimePick", () => {
        let e = null;
        for (const t of Object.keys(this._eventMaps))
          if (
            this._pickEventNames[t] &&
            ((e = this._eventMaps[t]), e && e.size > 0)
          )
            return void (this._realtimePickEnabled = !0);
        this._realtimePickEnabled = !1;
      }),
      publicField(this, "_raycast", () => {
        const e = this._engine;
        this._raycaster.setFromCamera(this._mouse, e.camera),
          this._raycaster.mouse.copy(this._mouse);
        const t = this._raycaster.intersectObjects(
          e.rendering.objectsScene.children,
          !0
        );
        this._intersections = t;
      }),
      publicField(this, "get3DTilesObject", (e) => {
        for (; e && !e.is3DTiles; ) e = e.parent;
        return e;
      }),
      publicField(this, "get3DTilesPropertiesByBatchId", (e, t) => {
        let i = e;
        for (; !i.batchTable; ) i = i.parent;
        if (!i) return void console.warn("batch table not found");
        const n = i.batchTable,
          s = {};
        for (const r of Object.keys(n.header)) {
          const e = n.header[r];
          s[r] = e[t];
        }
        return (s._tileUri = i._tileUri), (s.tile = i), s;
      }),
      publicField(this, "triggerFirstEventObject", (e, t) => {
        if (!this._intersections || 0 === this._intersections.length) return !1;
        if (!this._eventMaps[e]) return !1;
        const i = this._eventMaps[e];
        for (let n = 0, s = this._intersections.length; n < s; ++n) {
          const e = this._intersections[n],
            s = e.object;
          if (!s.visible) continue;
          let r = this._getEventProxyObject(s);
          if (!r.visible) continue;
          const a = s.geometry ? s.geometry.getAttribute("_batchid") : void 0;
          let o = !1,
            l = !1,
            h = null;
          if (a) {
            const e = this.get3DTilesObject(s);
            e && ((r = e), (o = !0));
          } else {
            const e = this.get3DTilesObject(s);
            e && ((l = !0), (h = r), (r = e));
          }
          if (i.has(r)) {
            if (
              ((t.object = r),
              e.point && this._correctHitPosition(e.point, t),
              o)
            ) {
              const i = a.getX(e.face.a);
              t.entity = this.get3DTilesPropertiesByBatchId(s, i);
              if (!this.get3DTilesObject(s).isEntityVisible(t.entity)) continue;
            } else
              l
                ? h.isEventEntitySupported &&
                  (t.entity = this._getEventEntity(h, e))
                : r.isEventEntitySupported &&
                  (t.entity = this._getEventEntity(r, e));
            t.directObject = s;
            const n = i.get(r);
            return this._executeCallbacks(n, t), !0;
          }
        }
        return !1;
      }),
      publicField(this, "_getEventEntity", (e, t) => {
        let i = -1;
        return (
          void 0 !== t.instanceId
            ? (i = t.instanceId)
            : void 0 !== t.face && null !== t.face
            ? e.getEntityIndexByFace &&
              (i = e.getEntityIndexByFace(t.faceIndex, t.face.a))
            : void 0 !== t.index && (i = t.index),
          i < 0 ? null : e.getEntityByIndex(i)
        );
      }),
      publicField(this, "_getEventProxyObject", (e) => {
        for (; e.__eventProxyObject || e.__eventProxyByParent; )
          e = e.__eventProxyByParent ? e.parent : e.__eventProxyObject;
        return e;
      }),
      publicField(this, "_correctHitPosition", (e, t) => {
        const i = [e.x, e.y, e.z],
          n = this._engine.map._map.normalizeEarthPointArr(i);
        (n[2] = i[2]), (t.point = n), (t.position = i);
      }),
      publicField(this, "_handlePointerDown", (e) => {
        if (
          (this._updateMouse(e),
          this._raycast(),
          this.triggerFirstEventObject(ny.EVENT_NAME_POINTER_DOWN, e) &&
            (e.event.defaultPrevented ||
              (e.event.domEvent && e.event.domEvent.defaultPrevented)))
        )
          return;
        const t =
          this._eventMaps.pointerdown &&
          this._eventMaps.pointerdown.get(this._defaultEventObject);
        t && this._executeCallbacks(t, e);
      }),
      publicField(this, "_handlePointerUp", (e) => {
        if (
          (this._updateMouse(e),
          this._raycast(),
          this.triggerFirstEventObject(ny.EVENT_NAME_POINTER_UP, e) &&
            (e.event.defaultPrevented ||
              (e.event.domEvent && e.event.domEvent.defaultPrevented)))
        )
          return;
        const t =
          this._eventMaps.pointerup &&
          this._eventMaps.pointerup.get(this._defaultEventObject);
        t && this._executeCallbacks(t, e);
      }),
      publicField(this, "_handleClick", (e) => {
        if (
          (this._updateMouse(e),
          this._raycast(),
          this.triggerFirstEventObject(ny.EVENT_NAME_CLICK, e) &&
            (e.event.defaultPrevented ||
              (e.event.domEvent && e.event.domEvent.defaultPrevented)))
        )
          return;
        const t =
          this._eventMaps.click &&
          this._eventMaps.click.get(this._defaultEventObject);
        t && this._executeCallbacks(t, e);
      }),
      publicField(this, "_handleDblClick", (e) => {
        if (
          (this._updateMouse(e),
          this._raycast(),
          this.triggerFirstEventObject(ny.EVENT_NAME_DOUBLE_CLICK, e) &&
            (e.event.defaultPrevented ||
              (e.event.domEvent && e.event.domEvent.defaultPrevented)))
        )
          return;
        const t =
          this._eventMaps.dblclick &&
          this._eventMaps.dblclick.get(this._defaultEventObject);
        t && this._executeCallbacks(t, e);
      }),
      publicField(this, "_handleRightClick", (e) => {
        if (
          (this._updateMouse(e),
          this._raycast(),
          this.triggerFirstEventObject(ny.EVENT_NAME_RIGHT_CLICK, e) &&
            (e.event.defaultPrevented ||
              (e.event.domEvent && e.event.domEvent.defaultPrevented)))
        )
          return;
        const t =
          this._eventMaps.rightclick &&
          this._eventMaps.rightclick.get(this._defaultEventObject);
        t && this._executeCallbacks(t, e);
      }),
      publicField(this, "_handleRightDblClick", (e) => {
        if (
          (this._updateMouse(e),
          this._raycast(),
          this.triggerFirstEventObject(ny.EVENT_NAME_RIGHT_DOUBLE_CLICK, e) &&
            (e.event.defaultPrevented ||
              (e.event.domEvent && e.event.domEvent.defaultPrevented)))
        )
          return;
        const t =
          this._eventMaps.rightdblclick &&
          this._eventMaps.rightdblclick.get(this._defaultEventObject);
        t && this._executeCallbacks(t, e);
      }),
      publicField(this, "_updateMouse", (e) => {
        const t = this._engine.map.getResolution(),
          i = e.pixel[0] / t.x,
          n = e.pixel[1] / t.y;
        this._mouse.set(2 * i - 1, 1 - 2 * n),
          this._mousePosition.set(e.pixel[0], e.pixel[1]);
      }),
      publicField(this, "_triggerMouseleaveEvent", () => {
        const e = this._lastMousePickIntersectParams,
          t = e.object;
        if (!t) return;
        const i = this._objectEvents.get(t);
        i &&
          i[ny.EVENT_NAME_MOUSE_LEAVE] &&
          this._executeCallbacks(i[ny.EVENT_NAME_MOUSE_LEAVE], {
            ...this._mousePickParams,
            object: e.object,
            entity: e.entity,
          });
      }),
      publicField(this, "_isSameObjectAndEntity", (e, t) => {
        const i = e.object,
          n = t.object,
          s = e.entity,
          r = t.entity;
        return (
          i === n &&
          ((void 0 === s && void 0 === r) ||
            (void 0 !== s &&
              void 0 !== r &&
              (void 0 === s.index || s.index === r.index)))
        );
      }),
      publicField(this, "_getMouseHoverIntersetion", () => {
        if (!this._intersections || 0 === this._intersections.length) return !1;
        const e = this._mousePickParams;
        for (let t = 0, i = this._intersections.length; t < i; ++t) {
          const i = this._intersections[t],
            n = i.object;
          if (!n.visible) continue;
          let s = this._getEventProxyObject(n);
          if (!s.visible) continue;
          const r = n.geometry ? n.geometry.getAttribute("_batchid") : void 0;
          let a = !1;
          if (r) {
            const e = this.get3DTilesObject(n);
            e && ((s = e), (a = !0));
          } else {
            const e = this.get3DTilesObject(n);
            e && (s = e);
          }
          let o = null;
          if (
            (this._objectEvents.has(s) && (o = this._objectEvents.get(s)),
            o &&
              (o[ny.EVENT_NAME_MOUSE_MOVE] ||
                o[ny.EVENT_NAME_MOUSE_ENTER] ||
                o[ny.EVENT_NAME_MOUSE_LEAVE]))
          ) {
            if (
              ((e.object = s),
              i.point && this._correctHitPosition(i.point, e),
              a)
            ) {
              const t = r.getX(i.face.a);
              e.entity = this.get3DTilesPropertiesByBatchId(n, t);
            } else
              s.isEventEntitySupported &&
                (e.entity = this._getEventEntity(s, i));
            return (e.directObject = n), o;
          }
        }
      }),
      (this._engine = e),
      (this._defaultEventObject = {}),
      (this._raycaster.mouse = new Vector2()),
      (this._pickEventNames = {
        [ny.EVENT_NAME_MOUSE_MOVE]: !0,
        [ny.EVENT_NAME_MOUSE_ENTER]: !0,
        [ny.EVENT_NAME_MOUSE_LEAVE]: !0,
      });
  }
  bind(e, t, i) {
    "string" == typeof e && ((i = t), (t = e), (e = this._defaultEventObject)),
      this._eventMaps[t] || (this._eventMaps[t] = new Map());
    const n = this._eventMaps[t];
    n.has(e) || n.set(e, []);
    const s = n.get(e);
    -1 === s.indexOf(i) && s.push(i),
      this._objectEvents.has(e) || this._objectEvents.set(e, {});
    const r = this._objectEvents.get(e);
    r[t] || (r[t] = s), this._checkShouldEnableRealtimePick();
  }
  unbind(e, t, i) {
    "string" == typeof e && ((i = t), (t = e), (e = this._defaultEventObject));
    const n = this._eventMaps[t];
    let s = !1;
    if (n && n.has(e)) {
      const t = n.get(e),
        r = t.indexOf(i);
      r > -1 && t.splice(r, 1), 0 === t.length && (n.delete(e), (s = !0));
    }
    if (s) {
      const i = this._objectEvents.get(e);
      i && delete i[t];
    }
    this._checkShouldEnableRealtimePick();
  }
  markEventProxy(e, t) {
    const i = t || e;
    if (e.children)
      for (let n = 0, s = e.children.length; n < s; n++)
        (e.children[n].__eventProxyObject = i),
          this.markEventProxy(e.children[n]);
  }
  createMultipleToggleEvent(e, t = 0) {
    return new iy(e, t);
  }
  _executeCallbacks(e, t) {
    if (e)
      for (const i of e)
        if (i) {
          if (
            t.event &&
            (t.event.defaultPrevented ||
              (t.event.domEvent && t.event.domEvent.defaultPrevented))
          )
            return;
          i.isFlowEvent ? i.execute(t) : i(t);
        }
  }
  requestMousemoveRaycast(e) {
    if (!this._realtimePickEnabled) return;
    this._updateMouse(e),
      (this._mousePickParams = e),
      (this._mousePickNeedsUpdate = !0);
    const t =
      this._eventMaps.mousemove &&
      this._eventMaps.mousemove.get(this._defaultEventObject);
    if (t) {
      this._raycaster.setFromCamera(this._mouse, this._engine.rendering.camera),
        this._raycaster.ray.intersectPlane(this._mapPlane, this._tempVector3);
      const i = [this._tempVector3.x, this._tempVector3.y, this._tempVector3.z],
        n = this._engine.map._map.normalizeEarthPointArr(i);
      this._executeCallbacks(t, { ...e, point: n, position: i });
    }
    this._engine.requestRender();
  }
  executeMousemoveRaycast() {
    if (!this._mousePickNeedsUpdate) return;
    (this._mousePickNeedsUpdate = !1), this._raycast();
    const e = this._getMouseHoverIntersetion();
    if (e) {
      if (
        (this._executeCallbacks(
          e[ny.EVENT_NAME_MOUSE_MOVE],
          this._mousePickParams
        ),
        this._lastMousePickIntersectParams &&
          this._isSameObjectAndEntity(
            this._mousePickParams,
            this._lastMousePickIntersectParams
          ))
      )
        return void (this._lastMousePickIntersectParams =
          this._mousePickParams);
      this._lastMousePickIntersectParams && this._triggerMouseleaveEvent(),
        this._executeCallbacks(
          e[ny.EVENT_NAME_MOUSE_ENTER],
          this._mousePickParams
        ),
        (this._lastMousePickIntersectParams = this._mousePickParams);
    } else
      this._lastMousePickIntersectParams && this._triggerMouseleaveEvent(),
        (this._lastMousePickIntersectParams = null);
  }
  dispose() {}
};
let sy = ny;
publicField(sy, "EVENT_NAME_CLICK", "click"),
  publicField(sy, "EVENT_NAME_DOUBLE_CLICK", "dblclick"),
  publicField(sy, "EVENT_NAME_RIGHT_CLICK", "rightclick"),
  publicField(sy, "EVENT_NAME_RIGHT_DOUBLE_CLICK", "rightdblclick"),
  publicField(sy, "EVENT_NAME_MOUSE_MOVE", "mousemove"),
  publicField(sy, "EVENT_NAME_MOUSE_ENTER", "mouseenter"),
  publicField(sy, "EVENT_NAME_MOUSE_LEAVE", "mouseleave"),
  publicField(sy, "EVENT_NAME_POINTER_DOWN", "pointerdown"),
  publicField(sy, "EVENT_NAME_POINTER_UP", "pointerup");
class ry {
  init() {}
  parsePointToArr(e) {
    if (!e) return null;
    let t = [];
    if (Array.isArray(e)) for (let i of e) t.push(parseFloat(i));
    else if ("string" == typeof e) {
      const i = e.split(",");
      for (let e = 0; e < i.length; e++) t[e] = parseFloat(i[e]);
    }
    return t;
  }
  projectPointArr(e, t) {}
  projectGeoJSON(e) {
    if (e)
      if ("FeatureCollection" === e.type || e.features) {
        const t = e.features;
        for (const e of t) this.projectGeoJSON(e);
      } else if (Array.isArray(e)) {
        const t = e;
        for (const e of t) this.projectGeoJSON(e);
      } else if (
        ("Feature" === e.type || e.geometry) &&
        Array.isArray(e.geometry.coordinates)
      ) {
        if (e.geometry[this.projectionCoordsName]) return;
        const t = this.projectCoordinates(e.geometry.coordinates);
        e.geometry[this.projectionCoordsName] = t;
      }
  }
  projectCoordinates(e) {
    if (Array.isArray(e[0])) {
      const t = [];
      for (let i of e) t.push(this.projectCoordinates(i));
      return t;
    }
    if ("number" == typeof e[0] || "string" == typeof e[0])
      return this.projectPointArr(e);
  }
  bindCanvas() {
    console.warn("bindCanvas must be implemented in subclass");
  }
  releaseCanvas() {
    console.warn("releaseCanvas must be implemented in subclass");
  }
  dispose() {}
}
const ay = !!window.PointerEvent,
  oy = /ipod|ipad|iphone|android/.test(navigator.userAgent.toLowerCase()),
  ly = (e) => "touch" === e.pointerType,
  hy = (() => {
    let e;
    return (
      (e = ay
        ? {
            DOWN: "pointerdown",
            MOVE: "pointermove",
            UP: "pointerup",
            CANCEL: "pointercancel",
          }
        : oy
        ? {
            DOWN: "touchstart",
            MOVE: "touchmove",
            UP: "touchend",
            CANCEL: "touchcancel",
          }
        : {
            DOWN: "mousedown",
            MOVE: "mousemove",
            UP: "mouseup",
            CANCEL: "mousecancel",
          }),
      e
    );
  })(),
  cy = 0,
  uy = 1,
  dy = 2,
  py = new Vector2(),
  fy = new $l(),
  my = new zn(new Vector3(0, 0, 1), 0);
new Vector3();
const gy = new Vector3(),
  _y = new Vector3(),
  vy = new Vector3(),
  Ay = new Dn();
(Ay.fov = 35), new Vector2();
class yy {
  constructor(e) {
    publicField(this, "map"),
      publicField(this, "currentAction"),
      publicField(this, "startX"),
      publicField(this, "startY"),
      publicField(this, "startCenterX"),
      publicField(this, "startCenterY"),
      publicField(this, "startPitch"),
      publicField(this, "startHeading"),
      publicField(this, "startZoom"),
      publicField(this, "startZoomUnits"),
      publicField(this, "startAtTop"),
      publicField(this, "mapWidth"),
      publicField(this, "mapHeight"),
      publicField(this, "startCamera", new Dn()),
      publicField(this, "startCenter", new Vector3()),
      publicField(this, "startNdc", new Vector2()),
      publicField(this, "startPoint", new Vector3()),
      publicField(this, "startScaleX", 1),
      publicField(this, "startScaleY", 1),
      publicField(this, "startBoundX"),
      publicField(this, "startBoundY"),
      publicField(this, "_enabled", !1),
      publicField(this, "minPitch", 0),
      publicField(this, "maxPitch", 89),
      publicField(this, "zoomSpeed", 0.005),
      publicField(this, "headingSpeed", 0.4),
      publicField(this, "pitchSpeed", 0.3),
      publicField(this, "doubleClickTimer", null),
      publicField(this, "clickInterval", 200),
      publicField(this, "init", () => {
        const e = this.map.domContainer;
        e.addEventListener(hy.DOWN, this.handleMouseDown),
          e.addEventListener("wheel", this.handleWheel),
          e.addEventListener("contextmenu", this.handleContextMenu),
          e.addEventListener(hy.MOVE, this.handleMouseMove);
      }),
      publicField(this, "handleResize", (e) => {
        const [t, i] = this.map.getContainerSize();
        (this.mapWidth = t), (this.mapHeight = i);
        const n = this.map.domContainer.getBoundingClientRect();
        (this.startBoundX = n.left),
          (this.startBoundY = n.top),
          (this.startScaleX = n.width / t),
          (this.startScaleY = n.height / i);
      }),
      publicField(this, "handleMouseMove", (e) => {
        this.currentAction === cy &&
          this.onEventMouseMove &&
          this.onEventMouseMove(e);
      }),
      publicField(this, "handleMouseDown", (e) => {
        let t = this.mapHeight,
          i = this.mapWidth;
        const n = this.map.domContainer.getBoundingClientRect();
        (this.startBoundX = n.left),
          (this.startBoundY = n.top),
          (this.startScaleX = n.width / i),
          (this.startScaleY = n.height / t);
        const s = (e.clientX - this.startBoundX) / this.startScaleX,
          r = (e.clientY - this.startBoundY) / this.startScaleY;
        if (
          (0 === e.button
            ? ((this.startZoomUnits = this.map.getZoomUnitsByZoom(
                this.map.zoom
              )),
              this.setPanStartState(s, r),
              (this.currentAction = uy))
            : 2 === e.button
            ? (this.currentAction = dy)
            : (this.currentAction = cy),
          this.currentAction === cy)
        )
          return;
        (this.startX = s), (this.startY = r);
        const a = this.map;
        (this.startCenterX = a.center[0]),
          (this.startCenterY = a.center[1]),
          (this.startPitch = a.pitch),
          (this.startHeading = a.heading),
          (this.startZoom = a.zoom),
          (this.startAtTop = r < t / 2),
          document.addEventListener(hy.MOVE, this.handleMouseDragging),
          document.addEventListener(hy.UP, this.handleMouseUp);
      }),
      publicField(this, "handleMouseDragging", (e) => {
        if (this.currentAction === cy) return;
        this.hasMoved = !0;
        const t = (this.currentPixelX =
            (e.clientX - this.startBoundX) / this.startScaleX),
          i = (this.currentPixelY =
            (e.clientY - this.startBoundY) / this.startScaleY);
        this.currentAction === uy
          ? this.handlePan(t, i)
          : this.currentAction === dy && this.handleRotate(t, i);
      }),
      publicField(this, "handleMouseUp", (e) => {
        (this.currentAction = cy),
          document.removeEventListener(hy.MOVE, this.handleMouseDragging),
          document.removeEventListener(hy.UP, this.handleMouseUp),
          e && this.onEventClick && (this.hasMoved || this.onEventClick(e)),
          e &&
            this.onEventDblClick &&
            (!this.hasMoved && this.waitSecondClick
              ? (this.onEventDblClick(e), this.clearDoubleClickTimer())
              : (this.waitSecondClick = !0)),
          clearTimeout(this.doubleClickTimer),
          (this.doubleClickTimer = setTimeout(() => {
            this.clearDoubleClickTimer();
          }, this.clickInterval)),
          (this.hasMoved = !1);
      }),
      publicField(this, "clearDoubleClickTimer", () => {
        this.doubleClickTimer && clearTimeout(this.doubleClickTimer),
          (this.waitSecondClick = !1),
          (this.doubleClickTimer = null);
      }),
      publicField(this, "handleContextMenu", (e) => {
        e.preventDefault();
      }),
      publicField(this, "handleWheel", (e) => {
        e.preventDefault(), e.stopPropagation();
        const t = (e.clientX - this.startBoundX) / this.startScaleX,
          i = (e.clientY - this.startBoundY) / this.startScaleY;
        this.handleZoom({
          deltaX: e.deltaX,
          deltaY: e.deltaY,
          pixelX: t,
          pixelY: i,
        });
      }),
      publicField(this, "handlePan", (e, t) => {
        const i = this.map;
        this.getNdc(e, t, py),
          this.ndcToPoint(py, this.startCamera, vy),
          vy.distanceTo(this.startCamera.position) > 6e3 * i.zoomUnits
            ? this.handleMouseUp()
            : (gy.subVectors(this.startCenter, vy.sub(this.startPoint)),
              (i.center = [gy.x, gy.y]),
              i.updateView());
      }),
      publicField(this, "setPanStartState", (e, t) => {
        const i = this.map;
        this.startCamera.copy(i.camera),
          this.startCamera.updateMatrixWorld(),
          this.startCenter.set(i.center[0], i.center[1], 0),
          this.getNdc(e, t, this.startNdc),
          this.ndcToPoint(this.startNdc, i.camera, this.startPoint);
      }),
      publicField(this, "handleRotate", (e, t) => {
        const i = this.map;
        let n = e - this.startX;
        const s = t - this.startY;
        this.startAtTop || (n *= -1);
        let r = this.startHeading + n * this.headingSpeed;
        (r = this.makeHeadingSafe(r)), (i.heading = r);
        let a = this.startPitch + s * this.pitchSpeed;
        (a = this.makePitchSafe(a)), (i.pitch = a), i.updateView();
      }),
      publicField(this, "handleZoom", (e) => {
        const t = this.map;
        let i = t.zoom,
          n = i + e.deltaY * this.zoomSpeed * -1;
        if (i === n) return;
        if (((n = this.makeZoomSafe(n)), n < t.earthViewZoomMax))
          return (this.map.zoom = n), void this.map.updateView();
        let s = t.center,
          r = t.pitch,
          a = t.heading;
        this.getNdc(e.pixelX, e.pixelY, py),
          gy.set(s[0], s[1], 0),
          this.ndcToPoint(py, t.camera, _y),
          _y.distanceTo(t.camera.position) > 6e3 * t.zoomUnits ||
            (t.computeMapCameraMatrix(Ay, s, n, r, a),
            this.ndcToPoint(py, Ay, vy),
            gy.sub(vy.sub(_y)),
            (this.map.center[0] = gy.x),
            (this.map.center[1] = gy.y),
            (this.map.zoom = n),
            this.map.updateView());
      }),
      publicField(this, "makeZoomSafe", (e) =>
        e > this.map.maxZoom
          ? this.map.maxZoom
          : e < this.map.minZoom
          ? this.map.minZoom
          : e
      ),
      publicField(
        this,
        "makeHeadingSafe",
        (e) => ((e %= 360) < 0 && (e += 360), e)
      ),
      publicField(this, "makePitchSafe", (e) =>
        e < this.minPitch
          ? this.minPitch
          : e > this.maxPitch
          ? this.maxPitch
          : e
      ),
      publicField(this, "dispose", () => {
        const e = this.map.domContainer;
        e.removeEventListener(hy.DOWN, this.handleMouseDown),
          e.removeEventListener("wheel", this.handleWheel),
          e.removeEventListener("contextmenu", this.handleContextMenu),
          document.removeEventListener(hy.MOVE, this.handleMouseDragging),
          document.removeEventListener(hy.UP, this.handleMouseUp),
          e.removeEventListener(hy.MOVE, this.handleMouseMove),
          this.clearDoubleClickTimer();
      }),
      (this.map = e),
      (this.enabled = !0),
      (this.currentAction = cy);
  }
  set enabled(e) {
    e !== this._enabled &&
      (e ? this.init() : this.dispose(), (this._enabled = e));
  }
  ndcToPoint(e, t, i) {
    fy.setFromCamera(e, t), fy.ray.intersectPlane(my, i);
  }
  getNdc(e, t, i) {
    (i.x = (e / this.mapWidth) * 2 - 1), (i.y = 1 - (t / this.mapHeight) * 2);
  }
}
var xy = {},
  by = {},
  Ey = {};
!(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = void 0);
  var t = 1;
  e.default = function () {
    return "".concat(t++);
  };
})(Ey);
var Sy = {},
  Cy = {},
  My = {};
!(function (e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), (e.default = void 0);
  e.default = function (e) {
    var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 60,
      i = null;
    return function () {
      for (
        var n = this, s = arguments.length, r = new Array(s), a = 0;
        a < s;
        a++
      )
        r[a] = arguments[a];
      clearTimeout(i),
        (i = setTimeout(function () {
          e.apply(n, r);
        }, t));
    };
  };
})(My);
var wy = {};
Object.defineProperty(wy, "__esModule", { value: !0 }),
  (wy.SensorTabIndex = wy.SensorClassName = wy.SizeSensorId = void 0);
wy.SizeSensorId = "size-sensor-id";
wy.SensorClassName = "size-sensor-object";
(wy.SensorTabIndex = "-1"),
  Object.defineProperty(Cy, "__esModule", { value: !0 }),
  (Cy.createSensor = void 0);
var Ty,
  Iy = (Ty = My) && Ty.__esModule ? Ty : { default: Ty },
  Ry = wy;
Cy.createSensor = function (e) {
  var t = void 0,
    i = [],
    n = (0, Iy.default)(function () {
      i.forEach(function (t) {
        t(e);
      });
    }),
    s = function () {
      t &&
        t.parentNode &&
        (t.contentDocument &&
          t.contentDocument.defaultView.removeEventListener("resize", n),
        t.parentNode.removeChild(t),
        (t = void 0),
        (i = []));
    };
  return {
    element: e,
    bind: function (s) {
      t ||
        (t = (function () {
          "static" === getComputedStyle(e).position &&
            (e.style.position = "relative");
          var t = document.createElement("object");
          return (
            (t.onload = function () {
              t.contentDocument.defaultView.addEventListener("resize", n), n();
            }),
            (t.style.display = "block"),
            (t.style.position = "absolute"),
            (t.style.top = "0"),
            (t.style.left = "0"),
            (t.style.height = "100%"),
            (t.style.width = "100%"),
            (t.style.overflow = "hidden"),
            (t.style.pointerEvents = "none"),
            (t.style.zIndex = "-1"),
            (t.style.opacity = "0"),
            t.setAttribute("class", Ry.SensorClassName),
            t.setAttribute("tabindex", Ry.SensorTabIndex),
            (t.type = "text/html"),
            e.appendChild(t),
            (t.data = "about:blank"),
            t
          );
        })()),
        -1 === i.indexOf(s) && i.push(s);
    },
    destroy: s,
    unbind: function (e) {
      var n = i.indexOf(e);
      -1 !== n && i.splice(n, 1), 0 === i.length && t && s();
    },
  };
};
var Py = {};
Object.defineProperty(Py, "__esModule", { value: !0 }),
  (Py.createSensor = void 0);
var Dy = (function (e) {
  return e && e.__esModule ? e : { default: e };
})(My);
(Py.createSensor = function (e) {
  var t = void 0,
    i = [],
    n = (0, Dy.default)(function () {
      i.forEach(function (t) {
        t(e);
      });
    }),
    s = function () {
      t.disconnect(), (i = []), (t = void 0);
    };
  return {
    element: e,
    bind: function (s) {
      var r;
      t || ((r = new ResizeObserver(n)).observe(e), n(), (t = r)),
        -1 === i.indexOf(s) && i.push(s);
    },
    destroy: s,
    unbind: function (e) {
      var n = i.indexOf(e);
      -1 !== n && i.splice(n, 1), 0 === i.length && t && s();
    },
  };
}),
  Object.defineProperty(Sy, "__esModule", { value: !0 }),
  (Sy.createSensor = void 0);
var Ly = Cy,
  Fy = "undefined" != typeof ResizeObserver ? Py.createSensor : Ly.createSensor;
(Sy.createSensor = Fy),
  Object.defineProperty(by, "__esModule", { value: !0 }),
  (by.removeSensor = by.getSensor = void 0);
var Ny = (function (e) {
    return e && e.__esModule ? e : { default: e };
  })(Ey),
  By = Sy,
  ky = wy;
var Oy = {};
by.getSensor = function (e) {
  var t = e.getAttribute(ky.SizeSensorId);
  if (t && Oy[t]) return Oy[t];
  var i = (0, Ny.default)();
  e.setAttribute(ky.SizeSensorId, i);
  var n = (0, By.createSensor)(e);
  return (Oy[i] = n), n;
};
(by.removeSensor = function (e) {
  var t = e.element.getAttribute(ky.SizeSensorId);
  e.element.removeAttribute(ky.SizeSensorId),
    e.destroy(),
    t && Oy[t] && delete Oy[t];
}),
  Object.defineProperty(xy, "__esModule", { value: !0 }),
  (xy.ver = Gy = xy.clear = zy = xy.bind = void 0);
var Uy = by,
  zy = (xy.bind = function (e, t) {
    var i = (0, Uy.getSensor)(e);
    return (
      i.bind(t),
      function () {
        i.unbind(t);
      }
    );
  }),
  Gy = (xy.clear = function (e) {
    var t = (0, Uy.getSensor)(e);
    (0, Uy.removeSensor)(t);
  });
xy.ver = "1.0.1";
const Vy = new $l(),
  Qy = new zn(new Vector3(0, 0, 1), 0),
  Hy = new Vector3(),
  jy = new Matrix4(),
  Wy = new Vector4();
new Vector2(-1, -1);
const qy = new Vector2(-1, 0.9),
  Xy = new Vector2(1, 0.9),
  Yy = new Vector2(1, -1),
  Ky = new Vector3();
class Zy extends ry {
  constructor(e, t, i = {}) {
    super(t, i),
      publicField(this, "isBlankMap", !0),
      publicField(this, "MERCATOR_LENGTH", 20037508.3427892),
      publicField(this, "projectionCoordsName", "_web_mercator"),
      publicField(this, "origin", [0, 0]),
      publicField(this, "center", [0, 0]),
      publicField(this, "zoom", 0),
      publicField(this, "pitch", 0),
      publicField(this, "heading", 0),
      publicField(this, "bounds", [
        [-this.MERCATOR_LENGTH, -this.MERCATOR_LENGTH],
        [this.MERCATOR_LENGTH, this.MERCATOR_LENGTH],
      ]),
      publicField(this, "near", 100),
      publicField(this, "_far", 38e3),
      publicField(this, "fov", 35),
      publicField(this, "handleViewChange", () => {
        this.onViewChanged && this.onViewChanged();
      }),
      publicField(this, "handleMapResize", () => {
        this.control && this.control.handleResize(this.getResolution()),
          this.onResolutionChanged &&
            this.onResolutionChanged(this.getResolution());
      }),
      publicField(this, "handleEventClick", (e) => {
        const t = this._engine,
          i = t.event,
          n = t.rendering.canvas.getBoundingClientRect(),
          s = e.clientX - n.left,
          r = e.clientY - n.top,
          a = (s / n.width) * 2 - 1,
          o = 1 - (2 * r) / n.height;
        Vy.setFromCamera({ x: a, y: o }, t.rendering.camera),
          Vy.ray.intersectPlane(Qy, Hy);
        const l = [s, r],
          h = [Hy.x, Hy.y, Hy.z],
          c = this.normalizeEarthPointArr(h);
        2 === e.button
          ? i._handleRightClick({ pixel: l, point: c, position: h, event: e })
          : i._handleClick({ pixel: l, point: c, position: h, event: e });
      }),
      publicField(this, "handleEventDblClick", (e) => {
        const t = this._engine,
          i = t.event,
          n = t.rendering.canvas.getBoundingClientRect(),
          s = e.clientX - n.left,
          r = e.clientY - n.top,
          a = (s / n.width) * 2 - 1,
          o = 1 - (2 * r) / n.height;
        Vy.setFromCamera({ x: a, y: o }, t.rendering.camera),
          Vy.ray.intersectPlane(Qy, Hy);
        const l = [s, r],
          h = [Hy.x, Hy.y, Hy.z],
          c = this.normalizeEarthPointArr(h);
        2 === e.button
          ? i._handleRightDblClick({
              pixel: l,
              point: c,
              position: h,
              event: e,
            })
          : i._handleDblClick({ pixel: l, point: c, position: h, event: e });
      }),
      publicField(this, "handleEventPointerDown", (e) => {
        const t = this._engine,
          i = t.event,
          n = t.rendering.canvas.getBoundingClientRect(),
          s = e.clientX - n.left,
          r = e.clientY - n.top,
          a = (s / n.width) * 2 - 1,
          o = 1 - (2 * r) / n.height;
        Vy.setFromCamera({ x: a, y: o }, t.rendering.camera),
          Vy.ray.intersectPlane(Qy, Hy);
        const l = [s, r],
          h = [Hy.x, Hy.y, Hy.z],
          c = this.normalizeEarthPointArr(h);
        i._handlePointerDown({ pixel: l, point: c, position: h, event: e });
      }),
      publicField(this, "handleEventPointerUp", (e) => {
        const t = this._engine,
          i = t.event,
          n = t.rendering.canvas.getBoundingClientRect(),
          s = e.clientX - n.left,
          r = e.clientY - n.top,
          a = (s / n.width) * 2 - 1,
          o = 1 - (2 * r) / n.height;
        Vy.setFromCamera({ x: a, y: o }, t.rendering.camera),
          Vy.ray.intersectPlane(Qy, Hy);
        const l = [s, r],
          h = [Hy.x, Hy.y, Hy.z],
          c = this.normalizeEarthPointArr(h);
        i._handlePointerUp({ pixel: l, point: c, position: h, event: e });
      }),
      publicField(this, "handleEventMouseMove", (e) => {
        this._engine.event.requestMousemoveRaycast({
          pixel: this._getPixelFromEvent(e),
          event: e,
        });
      }),
      publicField(this, "_getPixelFromEvent", (e) => {
        const t = this._engine.rendering.canvas.getBoundingClientRect();
        return [e.clientX - t.left, e.clientY - t.top];
      }),
      (this._engine = e),
      (this.domContainer = t);
  }
  afterInit() {
    (this.camera.matrixAutoUpdate = !1),
      this.bindCanvas(),
      this.handleMapResize(),
      zy(this.domContainer, this.handleMapResize),
      this.initControl();
  }
  initControl() {
    (this.control = new yy(this)),
      (this.control.onEventClick = this.handleEventClick),
      (this.control.onEventDblClick = this.handleEventDblClick),
      (this.control.onEventMouseMove = this.handleEventMouseMove);
  }
  bindCanvas() {
    this.domContainer.appendChild(this.canvas);
  }
  releaseCanvas() {
    this.domContainer.removeChild(this.canvas);
  }
  getContainerSize() {
    return [this.domContainer.clientWidth, this.domContainer.clientHeight];
  }
  getResolution() {
    return new Vector2(
      this.domContainer.clientWidth,
      this.domContainer.clientHeight
    );
  }
  getCenter() {
    return this.normalizeEarthPointArr(this.center);
  }
  getZoom() {
    return this.zoom;
  }
  getPitch() {
    return this.pitch;
  }
  getZoomUnitsByZoom(e) {
    return this.MERCATOR_LENGTH / 128 / Math.pow(2, e);
  }
  getZoomByZoomUnits(e) {
    return Math.log2(this.MERCATOR_LENGTH / 128 / e);
  }
  getZoomUnits() {
    return this.getZoomUnitsByZoom(this.zoom);
  }
  getHeading() {
    return this.heading;
  }
  enableControl() {
    this.control.enabled = !0;
  }
  disableControl() {
    this.control.enabled = !1;
  }
  setCameraMatrix() {
    this.handleViewChange();
  }
  updateCamera() {
    this.computeMapCameraMatrix(
      this.camera,
      this.center,
      this.zoom,
      this.pitch,
      this.heading
    );
  }
  computeMapCameraMatrix(e, t, i, n, s) {
    const [r, a] = this.getContainerSize();
    let o = (this.zoomUnits = this.getZoomUnitsByZoom(i));
    if (r * o > this.bounds[1][0] - this.bounds[0][0]) {
      let e = (this.bounds[1][0] - this.bounds[0][0]) / r;
      (o = this.zoomUnits = e), (this.zoom = this.getZoomByZoomUnits(e));
    }
    if (a * o > this.bounds[1][1] - this.bounds[0][1]) {
      let e = (this.bounds[1][1] - this.bounds[0][1]) / a;
      (o = this.zoomUnits = e), (this.zoom = this.getZoomByZoomUnits(e));
    }
    t[0] - (r / 2) * o < this.bounds[0][0] &&
      (t[0] = this.bounds[0][0] + (r / 2) * o),
      t[0] + (r / 2) * o > this.bounds[1][0] &&
        (t[0] = this.bounds[1][0] - (r / 2) * o),
      t[1] - (a / 2) * o < this.bounds[0][1] &&
        (t[1] = this.bounds[0][1] + (a / 2) * o),
      t[1] + (a / 2) * o > this.bounds[1][1] &&
        (t[1] = this.bounds[1][1] - (a / 2) * o),
      (this.center = t);
    const l = (a / 2 / Math.tan(((this.fov / 2) * Math.PI) / 180)) * o;
    (this.cameraDistance = l),
      e.position.set(0, 0, 0),
      e.quaternion.set(0, 0, 0, 1),
      e.up.set(0, 0, 1),
      e.translateX(t[0]),
      e.translateY(t[1]),
      t[2] && e.translateZ(t[2]),
      e.rotateOnAxis(new Vector3(0, 0, 1), (s * Math.PI) / 180),
      e.rotateOnAxis(new Vector3(1, 0, 0), (n * Math.PI) / 180),
      e.translateZ(l),
      e.updateMatrix(),
      e.updateMatrixWorld(),
      (e.aspect = r / a);
    let h = o;
    h < 1 && (h = 1),
      (e.near = Math.min(Math.max(e.position.z / 1e4, 0.1), 10)),
      (e.far = this._far * h),
      e.updateProjectionMatrix();
  }
  setCenter(e) {
    const t = this.normalizeMapPoint(e);
    t && (this.center = t), this.setCameraMatrix();
  }
  setProjectionCenter(e) {
    const t = this.normalizeEarthPointArr(e);
    this.setCenter(t);
  }
  setZoom(e) {
    isNaN(e) || (this.zoom = e), this.setCameraMatrix();
  }
  zoomIn() {
    this.setZoom(this.zoom + 1);
  }
  zoomOut() {
    this.setZoom(this.zoom - 1);
  }
  setHeading(e) {
    (this.heading = e), this.setCameraMatrix();
  }
  setPitch(e) {
    (this.pitch = e), this.setCameraMatrix();
  }
  setMaxRange(e) {
    console.warn(
      "setMaxRange is only compatible with 3DMap Control,\n            please set options 'map: {is3DControl: true}' when Engine is created"
    );
  }
  lookAt(e, t = {}) {
    let i = [];
    e.isVector3 ? e.toArray(i) : (i = e);
    const n = this.normalizeMapPoint(i);
    n && (this.center = n),
      void 0 !== t.heading && (this.heading = t.heading),
      void 0 !== t.pitch && (this.pitch = t.pitch),
      void 0 !== t.zoom && (this.zoom = t.zoom),
      this.setCameraMatrix();
  }
  setBounds(e) {
    this.bounds = [this.projectPointArr(e[0]), this.projectPointArr(e[1])];
  }
  getBoundsOld() {
    const e = [],
      t = new Vector2(),
      i = ze.mapLinear(
        ze.clamp(Math.abs(90 - this.pitch), 0, 50),
        0,
        50,
        0.1,
        1
      );
    t.set(-1, -1 * i),
      Vy.setFromCamera(t, this.camera),
      Vy.ray.intersectPlane(Qy, Ky);
    const n = Ky.x,
      s = Ky.y;
    t.set(-1, 1 * i),
      Vy.setFromCamera(qy, this.camera),
      Vy.ray.intersectPlane(Qy, Ky);
    const r = Ky.x,
      a = Ky.y;
    t.set(1, 1 * i),
      Vy.setFromCamera(Xy, this.camera),
      Vy.ray.intersectPlane(Qy, Ky);
    const o = Ky.x,
      l = Ky.y;
    t.set(1, -1 * i),
      Vy.setFromCamera(Yy, this.camera),
      Vy.ray.intersectPlane(Qy, Ky);
    const h = Ky.x,
      c = Ky.y;
    (e[0] = Math.min(n, r, o, h)),
      (e[1] = Math.min(s, a, l, c)),
      (e[2] = Math.max(n, r, o, h)),
      (e[3] = Math.max(s, a, l, c));
    const u = this.normalizeEarthPointArr([e[0], e[1]]),
      d = this.normalizeEarthPointArr([e[2], e[3]]);
    return new Box3(new Vector3(u[0], u[1], 0), new Vector3(d[0], d[1], 0));
  }
  getBoundsLarger() {
    const e = this.camera;
    jy.multiplyMatrices(e.matrixWorld, e.projectionMatrixInverse);
    let t = 1 / 0,
      i = 1 / 0,
      n = -1 / 0,
      s = -1 / 0;
    [
      [-1, -1, -1],
      [1, -1, -1],
      [1, 1, -1],
      [-1, 1, -1],
      [-1, -1, 1],
      [1, -1, 1],
      [1, 1, 1],
      [-1, 1, 1],
    ].forEach((e) => {
      Wy.set(e[0], e[1], e[2], 1),
        Wy.applyMatrix4(jy),
        Wy.divideScalar(Wy.w),
        Wy.x < t && (t = Wy.x),
        Wy.x > n && (n = Wy.x),
        Wy.y < i && (i = Wy.y),
        Wy.y > s && (s = Wy.y);
    });
    const r = this.normalizeEarthPointArr([t, i]),
      a = this.normalizeEarthPointArr([n, s]);
    return new Box3(new Vector3(r[0], r[1], 0), new Vector3(a[0], a[1], 0));
  }
  getBounds() {
    Vy.setFromCamera(new Vector2(), this.camera), Vy.ray.intersectPlane(Qy, Hy);
    const e = Hy.clone(),
      t = this.camera.position.distanceTo(Hy),
      i = new Vector3(2 * t, 2 * t),
      n = new Vector3(),
      s = new Vector3();
    return n.subVectors(e, i), s.addVectors(e, i), new Box3(n, s);
  }
  normalizeMapPoint(e) {
    return this.normalizeProjectionPointArr(e);
  }
  normalizeProjectionPointArr(e) {
    let t = this.parsePointToArr(e),
      i = uv(t);
    return (
      (i[0] -= this.origin[0]),
      (i[1] -= this.origin[1]),
      void 0 !== t[2] && (i[2] = t[2]),
      i
    );
  }
  normalizeEarthPointArr(e) {
    let t = this.parsePointToArr(e);
    (t[0] += this.origin[0]), (t[1] += this.origin[1]);
    let i = dv(t);
    return void 0 !== t[2] && (i[2] = t[2]), i;
  }
  projectPointArr(e, t) {
    if (!e) return t;
    let i = null;
    return (
      (i = e[0] > 180 || e[1] > 90 ? [e[0], e[1]] : uv(e)),
      void 0 !== e[2] && (i[2] = e[2]),
      (i[0] -= this.origin[0]),
      (i[1] -= this.origin[1]),
      i
    );
  }
  updateView() {
    this.setCameraMatrix();
  }
  getCameraDistance() {
    return this.cameraDistance;
  }
  getProjectionCenter() {
    return [this.center[0], this.center[1]];
  }
  dispose() {
    this.releaseCanvas(),
      Gy(this.domContainer),
      this._engine.event,
      this.control.dispose(),
      super.dispose();
  }
  get far() {
    return this._far;
  }
  set far(e) {
    this._far = e;
  }
}
publicField(Zy, "EARTH_RADIUS", 637e4);
const Jy = 0,
  $y = 1,
  ex = 2,
  tx = 3,
  ix = 4,
  nx = 0,
  sx = new Vector2(),
  rx = new $l(),
  ax = new zn(new Vector3(0, 0, 1), 0);
new Vector3(), new Vector3(), new Vector3();
const ox = new Vector3(),
  lx = new Dn();
new Dn(), (lx.fov = 35), new Vector2(), (window.v2 = Vector2);
class hx {
  constructor(e) {
    publicField(this, "map"),
      publicField(this, "currentAction"),
      publicField(this, "startX"),
      publicField(this, "startY"),
      publicField(this, "startCenterX"),
      publicField(this, "startCenterY"),
      publicField(this, "startPitch"),
      publicField(this, "startHeading"),
      publicField(this, "startZoom"),
      publicField(this, "startZoomUnits"),
      publicField(this, "startAtTop"),
      publicField(this, "mapWidth"),
      publicField(this, "mapHeight"),
      publicField(this, "startCamera", new Dn()),
      publicField(this, "startCenter", new Vector3()),
      publicField(this, "startNdc", new Vector2()),
      publicField(this, "startPoint", new Vector3()),
      publicField(this, "startScaleX", 1),
      publicField(this, "startScaleY", 1),
      publicField(this, "startBoundX"),
      publicField(this, "startBoundY"),
      publicField(this, "_enabled", !1),
      publicField(this, "minPitch", 0),
      publicField(this, "maxPitch", 89),
      publicField(this, "zoomSpeed", 0.005),
      publicField(this, "headingSpeed", 0.4),
      publicField(this, "pitchSpeed", 0.3),
      publicField(this, "doubleClickTimer", null),
      publicField(this, "clickInterval", 200),
      publicField(this, "_rotationMode", 1),
      publicField(this, "_buttonDown", { LEFT: !1, MIDDLE: !1, RIGHT: !1 }),
      publicField(this, "_primaryStartPosition", new Vector2()),
      publicField(this, "_primaryPosition", new Vector2()),
      publicField(this, "_primaryPreviousPosition", new Vector2()),
      publicField(this, "_positions", new Map()),
      publicField(this, "_previousPositions", new Map()),
      publicField(this, "_isPinching", !1),
      publicField(this, "_isTouchHolding", !1),
      publicField(this, "_lastPinchDist", 0),
      publicField(this, "_lastSeenTouchEvent", -800),
      publicField(this, "_whichKindOfPinch"),
      publicField(this, "_pinchConnectPosition", {
        position1: new Vector2(),
        position2: new Vector2(),
      }),
      publicField(this, "_pinchActionPosition", {
        position1: new Vector2(),
        position2: new Vector2(),
      }),
      publicField(this, "_pinchActionTimer"),
      publicField(this, "_touchHoldTimer"),
      publicField(this, "_clickPixelTolerance", 5),
      publicField(this, "_holdPixelTolerance", 25),
      publicField(this, "init", () => {
        const e = this.map.domContainer;
        e.addEventListener(hy.DOWN, this.handlePointerDown),
          e.addEventListener("wheel", this.handleWheel),
          e.addEventListener("contextmenu", this.handleContextMenu),
          e.addEventListener(hy.MOVE, this.handlePointerMove),
          this.initCursorAnchor();
      }),
      publicField(this, "initCursorAnchor", () => {
        const e = (this.cursorAnchor = document.createElement("div"));
        (e.style.position = "absolute"),
          (e.style.width = "40px"),
          (e.style.height = "40px"),
          (e.style.backgroundColor = "rgba(255, 255, 255, 0.5)"),
          (e.style.zIndex = 100),
          (e.style.pointerEvents = "none"),
          (e.style.display = "none"),
          this.map.domContainer.appendChild(e);
      }),
      publicField(this, "showCursorAnchor", (e, t) => {
        1 !== this._rotationMode &&
          ((this.cursorAnchor.style.left = e - 20 + "px"),
          (this.cursorAnchor.style.top = t - 20 + "px"),
          (this.cursorAnchor.style.display = "block"));
      }),
      publicField(this, "hideCursorAnchor", () => {
        this.cursorAnchor.style.display = "none";
      }),
      publicField(this, "handleResize", (e) => {
        const [t, i] = this.map.getContainerSize();
        (this.mapWidth = t), (this.mapHeight = i);
        const n = this.map.domContainer.getBoundingClientRect();
        (this.startBoundX = n.left),
          (this.startBoundY = n.top),
          (this.startScaleX = n.width / t),
          (this.startScaleY = n.height / i);
      }),
      publicField(this, "fireTouchEvents", (e) => {
        const t = this.map;
        let i = this.mapWidth,
          n = this.mapHeight;
        const s = this._positions,
          r = s.size,
          a = this._isPinching;
        if (1 !== r && this._buttonDown[nx]) {
          if (
            ((this._buttonDown[nx] = !1),
            this._touchHoldTimer &&
              (clearTimeout(this._touchHoldTimer),
              (this._touchHoldTimer = void 0)),
            e && this.onEventPointerUp && this.onEventPointerUp(e),
            0 === r &&
              !this._isTouchHolding &&
              e &&
              this.onEventClick &&
              !this.hasMoved)
          ) {
            cx(
              this._primaryStartPosition,
              Array.from(this._previousPositions.values())[0],
              this._clickPixelTolerance
            ) && this.onEventClick(e);
          }
          (this._isTouchHolding = !1), (this.hasMoved = !1), this.currentAction;
        }
        if (
          (r <= 1 &&
            a &&
            (this._pinchActionTimer &&
              (clearTimeout(this._pinchActionTimer),
              (this._pinchActionTimer = void 0)),
            (this._isPinching = !1),
            (this._whichKindOfPinch = void 0),
            (this._lastPinchDist = 0),
            this.currentAction),
          1 === r && !a)
        ) {
          const r = Array.from(s.values())[0];
          this._primaryPosition.copy(r),
            this._primaryStartPosition.copy(r),
            this._primaryPreviousPosition.copy(r),
            (this._buttonDown[nx] = !0);
          const a = this.map.domContainer.getBoundingClientRect();
          (this.startBoundX = a.left),
            (this.startBoundY = a.top),
            (this.startScaleX = a.width / i),
            (this.startScaleY = a.height / n);
          const o = r.x,
            l = r.y,
            h = new Vector2((o / i) * 2 - 1, 1 - (2 * l) / n),
            c = t._getFirstIntersectionPoint(h);
          this.startCamera.copy(t.camera),
            this.startCamera.updateMatrixWorld(),
            (ax.constant = -c.z),
            this.startPoint.copy(c),
            (this.currentAction = $y),
            e && this.onEventPointerDown && this.onEventPointerDown(e),
            (this.startX = o),
            (this.startY = l),
            (this.startAtTop = l < n / 2),
            document.addEventListener(hy.UP, this.handlePointerUp),
            (this._touchHoldTimer = setTimeout(function () {
              if (
                this._enabled &&
                ((this._touchHoldTimer = void 0),
                (this._isTouchHolding = !0),
                e && this.onEventClick)
              ) {
                cx(
                  this._primaryStartPosition,
                  Array.from(this._previousPositions.values())[0],
                  this._clickPixelTolerance
                ) && this.onEventClick(e);
              }
            }, this.touchHoldDelayMilliseconds)),
            e.preventDefault();
        }
        if (2 === r && !a) {
          const i = Array.from(s.values())[0],
            n = Array.from(s.values())[1];
          this._isPinching = !0;
          const r = t.getProjectionCenter();
          this.startPoint.set(r[0], r[1], r[2]);
          const a = t.decomposeRotation();
          (this.startHeading = a.heading),
            (this.startPitch = a.pitch),
            (this.startDistance = t.camera.position.distanceTo(
              this.startPoint
            ));
          const o = i.x,
            l = i.y;
          this.showCursorAnchor(o, l),
            (this.currentAction = ex),
            (this.startX = n.x),
            (this.startY = n.y),
            (this._lastPinchDist = i.distanceTo(n)),
            this._pinchConnectPosition.position1.copy(i),
            this._pinchConnectPosition.position2.copy(n),
            (this._pinchActionTimer = setTimeout(() => {
              this._enabled &&
                (clearTimeout(this._pinchActionTimer),
                (this._pinchActionTimer = void 0));
            }, 150)),
            e.preventDefault();
        }
      }),
      publicField(this, "fireTouchMoveEvents", (e) => {
        const t = this.map,
          i = this._positions;
        this._previousPositions;
        const n = i.size;
        if (this.currentAction !== Jy) {
          if (((this.hasMoved = !0), this.onMouseDragging)) {
            if (!this.onMouseDragging()) return;
          }
          if (
            ((this.map.domContainer.style.cursor = "grabbing"),
            1 === n && this._buttonDown[nx])
          ) {
            const n = Array.from(i.values())[0],
              s = n.x,
              r = n.y;
            this._primaryPosition.copy(n);
            const a = this._primaryPreviousPosition;
            if (
              (this.getNdc(s, r, sx),
              !this.ndcToPoint(sx, this.startCamera, ox) ||
                ox.distanceTo(t.camera.position) > 0.8 * t.camera.far)
            )
              return void this.handlePointerUp();
            ox.sub(this.startPoint),
              ox.subVectors(this.startCamera.position, ox),
              t.camera.position.copy(ox),
              (t.center = [ox.x, ox.y]),
              e && this.onEventMouseMove && this.onEventMouseMove(e),
              a.copy(n),
              e.preventDefault();
          } else if (2 === n && this._isPinching) {
            const e = t.camera,
              n = Array.from(i.values())[0],
              s = Array.from(i.values())[1];
            if (this._pinchActionTimer)
              return (
                this._pinchActionPosition.position1.copy(n),
                void this._pinchActionPosition.position2.copy(s)
              );
            if (void 0 === this._whichKindOfPinch) {
              const e = new Vector2(),
                t = new Vector2(),
                i = new Vector2();
              e.subVectors(
                this._pinchConnectPosition.position1,
                this._pinchConnectPosition.position2
              ),
                e.normalize(),
                t.subVectors(
                  this._pinchActionPosition.position1,
                  this._pinchConnectPosition.position1
                ),
                t.normalize(),
                i.subVectors(
                  this._pinchActionPosition.position2,
                  this._pinchConnectPosition.position2
                ),
                i.normalize();
              const n = t.dot(i),
                s = e.dot(i);
              n > 0.8
                ? (this._whichKindOfPinch = tx)
                : Math.abs(s) < 0.7
                ? (this._whichKindOfPinch = ex)
                : (this._whichKindOfPinch = ix);
            }
            if (this._whichKindOfPinch === tx) {
              const i = s.y - this.startY;
              let n = this.startPitch + i * this.pitchSpeed;
              if (((n = this.makePitchSafe(n)), 1 === this._rotationMode))
                t._cameraLookAt(e, this.startPoint, {
                  heading: this.startHeading,
                  pitch: n,
                  range: this.startDistance,
                });
              else {
                t._cameraLookAt(lx, this.startPoint, {
                  heading: this.startHeading,
                  pitch: n,
                  range: 0.2,
                }),
                  this.getNdc(this.startX, this.startY, sx),
                  rx.setFromCamera(sx, lx);
                const i = rx.ray.direction.clone();
                sx.set(0, 0), rx.setFromCamera(sx, lx);
                const s = rx.ray.direction.clone();
                i.angleTo(s);
                const r = new Vector3();
                r.copy(i),
                  r.normalize(),
                  r.multiplyScalar(this.startDistance),
                  e.position.copy(ox.copy(this.startPoint).sub(r)),
                  e.quaternion.copy(lx.quaternion);
              }
              t.pitch = n;
            } else if (this._whichKindOfPinch === ix) {
              const i = n.distanceTo(s),
                r = 2 * (this._lastPinchDist - i),
                a = ze.clamp(r * this.zoomSpeed * -1, -0.5, 0.5);
              this.getNdc((n.x + s.x) / 2, (n.y + s.y) / 2, sx);
              const o = t._getFirstIntersectionPoint(sx),
                l = e.position.distanceTo(o);
              if (l > 0.8 * e.far) return;
              let h = a * ze.clamp(l, 0.5, 1e7);
              h + 0.2 > l
                ? ((h = l - 0.2), (t.range = 0.2))
                : (t.range = l - h),
                t.maxRange && t.maxRange < l && a < 0 && (h = 0);
              const c = new Vector3();
              c.subVectors(o, e.position), c.normalize();
              const u = new Vector3();
              u.copy(c).multiplyScalar(h).add(e.position),
                e.position.copy(u),
                (t.center = [u.x, u.y]),
                (this._lastPinchDist = i);
            } else if (this._whichKindOfPinch === ex) {
              const i = new Vector2();
              i.subVectors(
                this._pinchConnectPosition.position2,
                this._pinchConnectPosition.position1
              ),
                i.normalize();
              const r = new Vector2();
              r.subVectors(s, n), r.normalize();
              let a = (function (e, t) {
                  let i = e.x * t.x + e.y * t.y,
                    n = Math.sqrt(e.x * e.x + e.y * e.y),
                    s = Math.sqrt(t.x * t.x + t.y * t.y),
                    r = Math.acos(i / (n * s));
                  e.x * t.y < t.x * e.y && (r = 2 * Math.PI - r);
                  return r;
                })(r, i),
                o = this.startHeading - (a / Math.PI) * 180;
              (o = this.makeHeadingSafe(o)),
                t._cameraLookAt(e, this.startPoint, {
                  heading: o,
                  pitch: this.startPitch,
                  range: this.startDistance,
                });
            }
          }
          this.handleCameraBeforeRender(), this.map.updateView();
        }
      }),
      publicField(this, "handlePointerMove", (e) => {
        if (ly(e)) {
          const t = this._positions,
            i = e.pointerId;
          let n = t.get(i);
          if (!n) return;
          let s = this.getPixelPositon(e);
          n.set(s[0], s[1]), this.fireTouchMoveEvents(e);
          this._previousPositions.get(i).copy(t.get(i));
        } else this.handleMouseMove(e);
      }),
      publicField(this, "handleMouseMove", (e) => {
        this.onEventMouseMove && this.onEventMouseMove(e);
      }),
      publicField(this, "handlePointerDown", (e) => {
        if (ly(e)) {
          const t = e.pointerId;
          let i = this.getPixelPositon(e);
          this._positions.set(t, new Vector2(i[0], i[1])),
            this.fireTouchEvents(e),
            this._previousPositions.set(t, this._positions.get(t).clone());
        } else this.handleMouseDown(e);
      }),
      publicField(this, "handleMouseDown", (e) => {
        const t = this.map;
        let i = this.mapWidth,
          n = this.mapHeight;
        const s = this.map.domContainer.getBoundingClientRect();
        (this.startBoundX = s.left),
          (this.startBoundY = s.top),
          (this.startScaleX = s.width / i),
          (this.startScaleY = s.height / n);
        const [r, a] = this.getPixelPositon(e),
          o = new Vector2((r / i) * 2 - 1, 1 - (2 * a) / n);
        if (0 === e.button) {
          const e = t._getFirstIntersectionPoint(o);
          this.startCamera.copy(t.camera),
            this.startCamera.updateMatrixWorld(),
            (ax.constant = -e.z),
            this.startPoint.copy(e),
            (this.currentAction = $y);
        } else if (2 === e.button) {
          if (1 === this._rotationMode) {
            const e = t.getProjectionCenter();
            this.startPoint.set(e[0], e[1], e[2]);
            const i = t.decomposeRotation();
            (this.startHeading = i.heading), (this.startPitch = i.pitch);
          } else {
            const e = t._getFirstIntersectionPoint(o);
            this.startCamera.copy(t.camera),
              this.startCamera.updateMatrixWorld();
            const i = new Vector3();
            i.subVectors(e, this.startCamera.position),
              i.normalize(),
              this.startPoint.copy(e);
            const n = t.decomposeRotationFromDirection(i);
            (this.startHeading = n.heading), (this.startPitch = n.pitch);
          }
          (this.startDistance = t.camera.position.distanceTo(this.startPoint)),
            (this.currentAction = ex),
            this.showCursorAnchor(r, a);
        } else this.currentAction = Jy;
        this.currentAction !== Jy &&
          (e &&
            this.onEventPointerDown &&
            (this.hasMoved || this.onEventPointerDown(e)),
          (this.startX = r),
          (this.startY = a),
          (this.startAtTop = a < n / 2),
          document.addEventListener(hy.MOVE, this.handleMouseDragging),
          document.addEventListener(hy.UP, this.handleMouseUp));
      }),
      publicField(this, "handleMouseDragging", (e) => {
        if (this.currentAction === Jy) return;
        this.hasMoved = !0;
        const [t, i] = this.getPixelPositon(e);
        if (this.onMouseDragging) {
          if (!this.onMouseDragging()) return;
        }
        this.currentAction === $y
          ? ((this.map.domContainer.style.cursor = "grabbing"),
            this.handlePan(t, i))
          : this.currentAction === ex &&
            ((this.map.domContainer.style.cursor = "grabbing"),
            this.handleRotate(t, i)),
          this.handleCameraBeforeRender(),
          this.map.updateView();
      }),
      publicField(this, "handlePointerUp", (e) => {
        if (ly(e)) {
          const t = e.pointerId;
          this._positions.delete(t),
            this.fireTouchEvents(e),
            this._previousPositions.delete(t);
        } else this.handleMouseDown(e);
      }),
      publicField(this, "handleMouseUp", (e) => {
        (this.currentAction = Jy),
          (this.map.domContainer.style.cursor = "default"),
          this.hideCursorAnchor(),
          document.removeEventListener(hy.MOVE, this.handleMouseDragging),
          document.removeEventListener(hy.UP, this.handleMouseUp),
          e && this.onEventPointerUp && this.onEventPointerUp(e),
          e && this.onEventClick && (this.hasMoved || this.onEventClick(e)),
          e &&
            this.onEventDblClick &&
            (!this.hasMoved && this.waitSecondClick
              ? (this.onEventDblClick(e), this.clearDoubleClickTimer())
              : (this.waitSecondClick = !0)),
          clearTimeout(this.doubleClickTimer),
          (this.doubleClickTimer = setTimeout(() => {
            this.clearDoubleClickTimer();
          }, this.clickInterval)),
          (this.hasMoved = !1);
      }),
      publicField(this, "clearDoubleClickTimer", () => {
        this.doubleClickTimer && clearTimeout(this.doubleClickTimer),
          (this.waitSecondClick = !1),
          (this.doubleClickTimer = null);
      }),
      publicField(this, "handleContextMenu", (e) => {
        e.preventDefault();
      }),
      publicField(this, "handleWheel", (e) => {
        e.preventDefault(), e.stopPropagation();
        const [t, i] = this.getPixelPositon(e);
        this.handleZoom({
          deltaX: e.deltaX,
          deltaY: e.deltaY,
          pixelX: t,
          pixelY: i,
        }),
          this.handleCameraBeforeRender(),
          this.map.updateView();
      }),
      publicField(this, "handlePan", (e, t) => {
        const i = this.map;
        this.getNdc(e, t, sx),
          !this.ndcToPoint(sx, this.startCamera, ox) ||
          ox.distanceTo(i.camera.position) > 0.8 * i.camera.far
            ? this.handleMouseUp()
            : (ox.sub(this.startPoint),
              ox.subVectors(this.startCamera.position, ox),
              i.camera.position.copy(ox),
              (i.center = [ox.x, ox.y]));
      }),
      publicField(this, "handleRotate", (e, t) => {
        const i = this.map,
          n = i.camera;
        let s = e - this.startX;
        const r = t - this.startY;
        this.startAtTop || (s *= -1);
        let a = this.startHeading + s * this.headingSpeed;
        a = this.makeHeadingSafe(a);
        let o = this.startPitch + r * this.pitchSpeed;
        if (((o = this.makePitchSafe(o)), 1 === this._rotationMode))
          i._cameraLookAt(n, this.startPoint, {
            heading: a,
            pitch: o,
            range: this.startDistance,
          });
        else {
          i._cameraLookAt(lx, this.startPoint, {
            heading: a,
            pitch: o,
            range: 0.2,
          }),
            this.getNdc(this.startX, this.startY, sx),
            rx.setFromCamera(sx, lx);
          const e = rx.ray.direction.clone();
          sx.set(0, 0), rx.setFromCamera(sx, lx);
          const t = rx.ray.direction.clone();
          e.angleTo(t);
          const s = new Vector3();
          s.copy(e),
            s.normalize(),
            s.multiplyScalar(this.startDistance),
            n.position.copy(ox.copy(this.startPoint).sub(s)),
            n.quaternion.copy(lx.quaternion);
        }
        (i.pitch = o), (i.heading = a);
      }),
      publicField(this, "handleZoom", (e) => {
        const t = this.map,
          i = t.camera,
          n = ze.clamp(e.deltaY * this.zoomSpeed * -1, -0.5, 0.5);
        this.getNdc(e.pixelX, e.pixelY, sx);
        const s = t._getFirstIntersectionPoint(sx),
          r = i.position.distanceTo(s);
        if (r > 0.8 * i.far) return;
        let a = n * ze.clamp(r, 0.5, 1e7);
        a + 0.2 > r ? ((a = r - 0.2), (t.range = 0.2)) : (t.range = r - a),
          t.maxRange && t.maxRange < r && n < 0 && (a = 0);
        const o = new Vector3();
        o.subVectors(s, i.position), o.normalize();
        const l = new Vector3();
        l.copy(o).multiplyScalar(a).add(i.position),
          i.position.copy(l),
          (t.center = [l.x, l.y]);
      }),
      publicField(
        this,
        "makeHeadingSafe",
        (e) => ((e %= 360) < 0 && (e += 360), e)
      ),
      publicField(this, "makePitchSafe", (e) =>
        e < this.minPitch
          ? this.minPitch
          : e > this.maxPitch
          ? this.maxPitch
          : e
      ),
      publicField(this, "dispose", () => {
        const e = this.map.domContainer;
        e.removeEventListener(hy.DOWN, this.handlePointerDown),
          e.removeEventListener("wheel", this.handleWheel),
          e.removeEventListener("contextmenu", this.handleContextMenu),
          document.removeEventListener(hy.MOVE, this.handleMouseDragging),
          document.removeEventListener(hy.UP, this.handleMouseUp),
          e.removeEventListener(hy.MOVE, this.handlePointerMove),
          this.clearDoubleClickTimer(),
          this.cursorAnchor.remove();
      }),
      (this.map = e),
      (this.enabled = !0),
      (this.currentAction = Jy);
  }
  set enabled(e) {
    e !== this._enabled &&
      (e ? this.init() : this.dispose(), (this._enabled = e));
  }
  handleCameraBeforeRender() {
    this.map.camera.updateMatrix(), this.map.camera.updateMatrixWorld();
    let e = !0;
    this.onEventCameraChange && (e = this.onEventCameraChange()),
      e
        ? ((this.originCamera = this.map.camera.clone()),
          (this.originMap = {
            center: this.map.center,
            pitch: this.map.pitch,
            heading: this.map.heading,
          }))
        : (this.map.camera.copy(this.originCamera, !0),
          this.map._engine.camera.copy(this.originCamera, !0),
          this.map.camera.updateMatrix(),
          this.map.camera.updateMatrixWorld(),
          this.map.camera.updateProjectionMatrix(),
          (this.map.pitch = this.originMap.pitch),
          (this.map.center = this.originMap.center),
          (this.map.heading = this.originMap.heading));
  }
  getPixelPositon(e) {
    let t = e.clientX,
      i = e.clientY;
    ((e) => e.type.includes("touch"))(e) &&
      ((t = e.changedTouches[0].clientX), (i = e.changedTouches[0].clientY));
    return [
      (this.currentPixelX = (t - this.startBoundX) / this.startScaleX),
      (this.currentPixelY = (i - this.startBoundY) / this.startScaleY),
    ];
  }
  ndcToPoint(e, t, i) {
    return (
      rx.setFromCamera(e, t),
      !!rx.ray.intersectsPlane(ax) && (rx.ray.intersectPlane(ax, i), !0)
    );
  }
  getNdc(e, t, i) {
    (i.x = (e / this.mapWidth) * 2 - 1), (i.y = 1 - (t / this.mapHeight) * 2);
  }
}
function cx(e, t, i) {
  const n = e.x - t.x,
    s = e.y - t.y;
  return Math.sqrt(n * n + s * s) < i;
}
const ux = new Vector3(0, 0, -1),
  dx = new Vector3(0, 1, 0),
  px = new $l();
px.mouse = new Vector2();
const fx = new zn(new Vector3(0, 0, 1), 0),
  mx = new Vector3();
new Matrix4();
class gx extends Zy {
  constructor() {
    super(...arguments),
      publicField(this, "isBlankMap3D", !0),
      publicField(this, "_viewStateDirty", !0),
      publicField(this, "maxRange"),
      publicField(this, "range"),
      publicField(this, "bounds", []),
      publicField(this, "handleEventCameraChange", () => {
        const [e, t] = this.bounds;
        if (e && t) {
          const [i, n] = e,
            [s, r] = t,
            [a, o, l] = this.projectPointArr(this.getCenter2D());
          let h = !1;
          return (
            Math.ceil(a) < i && (h = !0),
            Math.ceil(o) < n && (h = !0),
            Math.floor(a) > s && (h = !0),
            Math.floor(o) > r && (h = !0),
            !h
          );
        }
        return !0;
      }),
      publicField(this, "_getFirstIntersectionPoint", (e) => {
        const t = this._engine;
        px.setFromCamera(e, t.camera), px.mouse.copy(e);
        const i = px.intersectObjects(t.rendering.objectsScene.children, !0);
        let n = null;
        for (let s = 0, r = i.length; s < r; s++)
          if (
            !(
              i[s].object.isPoints ||
              i[s].object.isLine ||
              i[s].object.collisionDisabled
            )
          ) {
            n = i[s];
            break;
          }
        return null !== n && n.point
          ? n.point
          : (px.ray.intersectPlane(fx, mx), mx);
      });
  }
  initControl() {
    (this.control = new hx(this)),
      (this.control.onEventPointerDown = this.handleEventPointerDown),
      (this.control.onEventPointerUp = this.handleEventPointerUp),
      (this.control.onEventClick = this.handleEventClick),
      (this.control.onEventDblClick = this.handleEventDblClick),
      (this.control.onEventMouseMove = this.handleEventMouseMove),
      (this.control.onEventCameraChange = this.handleEventCameraChange);
  }
  updateView() {
    this.handleViewChange();
  }
  getCenter() {
    return this.normalizeEarthPointArr(this.getProjectionCenter());
  }
  getProjectionCenter() {
    const e = new Vector2(),
      t = this._getFirstIntersectionPoint(e);
    return [t.x, t.y, t.z];
  }
  getCenter2D() {
    return this.normalizeEarthPointArr(this.getProjectionCenter2D());
  }
  getProjectionCenter2D() {
    return (
      px.setFromCamera(new Vector2(), this.camera),
      px.ray.intersectPlane(fx, mx),
      [mx.x, mx.y, mx.z]
    );
  }
  getPitch() {
    return this.pitch;
  }
  getHeading() {
    return this.heading;
  }
  getCalcRange() {
    const e = this.getProjectionCenter();
    return this.camera.position.distanceTo(mx.set(e[0], e[1], e[2]));
  }
  getZoom() {
    return this.getZoomByZoomUnits(this.getZoomUnits());
  }
  getZoomUnits() {
    const [e, t] = this.getContainerSize();
    return (
      (this.getCameraDistance() * Math.tan(ze.degToRad(this.fov / 2)) * 2) / t
    );
  }
  getCameraDistance() {
    return (
      this.range ||
        (px.setFromCamera(new Vector2(), this.camera),
        px.ray.intersectPlane(fx, mx),
        (this.range = this.camera.position.distanceTo(mx))),
      this.range
    );
  }
  setCenter(e) {
    this.setProjectionCenter(this.normalizeProjectionPointArr(e));
  }
  setProjectionCenter(e) {
    const t = this.decomposeRotation();
    this._cameraLookAt(this.camera, e, {
      ...t,
      height: this.camera.position.z,
    }),
      (this.center = e),
      this.updateView();
  }
  setZoom(e) {
    const t = this.decomposeRotation(),
      i = this.getProjectionCenter(),
      n = this.getZoomUnitsByZoom(e),
      [s, r] = this.getContainerSize(),
      a = ((r / 2) * n) / Math.tan(ze.degToRad(this.fov / 2));
    this._cameraLookAt(this.camera, i, { ...t, range: 0.1 * a, height: a }),
      (this.zoom = e),
      this.updateView();
  }
  setPitch(e) {
    const t = this.decomposeRotation(),
      i = this.getProjectionCenter(),
      n = this.camera.position.distanceTo(mx.set(i[0], i[1], i[2]));
    this._cameraLookAt(this.camera, i, {
      heading: t.heading,
      pitch: e,
      range: n,
    }),
      (this.pitch = e),
      this.updateView();
  }
  setHeading(e) {
    const t = this.decomposeRotation(),
      i = this.getProjectionCenter(),
      n = this.camera.position.distanceTo(mx.set(i[0], i[1], i[2]));
    this._cameraLookAt(this.camera, i, {
      heading: e,
      pitch: t.pitch,
      range: n,
    }),
      (this.heading = e),
      this.updateView();
  }
  setRange(e) {
    const t = this.decomposeRotation(),
      i = this.getProjectionCenter();
    this._cameraLookAt(this.camera, i, { ...t, range: e }),
      (this.range = e),
      this.updateView();
  }
  setMaxRange(e) {
    this.maxRange = e;
  }
  zoomIn() {
    const e = this.decomposeRotation(),
      t = this.getProjectionCenter();
    let i = this.camera.position.distanceTo(mx.set(t[0], t[1], t[2])),
      n = 0.5 * ze.clamp(i, 0.5, 1e7);
    n + 0.2 > i ? ((n = i - 0.2), (i = 0.2)) : (i -= n),
      this._cameraLookAt(this.camera, t, { ...e, range: i }),
      (this.range = i),
      this.updateView();
  }
  zoomOut() {
    const e = this.decomposeRotation(),
      t = this.getProjectionCenter();
    let i = this.camera.position.distanceTo(mx.set(t[0], t[1], t[2])),
      n = -0.5 * ze.clamp(i, 0.5, 1e7);
    n + 0.2 > i ? ((n = i - 0.2), (i = 0.2)) : (i -= n),
      this._cameraLookAt(this.camera, t, { ...e, range: i }),
      (this.range = i),
      this.updateView();
  }
  lookAt(e, t = {}) {
    let i = [];
    e.isVector3 ? e.toArray(i) : (i = e);
    let n = this.normalizeProjectionPointArr(i);
    const { heading: s, pitch: r, range: a } = t;
    isNaN(s) || (this.heading = s),
      isNaN(r) || (this.pitch = r),
      isNaN(a) || (this.range = a),
      this._cameraLookAt(this.camera, n, t);
  }
  _cameraLookAt(e, t, i) {
    const {
        heading: n = this.heading,
        pitch: s = this.pitch,
        range: r,
        height: a,
      } = i,
      o = new Quaternion();
    o.setFromAxisAngle(new Vector3(0, 0, 1), (n * Math.PI) / 180);
    const l = new Quaternion();
    l.setFromAxisAngle(new Vector3(1, 0, 0), (s * Math.PI) / 180);
    const h = new Quaternion();
    h.multiplyQuaternions(o, l);
    const c = new Vector3(0, 0, -1);
    c.applyQuaternion(h), c.negate();
    const u = new Vector3();
    Array.isArray(t) ? u.set(t[0], t[1], t[2] || 0) : t.isVector3 && u.copy(t);
    const d = new Vector3();
    isNaN(r) || (d.copy(c), d.multiplyScalar(r), u.add(d)),
      e.position.copy(u),
      e.quaternion.copy(h),
      e.updateMatrix(),
      e.updateMatrixWorld();
  }
  offsetFromHeadingPitchRange(e = 0, t = 0, i = 0) {
    const n = new Quaternion();
    n.setFromAxisAngle(new Vector3(0, 0, 1), (e * Math.PI) / 180);
    const s = new Quaternion();
    s.setFromAxisAngle(new Vector3(1, 0, 0), (t * Math.PI) / 180);
    const r = new Quaternion();
    r.multiplyQuaternions(n, s);
    const a = new Vector3(0, 0, -1);
    a.applyQuaternion(r), a.negate();
    const o = new Vector3();
    return o.copy(a).multiplyScalar(i), o;
  }
  decomposeRotation() {
    const e = this.camera.quaternion,
      t = ux.clone(),
      i = dx.clone();
    return (
      t.applyQuaternion(e),
      t.clampScalar(-1, 1),
      i.applyQuaternion(e),
      this.decomposeRotationFromDirection(t, i)
    );
  }
  decomposeRotationFromDirection(e, t) {
    const i = 180 - ze.radToDeg(Math.acos(e.z));
    let n = ze.radToDeg(Math.atan2(e.y, e.x));
    return (
      0 === e.x && 0 === e.y && (n = ze.radToDeg(Math.atan2(t.y, t.x))),
      (n = (n - 90) % 360),
      { heading: n, pitch: i }
    );
  }
  setBounds(e) {
    this.bounds = [
      this.projectPointArr(e[0]).map((e) => Math.ceil(e)),
      this.projectPointArr(e[1]).map((e) => Math.ceil(e)),
    ];
  }
  lockDrag(e) {
    this.control.onMouseDragging = e ? () => !1 : null;
  }
  updateCamera() {
    const e = this.camera;
    e.updateMatrix(), e.updateMatrixWorld();
    const [t, i] = this.getContainerSize();
    e.aspect = t / i;
    const n = e.position.z;
    let s = this.pitch + this.fov / 2,
      r = 1e6;
    (r = (n / Math.cos(ze.degToRad(Math.min(s, 89)))) * 1.25),
      (e.near = Math.min(Math.max(n / 1e4, 0.1), 10)),
      r < 2e4 && (r = 2e4),
      (e.far = r),
      e.updateProjectionMatrix();
  }
}
class _x extends gx {
  constructor() {
    super(...arguments),
      publicField(this, "projectionCoordsName", "_bmap_mercator");
  }
  normalizeMapPoint(e) {
    return this.normalizeEarthPointArr(e) || [0, 0];
  }
  normalizeProjectionPointArr(e) {
    const t = this.parsePointToArr(e);
    if (t && t[0] < 180 && t[1] < 90) {
      const e = Tv.convertLL2MC({ lng: t[0], lat: t[1] });
      (t[0] = e.lng), (t[1] = e.lat);
    }
    return t;
  }
  normalizeEarthPointArr(e) {
    const t = this.parsePointToArr(e);
    if (t && (t[0] > 180 || t[1] > 90)) {
      const e = Tv.convertMC2LL({ lng: t[0], lat: t[1] });
      (t[0] = e.lng), (t[1] = e.lat);
    }
    return t;
  }
  projectPointArr(e) {
    let t = [];
    if (e[0] > 180 || e[1] > 90) (t[0] = e[0]), (t[1] = e[1]);
    else {
      const i = Tv.convertLL2MC({ lng: e[0], lat: e[1] });
      (t[0] = i.lng), (t[1] = i.lat);
    }
    return void 0 !== e[2] && (t[2] = e[2]), t;
  }
}
var vx = 0.9996,
  Ax = 0.00669438,
  yx = Math.pow(Ax, 2),
  xx = Math.pow(Ax, 3),
  bx = Ax / (1 - Ax),
  Ex = Math.sqrt(1 - Ax),
  Sx = (1 - Ex) / (1 + Ex),
  Cx = Math.pow(Sx, 2),
  Mx = Math.pow(Sx, 3),
  wx = Math.pow(Sx, 4),
  Tx = Math.pow(Sx, 5),
  Ix = 1 - Ax / 4 - (3 * yx) / 64 - (5 * xx) / 256,
  Rx = (3 * Ax) / 8 + (3 * yx) / 32 + (45 * xx) / 1024,
  Px = (15 * yx) / 256 + (45 * xx) / 1024,
  Dx = (35 * xx) / 3072,
  Lx = 1.5 * Sx - (27 / 32) * Mx + (269 / 512) * Tx,
  Fx = (21 / 16) * Cx - (55 / 32) * wx,
  Nx = (151 / 96) * Mx - (417 / 128) * Tx,
  Bx = (1097 / 512) * wx,
  kx = 6378137;
function Ox(e) {
  return 6 * (e - 1) - 180 + 3;
}
function Ux(e) {
  return (e / Math.PI) * 180;
}
function zx(e) {
  return (e * Math.PI) / 180;
}
class Gx extends gx {
  constructor(e, t, i = {}) {
    super(e, t, i),
      publicField(this, "projectionCoordsName", "_utm"),
      (this.zone = i.utmZone || 50);
  }
  normalizeMapPoint(e) {
    return this.normalizeEarthPointArr(e) || [0, 0];
  }
  normalizeProjectionPointArr(e) {
    const t = this.parsePointToArr(e);
    if (t && t[0] < 180 && t[1] < 90) {
      const e = (function (e, t) {
        const i = e[0],
          n = e[1];
        if (n > 84 || n < -80)
          throw new RangeError(
            "latitude out of range (must be between 80 deg S and 84 deg N)"
          );
        if (i > 180 || i < -180)
          throw new RangeError(
            "longitude out of range (must be between 180 deg W and 180 deg E)"
          );
        var s = zx(n),
          r = Math.sin(s),
          a = Math.cos(s),
          o = Math.tan(s),
          l = Math.pow(o, 2),
          h = Math.pow(o, 4),
          c = zx(i),
          u = zx(Ox(t)),
          d = kx / Math.sqrt(1 - Ax * r * r),
          p = bx * a * a,
          f = a * (c - u),
          m = Math.pow(f, 2),
          g = Math.pow(f, 3),
          _ = Math.pow(f, 4),
          v = Math.pow(f, 5),
          A = Math.pow(f, 6),
          y =
            kx *
            (Ix * s -
              Rx * Math.sin(2 * s) +
              Px * Math.sin(4 * s) -
              Dx * Math.sin(6 * s)),
          x =
            vx *
            (y +
              d *
                o *
                (m / 2 +
                  (_ / 24) * (5 - l + 9 * p + 4 * p * p) +
                  (A / 720) * (61 - 58 * l + h + 600 * p - 330 * bx)));
        return (
          n < 0 && (x += 1e7),
          [
            vx *
              d *
              (f +
                (g / 6) * (1 - l + p) +
                (v / 120) * (5 - 18 * l + h + 72 * p - 58 * bx)) +
              5e5,
            x,
          ]
        );
      })(t, this.zone);
      (t[0] = e[0]), (t[1] = e[1]);
    }
    return t;
  }
  normalizeEarthPointArr(e) {
    const t = this.parsePointToArr(e);
    if (t) {
      const e = (function (e, t, i) {
        let n = e[0],
          s = e[1];
        if (i) {
          if (n < 1e5 || 1e6 <= n)
            throw new RangeError(
              "easting out of range (must be between 100 000 m and 999 999 m)"
            );
          if (s < 0 || s > 1e7)
            throw new RangeError(
              "northing out of range (must be between 0 m and 10 000 000 m)"
            );
        }
        if (t < 1 || t > 60)
          throw new RangeError(
            "zone number out of range (must be between 1 and 60)"
          );
        var r = n - 5e5,
          a = s / vx / (kx * Ix),
          o =
            a +
            Lx * Math.sin(2 * a) +
            Fx * Math.sin(4 * a) +
            Nx * Math.sin(6 * a) +
            Bx * Math.sin(8 * a),
          l = Math.sin(o),
          h = Math.pow(l, 2),
          c = Math.cos(o),
          u = Math.tan(o),
          d = Math.pow(u, 2),
          p = Math.pow(u, 4),
          f = 1 - Ax * h,
          m = Math.sqrt(f),
          g = (1 - Ax) / f,
          _ = Sx * c * c,
          v = _ * _,
          A = r / ((kx / m) * vx),
          y = Math.pow(A, 2),
          x = Math.pow(A, 3),
          b = Math.pow(A, 4),
          E = Math.pow(A, 5),
          S = Math.pow(A, 6),
          C =
            o -
            (u / g) *
              (y / 2 - (b / 24) * (5 + 3 * d + 10 * _ - 4 * v - 9 * bx)) +
            (S / 720) * (61 + 90 * d + 298 * _ + 45 * p - 252 * bx - 3 * v);
        return [
          Ux(
            (A -
              (x / 6) * (1 + 2 * d + _) +
              (E / 120) * (5 - 2 * _ + 28 * d - 3 * v + 8 * bx + 24 * p)) /
              c
          ) + Ox(t),
          Ux(C),
        ];
      })(t, this.zone);
      (t[0] = e[0]), (t[1] = e[1]);
    }
    return t;
  }
  projectPointArr(e) {
    return this.normalizeProjectionPointArr(e);
  }
}
class Vx extends ry {
  constructor(e, t, i) {
    super(t, i),
      publicField(this, "near", 0.1),
      publicField(this, "_far", 4e3),
      publicField(this, "fov", 35),
      publicField(this, "projectionCoordsName", "_bmap_mercator"),
      publicField(this, "handleMapUpdate", () => {
        this.onViewChanged && this.onViewChanged();
      }),
      publicField(this, "handleMapResize", () => {
        this.onResolutionChanged &&
          this.onResolutionChanged(this.getResolution());
      }),
      publicField(this, "handleEventClick", (e) => {
        const t = this._engine.event,
          i = [e.pixel.x, e.pixel.y],
          n = [e.latlng.lng, e.latlng.lat],
          s = [e.point.lng, e.point.lat];
        t._handleClick({ pixel: i, point: n, position: s, event: e });
      }),
      publicField(this, "handleEventRightClick", (e) => {
        const t = this._engine.event,
          i = [e.pixel.x, e.pixel.y],
          n = [e.latlng.lng, e.latlng.lat],
          s = [e.point.lng, e.point.lat];
        t._handleRightClick({ pixel: i, point: n, position: s, event: e });
      }),
      publicField(this, "handleEventDblClick", (e) => {
        const t = this._engine.event,
          i = [e.pixel.x, e.pixel.y],
          n = [e.latlng.lng, e.latlng.lat],
          s = [e.point.lng, e.point.lat];
        t._handleDblClick({ pixel: i, point: n, position: s, event: e });
      }),
      publicField(this, "handleEventRightDblClick", (e) => {
        const t = this._engine.event,
          i = [e.pixel.x, e.pixel.y],
          n = [e.latlng.lng, e.latlng.lat],
          s = [e.point.lng, e.point.lat];
        t._handleRightDblClick({ pixel: i, point: n, position: s, event: e });
      }),
      (this._engine = e),
      (this.map = t);
  }
  getContainerSize() {
    const e = this.map.getSize();
    return [e.width, e.height];
  }
  getResolution() {
    const e = this.map.getSize();
    return new Vector2(e.width, e.height);
  }
  afterInit() {
    const e = this.map;
    (this.canvas.style.zIndex = "3"),
      e.getContainer().appendChild(this.canvas),
      e.addEventListener("update", this.handleMapUpdate),
      e.addEventListener("resize", this.handleMapResize),
      e.addEventListener("click", this.handleEventClick),
      e.addEventListener("rightclick", this.handleEventRightClick),
      e.addEventListener("dblclick", this.handleEventDblClick),
      e.addEventListener("rightdblclick", this.handleEventRightDblClick),
      this.handleMapResize();
  }
  getCenter() {
    const e = this.map.getCenter();
    return [e.lng, e.lat];
  }
  getZoom() {
    return this.map.getZoom();
  }
  getZoomUnits() {
    return this.map.getZoomUnits();
  }
  getZoomByZoomUnits(e) {
    return window.BMAPGL_84
      ? Math.log2(this.MERCATOR_LENGTH / 128 / e)
      : 18 - Math.log2(e);
  }
  getZoomUnitsByZoom(e) {
    return this.map.getZoomUnits(e);
  }
  getHeading() {
    return this.map.getHeading();
  }
  getPitch() {
    return this.map.getTilt();
  }
  setCenter(e) {
    this.map.setCenter(this.normalizeMapPoint(e));
  }
  setProjectionCenter(e) {
    const t = this.normalizeEarthPointArr(e);
    this.setCenter(t);
  }
  setZoom(e) {
    this.map.setZoom(e);
  }
  setPitch(e) {
    this.map.setTilt(e);
  }
  setHeading(e) {
    this.map.setHeading(e);
  }
  setBounds(e) {
    let t = [this.projectPointArr(e[0]), this.projectPointArr(e[1])];
    this.map.setBounds(
      new BMapGL.Point(t[0][0], t[0][1]),
      new BMapGL.Point(t[1][0], t[1][1])
    );
  }
  setMaxRange(e) {
    console.warn(
      "setMaxRange is only compatible with 3DMap Control,\n            please set options 'map: {is3DControl: true}' when Engine is created"
    );
  }
  getBounds() {
    const e = new Vector3(),
      t = new Vector3(),
      i = this.map.getBoundsIn();
    return (
      e.set(i.getMin().lng, i.getMin().lat, 0),
      t.set(i.getMax().lng, i.getMax().lat, 0),
      new Box3(e, t)
    );
  }
  enableControl() {
    this.map.enableDragging();
  }
  disableControl() {
    this.map.disableDragging();
  }
  zoomIn() {
    this.map.zoomIn();
  }
  zoomOut() {
    this.map.zoomOut();
  }
  updateCamera() {
    this.updateMatrixWorld(), this.updateProjectionMatrix();
  }
  updateMatrixWorld() {
    const e = this.map,
      t = this.camera,
      i = e.getCenterIn(),
      n = [i.lng, i.lat],
      s = e.getZoomUnits(),
      r = e.getTilt(),
      a = e.getHeading(),
      [o, l] = this.getContainerSize(),
      h = (l / 2 / Math.tan(((this.fov / 2) * Math.PI) / 180)) * s;
    (this.cameraDistance = h),
      t.position.set(0, 0, 0),
      t.quaternion.set(0, 0, 0, 1),
      t.up.set(0, 1, 0),
      t.translateX(n[0]),
      t.translateY(n[1]),
      t.rotateOnAxis(new Vector3(0, 0, 1), (a * Math.PI) / 180),
      t.rotateOnAxis(new Vector3(1, 0, 0), (r * Math.PI) / 180),
      t.translateZ(h),
      t.updateMatrix(),
      t.updateMatrixWorld();
  }
  updateProjectionMatrix() {
    const e = this.camera,
      [t, i] = this.getContainerSize(),
      n = this.map.getZoomUnits();
    (e.aspect = t / i),
      (e.near = 0.1),
      (e.far = this._far * n),
      e.far < 1e3 && (e.far = 1e3),
      e.updateProjectionMatrix();
  }
  normalizeMapPoint(e) {
    const t = this.normalizeEarthPointArr(e) || [0, 0];
    return new BMapGL.Point(t[0], t[1], t[2]);
  }
  normalizeProjectionPointArr(e) {
    const t = this.parsePointToArr(e);
    return t && t[0] < 180 && t[1] < 90
      ? this.map.lnglatToMercator(t[0], t[1])
      : t;
  }
  normalizeEarthPointArr(e) {
    const t = this.parsePointToArr(e);
    if (t && (t[0] > 180 || t[1] > 90)) {
      const e = this.map.mercatorToLnglat(t[0], t[1]);
      return void 0 !== t[2] && (e[2] = t[2]), e;
    }
    return t;
  }
  projectPointArr(e) {
    let t = [];
    return (
      e[0] > 180 || e[1] > 90
        ? ((t[0] = e[0]), (t[1] = e[1]))
        : (t = this.map.lnglatToMercator(e[0], e[1])),
      void 0 !== e[2] && (t[2] = e[2]),
      t
    );
  }
  getCameraDistance() {
    return this.cameraDistance;
  }
  getProjectionCenter() {
    const e = this.map.getCenterIn();
    return [e.lng, e.lat];
  }
  dispose() {
    const e = this.map;
    e.getContainer().removeChild(this.canvas),
      e.removeEventListener("update", this.handleMapUpdate),
      e.removeEventListener("resize", this.handleMapResize),
      e.removeEventListener("click", this.handleEventClick),
      super.dispose();
  }
  get far() {
    return this._far;
  }
  set far(e) {}
}
class Qx extends ry {
  constructor(e, t, i) {
    super(t, i),
      publicField(this, "MERCATOR_LENGTH", 20037508.3427892),
      publicField(this, "projectionCoordsName", "_web_mercator"),
      publicField(this, "origin", [0, 0]),
      publicField(this, "center", [0, 0]),
      publicField(this, "pitch", 0),
      publicField(this, "heading", 0),
      publicField(this, "near", 0.1),
      publicField(this, "_far", 8e3),
      publicField(this, "fov", 35),
      publicField(this, "cameraDistance", 1e3),
      publicField(this, "handleEventClick", (e) => {
        const t = this._engine.event,
          i = [e.point.x, e.point.y],
          n = [e.lngLat.lng, e.lngLat.lat],
          s = this.normalizeProjectionPointArr(n);
        t._handleClick({
          pixel: i,
          point: n,
          position: s,
          event: e.originalEvent,
        });
      }),
      publicField(this, "handleEventDblClick", (e) => {
        const t = this._engine.event,
          i = [e.point.x, e.point.y],
          n = [e.lngLat.lng, e.lngLat.lat],
          s = this.normalizeProjectionPointArr(n);
        t._handleDblClick({
          pixel: i,
          point: n,
          position: s,
          event: e.originalEvent,
        });
      }),
      publicField(this, "handleEventRightClick", (e) => {
        const t = this._engine.event,
          i = [e.point.x, e.point.y],
          n = [e.lngLat.lng, e.lngLat.lat],
          s = this.normalizeProjectionPointArr(n);
        t._handleRightClick({
          pixel: i,
          point: n,
          position: s,
          event: e.originalEvent,
        });
      }),
      publicField(this, "handleMapResize", () => {
        this.onResolutionChanged &&
          this.onResolutionChanged(this.getResolution());
      }),
      (this._engine = e),
      (this.map = t),
      (this.domContainer = t._container);
  }
  afterInit() {
    (this.canvas.style.pointerEvents = "none"),
      this.domContainer.appendChild(this.canvas);
    const e = this.map;
    e.on("render", (e) => {
      this.onViewChanged && this.onViewChanged();
    }),
      e.on("click", this.handleEventClick),
      e.on("contextmenu", this.handleEventRightClick),
      e.on("dblclick", this.handleEventDblClick),
      e.on("resize", () => {
        this.handleMapResize();
      }),
      this.handleMapResize();
  }
  getContainerSize() {
    return [this.domContainer.clientWidth, this.domContainer.clientHeight];
  }
  getResolution() {
    return new Vector2(
      this.domContainer.clientWidth,
      this.domContainer.clientHeight
    );
  }
  setCenter(e) {
    this.map.setCenter(e);
  }
  setZoom(e) {
    this.map.setZoom(e);
  }
  setHeading(e) {
    this.map.setBearing(e);
  }
  setPitch(e) {
    this.map.setPitch(e);
  }
  getCenter() {
    const e = this.map.getCenter();
    return [e.lng, e.lat];
  }
  getZoom() {
    return this.map.getZoom();
  }
  getZoomUnitsByZoom(e) {
    return this.MERCATOR_LENGTH / 256 / Math.pow(2, e);
  }
  getZoomByZoomUnits(e) {
    return Math.log2(this.MERCATOR_LENGTH / 256 / e);
  }
  getZoomUnits() {
    return this.getZoomUnitsByZoom(this.map.getZoom());
  }
  getPitch() {
    return this.map.getPitch();
  }
  getHeading() {
    return this.map.getBearing();
  }
  enableControl() {
    this.map.dragPan.enable(), this.map.dragRotate.enable();
  }
  disableControl() {
    this.map.dragPan.disable(), this.map.dragRotate.disable();
  }
  zoomIn() {
    this.setZoom(this.getZoom() + 1);
  }
  zoomOut() {
    this.setZoom(this.getZoom() - 1);
  }
  flyTo(e) {}
  updateCamera() {
    this.updateMatrixWorld(), this.updateProjectionMatrix();
  }
  updateMatrixWorld() {
    this.map;
    const e = this.camera,
      t = this.getCenter(),
      i = this.getZoomUnits(),
      n = this.getPitch(),
      s = this.getHeading(),
      [r, a] = this.getContainerSize(),
      o = this.normalizeProjectionPointArr(t),
      l = (a / 2 / Math.tan(((this.fov / 2) * Math.PI) / 180)) * i;
    (this.cameraDistance = l),
      e.position.set(0, 0, 0),
      e.quaternion.set(0, 0, 0, 1),
      e.up.set(0, 1, 0),
      e.translateX(o[0]),
      e.translateY(o[1]),
      e.rotateOnAxis(new Vector3(0, 0, -1), (s * Math.PI) / 180),
      e.rotateOnAxis(new Vector3(1, 0, 0), (n * Math.PI) / 180),
      e.translateZ(l),
      e.updateMatrix();
  }
  updateProjectionMatrix() {
    const e = this.camera,
      t = this.getZoomUnits(),
      [i, n] = this.getContainerSize();
    (e.aspect = i / n),
      (e.fov = this.fov),
      (e.near = this.near * t),
      (e.far = this._far * t),
      e.updateProjectionMatrix();
  }
  normalizeMapPoint(e) {
    return this.normalizeEarthPointArr(e);
  }
  normalizeProjectionPointArr(e) {
    let t = this.parsePointToArr(e);
    return (t = uv(t)), (t[0] -= this.origin[0]), (t[1] -= this.origin[1]), t;
  }
  normalizeEarthPointArr(e) {
    let t = this.parsePointToArr(e);
    (t[0] += this.origin[0]), (t[1] += this.origin[1]);
    let i = dv(t);
    return void 0 !== t[2] && (i[2] = t[2]), i;
  }
  projectPointArr(e, t) {
    if (!e) return t;
    let i = null;
    return (
      (i = e[0] > 180 || e[1] > 90 ? [e[0], e[1]] : uv(e)),
      void 0 !== e[2] && (i[2] = e[2]),
      (i[0] -= this.origin[0]),
      (i[1] -= this.origin[1]),
      i
    );
  }
  dispose() {
    this.domContainer.removeChild(this.canvas),
      this._engine.event,
      super.dispose();
  }
  getProjectionCenter() {
    const e = this.map.getCenter();
    return this.normalizeProjectionPointArr(e);
  }
  getCameraDistance() {
    return this.cameraDistance;
  }
  get far() {
    return this._far;
  }
  set far(e) {}
}
publicField(Qx, "EARTH_RADIUS", 637e4);
class Hx {
  constructor(e, t = {}) {
    publicField(this, "_engine"),
      publicField(this, "_map"),
      publicField(this, "_container"),
      publicField(this, "_mapType"),
      publicField(this, "handleViewChange", () => {
        this._engine.rendering.requestRender();
      }),
      publicField(this, "handleResolutionChange", (e) => {
        this._engine.rendering.setResolution(e);
      }),
      (this._engine = e);
    const i = e.container,
      n = t.coordType;
    if (
      (i instanceof HTMLElement
        ? "ecef" === n ||
          ("bd09" === n
            ? ((this._map = new _x(e, i, t)),
              (this._container = i),
              (this._mapType = "blank_bd09"))
            : "utm" === n
            ? ((this._map = new Gx(e, i, t)),
              (this._container = i),
              (this._mapType = "blank_utm"))
            : t.is3DControl
            ? ((this._map = new gx(e, i, t)),
              (this._container = i),
              (this._mapType = "blank_3dcontrol"))
            : ((this._map = new Zy(e, i, t)),
              (this._container = i),
              (this._mapType = "blank")))
        : window.BMapGL && i instanceof BMapGL.Map
        ? ((this._map = new Vx(e, i, t)),
          (this._container = i.container),
          (this._mapType = "bmapgl"))
        : i._mapId &&
          ((this._map = new Qx(e, i, t)),
          (this._container = i._container),
          (this._mapType = "mapbox")),
      !this._map)
    )
      throw new Error("map is invalid");
  }
  init() {
    this._map.init(),
      (this._map.onViewChanged = this.handleViewChange),
      (this._map.onResolutionChanged = this.handleResolutionChange);
  }
  afterInit() {
    const e = this._engine,
      n = this._map;
    (n.canvas = e.rendering.canvas),
      (n.camera = e.rendering.camera),
      i(this._container, `${t}-container`),
      n.afterInit();
  }
  setCenter(e) {
    this._map.setCenter(e);
  }
  setZoom(e) {
    this._map.setZoom(e);
  }
  setHeading(e) {
    this._map.setHeading(e);
  }
  setPitch(e) {
    this._map.setPitch(e);
  }
  setBounds(e) {
    this._map.setBounds(e);
  }
  lockDrag(e) {
    this._map.lockDrag(e);
  }
  setMaxRange(e) {
    this._map.setMaxRange(e);
  }
  lookAt(e, t = {}) {
    this._map.lookAt(e, t);
  }
  getBoundingBox() {
    return this._map.getBounds();
  }
  getCenter() {
    return this._map.getCenter();
  }
  getCenter2D() {
    return this._map.getCenter2D
      ? this._map.getCenter2D()
      : this._map.getCenter();
  }
  getZoom() {
    return this._map.getZoom();
  }
  getZoomUnits() {
    return this._map.getZoomUnits();
  }
  getZoomByZoomUnits(e) {
    return this._map.getZoomByZoomUnits(e);
  }
  getZoomUnitsByZoom(e) {
    return this._map.getZoomUnitsByZoom(e);
  }
  getHeading() {
    return this._map.getHeading();
  }
  getPitch() {
    return this._map.getPitch();
  }
  getProjectionCenter() {
    return this._map.getProjectionCenter();
  }
  getProjectionCenter2D() {
    return this._map.getProjectionCenter2D
      ? this._map.getProjectionCenter2D()
      : this._map.getProjectionCenter();
  }
  getCameraDistance() {
    return this._map.getCameraDistance();
  }
  getResolution() {
    return this._map.getResolution();
  }
  projectPointArr(e) {
    return this._map.projectPointArr(e);
  }
  unprojectPointArr(e) {
    return this._map.normalizeEarthPointArr(e);
  }
  projectCoordinates(e) {
    return this._map.projectCoordinates(e);
  }
  enableControl() {
    this._map.enableControl();
  }
  disableControl() {
    this._map.disableControl();
  }
  updateCamera() {
    this._map.updateCamera();
  }
  getScaleAt(e) {
    return 1 / Math.cos((Math.PI * e[1]) / 180);
  }
  zoomIn() {
    this._map.zoomIn();
  }
  zoomOut() {
    this._map.zoomOut();
  }
  zoomTo(e, t = { range: 0, zoom: 0 }) {
    let i = null;
    if (e.is3DTiles) i = e.getBounds();
    else if (e.isInstancedMesh)
      e.computeBoundingBox(),
        (i = e.boundingBox),
        (i = i.clone()),
        i.applyMatrix4(e.matrixWorld);
    else if (e.isMesh) {
      const t = e.geometry;
      (i = t.boundingBox),
        i || (t.computeBoundingBox(), (i = t.boundingBox)),
        (i = i.clone()),
        i.applyMatrix4(e.matrixWorld);
    } else
      e.boundingBox &&
        ((i = e.boundingBox), (i = i.clone()), i.applyMatrix4(e.matrixWorld));
    if (!i) return;
    const n = this.getResolution(),
      s = (i.max.x - i.min.x) / n.x,
      r = (i.max.y - i.min.y) / n.y,
      a = Math.max(s, r),
      o = this._map.getZoomByZoomUnits(a),
      l = [
        (i.max.x + i.min.x) / 2,
        (i.max.y + i.min.y) / 2,
        (i.max.z + i.min.z) / 2,
      ];
    if (this._map.isBlankMap3D) {
      let e =
        Math.max(i.max.x - i.min.x, i.max.y - i.min.y) /
        Math.tan(((this.fov / 2) * Math.PI) / 180);
      this._map._cameraLookAt(this._map.camera, l, { range: e + t.range }),
        (this._map.range = e + t.range);
    } else this._map.setProjectionCenter(l), this._map.setZoom(o + t.zoom);
    this._engine.requestRender();
  }
  bindCanvas() {
    this._map.bindCanvas();
  }
  releaseCanvas() {
    this._map.releaseCanvas();
  }
  dispose() {
    this._map.dispose();
  }
  set onResolutionChanged(e) {
    this._map.onResolutionChanged = e;
  }
  get projectionCoordsName() {
    return this._map.projectionCoordsName;
  }
  get map() {
    return this._map;
  }
  get mapType() {
    return this._mapType;
  }
  get container() {
    return this._container;
  }
  get fov() {
    return this._map.fov;
  }
  get near() {
    return this._map.near;
  }
  get far() {
    return this._map.far;
  }
}
class jx extends Object3D {
  constructor() {
    super(),
      publicField(this, "_boxGeometry"),
      publicField(this, "_boxMesh"),
      (this._boxMaterial = new Oi({
        transparent: !0,
        color: 16711680,
        opacity: 0.3,
      }));
  }
  attach(e) {
    this._object = e;
    const t = e.geometry;
    t.boundingBox || t.computeBoundingBox(),
      this._boxGeometry && this._boxGeometry.dispose();
    const i = t.boundingBox;
    if (
      ((this._boxGeometry = new Cn(
        i.max.x - i.min.x,
        i.max.y - i.min.y,
        i.max.z - i.min.z
      )),
      this._boxMesh)
    )
      this._boxMesh.geometry = this._boxGeometry;
    else {
      const e = (this._boxMesh = new En(this._boxGeometry, this._boxMaterial));
      this.add(e);
    }
  }
  detach() {
    (this._object = null), this.remove(this._boxMesh), (this._boxMesh = null);
  }
  onBeforeScenePrepareRender() {
    if (this._object) {
      this._object.updateMatrixWorld();
      const e = this._boxMesh;
      this._object.matrixWorld.decompose(e.position, e.rotation, e.scale);
    }
  }
}
const Wx = new $l(),
  qx = new Vector3(),
  Xx = new Vector3(),
  Yx = new Quaternion(),
  Kx = {
    X: new Vector3(1, 0, 0),
    Y: new Vector3(0, 1, 0),
    Z: new Vector3(0, 0, 1),
  },
  Zx = { type: "change" },
  Jx = { type: "pointerdown" },
  $x = { type: "pointerup", mode: null },
  eb = { type: "pointermove", mode: null },
  tb = { type: "objectChange" };
class ib extends Object3D {
  constructor(e, t) {
    super(),
      publicField(this, "_cameraScale"),
      publicField(this, "_endNorm"),
      publicField(this, "_gizmo"),
      publicField(this, "_getPointer"),
      publicField(this, "_onPointerDown"),
      publicField(this, "_onPointerHover"),
      publicField(this, "_onPointerMove"),
      publicField(this, "_onPointerUp"),
      publicField(this, "_parentPosition"),
      publicField(this, "_parentQuaternion"),
      publicField(this, "_parentQuaternionInv"),
      publicField(this, "_parentScale"),
      publicField(this, "_plane"),
      publicField(this, "_positionStart"),
      publicField(this, "_quaternionStart"),
      publicField(this, "_scaleStart"),
      publicField(this, "_startNorm"),
      publicField(this, "_worldQuaternionInv"),
      publicField(this, "_worldScale"),
      publicField(this, "_worldScaleStart"),
      publicField(this, "_offset"),
      publicField(this, "isTransformControls"),
      void 0 === t &&
        (console.warn(
          'THREE.TransformControls: The second parameter "domElement" is now mandatory.'
        ),
        (t = document)),
      (this.visible = !1),
      (this.domElement = t),
      (this.domElement.style.touchAction = "none");
    const i = new Eb();
    (this._gizmo = i), this.add(i);
    const n = new Sb();
    (this._plane = n), this.add(n);
    const s = this;
    function r(e, t) {
      let r = t;
      Object.defineProperty(s, e, {
        get: function () {
          return void 0 !== r ? r : t;
        },
        set: function (t) {
          r !== t &&
            ((r = t),
            (n[e] = t),
            (i[e] = t),
            s.dispatchEvent({ type: e + "-changed", value: t }),
            s.dispatchEvent(Zx));
        },
      }),
        (s[e] = t),
        (n[e] = t),
        (i[e] = t);
    }
    r("camera", e),
      r("object", void 0),
      r("enabled", !0),
      r("axis", null),
      r("mode", "translate"),
      r("translationSnap", null),
      r("rotationSnap", null),
      r("scaleSnap", null),
      r("space", "local"),
      r("size", 0.7),
      r("dragging", !1),
      r("showX", !0),
      r("showY", !0),
      r("showZ", !0);
    const a = new Vector3(),
      o = new Vector3(),
      l = new Quaternion(),
      h = new Quaternion(),
      c = new Vector3(),
      u = new Quaternion(),
      d = new Vector3(),
      p = new Vector3(),
      f = new Vector3(),
      m = new Vector3();
    r("worldPosition", a),
      r("worldPositionStart", o),
      r("worldQuaternion", l),
      r("worldQuaternionStart", h),
      r("cameraPosition", c),
      r("cameraQuaternion", u),
      r("pointStart", d),
      r("pointEnd", p),
      r("rotationAxis", f),
      r("rotationAngle", 0),
      r("eye", m),
      (this._offset = new Vector3()),
      (this._startNorm = new Vector3()),
      (this._endNorm = new Vector3()),
      (this._cameraScale = new Vector3()),
      (this._parentPosition = new Vector3()),
      (this._parentQuaternion = new Quaternion()),
      (this._parentQuaternionInv = new Quaternion()),
      (this._parentScale = new Vector3()),
      (this._worldScaleStart = new Vector3()),
      (this._worldQuaternionInv = new Quaternion()),
      (this._worldScale = new Vector3()),
      (this._positionStart = new Vector3()),
      (this._quaternionStart = new Quaternion()),
      (this._scaleStart = new Vector3()),
      (this._getPointer = nb.bind(this)),
      (this._onPointerDown = rb.bind(this)),
      (this._onPointerHover = sb.bind(this)),
      (this._onPointerMove = ab.bind(this)),
      (this._onPointerUp = ob.bind(this)),
      this.domElement.addEventListener("pointerdown", this._onPointerDown),
      this.domElement.addEventListener("pointermove", this._onPointerHover),
      this.domElement.addEventListener("pointerup", this._onPointerUp);
  }
  updateMatrixWorld() {
    void 0 !== this.object &&
      (this.object.updateMatrixWorld(),
      null === this.object.parent
        ? console.error(
            "TransformControls: The attached 3D object must be a part of the scene graph."
          )
        : this.object.parent.matrixWorld.decompose(
            this._parentPosition,
            this._parentQuaternion,
            this._parentScale
          ),
      this.object.matrixWorld.decompose(
        this.worldPosition,
        this.worldQuaternion,
        this._worldScale
      ),
      this._parentQuaternionInv.copy(this._parentQuaternion).invert(),
      this._worldQuaternionInv.copy(this.worldQuaternion).invert()),
      this.camera.updateMatrixWorld(),
      this.camera.matrixWorld.decompose(
        this.cameraPosition,
        this.cameraQuaternion,
        this._cameraScale
      ),
      this.eye.copy(this.cameraPosition).sub(this.worldPosition).normalize(),
      super.updateMatrixWorld(this);
  }
  pointerHover(e) {
    if (void 0 === this.object || !0 === this.dragging) return;
    Wx.setFromCamera(e, this.camera);
    const t = lb(this._gizmo.picker[this.mode], Wx);
    this.axis = t ? t.object.name : null;
  }
  pointerDown(e) {
    if (
      void 0 !== this.object &&
      !0 !== this.dragging &&
      0 === e.button &&
      null !== this.axis
    ) {
      Wx.setFromCamera(e, this.camera);
      const t = lb(this._plane, Wx, !0);
      t &&
        (this.object.updateMatrixWorld(),
        this.object.parent.updateMatrixWorld(),
        this._positionStart.copy(this.object.position),
        this._quaternionStart.copy(this.object.quaternion),
        this._scaleStart.copy(this.object.scale),
        this.object.matrixWorld.decompose(
          this.worldPositionStart,
          this.worldQuaternionStart,
          this._worldScaleStart
        ),
        this.pointStart.copy(t.point).sub(this.worldPositionStart)),
        (this.dragging = !0),
        (Jx.mode = this.mode),
        this.dispatchEvent(Jx);
    }
  }
  pointerMove(e) {
    const t = this.axis,
      i = this.mode,
      n = this.object;
    let s = this.space;
    if (
      ("scale" === i
        ? (s = "local")
        : ("E" !== t && "XYZE" !== t && "XYZ" !== t) || (s = "world"),
      void 0 === n || null === t || !1 === this.dragging || -1 !== e.button)
    )
      return;
    Wx.setFromCamera(e, this.camera);
    const r = lb(this._plane, Wx, !0);
    if (r) {
      if (
        (this.pointEnd.copy(r.point).sub(this.worldPositionStart),
        "translate" === i)
      )
        this._offset.copy(this.pointEnd).sub(this.pointStart),
          "local" === s &&
            "XYZ" !== t &&
            this._offset.applyQuaternion(this._worldQuaternionInv),
          -1 === t.indexOf("X") && (this._offset.x = 0),
          -1 === t.indexOf("Y") && (this._offset.y = 0),
          -1 === t.indexOf("Z") && (this._offset.z = 0),
          "local" === s && "XYZ" !== t
            ? this._offset
                .applyQuaternion(this._quaternionStart)
                .divide(this._parentScale)
            : this._offset
                .applyQuaternion(this._parentQuaternionInv)
                .divide(this._parentScale),
          n.position.copy(this._offset).add(this._positionStart),
          this.translationSnap &&
            ("local" === s &&
              (n.position.applyQuaternion(
                Yx.copy(this._quaternionStart).invert()
              ),
              -1 !== t.search("X") &&
                (n.position.x =
                  Math.round(n.position.x / this.translationSnap) *
                  this.translationSnap),
              -1 !== t.search("Y") &&
                (n.position.y =
                  Math.round(n.position.y / this.translationSnap) *
                  this.translationSnap),
              -1 !== t.search("Z") &&
                (n.position.z =
                  Math.round(n.position.z / this.translationSnap) *
                  this.translationSnap),
              n.position.applyQuaternion(this._quaternionStart)),
            "world" === s &&
              (n.parent &&
                n.position.add(qx.setFromMatrixPosition(n.parent.matrixWorld)),
              -1 !== t.search("X") &&
                (n.position.x =
                  Math.round(n.position.x / this.translationSnap) *
                  this.translationSnap),
              -1 !== t.search("Y") &&
                (n.position.y =
                  Math.round(n.position.y / this.translationSnap) *
                  this.translationSnap),
              -1 !== t.search("Z") &&
                (n.position.z =
                  Math.round(n.position.z / this.translationSnap) *
                  this.translationSnap),
              n.parent &&
                n.position.sub(
                  qx.setFromMatrixPosition(n.parent.matrixWorld)
                )));
      else if ("scale" === i) {
        if (-1 !== t.search("XYZ")) {
          let e = this.pointEnd.length() / this.pointStart.length();
          this.pointEnd.dot(this.pointStart) < 0 && (e *= -1), Xx.set(e, e, e);
        } else
          qx.copy(this.pointStart),
            Xx.copy(this.pointEnd),
            qx.applyQuaternion(this._worldQuaternionInv),
            Xx.applyQuaternion(this._worldQuaternionInv),
            Xx.divide(qx),
            -1 === t.search("X") && (Xx.x = 1),
            -1 === t.search("Y") && (Xx.y = 1),
            -1 === t.search("Z") && (Xx.z = 1);
        n.scale.copy(this._scaleStart).multiply(Xx),
          this.scaleSnap &&
            (-1 !== t.search("X") &&
              (n.scale.x =
                Math.round(n.scale.x / this.scaleSnap) * this.scaleSnap ||
                this.scaleSnap),
            -1 !== t.search("Y") &&
              (n.scale.y =
                Math.round(n.scale.y / this.scaleSnap) * this.scaleSnap ||
                this.scaleSnap),
            -1 !== t.search("Z") &&
              (n.scale.z =
                Math.round(n.scale.z / this.scaleSnap) * this.scaleSnap ||
                this.scaleSnap));
      } else if ("rotate" === i) {
        this._offset.copy(this.pointEnd).sub(this.pointStart);
        const e =
          20 /
          this.worldPosition.distanceTo(
            qx.setFromMatrixPosition(this.camera.matrixWorld)
          );
        "E" === t
          ? (this.rotationAxis.copy(this.eye),
            (this.rotationAngle = this.pointEnd.angleTo(this.pointStart)),
            this._startNorm.copy(this.pointStart).normalize(),
            this._endNorm.copy(this.pointEnd).normalize(),
            (this.rotationAngle *=
              this._endNorm.cross(this._startNorm).dot(this.eye) < 0 ? 1 : -1))
          : "XYZE" === t
          ? (this.rotationAxis.copy(this._offset).cross(this.eye).normalize(),
            (this.rotationAngle =
              this._offset.dot(qx.copy(this.rotationAxis).cross(this.eye)) * e))
          : ("X" !== t && "Y" !== t && "Z" !== t) ||
            (this.rotationAxis.copy(Kx[t]),
            qx.copy(Kx[t]),
            "local" === s && qx.applyQuaternion(this.worldQuaternion),
            (this.rotationAngle =
              this._offset.dot(qx.cross(this.eye).normalize()) * e)),
          this.rotationSnap &&
            (this.rotationAngle =
              Math.round(this.rotationAngle / this.rotationSnap) *
              this.rotationSnap),
          "local" === s && "E" !== t && "XYZE" !== t
            ? (n.quaternion.copy(this._quaternionStart),
              n.quaternion
                .multiply(
                  Yx.setFromAxisAngle(this.rotationAxis, this.rotationAngle)
                )
                .normalize())
            : (this.rotationAxis.applyQuaternion(this._parentQuaternionInv),
              n.quaternion.copy(
                Yx.setFromAxisAngle(this.rotationAxis, this.rotationAngle)
              ),
              n.quaternion.multiply(this._quaternionStart).normalize());
      }
      this.dispatchEvent(Zx),
        this.dispatchEvent(tb),
        (eb.mode = this.mode),
        this.dispatchEvent(eb);
    }
  }
  pointerUp(e) {
    0 === e.button &&
      (this.dragging &&
        null !== this.axis &&
        (($x.mode = this.mode), this.dispatchEvent($x)),
      (this.dragging = !1),
      (this.axis = null));
  }
  dispose() {
    this.domElement.removeEventListener("pointerdown", this._onPointerDown),
      this.domElement.removeEventListener("pointermove", this._onPointerHover),
      this.domElement.removeEventListener("pointermove", this._onPointerMove),
      this.domElement.removeEventListener("pointerup", this._onPointerUp),
      this.traverse(function (e) {
        e.geometry && e.geometry.dispose(), e.material && e.material.dispose();
      });
  }
  attach(e) {
    return (this.object = e), (this.visible = !0), this;
  }
  detach() {
    return (
      (this.object = void 0), (this.visible = !1), (this.axis = null), this
    );
  }
  reset() {
    this.enabled &&
      this.dragging &&
      (this.object.position.copy(this._positionStart),
      this.object.quaternion.copy(this._quaternionStart),
      this.object.scale.copy(this._scaleStart),
      this.dispatchEvent(Zx),
      this.dispatchEvent(tb),
      this.pointStart.copy(this.pointEnd));
  }
  getRaycaster() {
    return Wx;
  }
  getMode() {
    return this.mode;
  }
  setMode(e) {
    this.mode = e;
  }
  setTranslationSnap(e) {
    this.translationSnap = e;
  }
  setRotationSnap(e) {
    this.rotationSnap = e;
  }
  setScaleSnap(e) {
    this.scaleSnap = e;
  }
  setSize(e) {
    this.size = e;
  }
  setSpace(e) {
    this.space = e;
  }
  update() {
    console.warn(
      "THREE.TransformControls: update function has no more functionality and therefore has been deprecated."
    );
  }
}
function nb(e) {
  if (this.domElement.ownerDocument.pointerLockElement)
    return { x: 0, y: 0, button: e.button };
  {
    const t = this.domElement.getBoundingClientRect();
    return {
      x: ((e.clientX - t.left) / t.width) * 2 - 1,
      y: (-(e.clientY - t.top) / t.height) * 2 + 1,
      button: e.button,
    };
  }
}
function sb(e) {
  if (this.enabled)
    switch (e.pointerType) {
      case "mouse":
      case "pen":
        this.pointerHover(this._getPointer(e));
    }
}
function rb(e) {
  this.enabled &&
    (this.domElement.addEventListener("pointermove", this._onPointerMove),
    this.pointerHover(this._getPointer(e)),
    this.pointerDown(this._getPointer(e)));
}
function ab(e) {
  this.enabled && this.pointerMove(this._getPointer(e));
}
function ob(e) {
  this.enabled &&
    (this.domElement.releasePointerCapture(e.pointerId),
    this.domElement.removeEventListener("pointermove", this._onPointerMove),
    this.pointerUp(this._getPointer(e)));
}
function lb(e, t, i) {
  const n = t.intersectObject(e, !0);
  for (let s = 0; s < n.length; s++) if (n[s].object.visible || i) return n[s];
  return !1;
}
ib.prototype.isTransformControls = !0;
const hb = new ii(),
  cb = new Vector3(0, 1, 0),
  ub = new Vector3(0, 0, 0),
  db = new Matrix4(),
  pb = new Quaternion(),
  fb = new Quaternion(),
  mb = new Vector3(),
  gb = new Matrix4(),
  _b = new Vector3(1, 0, 0),
  vb = new Vector3(0, 1, 0),
  Ab = new Vector3(0, 0, 1),
  yb = new Vector3(),
  xb = new Vector3(),
  bb = new Vector3();
class Eb extends Object3D {
  constructor() {
    super(), (this.type = "TransformControlsGizmo");
    const e = new Oi({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0,
      }),
      t = new to({
        depthTest: !1,
        depthWrite: !1,
        fog: !1,
        toneMapped: !1,
        transparent: !0,
      }),
      i = e.clone();
    i.opacity = 0.15;
    const n = t.clone();
    n.opacity = 0.5;
    const s = e.clone();
    s.color.setHex(16711680);
    const r = e.clone();
    r.color.setHex(65280);
    const a = e.clone();
    a.color.setHex(255);
    const o = e.clone();
    o.color.setHex(16711680), (o.opacity = 0.5);
    const l = e.clone();
    l.color.setHex(65280), (l.opacity = 0.5);
    const h = e.clone();
    h.color.setHex(255), (h.opacity = 0.5);
    const c = e.clone();
    c.opacity = 0.25;
    const u = e.clone();
    u.color.setHex(16776960), (u.opacity = 0.25);
    e.clone().color.setHex(16776960);
    const d = e.clone();
    d.color.setHex(7895160);
    const p = new Po(0, 0.04, 0.1, 12);
    p.translate(0, 0.05, 0);
    const f = new Cn(0.08, 0.08, 0.08);
    f.translate(0, 0.04, 0);
    const m = new rn();
    m.setAttribute("position", new Ki([0, 0, 0, 1, 0, 0], 3));
    const g = new Po(0.0075, 0.0075, 0.5, 3);
    function _(e, t) {
      const i = new zo(e, 0.0075, 3, 64, t * Math.PI * 2);
      return i.rotateY(Math.PI / 2), i.rotateX(Math.PI / 2), i;
    }
    g.translate(0, 0.25, 0);
    const v = {
        X: [
          [new En(p, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
          [new En(p, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
          [new En(g, s), [0, 0, 0], [0, 0, -Math.PI / 2]],
        ],
        Y: [
          [new En(p, r), [0, 0.5, 0]],
          [new En(p, r), [0, -0.5, 0], [Math.PI, 0, 0]],
          [new En(g, r)],
        ],
        Z: [
          [new En(p, a), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
          [new En(p, a), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
          [new En(g, a), null, [Math.PI / 2, 0, 0]],
        ],
        XYZ: [[new En(new Oo(0.1, 0), c.clone()), [0, 0, 0]]],
        XY: [[new En(new Cn(0.15, 0.15, 0.01), h.clone()), [0.15, 0.15, 0]]],
        YZ: [
          [
            new En(new Cn(0.15, 0.15, 0.01), o.clone()),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new En(new Cn(0.15, 0.15, 0.01), l.clone()),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
      },
      A = {
        X: [
          [
            new En(new Po(0.2, 0, 0.6, 4), i),
            [0.3, 0, 0],
            [0, 0, -Math.PI / 2],
          ],
          [
            new En(new Po(0.2, 0, 0.6, 4), i),
            [-0.3, 0, 0],
            [0, 0, Math.PI / 2],
          ],
        ],
        Y: [
          [new En(new Po(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
          [new En(new Po(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]],
        ],
        Z: [
          [new En(new Po(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
          [
            new En(new Po(0.2, 0, 0.6, 4), i),
            [0, 0, -0.3],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XYZ: [[new En(new Oo(0.2, 0), i)]],
        XY: [[new En(new Cn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]],
        YZ: [
          [
            new En(new Cn(0.2, 0.2, 0.01), i),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new En(new Cn(0.2, 0.2, 0.01), i),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
      },
      y = {
        START: [[new En(new Oo(0.01, 2), n), null, null, null, "helper"]],
        END: [[new En(new Oo(0.01, 2), n), null, null, null, "helper"]],
        DELTA: [
          [
            new oo(
              (function () {
                const e = new rn();
                return (
                  e.setAttribute("position", new Ki([0, 0, 0, 1, 1, 1], 3)), e
                );
              })(),
              n
            ),
            null,
            null,
            null,
            "helper",
          ],
        ],
        X: [[new oo(m, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [
          [
            new oo(m, n.clone()),
            [0, -1e3, 0],
            [0, 0, Math.PI / 2],
            [1e6, 1, 1],
            "helper",
          ],
        ],
        Z: [
          [
            new oo(m, n.clone()),
            [0, 0, -1e3],
            [0, -Math.PI / 2, 0],
            [1e6, 1, 1],
            "helper",
          ],
        ],
      },
      x = {
        XYZE: [[new En(_(0.5, 1), d), null, [0, Math.PI / 2, 0]]],
        X: [[new En(_(0.5, 0.5), s)]],
        Y: [[new En(_(0.5, 0.5), r), null, [0, 0, -Math.PI / 2]]],
        Z: [[new En(_(0.5, 0.5), a), null, [0, Math.PI / 2, 0]]],
        E: [[new En(_(0.75, 1), u), null, [0, Math.PI / 2, 0]]],
      },
      b = {
        AXIS: [
          [new oo(m, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"],
        ],
      },
      E = {
        XYZE: [[new En(new Uo(0.25, 10, 8), i)]],
        X: [
          [
            new En(new zo(0.5, 0.1, 4, 24), i),
            [0, 0, 0],
            [0, -Math.PI / 2, -Math.PI / 2],
          ],
        ],
        Y: [
          [new En(new zo(0.5, 0.1, 4, 24), i), [0, 0, 0], [Math.PI / 2, 0, 0]],
        ],
        Z: [
          [new En(new zo(0.5, 0.1, 4, 24), i), [0, 0, 0], [0, 0, -Math.PI / 2]],
        ],
        E: [[new En(new zo(0.75, 0.1, 2, 24), i)]],
      },
      S = {
        X: [
          [new En(f, s), [0.5, 0, 0], [0, 0, -Math.PI / 2]],
          [new En(g, s), [0, 0, 0], [0, 0, -Math.PI / 2]],
          [new En(f, s), [-0.5, 0, 0], [0, 0, Math.PI / 2]],
        ],
        Y: [
          [new En(f, r), [0, 0.5, 0]],
          [new En(g, r)],
          [new En(f, r), [0, -0.5, 0], [0, 0, Math.PI]],
        ],
        Z: [
          [new En(f, a), [0, 0, 0.5], [Math.PI / 2, 0, 0]],
          [new En(g, a), [0, 0, 0], [Math.PI / 2, 0, 0]],
          [new En(f, a), [0, 0, -0.5], [-Math.PI / 2, 0, 0]],
        ],
        XY: [[new En(new Cn(0.15, 0.15, 0.01), h), [0.15, 0.15, 0]]],
        YZ: [
          [
            new En(new Cn(0.15, 0.15, 0.01), o),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new En(new Cn(0.15, 0.15, 0.01), l),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XYZ: [[new En(new Cn(0.1, 0.1, 0.1), c.clone())]],
      },
      C = {
        X: [
          [
            new En(new Po(0.2, 0, 0.6, 4), i),
            [0.3, 0, 0],
            [0, 0, -Math.PI / 2],
          ],
          [
            new En(new Po(0.2, 0, 0.6, 4), i),
            [-0.3, 0, 0],
            [0, 0, Math.PI / 2],
          ],
        ],
        Y: [
          [new En(new Po(0.2, 0, 0.6, 4), i), [0, 0.3, 0]],
          [new En(new Po(0.2, 0, 0.6, 4), i), [0, -0.3, 0], [0, 0, Math.PI]],
        ],
        Z: [
          [new En(new Po(0.2, 0, 0.6, 4), i), [0, 0, 0.3], [Math.PI / 2, 0, 0]],
          [
            new En(new Po(0.2, 0, 0.6, 4), i),
            [0, 0, -0.3],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XY: [[new En(new Cn(0.2, 0.2, 0.01), i), [0.15, 0.15, 0]]],
        YZ: [
          [
            new En(new Cn(0.2, 0.2, 0.01), i),
            [0, 0.15, 0.15],
            [0, Math.PI / 2, 0],
          ],
        ],
        XZ: [
          [
            new En(new Cn(0.2, 0.2, 0.01), i),
            [0.15, 0, 0.15],
            [-Math.PI / 2, 0, 0],
          ],
        ],
        XYZ: [[new En(new Cn(0.2, 0.2, 0.2), i), [0, 0, 0]]],
      },
      M = {
        X: [[new oo(m, n.clone()), [-1e3, 0, 0], null, [1e6, 1, 1], "helper"]],
        Y: [
          [
            new oo(m, n.clone()),
            [0, -1e3, 0],
            [0, 0, Math.PI / 2],
            [1e6, 1, 1],
            "helper",
          ],
        ],
        Z: [
          [
            new oo(m, n.clone()),
            [0, 0, -1e3],
            [0, -Math.PI / 2, 0],
            [1e6, 1, 1],
            "helper",
          ],
        ],
      };
    function w(e) {
      const t = new Object3D();
      for (const i in e)
        for (let n = e[i].length; n--; ) {
          const s = e[i][n][0].clone(),
            r = e[i][n][1],
            a = e[i][n][2],
            o = e[i][n][3],
            l = e[i][n][4];
          (s.name = i),
            (s.tag = l),
            r && s.position.set(r[0], r[1], r[2]),
            a && s.rotation.set(a[0], a[1], a[2]),
            o && s.scale.set(o[0], o[1], o[2]),
            s.updateMatrix();
          const h = s.geometry.clone();
          h.applyMatrix4(s.matrix),
            (s.geometry = h),
            (s.renderOrder = 1 / 0),
            s.position.set(0, 0, 0),
            s.rotation.set(0, 0, 0),
            s.scale.set(1, 1, 1),
            t.add(s);
        }
      return t;
    }
    (this.gizmo = {}),
      (this.picker = {}),
      (this.helper = {}),
      this.add((this.gizmo.translate = w(v))),
      this.add((this.gizmo.rotate = w(x))),
      this.add((this.gizmo.scale = w(S))),
      this.add((this.picker.translate = w(A))),
      this.add((this.picker.rotate = w(E))),
      this.add((this.picker.scale = w(C))),
      this.add((this.helper.translate = w(y))),
      this.add((this.helper.rotate = w(b))),
      this.add((this.helper.scale = w(M))),
      (this.picker.translate.visible = !1),
      (this.picker.rotate.visible = !1),
      (this.picker.scale.visible = !1);
  }
  onBeforeScenePrepareRender() {
    const e =
      "local" === ("scale" === this.mode ? "local" : this.space)
        ? this.worldQuaternion
        : fb;
    (this.gizmo.translate.visible = "translate" === this.mode),
      (this.gizmo.rotate.visible = "rotate" === this.mode),
      (this.gizmo.scale.visible = "scale" === this.mode),
      (this.helper.translate.visible = "translate" === this.mode),
      (this.helper.rotate.visible = "rotate" === this.mode),
      (this.helper.scale.visible = "scale" === this.mode);
    let t = [];
    (t = t.concat(this.picker[this.mode].children)),
      (t = t.concat(this.gizmo[this.mode].children)),
      (t = t.concat(this.helper[this.mode].children));
    for (let i = 0; i < t.length; i++) {
      const n = t[i];
      let s;
      if (
        ((n.visible = !0),
        n.rotation.set(0, 0, 0),
        n.position.copy(this.worldPosition),
        (s = this.camera.isOrthographicCamera
          ? (this.camera.top - this.camera.bottom) / this.camera.zoom
          : this.worldPosition.distanceTo(this.cameraPosition) *
            Math.min(
              (1.9 * Math.tan((Math.PI * this.camera.fov) / 360)) /
                this.camera.zoom,
              7
            )),
        n.scale.set(1, 1, 1).multiplyScalar((s * this.size) / 4),
        "helper" !== n.tag)
      ) {
        if (
          (n.quaternion.copy(e),
          "translate" === this.mode || "scale" === this.mode)
        ) {
          const t = 0.99,
            i = 0.2;
          "X" === n.name &&
            Math.abs(cb.copy(_b).applyQuaternion(e).dot(this.eye)) > t &&
            (n.scale.set(1e-10, 1e-10, 1e-10), (n.visible = !1)),
            "Y" === n.name &&
              Math.abs(cb.copy(vb).applyQuaternion(e).dot(this.eye)) > t &&
              (n.scale.set(1e-10, 1e-10, 1e-10), (n.visible = !1)),
            "Z" === n.name &&
              Math.abs(cb.copy(Ab).applyQuaternion(e).dot(this.eye)) > t &&
              (n.scale.set(1e-10, 1e-10, 1e-10), (n.visible = !1)),
            "XY" === n.name &&
              Math.abs(cb.copy(Ab).applyQuaternion(e).dot(this.eye)) < i &&
              (n.scale.set(1e-10, 1e-10, 1e-10), (n.visible = !1)),
            "YZ" === n.name &&
              Math.abs(cb.copy(_b).applyQuaternion(e).dot(this.eye)) < i &&
              (n.scale.set(1e-10, 1e-10, 1e-10), (n.visible = !1)),
            "XZ" === n.name &&
              Math.abs(cb.copy(vb).applyQuaternion(e).dot(this.eye)) < i &&
              (n.scale.set(1e-10, 1e-10, 1e-10), (n.visible = !1));
        } else
          "rotate" === this.mode &&
            (pb.copy(e),
            cb.copy(this.eye).applyQuaternion(Yx.copy(e).invert()),
            -1 !== n.name.search("E") &&
              n.quaternion.setFromRotationMatrix(db.lookAt(this.eye, ub, vb)),
            "X" === n.name &&
              (Yx.setFromAxisAngle(_b, Math.atan2(-cb.y, cb.z)),
              Yx.multiplyQuaternions(pb, Yx),
              n.quaternion.copy(Yx)),
            "Y" === n.name &&
              (Yx.setFromAxisAngle(vb, Math.atan2(cb.x, cb.z)),
              Yx.multiplyQuaternions(pb, Yx),
              n.quaternion.copy(Yx)),
            "Z" === n.name &&
              (Yx.setFromAxisAngle(Ab, Math.atan2(cb.y, cb.x)),
              Yx.multiplyQuaternions(pb, Yx),
              n.quaternion.copy(Yx)));
        (n.visible = n.visible && (-1 === n.name.indexOf("X") || this.showX)),
          (n.visible = n.visible && (-1 === n.name.indexOf("Y") || this.showY)),
          (n.visible = n.visible && (-1 === n.name.indexOf("Z") || this.showZ)),
          (n.visible =
            n.visible &&
            (-1 === n.name.indexOf("E") ||
              (this.showX && this.showY && this.showZ))),
          (n.material._color = n.material._color || n.material.color.clone()),
          (n.material._opacity = n.material._opacity || n.material.opacity),
          n.material.color.copy(n.material._color),
          (n.material.opacity = n.material._opacity),
          this.enabled &&
            this.axis &&
            (n.name === this.axis ||
              this.axis.split("").some(function (e) {
                return n.name === e;
              })) &&
            (n.material.color.setHex(16776960), (n.material.opacity = 1));
      } else
        (n.visible = !1),
          "AXIS" === n.name
            ? (n.position.copy(this.worldPositionStart),
              (n.visible = !!this.axis),
              "X" === this.axis &&
                (Yx.setFromEuler(hb.set(0, 0, 0)),
                n.quaternion.copy(e).multiply(Yx),
                Math.abs(cb.copy(_b).applyQuaternion(e).dot(this.eye)) > 0.9 &&
                  (n.visible = !1)),
              "Y" === this.axis &&
                (Yx.setFromEuler(hb.set(0, 0, Math.PI / 2)),
                n.quaternion.copy(e).multiply(Yx),
                Math.abs(cb.copy(vb).applyQuaternion(e).dot(this.eye)) > 0.9 &&
                  (n.visible = !1)),
              "Z" === this.axis &&
                (Yx.setFromEuler(hb.set(0, Math.PI / 2, 0)),
                n.quaternion.copy(e).multiply(Yx),
                Math.abs(cb.copy(Ab).applyQuaternion(e).dot(this.eye)) > 0.9 &&
                  (n.visible = !1)),
              "XYZE" === this.axis &&
                (Yx.setFromEuler(hb.set(0, Math.PI / 2, 0)),
                cb.copy(this.rotationAxis),
                n.quaternion.setFromRotationMatrix(db.lookAt(ub, cb, vb)),
                n.quaternion.multiply(Yx),
                (n.visible = this.dragging)),
              "E" === this.axis && (n.visible = !1))
            : "START" === n.name
            ? (n.position.copy(this.worldPositionStart),
              (n.visible = this.dragging))
            : "END" === n.name
            ? (n.position.copy(this.worldPosition), (n.visible = this.dragging))
            : "DELTA" === n.name
            ? (n.position.copy(this.worldPositionStart),
              n.quaternion.copy(this.worldQuaternionStart),
              qx
                .set(1e-10, 1e-10, 1e-10)
                .add(this.worldPositionStart)
                .sub(this.worldPosition)
                .multiplyScalar(-1),
              qx.applyQuaternion(this.worldQuaternionStart.clone().invert()),
              n.scale.copy(qx),
              (n.visible = this.dragging))
            : (n.quaternion.copy(e),
              this.dragging
                ? n.position.copy(this.worldPositionStart)
                : n.position.copy(this.worldPosition),
              this.axis && (n.visible = -1 !== this.axis.search(n.name)));
    }
  }
}
Eb.prototype.isTransformControlsGizmo = !0;
class Sb extends En {
  constructor() {
    super(
      new PlaneGeometry(1e5, 1e5, 2, 2),
      new Oi({
        visible: !1,
        wireframe: !0,
        side: 2,
        transparent: !0,
        opacity: 0.1,
        toneMapped: !1,
      })
    ),
      (this.type = "TransformControlsPlane");
  }
  updateMatrixWorld(e) {
    let t = this.space;
    switch (
      (this.position.copy(this.worldPosition),
      "scale" === this.mode && (t = "local"),
      yb.copy(_b).applyQuaternion("local" === t ? this.worldQuaternion : fb),
      xb.copy(vb).applyQuaternion("local" === t ? this.worldQuaternion : fb),
      bb.copy(Ab).applyQuaternion("local" === t ? this.worldQuaternion : fb),
      cb.copy(xb),
      this.mode)
    ) {
      case "translate":
      case "scale":
        switch (this.axis) {
          case "X":
            cb.copy(this.eye).cross(yb), mb.copy(yb).cross(cb);
            break;
          case "Y":
            cb.copy(this.eye).cross(xb), mb.copy(xb).cross(cb);
            break;
          case "Z":
            cb.copy(this.eye).cross(bb), mb.copy(bb).cross(cb);
            break;
          case "XY":
            mb.copy(bb);
            break;
          case "YZ":
            mb.copy(yb);
            break;
          case "XZ":
            cb.copy(bb), mb.copy(xb);
            break;
          case "XYZ":
          case "E":
            mb.set(0, 0, 0);
        }
        break;
      default:
        mb.set(0, 0, 0);
    }
    0 === mb.length()
      ? this.quaternion.copy(this.cameraQuaternion)
      : (gb.lookAt(qx.set(0, 0, 0), mb, cb),
        this.quaternion.setFromRotationMatrix(gb)),
      super.updateMatrixWorld(e);
  }
  raycast(e, t) {
    t.length || super.raycast(e, t);
  }
}
Sb.prototype.isTransformControlsPlane = !0;
class Cb extends ib {
  constructor(e) {
    super(e.camera, e.map.container),
      publicField(this, "_enableKeyboardEvent", !1),
      publicField(this, "handleKeyboardEvent", (e) => {
        switch (e.keyCode) {
          case 81:
            this.setSpace("local" === this.space ? "world" : "local");
            break;
          case 87:
            this.setMode("translate");
            break;
          case 69:
            this.setMode("rotate");
            break;
          case 82:
            this.setMode("scale");
            break;
          case 187:
          case 107:
            this.setSize(this.size + 0.1);
            break;
          case 189:
          case 109:
            this.setSize(Math.max(this.size - 0.1, 0.1));
            break;
          case 88:
            this.showX = !this.showX;
            break;
          case 89:
            this.showY = !this.showY;
            break;
          case 90:
            this.showZ = !this.showZ;
            break;
          case 32:
            this.enabled = !this.enabled;
            break;
          case 27:
            this.reset();
        }
      }),
      (this.engine = e),
      this.addEventListener("change", (t) => {
        e.requestRender();
      }),
      this.addEventListener("objectChange", (t) => {
        e.requestRender();
      }),
      this.addEventListener("dragging-changed", (t) => {
        t.value ? e.map.disableControl() : e.map.enableControl();
      });
  }
  dispose() {
    super.dispose(), (this.enableKeyboardEvent = !1);
  }
  set enableKeyboardEvent(e) {
    e !== this._enableKeyboardEvent &&
      ((this._enableKeyboardEvent = e),
      e
        ? window.addEventListener("keydown", this.handleKeyboardEvent)
        : window.removeEventListener("keydown", this.handleKeyboardEvent));
  }
}
class Mb extends EventDispatcher {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_engine"),
      publicField(this, "_boundingBoxHelper"),
      publicField(this, "_selectedObject"),
      publicField(this, "_transformControl"),
      (this._engine = e);
  }
  isSelected(e) {
    return e === this._selectedObject;
  }
  select(e) {
    e.__engine_selected ||
      (this._selectedObject && (this._selectedObject.__engine_selected = !1),
      this._boundingBoxHelper ||
        ((this._boundingBoxHelper = new jx()),
        this._engine.add(this._boundingBoxHelper)),
      this._boundingBoxHelper.attach(e),
      (this._selectedObject = e),
      (e.__engine_selected = !0),
      this._engine.requestRender());
  }
  deselect(e) {
    this.isSelected(e) &&
      (this._boundingBoxHelper.detach(),
      (this._selectedObject = null),
      (e.__engine_selected = !1),
      this._engine.requestRender());
  }
  get transformControl() {
    return (
      this._transformControl ||
        ((this._transformControl = new Cb(this._engine)),
        (this._transformControl.enableKeyboardEvent = !0)),
      this._transformControl
    );
  }
  attachTransform(e) {
    const t = this._engine,
      i = this.transformControl;
    t.add(i), i.attach(e), i.updateMatrixWorld(), t.requestRender();
  }
  detachTransform() {
    const e = this._engine,
      t = this.transformControl;
    e.remove(t), t.detach();
  }
  dispose() {}
}
class wb {
  constructor(e, t, i = null) {
    publicField(this, "_container"),
      publicField(this, "_enabled"),
      publicField(this, "_controlOptions", {}),
      publicField(this, "_element"),
      publicField(this, "_engine"),
      (this._container = e);
    let n = !1;
    t
      ? ((n = !0), t instanceof Object && (this._controlOptions = t))
      : (n = !1),
      (this._enabled = n),
      (this._engine = i),
      (this._element = null),
      this._enabled && this.init();
  }
  init() {
    let e = (this._element = this.createDom());
    this._container.appendChild(e);
  }
  createDom() {}
  dispose() {
    this._element && (this.onDispose(), this._element.remove());
  }
  onDispose() {}
  get container() {
    return this._container;
  }
  get element() {
    return this._element;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    const t = !!e;
    if (this._enabled !== t) {
      const e = t ? "visible" : "hidden";
      this._element
        ? ((this._element.style.visibility = e), this.onDispose())
        : e && this.init(),
        (this._enabled = t);
    }
  }
}
class Tb extends wb {
  createDom() {
    return (
      (this._element = document.createElement("img")),
      i(this._element, "logo"),
      (this._url = this._url || Hm("assets/images/bdImg.png")),
      (this._element.src = this._url),
      this._element
    );
  }
  set url(e) {
    this._element && (this._element.src = e), (this._url = e);
  }
  get url() {
    return this._url;
  }
}
class Ib extends wb {
  createDom() {
    (this.handleZoomIn = this.handleZoomIn.bind(this)),
      (this.handleZoomOut = this.handleZoomOut.bind(this)),
      (this._element = document.createElement("div")),
      i(this._element, "zoom");
    const e = (this._zoomAdd = document.createElement("div"));
    i(e, "zoom-add");
    const t = document.createElement("div");
    i(t, "zoom-add-tag"),
      t.setAttribute(
        "style",
        `background-image: url(${Hm("assets/images/mapZoom2x.png")});`
      ),
      e.addEventListener(hy.DOWN, this.handleZoomIn),
      e.appendChild(t);
    const n = (this._zoomSub = document.createElement("div"));
    i(n, "zoom-sub");
    const s = document.createElement("div");
    return (
      i(s, "zoom-sub-tag"),
      s.setAttribute(
        "style",
        `background-image: url(${Hm("assets/images/mapZoom2x.png")});`
      ),
      n.addEventListener(hy.DOWN, this.handleZoomOut),
      n.appendChild(s),
      this._element.appendChild(e),
      this._element.appendChild(n),
      this._element
    );
  }
  handleZoomIn() {
    this._engine.map.zoomIn();
  }
  handleZoomOut() {
    this._engine.map.zoomOut();
  }
  onDispose() {
    this._zoomAdd.removeEventListener(hy.DOWN, this.handleZoomIn),
      this._zoomSub.removeEventListener(hy.DOWN, this.handleZoomOut);
  }
}
class Rb extends wb {
  createDom() {
    (this._element = document.createElement("div")),
      i(this._element, "scale"),
      (this._text = document.createElement("div")),
      i(this._text, "scale-text"),
      (this._text.innerText = "20km");
    const e = document.createElement("div");
    i(e, "scale-line");
    const t = document.createElement("div");
    i(t, "scale-line-mid");
    const n = document.createElement("div");
    i(n, "scale-line-left");
    const s = document.createElement("div");
    return (
      i(s, "scale-line-right"),
      e.appendChild(t),
      e.appendChild(n),
      e.appendChild(s),
      this._element.appendChild(this._text),
      this._element.appendChild(e),
      (this.calculateScale = this.calculateScale.bind(this)),
      this._engine.rendering.addPrepareRenderListener(this.calculateScale),
      this._element
    );
  }
  calculateScale() {
    const e = this._engine.map.getZoomUnitsByZoom(this._engine.map.getZoom());
    let t = 0;
    const i = [0.05, 0.1, 0.2];
    for (let n = 0; n < 3 && t < 7; n++) {
      const s = i[n] * Math.pow(10, t),
        r = s / e;
      if (r >= 50 && r <= 150) {
        if (((this._element.style.width = r + "px"), t < 1))
          this._text.innerText = (s < 0.1 ? 5 : 100 * s) + "cm";
        else if (t < 2) this._text.innerText = (s < 1 ? 5 : 10 * s) + "dm";
        else {
          const e = s / 1e3,
            t = e < 1;
          this._text.innerText = t ? s + "m" : e + "km";
        }
        break;
      }
      n < 1 &&
        t < 1 &&
        r > 150 &&
        ((this._element.style.width = "150px"),
        (this._text.innerText = "< 5cm")),
        n > 1 && (t++, (n = 0));
    }
  }
  onDispose() {
    this._engine.rendering.removePrepareRenderListener(this.calculateScale);
  }
}
const Pb =
  "M358.4 768H426.666667v85.333333H213.333333v-213.333333h85.333334v68.266667l128-128 59.733333 59.733333-128 128z m345.6 0l-128-128 59.733333-59.733333 132.266667 132.266666V640h85.333333v213.333333h-213.333333v-85.333333h64zM358.4 298.666667l128 128-59.733333 59.733333-128-128V426.666667H213.333333V213.333333h213.333334v85.333334H358.4z m345.6 0H640V213.333333h213.333333v213.333334h-85.333333V354.133333l-132.266667 132.266667-59.733333-59.733333 128-128z";
class Db extends wb {
  createDom() {
    (this.handleClick = this.handleClick.bind(this)),
      (this.handleFullscreenChange = this.handleFullscreenChange.bind(this)),
      (this._element = document.createElement("div")),
      i(this._element, "fullscreen");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    return (
      e.setAttribute("class", "control-group-svg fullscreen-svg"),
      e.setAttribute("viewBox", "0 0 1024 1024"),
      e.setAttribute("version", "1.1"),
      (this._path = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "path"
      )),
      this._path.setAttribute("d", Pb),
      this._path.setAttribute("class", "fullscreen-path"),
      e.appendChild(this._path),
      (this._flag = !0),
      this._element.addEventListener(hy.DOWN, this.handleClick),
      document.addEventListener(
        "fullscreenchange",
        this.handleFullscreenChange
      ),
      this._element.appendChild(e),
      this._element
    );
  }
  handleClick() {
    const e = this._engine.container,
      t =
        e instanceof HTMLElement ||
        (e &&
          "object" == typeof e &&
          1 === e.nodeType &&
          "string" == typeof e.nodeName)
          ? e
          : e.container || e._container;
    this._flag
      ? t.requestFullscreen
        ? t.requestFullscreen()
        : t.msRequestFullscreen
        ? t.msRequestFullscreen()
        : t.mozRequestFullScreen
        ? t.mozRequestFullScreen()
        : t.webkitRequestFullScreen && t.webkitRequestFullScreen()
      : document.exitFullscreen
      ? document.exitFullscreen()
      : document.msExitFullscreen
      ? document.msExitFullscreen()
      : document.mozCancelFullScreen
      ? document.mozCancelFullScreen()
      : document.webkitCancelFullScreen && document.webkitCancelFullScreen();
  }
  handleFullscreenChange() {
    (this._flag = !this._flag),
      this._flag
        ? this._path.setAttribute("d", Pb)
        : this._path.setAttribute(
            "d",
            "M298.666667 631.466667H226.133333v-81.066667h217.6v204.8h-85.333333v-68.266667l-128 128L170.666667 759.466667l128-128z m422.4 0l128 128-59.733334 59.733333-128-128v68.266667h-85.333333V554.666667h217.6v81.066666h-72.533333zM298.666667 341.333333L187.733333 230.4 243.2 170.666667l115.2 115.2V217.6h85.333333v204.8H226.133333V341.333333H298.666667z m430.933333 0h64v81.066667h-217.6V217.6h85.333333v72.533333L780.8 170.666667l59.733333 59.733333L729.6 341.333333z"
          );
  }
  onDispose() {
    this._element.removeEventListener(hy.DOWN, this.handleClick),
      document.removeEventListener(
        "fullscreenchange",
        this.handleFullscreenChange
      );
  }
}
class Lb extends wb {
  createDom() {
    (this.locate = this.locate.bind(this)),
      (this._element = document.createElement("div")),
      i(this._element, "geo-locate");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    e.setAttribute("class", "control-group-svg geo-locate-svg"),
      e.setAttribute("viewBox", "0 0 1024 1024"),
      e.setAttribute("version", "1.1");
    const t = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return (
      t.setAttribute(
        "d",
        "M87.424 469.312A426.816 426.816 0 0 1 469.312 87.424V0h85.376v87.424a426.816 426.816 0 0 1 381.888 381.888H1024v85.376h-87.424a426.816 426.816 0 0 1-381.888 381.888V1024h-85.376v-87.424A426.816 426.816 0 0 1 87.424 554.688H0v-85.376h87.424z m424.576 384a341.312 341.312 0 1 0 0-682.624 341.312 341.312 0 0 0 0 682.624z m0-170.624a170.688 170.688 0 1 0 0-341.376 170.688 170.688 0 0 0 0 341.376z"
      ),
      t.setAttribute("class", "geo-locate-path"),
      e.appendChild(t),
      this._element.addEventListener(hy.DOWN, this.locate),
      this._element.appendChild(e),
      this._element
    );
  }
  locate() {
    window.navigator.geolocation.getCurrentPosition(
      (e) => {
        var t;
        const { longitude: i, latitude: n } = null != (t = e.coords) ? t : {};
        isNaN(i) || isNaN(n)
          ? console.error("定位出错，请重新定位！")
          : (this._engine.map.setCenter([i, n]), this._engine.map.setZoom(18));
      },
      (e) => {
        console.error("定位未开启");
      }
    );
  }
  onDispose() {
    this._element.removeEventListener(hy.DOWN, this.locate);
  }
}
class Fb extends wb {
  constructor() {
    super(...arguments),
      publicField(this, "screenshot", (e, t) => {
        const i = this._engine.rendering.canvas,
          n = this._engine.map.mapType,
          s = document.createElement("canvas"),
          r = s.getContext("2d");
        if (((s.width = i.width), (s.height = i.height), "bmapgl" === n)) {
          const e = this._engine.container._webglPainter._canvas;
          r.drawImage(e, 0, 0, e.width, e.height);
        } else if ("mapbox" === n) {
          const e = this._engine.container._canvas;
          r.drawImage(e, 0, 0, e.width, e.height);
        }
        r.drawImage(i, 0, 0, i.width, i.height);
        let a = s.toDataURL();
        if (t) {
          e = e || "download.png";
          const t = document.createElement("a");
          (t.href = a), (t.download = e), t.click();
        }
        return a;
      });
  }
  createDom() {
    (this.handleClick = this.handleClick.bind(this)),
      (this._element = document.createElement("div")),
      i(this._element, "export-image");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    e.setAttribute("class", "control-group-svg export-image-svg"),
      e.setAttribute("viewBox", "0 0 1024 1024"),
      e.setAttribute("version", "1.1");
    const t = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return (
      t.setAttribute(
        "d",
        "M867.90864 574.538232V257.779543a50.844091 50.844091 0 0 0-50.844092-50.844091h-610.129096a50.844091 50.844091 0 0 0-50.844092 50.844091v499.797418l430.141013-257.779543a152.532274 152.532274 0 0 1 157.108243 0z m0 118.466733l-177.445879-106.264151a50.844091 50.844091 0 0 0-50.844092 0L254.220457 817.064548h562.844091a50.844091 50.844091 0 0 0 50.844092-50.844091z m-660.973188-587.757696h610.129096a152.532274 152.532274 0 0 1 152.532274 152.532274v508.440914a152.532274 152.532274 0 0 1-152.532274 152.532274h-610.129096a152.532274 152.532274 0 0 1-152.532274-152.532274v-508.440914a152.532274 152.532274 0 0 1 152.532274-152.532274z m127.110228 355.90864a76.266137 76.266137 0 1 1 76.266137-76.266137 76.266137 76.266137 0 0 1-76.266137 76.266137z"
      ),
      e.appendChild(t),
      this._element.addEventListener(hy.DOWN, this.handleClick),
      this._element.appendChild(e),
      this._element
    );
  }
  handleClick() {
    this.screenshot("download.png", !0);
  }
  onDispose() {
    this._element.removeEventListener(hy.DOWN, this.handleClick);
  }
}
class Nb extends wb {
  constructor() {
    super(...arguments),
      publicField(this, "_mapInfo", {
        pitch: 0,
        heading: 0,
        zoom: 0,
        center: [0, 0],
        mousePoint: [0, 0],
      }),
      publicField(this, "_prefix", {
        M: "指针位置",
        C: "中心点",
        Z: "级别",
        H: "旋转角",
        P: "倾角",
      }),
      publicField(this, "_separator", " | "),
      publicField(this, "_template", "CZ");
  }
  createDom() {
    return (
      (this._element = document.createElement("div")),
      i(this._element, "mouse-location"),
      (this._enableMousePositionTracking = !1),
      (this._eventName = "pointerdown"),
      (this.eventCallback = this.update.bind(this)),
      this._engine.event.bind(this._eventName, this.eventCallback),
      (this._viewChangedCallback = () => {
        if (this._engine.rendering.renderState.viewChanged) {
          const e = this._engine.map,
            t = e.getCenter2D();
          (this._mapInfo.pitch = Bb(e.getPitch())),
            (this._mapInfo.heading = Bb(e.getHeading())),
            (this._mapInfo.zoom = Bb(e.getZoom())),
            (this._mapInfo.center = [t[0].toFixed(6), t[1].toFixed(6)]),
            this.updateInfoText();
        }
      }),
      this._engine.rendering.addPrepareRenderListener(
        this._viewChangedCallback
      ),
      this._element
    );
  }
  update(e) {
    const t = e.point;
    t &&
      /M/gi.test(this._template) &&
      ((this._mapInfo.mousePoint = [t[0].toFixed(6), t[1].toFixed(6)]),
      this.updateInfoText());
  }
  updateInfoText() {
    const {
        center: e,
        heading: t,
        pitch: i,
        zoom: n,
        mousePoint: s,
      } = this._mapInfo,
      r = { M: s, C: e, Z: n, H: t, P: i },
      a = this.template
        .replace(
          /[MCZHP]/gi,
          (e) =>
            `${this.prefix[e.toUpperCase()]}: ${r[e.toUpperCase()]}${
              this.separator
            }`
        )
        .slice(0, -this.separator.length);
    this._element.innerText = a;
  }
  get enableMousePositionTracking() {
    return this._enableMousePositionTracking;
  }
  set enableMousePositionTracking(e) {
    this._enableMousePositionTracking !== e &&
      ((this._enableMousePositionTracking = e),
      this._engine.event.unbind(this._eventName, this.eventCallback),
      (this._eventName = e ? "mousemove" : "pointerdown"),
      this._engine.event.bind(this._eventName, this.eventCallback));
  }
  get template() {
    return this._template;
  }
  set template(e) {
    (this._template = e), this.updateInfoText();
  }
  get separator() {
    return this._separator;
  }
  set separator(e) {
    (this._separator = e), this.updateInfoText();
  }
  get prefix() {
    return this._prefix;
  }
  set prefix(e) {
    (this._prefix = e), this.updateInfoText();
  }
  onDispose() {
    this._engine.event.unbind(this._eventName, this.eventCallback),
      this._engine.rendering.removePrepareRenderListener(
        this._viewChangedCallback
      );
  }
}
function Bb(e, t) {
  if (!t) return Math.round(e);
  const i = 10 * t;
  return Math.round(e * i) / i;
}
class kb extends wb {
  createDom() {
    (this._element = document.createElement("div")), i(this._element, "drawer");
    const e = (this._drawerBtn = document.createElement("div"));
    i(e, "drawer-btn");
    const n = document.createElementNS("http://www.w3.org/2000/svg", "svg");
    n.setAttribute("class", "drawer-icon"),
      n.setAttribute("viewBox", "0 0 1024 1024"),
      n.setAttribute("version", "1.1");
    const s = document.createElementNS("http://www.w3.org/2000/svg", "path");
    s.setAttribute(
      "d",
      "M512 821.504l-416-208-96 48 512 256 512-256-96-48-416 208z m0-181.173333l-416-208-96 48 512 256 512-256-96-48-416 208zM1024 298.666667L512 42.666667 0 298.666667l512 256 512-256zM512 138.058667L833.184 298.666667 512 459.274667 190.816 298.666667 512 138.058667z"
    ),
      n.appendChild(s),
      e.addEventListener(hy.DOWN, this.openDrawer),
      e.appendChild(n);
    const r = (this._drawerList = document.createElement("div"));
    i(r, "drawer-list"),
      r.setAttribute("id", `${t}-drawer-list`),
      (r.style.display = "none");
    const a = document.createElement("div");
    i(a, "drawer-content");
    const o = this._controlOptions,
      l = o && o.length > 0 ? o.length : 0;
    if (((this._drawerCheckboxs = []), l > 0)) {
      const e = this.addChangeListener.bind(this);
      for (let t = 0; t < l; t++) {
        const n = o[t],
          s = document.createElement("div");
        i(s, "drawer-item");
        const r = document.createElement("input");
        i(r, "drawer-item-check"),
          e(r, (e) => {
            e.stopPropagation();
            const t = e.target.checked;
            n.onChange && n.onChange(t, n.data, this._engine);
          }),
          r.setAttribute("type", "checkbox"),
          n.defaultChecked &&
            (r.setAttribute("checked", n.defaultChecked),
            n.onChange && n.onChange(!0, n.data, this._engine)),
          this._drawerCheckboxs.push(r);
        const l = document.createElement("span");
        i(l, "drawer-item-name"),
          (l.innerText = n.name),
          (l.onclick = () => {
            r.click();
          }),
          s.appendChild(r),
          s.appendChild(l),
          a.appendChild(s);
      }
    }
    const h = document.createElement("div");
    return (
      i(h, "drawer-arrow"),
      r.appendChild(a),
      r.appendChild(h),
      this._element.appendChild(e),
      this._element.appendChild(r),
      this._element
    );
  }
  addChangeListener(e, t) {
    this._eventMap || (this._eventMap = new WeakMap()),
      e.addEventListener("change", t),
      this._eventMap.set(e, t);
  }
  removeChangeListener(e) {
    const t = this._eventMap.get(e);
    e.removeEventListener("change", t), this._eventMap.delete(e);
  }
  openDrawer() {
    const e = document.getElementById(`${t}-drawer-list`);
    e.style.display = "none" === e.style.display ? "block" : "none";
  }
  onDispose() {
    this._drawerBtn.addEventListener(hy.DOWN, this.openDrawer);
    for (let e = 0; e < this._drawerCheckboxs.length; e++)
      this.removeChangeListener(this._drawerCheckboxs[e]);
  }
}
class Ob extends wb {
  createDom() {
    (this.handleUpBtnClick = this.handleUpBtnClick.bind(this)),
      (this.handleDownBtnClick = this.handleDownBtnClick.bind(this)),
      (this.handleLeftBtnClick = this.handleLeftBtnClick.bind(this)),
      (this.handleRightBtnClick = this.handleRightBtnClick.bind(this)),
      (this.handleCenterBtnClick = this.handleCenterBtnClick.bind(this)),
      (this._element = document.createElement("div")),
      i(this._element, "compass"),
      this._element.setAttribute(
        "style",
        `background-image: url(${Hm("assets/images/mapCompass.png")});`
      ),
      (this._up = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      )),
      this._up.setAttribute("class", "compass-up"),
      this._up.setAttribute("viewBox", "0 0 1024 1024"),
      this._up.setAttribute("version", "1.1");
    const e = document.createElementNS("http://www.w3.org/2000/svg", "path");
    e.setAttribute(
      "d",
      "M910.222222 796.444444c-17.066667 0-34.133333-5.688889-45.511111-17.066666L551.822222 409.6c-11.377778-5.688889-17.066667-11.377778-34.133333-11.377778-5.688889 0-22.755556 5.688889-28.444445 11.377778l-329.955555 364.088889c-22.755556 22.755556-56.888889 22.755556-79.644445 5.688889-22.755556-22.755556-22.755556-56.888889-5.688888-79.644445l329.955555-364.088889c28.444444-34.133333 73.955556-51.2 119.466667-51.2s85.333333 22.755556 119.466666 56.888889l312.888889 364.088889c22.755556 22.755556 17.066667 56.888889-5.688889 79.644445-11.377778 5.688889-28.444444 11.377778-39.822222 11.377777z"
    ),
      this._up.addEventListener(hy.DOWN, this.handleUpBtnClick),
      this._up.appendChild(e),
      (this._down = document.createElementNS(
        "http://www.w3.org/2000/svg",
        "svg"
      )),
      this._down.setAttribute("class", "compass-down"),
      this._down.setAttribute("viewBox", "0 0 1024 1024"),
      this._down.setAttribute("version", "1.1");
    const t = document.createElementNS("http://www.w3.org/2000/svg", "path");
    return (
      t.setAttribute(
        "d",
        "M517.688889 796.444444c-45.511111 0-85.333333-17.066667-119.466667-51.2L73.955556 381.155556c-22.755556-22.755556-17.066667-56.888889 5.688888-79.644445 22.755556-22.755556 56.888889-17.066667 79.644445 5.688889l329.955555 364.088889c5.688889 5.688889 17.066667 11.377778 28.444445 11.377778s22.755556-5.688889 34.133333-17.066667l312.888889-364.088889c22.755556-22.755556 56.888889-28.444444 79.644445-5.688889 22.755556 22.755556 28.444444 56.888889 5.688888 79.644445L637.155556 739.555556c-28.444444 39.822222-68.266667 56.888889-119.466667 56.888888 5.688889 0 0 0 0 0z"
      ),
      this._down.addEventListener(hy.DOWN, this.handleDownBtnClick),
      this._down.appendChild(t),
      (this._left = document.createElement("div")),
      i(this._left, "compass-left"),
      this._left.setAttribute(
        "style",
        `background-image: url(${Hm("assets/images/mapCompass.png")});`
      ),
      this._left.addEventListener(hy.DOWN, this.handleLeftBtnClick),
      (this._right = document.createElement("div")),
      i(this._right, "compass-right"),
      this._right.setAttribute(
        "style",
        `background-image: url(${Hm("assets/images/mapCompass.png")});`
      ),
      this._right.addEventListener(hy.DOWN, this.handleRightBtnClick),
      (this._compass = document.createElement("div")),
      i(this._compass, "compass-center"),
      this._compass.setAttribute(
        "style",
        `background-image: url(${Hm("assets/images/mapCompass.png")});`
      ),
      this._compass.addEventListener(hy.DOWN, this.handleCenterBtnClick),
      this._element.appendChild(this._up),
      this._element.appendChild(this._down),
      this._element.appendChild(this._left),
      this._element.appendChild(this._right),
      this._element.appendChild(this._compass),
      this._engine.rendering.addPrepareRenderListener(() => {
        this._compass.style.transform = `rotate(${this._engine.map.getHeading()}deg)`;
      }),
      this._element
    );
  }
  handleUpBtnClick() {
    const e = this._engine.map.getPitch();
    let t = e + 2;
    (t = t > 89 ? 89 : t < 0 ? 0 : t), e !== t && this._engine.map.setPitch(t);
  }
  handleDownBtnClick() {
    const e = this._engine.map.getPitch();
    let t = e - 2;
    (t = t > 89 ? 89 : t < 0 ? 0 : t), e !== t && this._engine.map.setPitch(t);
  }
  handleLeftBtnClick() {
    let e = this._engine.map.getHeading() - 2;
    this._engine.map.setHeading((e + 360) % 360);
  }
  handleRightBtnClick() {
    let e = this._engine.map.getHeading() + 2;
    this._engine.map.setHeading(e % 360);
  }
  handleCenterBtnClick() {
    this._engine.map.setHeading(0);
  }
  onDispose() {
    this._up.removeEventListener(hy.DOWN, this.handleUpBtnClick),
      this._down.removeEventListener(hy.DOWN, this.handleDownBtnClick),
      this._left.removeEventListener(hy.DOWN, this.handleLeftBtnClick),
      this._right.removeEventListener(hy.DOWN, this.handleRightBtnClick),
      this._compass.removeEventListener(hy.DOWN, this.handleCenterBtnClick);
  }
}
class Ub {
  constructor(e, n = {}) {
    publicField(this, "_container"),
      publicField(this, "_engine"),
      publicField(this, "_logo"),
      publicField(this, "_zoom"),
      publicField(this, "_scale"),
      publicField(this, "_fullscreen"),
      publicField(this, "_geoLocate"),
      publicField(this, "_exportImage"),
      publicField(this, "_mapInfo"),
      publicField(this, "_compass");
    const s = e.container,
      r =
        s instanceof HTMLElement ||
        (s &&
          "object" == typeof s &&
          1 === s.nodeType &&
          "string" == typeof s.nodeName);
    this._container = r ? s : s.container || s._container;
    const a = document.createElement("div");
    (a.id = `${t}-controls`),
      i(a, `${t}-controls-pane`),
      this._container.appendChild(a);
    const o = document.createElement("div");
    i(o, "bottom-right-anchor"),
      (this._zoom = new Ib(o, n.zoom, e)),
      (this._compass = new Ob(o, n.compass, e)),
      a.appendChild(o);
    const l = document.createElement("div");
    i(l, "bottom-left-anchor"),
      a.appendChild(l),
      (this._fullscreen = new Db(l, n.fullscreen, e)),
      (this._exportImage = new Fb(l, n.exportImage, e)),
      (this._geoLocate = new Lb(l, n.geoLocate, e)),
      (this._logo = new Tb(a, n.logo, e)),
      (this._scale = new Rb(a, n.scale, e)),
      (this._mapInfo = new Nb(a, n.mapInfo, e)),
      (this._drawer = new kb(a, n.drawer, e));
  }
  dispose() {
    this._logo.dispose(),
      this._zoom.dispose(),
      this._scale.dispose(),
      this._fullscreen.dispose(),
      this._geoLocate.dispose(),
      this._exportImage.dispose(),
      this._mapInfo.dispose(),
      this._compass.dispose(),
      this._drawer.dispose();
  }
  get container() {
    return this._container;
  }
  get engine() {
    return this._engine;
  }
  get compass() {
    return this._compass;
  }
  get logo() {
    return this._logo;
  }
  get zoom() {
    return this._zoom;
  }
  get scale() {
    return this._scale;
  }
  get fullscreen() {
    return this._fullscreen;
  }
  get geoLocate() {
    return this._geoLocate;
  }
  get exportImage() {
    return this._exportImage;
  }
  get mapInfo() {
    return this._mapInfo;
  }
  get drawer() {
    return this._drawer;
  }
}
(qn.mvt_uniform_zoomunits_pars = "#define GLSLIFY 1\n"),
  (qn.mvt_extra_vertex_utils =
    "#define GLSLIFY 1\nfloat getPixelSize(vec3 position) {\n    // projectionMatrix第5位含义为可视区域高/宽\n    return 0.1 * projectionMatrix[1][1] / resolution.y * distance(cameraPosition, position);\n}\n"),
  (qn.mvt_selective_pars_vertex =
    "#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nattribute float objectIndex;\nuniform float selectedObjectIndex;\nvarying float isSelected;\n#endif"),
  (qn.mvt_selective_vertex =
    "#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nif (objectIndex == selectedObjectIndex) {\n\tisSelected = 1.0;\n} else {\n\tisSelected = 0.0;\n}\n#endif"),
  (qn.mvt_selective_pars_fragment =
    "#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nvarying float isSelected;\nuniform vec4 selectedObjectColor;\nuniform float selectedObjectColorMode;\n#endif"),
  (qn.mvt_selective_fragment =
    "#define GLSLIFY 1\n#ifdef MVT_ENABLE_SELECTIVE\nif (isSelected == 1.0) {\n\tif (selectedObjectColorMode == 1.) {\n\t\tgl_FragColor = selectedObjectColor;\n\t} else {\n\t\tgl_FragColor.rgb = selectedObjectColor.rgb * selectedObjectColor.a + gl_FragColor.rgb * (1.0 - selectedObjectColor.a);\n\t}\n\t\n}\n#endif"),
  (qn.mvt_keepsize_pars_vertex =
    "#define GLSLIFY 1\nuniform bool keepSize;\nuniform float pixelRatio;\nuniform vec2 resolution;\n"),
  (qn.mvt_keepsize_vertex =
    "#define GLSLIFY 1\nvec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\nfloat pixelSize = getPixelSize(worldPosition.xyz);\nif (keepSize) {\n    transformed *= pixelSize;\n}\n"),
  (qn.mvt_emissive_pars_fragment =
    "#define GLSLIFY 1\n#define MVT_EMISSIVE_SHADER\n\nuniform vec3 emissive;"),
  (qn.mvt_emissive_fragment =
    "#define GLSLIFY 1\n#ifdef MVT_EMISSIVE_SHADER\n    vec4 out_emissive = vec4(emissive.rgb, 1.0);\n#endif"),
  (qn.mvt_override_standard_emissivemap_pars_fragment =
    "#define GLSLIFY 1\n#ifdef USE_EMISSIVEMAP\n\n\tuniform sampler2D emissiveMap;\n\n#endif"),
  (qn.mvt_override_standard_emissivemap_fragment =
    "#define GLSLIFY 1\n#ifdef USE_EMISSIVEMAP\n\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\n\t// emissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n\n    \n#endif\n\nif (isEmissive) {\n    gl_FragColor = vec4(totalEmissiveRadiance, 1.0);\n\t#if defined( TONE_MAPPING )\n\t    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n    #endif\n    return;\n}"),
  (qn.mvt_override_basic_color_pars_fragment =
    "#define GLSLIFY 1\n#ifdef USE_COLOR\n\n\tvarying vec3 vColor;\n\n#endif"),
  (qn.mvt_override_basic_color_fragment =
    "#define GLSLIFY 1\nif (isEmissive) {\n    gl_FragColor = vec4(emissive, 1.0);\n    #if defined( TONE_MAPPING )\n\t    gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n    #endif\n    return;\n}\n#ifdef USE_COLOR\n\n\tdiffuseColor.rgb *= vColor;\n\n#endif"),
  (qn.mvt_animation_pars_vertex =
    "#define GLSLIFY 1\nuniform bool animationPeriodOffset;\n\n#ifdef ENABLE_ANIMATION_ROTATE\nuniform float animationRotatePeriod;\n#endif\n\n#ifdef ENABLE_ANIMATION_JUMP\nuniform float animationJumpPeriod;\nuniform float animationJumpHeight;\n#endif\n\n#ifdef ENABLE_ANIMATION_SCALE\nuniform float animationPeriod;\nuniform float targetScale;\nuniform bool opacityGradient;\n#endif\n\n#ifdef ENABLE_ANIMATION_BREATH\nuniform float animationPeriod;\nuniform float maxScale;\nuniform float minScale;\nuniform bool opacityGradient;\n#endif"),
  (qn.mvt_animation_vertex =
    "#define GLSLIFY 1\n#ifdef ENABLE_ANIMATION_ROTATE\n    float rotateRatio = mod(elapsedTime, animationRotatePeriod) / animationRotatePeriod;\n    if (animationPeriodOffset) {\n        rotateRatio = mod(rotateRatio + instancedRandomFactor, 1.0);\n    }\n    float rotation = rotateRatio * 6.28;\n    vec2 rotatedPosition;\n    rotatedPosition.x = cos( rotation ) * transformed.x - sin( rotation ) * transformed.y;\n    rotatedPosition.y = sin( rotation ) * transformed.x + cos( rotation ) * transformed.y;\n    transformed.xy = rotatedPosition;\n#endif\n\n#ifdef ENABLE_ANIMATION_JUMP\n    float jumpRatio = mod(elapsedTime, animationJumpPeriod) / animationJumpPeriod;\n    if (animationPeriodOffset) {\n        jumpRatio = mod(jumpRatio + instancedRandomFactor, 1.0);\n    }\n    if (jumpRatio <= 0.5) {\n        jumpRatio *= 2.0;\n        jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n    } else {\n        jumpRatio = (1.0 - jumpRatio) * 2.0;\n        jumpRatio = jumpRatio * jumpRatio * jumpRatio;\n    }\n    #ifdef USE_SIZE3\n        transformed.z += jumpRatio * animationJumpHeight / size3.z;\n    #else\n        transformed.z += jumpRatio * animationJumpHeight / size;\n    #endif\n#endif\n\n#ifdef ENABLE_ANIMATION_SCALE\n    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;\n    if (animationPeriodOffset) {\n        scaleRatio = mod(scaleRatio + instancedRandomFactor, 1.0);\n    }\n\n    vScale *= 1.0 + (targetScale - 1.0) * scaleRatio;\n\n    if (opacityGradient) {\n        if (targetScale > 1.0) {\n            opacityRatio = 1.0 - (targetScale - 1.0) * scaleRatio;\n        } else {\n            opacityRatio = 1.0 + (targetScale - 1.0) * scaleRatio;\n        }\n    }\n\n#endif\n\n#ifdef ENABLE_ANIMATION_BREATH\n    float scaleRatio = mod(elapsedTime, animationPeriod) / animationPeriod;\n    if (animationPeriodOffset) {\n        scaleRatio = mod(scaleRatio + instancedRandomFactor, 1.0);\n    }\n    float repeatNum = scaleRatio / 0.25;\n    float scaleFactor = mod(scaleRatio, 0.25) / 0.25;\n    float scaleNum = scaleFactor * (maxScale - 1.0);\n    float balance = (maxScale + minScale) / 2.0;\n\n    if (repeatNum > 1.0 && repeatNum < 3.0) {\n        // 下降\n        if (repeatNum < 2.0) {\n            scaleNum = (1.0 - scaleFactor) * (maxScale - balance);\n        } else {\n            scaleNum = -scaleFactor * (balance - minScale);\n        }\n    } else if (repeatNum >= 3.0) {\n        scaleNum = -(1.0 - scaleFactor) * (balance - minScale);\n    }\n\n    vScale *= balance + scaleNum;\n\n    if (opacityGradient) {\n        opacityRatio = (balance + scaleNum) / maxScale;\n    }\n\n#endif"),
  (qn.mvt_mrt_output_pars_fragment =
    "#define GLSLIFY 1\n#ifndef DISABLE_MRT\n    // layout(location = 1) out highp vec4 pc_fragColor1;\n    // layout(location = 2) out highp vec4 pc_fragColor2;\n    // layout(location = 3) out highp vec4 pc_fragColor3;\n    // layout(location = 4) out highp vec4 pc_fragColor4;\n    // layout(location = 5) out highp vec4 pc_fragColor5;\n    // layout(location = 6) out highp vec4 pc_fragColor6;\n    // layout(location = 7) out highp vec4 pc_fragColor7;\n    #if defined(MVT_MRT_OUT_EMISSIVE)\n        #if MVT_MRT_OUT_EMISSIVE == 1\n            layout(location = 1) out highp vec4 mvt_pc_emissive;\n        #elif MVT_MRT_OUT_EMISSIVE == 2\n            layout(location = 2) out highp vec4 mvt_pc_emissive;\n        #elif MVT_MRT_OUT_EMISSIVE == 3\n            layout(location = 3) out highp vec4 mvt_pc_emissive;\n        #elif MVT_MRT_OUT_EMISSIVE == 4\n            layout(location = 4) out highp vec4 mvt_pc_emissive;\n        #endif\n    #endif\n\n    #if defined(MVT_MRT_OUT_NORMAL)\n        #if MVT_MRT_OUT_NORMAL == 1\n            layout(location = 1) out highp vec4 mvt_pc_normal;\n        #elif MVT_MRT_OUT_NORMAL == 2\n            layout(location = 2) out highp vec4 mvt_pc_normal;\n        #elif MVT_MRT_OUT_NORMAL == 3\n            layout(location = 3) out highp vec4 mvt_pc_normal;\n        #elif MVT_MRT_OUT_NORMAL == 4\n            layout(location = 4) out highp vec4 mvt_pc_normal;\n        #endif\n    #endif\n\n    #if defined(MVT_MRT_OUT_METALLICROUGH)\n        #if MVT_MRT_OUT_METALLICROUGH == 1\n            layout(location = 1) out highp vec4 mvt_pc_metallicRough;\n        #elif MVT_MRT_OUT_METALLICROUGH == 2\n            layout(location = 2) out highp vec4 mvt_pc_metallicRough;\n        #elif MVT_MRT_OUT_METALLICROUGH == 3\n            layout(location = 3) out highp vec4 mvt_pc_metallicRough;\n        #elif MVT_MRT_OUT_METALLICROUGH == 4\n            layout(location = 4) out highp vec4 mvt_pc_metallicRough;\n        #endif\n    #endif\n#endif\n\n#if defined(MVT_EMISSIVE_UNIFORM)\n// 发光颜色自定义\n    #if defined(MVT_EMISSIVE_COLOR)\n        uniform vec3 mvt_emissive;\n    #endif  \n    uniform float mvt_emissiveIntensity;\n#endif"),
  (qn.mvt_mrt_output_fragment =
    "#define GLSLIFY 1\n#ifndef DISABLE_MRT\n    // 自定义发光颜色，完全由着色器控制 在着色器中输出 vec4 out_emissive;\n    #ifdef MVT_MRT_OUT_EMISSIVE\n        #if defined(MVT_EMISSIVE_SHADER)\n            mvt_pc_emissive = out_emissive;\n        #elif defined(STANDARD)\n            mvt_pc_emissive.rgb = totalEmissiveRadiance;\n            mvt_pc_emissive.a = pc_fragColor.a;\n        #elif defined(PHONG)\n            mvt_pc_emissive.rgb = totalEmissiveRadiance;\n            mvt_pc_emissive.a = pc_fragColor.a;\n        #elif defined(BASIC)\n            mvt_pc_emissive.rgb = emissive;\n            mvt_pc_emissive.a = pc_fragColor.a;\n        // 通过传入的uniform变量颜色自发光\n        #elif defined(MVT_EMISSIVE_UNIFORM)\n            // 发光颜色自定义\n            #if defined(MVT_EMISSIVE_COLOR)\n                mvt_pc_emissive.rgb = mvt_emissive * mvt_emissiveIntensity;\n                mvt_pc_emissive.a = pc_fragColor.a;\n            #else  \n                mvt_pc_emissive = pc_fragColor * mvt_emissiveIntensity;\n            #endif\n        #else\n            mvt_pc_emissive = vec4(0.0, 0.0, 0.0, 0.0);\n        #endif  \n    #endif\n\n    #ifdef MVT_MRT_OUT_NORMAL\n        #if defined(STANDARD)\n            #ifndef FLAT_SHADED\n                mvt_pc_normal = vec4(packNormalToRGB(vNormal), gl_FragCoord.z);\n            #else\n                mvt_pc_normal = vec4(0.0, 0.0, 0.0, 0.0);\n            #endif\n        #else\n            #if defined(MVT_FRAG_NORMAL)\n                mvt_pc_normal = vec4(packNormalToRGB(mvt_frag_normal), 1.0);\n            #else\n                mvt_pc_normal = vec4(0.0, 0.0, 0.0, 0.0);\n            #endif\n        #endif\n    #endif\n\n    #ifdef MVT_MRT_OUT_METALLICROUGH\n        #if defined(STANDARD)\n            mvt_pc_metallicRough = vec4(1.0 - material.roughness, 0.0, 0.0, 1.0);\n        #else\n            float temp_reflectionFactor = 0.0;\n            #if defined(MVT_FRAG_REFLECTION_FACTOR)\n                temp_reflectionFactor = mvt_frag_reflectionFactor;\n            #endif\n            mvt_pc_metallicRough = vec4(temp_reflectionFactor, 0.0, 0.0, 0.0);\n        #endif\n    #endif\n    \n    // pc_fragColor4 = vec4(1.0, 0.0, 1.0, 1.0);\n    // pc_fragColor5 = vec4(0.0, 1.0, 0.0, 1.0);\n    // pc_fragColor6 = vec4(0.0, 1.0, 0.0, 1.0);\n    // pc_fragColor7 = vec4(0.0, 1.0, 0.0, 1.0);\n#endif\n"),
  (qn.mvt_nmrt_output_pars_fragment =
    "#define GLSLIFY 1\n#if defined(MVT_EMISSIVE_UNIFORM)\n    // 发光颜色自定义\n    #if defined(MVT_EMISSIVE_COLOR)\n        uniform vec3 mvt_emissive;\n    #endif  \n    uniform float mvt_emissiveIntensity;\n#endif\nuniform bool isEmissive;"),
  (qn.mvt_nmrt_output_fragment =
    "#define GLSLIFY 1\n// if (isEmissive) {\n#if defined(MVT_MODE_EMISSIVE)\n    #if defined(MVT_EMISSIVE_SHADER)\n        gl_FragColor = out_emissive;\n    #elif defined(STANDARD)\n        gl_FragColor.rgb = totalEmissiveRadiance;\n    #elif defined(PHONG)\n        gl_FragColor.rgb = totalEmissiveRadiance;\n    #elif defined(BASIC)\n        gl_FragColor.rgb = emissive;\n    // 通过传入的uniform变量颜色自发光\n    #elif defined(MVT_EMISSIVE_UNIFORM)\n        // 发光颜色自定义\n        #if defined(MVT_EMISSIVE_COLOR)\n            gl_FragColor.rgb = mvt_emissive * mvt_emissiveIntensity;\n        #else\n            gl_FragColor = gl_FragColor * mvt_emissiveIntensity;\n        #endif\n    #else\n        gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);\n    #endif\n#endif\n//}"),
  (qn.mvt_extra_meshbasic_frag_pars =
    "#define GLSLIFY 1\n#define BASIC\nuniform vec3 emissive;"),
  (qn.mvt_clip_pars_vertex =
    "#define GLSLIFY 1\n#ifdef USE_CLIP\n    varying vec3 clip_position;\n    varying mat4 clip_modelMat4;\n    #ifdef IS_INSTANCE\n        varying mat4 clip_instanceMat4;\n    #endif\n#endif"),
  (qn.mvt_clip_vertex =
    "#define GLSLIFY 1\n#ifdef USE_CLIP\n    clip_position = position;\n    clip_modelMat4 = modelMatrix;\n    #ifdef IS_INSTANCE\n        clip_instanceMat4 = instanceMatrix;\n    #endif\n#endif\n"),
  (qn.mvt_clip_pars_fragment =
    "#define GLSLIFY 1\n#ifdef USE_CLIP\n\n    varying vec3 clip_position;\n    varying mat4 clip_modelMat4;\n    #ifdef IS_INSTANCE\n        varying mat4 clip_instanceMat4;\n    #endif\n\n    struct ClipParameters {\n        vec3 u_polygon[20];\n        int clip_type;\n        vec2 clip_point;\n        float clip_radius;\n        float clip_width;\n        float clip_height;\n        int clip_polygonCount;\n    };\n\n    uniform ClipParameters mvt_clipParameters;\n\n    bool pointInPolygon(vec3 p) {\n    bool inside = false;\n    int length = mvt_clipParameters.clip_polygonCount;\n    vec3 points[20] = mvt_clipParameters.u_polygon;\n    for (int i = 0; i < length; i++) {\n        float xi = points[i].x;\n        float yi = points[i].y;\n        float xj;\n        float yj;\n        if(i == 0) {\n            xj = points[length -1].x;\n            yj = points[length -1].y;\n        }\n        else {\n            xj = points[i - 1].x;\n            yj = points[i - 1].y;\n        }\n        bool intersect = ((yi > p.y) != (yj > p.y))\n                && (p.x < (xj - xi) * (p.y - yi) / (yj - yi) + xi);\n            if (intersect) {\n                inside = !inside;\n            }\n        }\n    return inside;\n    }\n\n    bool pointInCircle(vec2 point) {\n        float distance = length(point - mvt_clipParameters.clip_point);\n        return distance < mvt_clipParameters.clip_radius;\n    }\n\n    bool pointInRect(vec2 point) {\n        return (point.x > mvt_clipParameters.clip_point.x \n            && point.x < mvt_clipParameters.clip_point.x + mvt_clipParameters.clip_width\n            && point.y > mvt_clipParameters.clip_point.y \n            && point.y < mvt_clipParameters.clip_point.y + mvt_clipParameters.clip_height);\n    }\n\n#endif"),
  (qn.mvt_clip_fragment =
    "#define GLSLIFY 1\n#ifdef USE_CLIP\n    vec4 worldCoord;\n\n    #ifdef CUSTOM_WORLD_COORD\n        worldCoord = vec4(vMP, 1.0);\n    #else\n        #ifdef IS_INSTANCE\n            worldCoord = clip_modelMat4 * clip_instanceMat4 * vec4(clip_position, 1.0);\n        #else\n            worldCoord = clip_modelMat4 * vec4(clip_position, 1.0);\n        #endif\n    #endif\n    bool isInside = false;\n    if (mvt_clipParameters.clip_type == 0) {\n        isInside = pointInPolygon(worldCoord.xyz / worldCoord.w);\n    }\n    else if (mvt_clipParameters.clip_type == 1) {\n        isInside = pointInCircle(worldCoord.xy / worldCoord.w);\n    }\n    else if (mvt_clipParameters.clip_type == 2) {\n        isInside = pointInRect(worldCoord.xy / worldCoord.w);\n    }\n    if (!isInside) {\n        discard;\n    }\n#endif"),
  (qn.mvt_depth_packing =
    "#define GLSLIFY 1\nfloat mvt_linearize_depth(in float depth, in float cameraNear, in float cameraFar){\n    float a = cameraFar / (cameraFar - cameraNear);\n    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n    return a + b / depth;\n}\n\nfloat mvt_reconstruct_depth(sampler2D tDepth, const in vec2 uv, in float cameraNear, in float cameraFar){\n    float depth = texture2D(tDepth, uv).x;\n    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n}\n\nfloat mvtGetDepthFromTexture(sampler2D tDepth, vec2 uv, in float cameraNear, in float cameraFar) {\n    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n        return mvt_linearize_depth(mvt_reconstruct_depth(tDepth, uv, cameraNear, cameraFar), cameraNear, cameraFar);\n    #else\n        return texture2D(tDepth, uv).x;\n    #endif\n}\nvec3 mvtGetWorldPostionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix, mat4 viewInverseMatrix) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);\n\n    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];\n    // clipSpacePosition *= clipW;\n    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;\n    \n    // viewSpacePosition /= viewSpacePosition.w;\n    // return viewSpacePosition.xyz;\n    vec4 worldSpacePosition = viewInverseMatrix * viewSpacePosition;\n\n    return worldSpacePosition.xyz / worldSpacePosition.w;\n}\n\nvec3 mvtGetViewPostionByDepth(float depth, vec2 uv, mat4 projectionInverseMatrix) {\n    float z = depth * 2.0 - 1.0;\n    vec4 clipSpacePosition = vec4(uv * 2.0 - 1.0, z, 1.0);\n\n    // float viewZ = perspectiveDepthToViewZ(depth, cameraNear, cameraFar);\n    // float clipW = mvt_projectionMatrix[2][3] * viewZ + mvt_projectionMatrix[3][3];\n    // clipSpacePosition *= clipW;\n    vec4 viewSpacePosition = projectionInverseMatrix * clipSpacePosition;\n    \n    viewSpacePosition /= viewSpacePosition.w;\n    return viewSpacePosition.xyz;\n\n}\n"),
  (Oi.prototype.emissiveIntensity = 1),
  (Yn.basic.uniforms.emissive = { value: new Color(0) }),
  (Yn.basic.uniforms.isEmissive = { value: !1 });
class zb extends Al {
  constructor(e) {
    super(e), (this.type = G);
  }
  parse(e) {
    const t = function (e, t) {
        switch (e) {
          case 1:
            throw new Error("THREE.RGBELoader: Read Error: " + (t || ""));
          case 2:
            throw new Error("THREE.RGBELoader: Write Error: " + (t || ""));
          case 3:
            throw new Error("THREE.RGBELoader: Bad File Format: " + (t || ""));
          default:
            throw new Error("THREE.RGBELoader: Memory Error: " + (t || ""));
        }
      },
      i = function (e, t, i) {
        t = t || 1024;
        let n = e.pos,
          s = -1,
          r = 0,
          a = "",
          o = String.fromCharCode.apply(
            null,
            new Uint16Array(e.subarray(n, n + 128))
          );
        for (; 0 > (s = o.indexOf("\n")) && r < t && n < e.byteLength; )
          (a += o),
            (r += o.length),
            (n += 128),
            (o += String.fromCharCode.apply(
              null,
              new Uint16Array(e.subarray(n, n + 128))
            ));
        return -1 < s && (!1 !== i && (e.pos += r + s + 1), a + o.slice(0, s));
      },
      n = function (e, t, i, n) {
        const s = e[t + 3],
          r = Math.pow(2, s - 128) / 255;
        (i[n + 0] = e[t + 0] * r),
          (i[n + 1] = e[t + 1] * r),
          (i[n + 2] = e[t + 2] * r),
          (i[n + 3] = 1);
      },
      s = function (e, t, i, n) {
        const s = e[t + 3],
          r = Math.pow(2, s - 128) / 255;
        (i[n + 0] = Qi.toHalfFloat(Math.min(e[t + 0] * r, 65504))),
          (i[n + 1] = Qi.toHalfFloat(Math.min(e[t + 1] * r, 65504))),
          (i[n + 2] = Qi.toHalfFloat(Math.min(e[t + 2] * r, 65504))),
          (i[n + 3] = Qi.toHalfFloat(1));
      },
      r = new Uint8Array(e);
    r.pos = 0;
    const a = (function (e) {
        const n = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
          s = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
          r = /^\s*FORMAT=(\S+)\s*$/,
          a = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
          o = {
            valid: 0,
            string: "",
            comments: "",
            programtype: "RGBE",
            format: "",
            gamma: 1,
            exposure: 1,
            width: 0,
            height: 0,
          };
        let l, h;
        for (
          (e.pos >= e.byteLength || !(l = i(e))) && t(1, "no header found"),
            (h = l.match(/^#\?(\S+)/)) || t(3, "bad initial token"),
            o.valid |= 1,
            o.programtype = h[1],
            o.string += l + "\n";
          (l = i(e)), !1 !== l;

        )
          if (((o.string += l + "\n"), "#" !== l.charAt(0))) {
            if (
              ((h = l.match(n)) && (o.gamma = parseFloat(h[1])),
              (h = l.match(s)) && (o.exposure = parseFloat(h[1])),
              (h = l.match(r)) && ((o.valid |= 2), (o.format = h[1])),
              (h = l.match(a)) &&
                ((o.valid |= 4),
                (o.height = parseInt(h[1], 10)),
                (o.width = parseInt(h[2], 10))),
              2 & o.valid && 4 & o.valid)
            )
              break;
          } else o.comments += l + "\n";
        return (
          2 & o.valid || t(3, "missing format specifier"),
          4 & o.valid || t(3, "missing image size specifier"),
          o
        );
      })(r),
      o = a.width,
      l = a.height,
      h = (function (e, i, n) {
        const s = i;
        if (s < 8 || s > 32767 || 2 !== e[0] || 2 !== e[1] || 128 & e[2])
          return new Uint8Array(e);
        s !== ((e[2] << 8) | e[3]) && t(3, "wrong scanline width");
        const r = new Uint8Array(4 * i * n);
        r.length || t(4, "unable to allocate buffer space");
        let a = 0,
          o = 0;
        const l = 4 * s,
          h = new Uint8Array(4),
          c = new Uint8Array(l);
        let u = n;
        for (; u > 0 && o < e.byteLength; ) {
          o + 4 > e.byteLength && t(1),
            (h[0] = e[o++]),
            (h[1] = e[o++]),
            (h[2] = e[o++]),
            (h[3] = e[o++]),
            (2 == h[0] && 2 == h[1] && ((h[2] << 8) | h[3]) == s) ||
              t(3, "bad rgbe scanline format");
          let i,
            n = 0;
          for (; n < l && o < e.byteLength; ) {
            i = e[o++];
            const s = i > 128;
            if (
              (s && (i -= 128),
              (0 === i || n + i > l) && t(3, "bad scanline data"),
              s)
            ) {
              const t = e[o++];
              for (let e = 0; e < i; e++) c[n++] = t;
            } else c.set(e.subarray(o, o + i), n), (n += i), (o += i);
          }
          const d = s;
          for (let e = 0; e < d; e++) {
            let t = 0;
            (r[a] = c[e + t]),
              (t += s),
              (r[a + 1] = c[e + t]),
              (t += s),
              (r[a + 2] = c[e + t]),
              (t += s),
              (r[a + 3] = c[e + t]),
              (a += 4);
          }
          u--;
        }
        return r;
      })(r.subarray(r.pos), o, l);
    let c, u, d;
    switch (this.type) {
      case z:
        d = h.length / 4;
        const e = new Float32Array(4 * d);
        for (let i = 0; i < d; i++) n(h, 4 * i, e, 4 * i);
        (c = e), (u = z);
        break;
      case G:
        d = h.length / 4;
        const t = new Uint16Array(4 * d);
        for (let i = 0; i < d; i++) s(h, 4 * i, t, 4 * i);
        (c = t), (u = G);
        break;
      default:
        throw new Error("THREE.RGBELoader: unsupported type: ", this.type);
    }
    return {
      width: o,
      height: l,
      data: c,
      header: a.string,
      gamma: a.gamma,
      exposure: a.exposure,
      type: u,
    };
  }
  setDataType(e) {
    return (this.type = e), this;
  }
  load(e, t, i, n) {
    return super.load(
      e,
      function (e, i) {
        switch (e.type) {
          case z:
          case G:
            (e.colorSpace = ge),
              (e.minFilter = L),
              (e.magFilter = L),
              (e.generateMipmaps = !1),
              (e.flipY = !0);
        }
        t && t(e, i);
      },
      i,
      n
    );
  }
}
class Gb extends pl {
  constructor(e) {
    super(e), (this.hdrLoader = new zb()), (this.type = G);
  }
  load(e, t, i, n) {
    const s = new Nn();
    switch (((s.type = this.type), s.type)) {
      case z:
      case G:
        (s.colorSpace = ge),
          (s.minFilter = L),
          (s.magFilter = L),
          (s.generateMipmaps = !1);
    }
    const r = this;
    let a = 0;
    function o(t, i, n, o) {
      new gl(r.manager)
        .setPath(r.path)
        .setResponseType("arraybuffer")
        .setWithCredentials(r.withCredentials)
        .load(
          e[t],
          function (e) {
            a++;
            const n = r.hdrLoader.parse(e);
            if (n) {
              if (void 0 !== n.data) {
                const e = new Va(n.data, n.width, n.height);
                (e.type = s.type),
                  (e.colorSpace = s.colorSpace),
                  (e.format = s.format),
                  (e.minFilter = s.minFilter),
                  (e.magFilter = s.magFilter),
                  (e.generateMipmaps = s.generateMipmaps),
                  (s.images[t] = e);
              }
              6 === a && ((s.needsUpdate = !0), i && i(s));
            }
          },
          n,
          o
        );
    }
    for (let l = 0; l < e.length; l++) o(l, t, i, n);
    return s;
  }
  setDataType(e) {
    return (this.type = e), this.hdrLoader.setDataType(e), this;
  }
}
const Vb = { map: { value: null }, isEmissive: { value: !1 } };
class Qb extends ShaderMaterial {
  constructor(e) {
    super(),
      (this.defines = {}),
      (this.uniforms = In.clone(Vb)),
      (this.side = 2),
      (this.vertexShader =
        "#define GLSLIFY 1\nvarying vec2 vUv;\n\nvoid main()\n{\n    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);\n    vUv = uv;\n    gl_Position = projectionMatrix * viewPos;\n    gl_Position.z = gl_Position.w;\n}\n"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\nvarying vec2 vUv;\nuniform sampler2D map;\nvoid main() {\n\n    gl_FragColor = texture2D(map, vUv);\n\n    #include <colorspace_fragment>\n}\n"),
      (this.depthWrite = !1),
      (this.depthTest = !1),
      (this.envMap = null),
      N_(this, ["isEmissive"]),
      Object.defineProperties(this, {
        map: {
          get: function () {
            return this.uniforms.map.value;
          },
          set: function (e) {
            (this.uniforms.map.value = e), (this.needsUpdate = !0);
          },
        },
      });
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(),
      super.dispose();
  }
}
class Hb extends Wm {
  constructor(e = {}) {
    super(),
      publicField(this, "isCustomStaticSky", !0),
      publicField(this, "_textureIsCube", !1),
      publicField(this, "_textureIsHDR", !1),
      publicField(this, "_textureURL", null),
      publicField(this, "_textureNames", null),
      publicField(this, "_affectWorld", !0),
      publicField(this, "_isVerticalTexture", null),
      publicField(this, "_mesh", null),
      publicField(this, "_material", null),
      publicField(this, "_sphereGeometry", null),
      publicField(this, "_envTexture", null),
      publicField(this, "_engine", null),
      publicField(this, "_PMREMGenerator", null),
      e.texture;
    const t = (this._sphereGeometry = new Uo(1, 32, 32));
    this.isVerticalTexture = e.isVerticalTexture || !1;
    const i = (this._mesh = new En(t, this._material));
    (i.frustumCulled = !1),
      (i.collisionDisabled = !0),
      i.scale.setScalar(1e4),
      i.rotateX(Math.PI / 2),
      this.add(i);
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e),
      (this._engine = e),
      (this._PMREMGenerator = new ds(e.renderer)),
      this._loadSkyTexture();
  }
  onBeforeScenePrepareRender(e, t, i) {
    this._mesh.position.copy(i.position), super.onBeforeScenePrepareRender(e);
  }
  _loadSkyTexture() {
    if (!this._engine || !this._textureURL) return;
    let e = null;
    e = this._textureIsHDR
      ? this._textureIsCube
        ? new Gb()
        : new zb()
      : this._textureIsCube
      ? new vl()
      : new yl();
    const t = this._engine.rendering.scene;
    let i = null;
    this._textureIsCube
      ? (e.setPath(this._textureURL),
        (i = this._textureNames
          ? this._textureNames
          : this._textureIsHDR
          ? ["nz.HDR", "pz.HDR", "px.HDR", "nx.HDR", "py.HDR", "ny.HDR"]
          : ["px.jpg", "nx.jpg", "py.jpg", "ny.jpg", "pz.jpg", "nz.jpg"]))
      : (i = this._textureURL),
      e.load(i, (e) => {
        this._textureIsCube
          ? ((this._mesh.visible = !1),
            (e.colorSpace = me),
            (t.background = e),
            (this._envTexture = this._PMREMGenerator.fromCubemap(e).texture),
            this._affectWorld && (t.environment = this._envTexture))
          : ((t.background = null),
            (this._mesh.visible = !0),
            (e.colorSpace = me),
            (this._material.map = e),
            (this._material.needsUpdate = !0),
            this._isVerticalTexture
              ? (t.environment = null)
              : ((this._envTexture =
                  this._PMREMGenerator.fromEquirectangular(e).texture),
                this._affectWorld && (t.environment = this._envTexture))),
          this._engine.requestRender();
      });
  }
  get isVerticalTexture() {
    return this._verticalTexture;
  }
  set isVerticalTexture(e) {
    e !== this._isVerticalTexture &&
      (this._material && this._material.dispose(),
      (this._material = new Qb()),
      (this._isVerticalTexture = e),
      this._mesh && (this._mesh.material = this._material));
  }
  get textureURL() {
    return this._textureURL;
  }
  set textureURL(e) {
    (this._textureURL = e), this._loadSkyTexture();
  }
  get affectWorld() {
    return this._affectWorld;
  }
  set affectWorld(e) {
    const t = this._engine.rendering.scene;
    e
      ? ((this._affectWorld = !0), (t.environment = this._envTexture))
      : ((this._affectWorld = !1),
        t.environment === this._envTexture && (t.environment = null));
  }
}
const jb =
    "#define GLSLIFY 1\nvarying vec2 vUv;\nvoid main() {\n\n    vUv = uv;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\n}",
  Wb =
    "#define GLSLIFY 1\nconst float PI = 3.14159265358;\n\n// Units are in megameters.\nconst float groundRadiusMM = 6.371;\nconst float atmosphereRadiusMM = 6.471;\n\nconst vec2 tLUTRes = vec2(256.0, 64.0)*1.;\nconst vec2 msLUTRes = vec2(32.0, 32.0)*1.;\nconst vec2 skyLUTRes = vec2(200.0, 200.0)*2.;\n\nconst vec3 groundAlbedo = vec3(0.1);\n\n// These are per megameter.\nconst vec3 rayleighScatteringBase = vec3(5.802, 13.558, 33.1);\nconst float rayleighAbsorptionBase = 0.0;\n\nconst float mieScatteringBase = 3.996;\nconst float mieAbsorptionBase = 4.4;\n\nconst vec3 ozoneAbsorptionBase = vec3(0.650, 1.881, .085);\n\n// Quality\nconst float sunTransmittanceSteps = 40.0;\nconst float mulScattSteps = 20.0;\nconst int sqrtSamples = 8;\n\nconst int numScatteringSteps = 16;\n\nuniform float altitude;\nuniform float viewHeight;\n/*\n * Animates the sun movement.\n */\nfloat getSunAltitude(float time)\n{\n    const float periodSec = 10.0;\n    return (PI)*time/periodSec - PI/24.;\n}\nvec3 getSunDir(float time)\n{\n    // float altitude = getSunAltitude(time);\n    // altitude = 2.8;\n    return normalize(vec3(cos(altitude), sin(altitude), 0.0));\n}\n\n/* Animate camera */\nvec3 getViewPos(float time){\n\n    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0002 + viewHeight, 0.0);\n\n    // anything beyond about 7 falls apart because the skyview lut doesn't have enough resolution\n    float alt_range = 50.0;\n\n    // viewPos.y += (sin(time/10.0 - PI/2.)*.5+.5) * (atmosphereRadiusMM - groundRadiusMM) * alt_range;\n\n    return viewPos;\n}\n\nfloat getMiePhase(float cosTheta) {\n    const float g = 0.8;\n    const float scale = 3.0/(8.0*PI);\n\n    float num = (1.0-g*g)*(1.0+cosTheta*cosTheta);\n    float denom = (2.0+g*g)*pow((1.0 + g*g - 2.0*g*cosTheta), 1.5);\n\n    return scale*num/denom;\n}\n\nfloat getRayleighPhase(float cosTheta) {\n    const float k = 3.0/(16.0*PI);\n    return k*(1.0+cosTheta*cosTheta);\n}\n\nvoid getScatteringValues(vec3 pos,\n                         out vec3 rayleighScattering,\n                         out float mieScattering,\n                         out vec3 extinction) {\n    float altitudeKM = (length(pos)-groundRadiusMM)*1000.0;\n    // Note: Paper gets these switched up.\n    float rayleighDensity = exp(-altitudeKM/8.0);\n    float mieDensity = exp(-altitudeKM/1.2);\n\n    rayleighScattering = rayleighScatteringBase*rayleighDensity;\n    float rayleighAbsorption = rayleighAbsorptionBase*rayleighDensity;\n\n    mieScattering = mieScatteringBase*mieDensity;\n    float mieAbsorption = mieAbsorptionBase*mieDensity;\n\n    vec3 ozoneAbsorption = ozoneAbsorptionBase*max(0.0, 1.0 - abs(altitudeKM-25.0)/15.0);\n\n    extinction = rayleighScattering + rayleighAbsorption + mieScattering + mieAbsorption + ozoneAbsorption;\n}\n\nfloat safeacos(const float x) {\n    return acos(clamp(x, -1.0, 1.0));\n}\n\n// From https://gamedev.stackexchange.com/questions/96459/fast-ray-sphere-collision-code.\nfloat rayIntersectSphere(vec3 ro, vec3 rd, float rad) {\n    float b = dot(ro, rd);\n    float c = dot(ro, ro) - rad*rad;\n    if (c > 0.0f && b > 0.0) return -1.0;\n    float discr = b*b - c;\n    if (discr < 0.0) return -1.0;\n    // Special case: inside sphere, use far discriminant\n    if (discr > b*b) return (-b + sqrt(discr));\n    return -b - sqrt(discr);\n}\n\n// From https://www.shadertoy.com/view/wlBXWK\nvec2 rayIntersectSphere2D(\n    vec3 start, // starting position of the ray\n    vec3 dir, // the direction of the ray\n    float radius // and the sphere radius\n) {\n    // ray-sphere intersection that assumes\n    // the sphere is centered at the origin.\n    // No intersection when result.x > result.y\n    float a = dot(dir, dir);\n    float b = 2.0 * dot(dir, start);\n    float c = dot(start, start) - (radius * radius);\n    float d = (b*b) - 4.0*a*c;\n    if (d < 0.0) return vec2(1e5,-1e5);\n    return vec2(\n        (-b - sqrt(d))/(2.0*a),\n        (-b + sqrt(d))/(2.0*a)\n    );\n}\n\n/*\n * Same parameterization here.\n */\nvec3 getValFromTLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {\n    float height = length(pos);\n    vec3 up = pos / height;\n\tfloat sunCosZenithAngle = dot(sunDir, up);\n    vec2 uv = vec2(tLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),\n                   tLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));\n    uv /= bufferRes;\n    // return pos;\n    return texture(tex, uv).rgb;\n}\nvec3 getValFromMultiScattLUT(sampler2D tex, vec2 bufferRes, vec3 pos, vec3 sunDir) {\n    float height = length(pos);\n    vec3 up = pos / height;\n\tfloat sunCosZenithAngle = dot(sunDir, up);\n    vec2 uv = vec2(msLUTRes.x*clamp(0.5 + 0.5*sunCosZenithAngle, 0.0, 1.0),\n                   msLUTRes.y*max(0.0, min(1.0, (height - groundRadiusMM)/(atmosphereRadiusMM - groundRadiusMM))));\n    uv /= bufferRes;\n    return texture(tex, uv).rgb;\n}\n\n/* \n * Do raymarching : builds skyview lut inside atmoshpere, raymarches directly outside atmosphere\n*/\n\nvec3 raymarchScattering(sampler2D TLUT, vec2 TLUT_size, sampler2D MSLUT, vec2 MSLUT_size,\n                              vec3 viewPos,\n                              vec3 rayDir,\n                              vec3 sunDir,\n                              float numSteps) {\n                              \n                              \n    vec2 atmos_intercept = rayIntersectSphere2D(viewPos, rayDir, atmosphereRadiusMM);\n    float terra_intercept = rayIntersectSphere(viewPos, rayDir, groundRadiusMM);\n\n    float mindist, maxdist;\n\n    if (atmos_intercept.x < atmos_intercept.y){\n        // there is an atmosphere intercept!\n        // start at the closest atmosphere intercept\n        // trace the distance between the closest and farthest intercept\n        mindist = atmos_intercept.x > 0.0 ? atmos_intercept.x : 0.0;\n\t\tmaxdist = atmos_intercept.y > 0.0 ? atmos_intercept.y : 0.0;\n    } else {\n        // no atmosphere intercept means no atmosphere!\n        return vec3(0.0);\n    }\n\n    // if in the atmosphere start at the camera\n    if (length(viewPos) < atmosphereRadiusMM) mindist=0.0;\n\n    // if there's a terra intercept that's closer than the atmosphere one,\n    // use that instead!\n    if (terra_intercept > 0.0){ // confirm valid intercepts\t\t\t\n        maxdist = terra_intercept;\n    }\n\n    // start marching at the min dist\n    vec3 pos = viewPos + mindist * rayDir;\n                              \n    float cosTheta = dot(rayDir, sunDir);\n\n\tfloat miePhaseValue = getMiePhase(cosTheta);\n\tfloat rayleighPhaseValue = getRayleighPhase(-cosTheta);\n\n    vec3 lum = vec3(0.0);\n    vec3 transmittance = vec3(1.0);\n    float t = 0.0;\n    for (float i = 0.0; i < numSteps; i += 1.0) {\n        float newT = ((i + 0.3)/numSteps)*(maxdist-mindist);\n        float dt = newT - t;\n        t = newT;\n\n        vec3 newPos = pos + t*rayDir;\n\n        vec3 rayleighScattering, extinction;\n        float mieScattering;\n        \n        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n        vec3 sampleTransmittance = exp(-dt*extinction);\n\n        vec3 sunTransmittance = getValFromTLUT(TLUT, TLUT_size, newPos, sunDir);\n        vec3 psiMS = 0.0*getValFromMultiScattLUT(MSLUT, MSLUT_size, newPos, sunDir);\n\n        vec3 rayleighInScattering = rayleighScattering*(rayleighPhaseValue*sunTransmittance + psiMS);\n        vec3 mieInScattering = mieScattering*(miePhaseValue*sunTransmittance + psiMS);\n        vec3 inScattering = (rayleighInScattering + mieInScattering);\n\n        // Integrated scattering within path segment.\n        vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;\n\n        lum += scatteringIntegral*transmittance;\n\n        transmittance *= sampleTransmittance;\n    }\n    return lum;\n}\n\nvec3 getValFromSkyLUT(sampler2D viewTexture, vec3 viewPos, vec3 rayDir, vec3 sunDir) {\n\n    float height = length(viewPos);\n    vec3 up = viewPos / height;\n\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);\n    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2\n    float azimuthAngle; // Between 0 and 2*PI\n\n    vec3 right = cross(sunDir, up);\n    vec3 forward = cross(up, right);\n\n    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));\n    float sinTheta = dot(projectedDir, right);\n    float cosTheta = dot(projectedDir, forward);\n    azimuthAngle = atan(sinTheta, cosTheta) + PI;\n\n    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.\n    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);\n    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);\n    // uv *= skyLUTRes;\n    // uv /= viewResolution.xy;\n\n    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);;\n    return texture(viewTexture, uv).rgb;\n}\n\nvec3 jodieReinhardTonemap(vec3 c) {\n    // From: https://www.shadertoy.com/view/tdSXzD\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}",
  qb = {
    uniforms: {
      altitude: { value: 2.8 },
      transmittanceTexture: { value: null },
      transmittanceResolution: { value: [256, 256] },
      scatteringTexture: { value: null },
      scatteringResolution: { value: [256, 256] },
      viewTexture: { value: null },
      viewResolution: { value: [256, 256] },
      cameraDirection: { value: new Vector3(0, 0.27, -1) },
      viewHeight: { value: 0.002 },
      upDirection: { value: new Vector3(0, 1, 0) },
      tWeather: { value: null },
      mixGrayFactor: { value: 0 },
      isEmissive: { value: !1 },
      uTime: { value: null },
      uStarVisible: { value: !0 },
      uMoonMap: { value: null },
    },
    vertexShader:
      "#define GLSLIFY 1\nvarying vec3 vWorldPosition;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    //vWorldPosition = normalize(vec3(modelMatrix * vec4(position, 1.0)) - cameraPosition);\n    vWorldPosition = normalize(vec3(position.x, position.y, position.z));\n    // vWorldPosition = normalize(position);\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    gl_Position.z = gl_Position.w;\n}\n",
    fragmentShader:
      Wb +
      "\n#define GLSLIFY 1\n/*\n * Modified version of Andrew Helmer's https://www.shadertoy.com/view/slSXRW \n * implementation of Sebastian Hillare's Unreal engine sky-atmosphere\n * ... still doesn't implement aerial perspective lut, just makes space views possible\n * TODO: replace sunflare with something new that works\n        allow density profiles, and thicker atmospheres (fails beyond 7.1 right now)\n */\n\n/*\n * Final output basically looks up the value from the skyLUT, and then adds a sun on top,\n * does some tonemapping.\n */\n#include <common>\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\nuniform sampler2D transmittanceTexture;\nuniform vec2 transmittanceResolution;\nuniform sampler2D viewTexture;\nuniform vec2 viewResolution;\nuniform sampler2D scatteringTexture;\nuniform vec2 scatteringResolution;\nuniform vec2 iResolution;\nuniform vec3 cameraDirection;\nuniform vec3 upDirection;\nuniform float uTime;\nuniform bool uStarVisible;\nuniform sampler2D uMoonMap;\n\nconst int star_iterations = 10;\nconst vec3 col_star = vec3( .8, 0.8, 0.7 );\n\nconst vec3 grayColor = vec3(0.5, 0.5, 0.5);\n\nvec3 sunWithBloom(vec3 rayDir, vec3 sunDir) {\n    const float sunSolidAngle = 0.01*PI/180.0;\n    const float minSunCosTheta = cos(sunSolidAngle);\n\n    float cosTheta = dot(rayDir, sunDir);\n    if (cosTheta >= minSunCosTheta) return vec3(1.0);\n\n    float offset = minSunCosTheta - cosTheta;\n    float gaussianBloom = exp(-offset*50000.0)*0.5;\n    float invBloom = 1.0/(0.02 + offset*300.0)*0.01;\n    return vec3(gaussianBloom+invBloom);\n}\n\nfloat hash( float n ) { return fract(sin(n)*123.456789); }\n\nvec2 rotate( in vec2 uv, float a) {\n    float c = cos( a );\n    float s = sin( a );\n    return vec2( c * uv.x - s * uv.y, s * uv.x + c * uv.y );\n}\n\nfloat noise( in vec3 p ) {\n    vec3 fl = floor( p );\n    vec3 fr = fract( p );\n    fr = fr * fr * ( 3.0 - 2.0 * fr );\n\n    float n = fl.x + fl.y * 157.0 + 113.0 * fl.z;\n    return mix( mix( mix( hash( n +   0.0), hash( n +   1.0 ), fr.x ),\n                     mix( hash( n + 157.0), hash( n + 158.0 ), fr.x ), fr.y ),\n                mix( mix( hash( n + 113.0), hash( n + 114.0 ), fr.x ),\n                     mix( hash( n + 270.0), hash( n + 271.0 ), fr.x ), fr.y ), fr.z );\n}\n\nfloat fbm( in vec2 p, float t ) {\n    float f;\n    f  = 0.5000 * noise( vec3( p, t ) ); p *= 2.1;\n    f += 0.2500 * noise( vec3( p, t ) ); p *= 2.2;\n    f += 0.1250 * noise( vec3( p, t ) ); p *= 2.3;\n    f += 0.0625 * noise( vec3( p, t ) );\n    return f;\n}\n\nfloat fbmByTexture( vec2 p ) {\n    return 0.5000 * texture2D( uMoonMap, p * 1.00 ).x + \n        0.2500 * texture2D( uMoonMap, p * 2.02 ).x + \n        0.1250 * texture2D( uMoonMap, p * 4.03 ).x + \n        0.0625 * texture2D( uMoonMap, p * 8.04 ).x;\n}\n\n// moon\nvec3 moonWithBloom(vec3 rayDir, vec3 moonDir) {\n    const float sunSolidAngle = .6 * PI / 180.0;\n    const float minSunCosTheta = cos(sunSolidAngle);\n\n    float cosTheta = dot(rayDir, moonDir);\n    vec3 differ = rayDir - moonDir;\n    if (cosTheta >= minSunCosTheta) {\n        vec3 moon = vec3(0.98,0.97,0.95);\n        // 月球耀斑\n        moon *= (0.30 + 0.4 * fbmByTexture(vec2(1.0) + vec2(0.2 + differ.xz + differ.yx)));\n\n        return moon;\n    }\n\n    float offset = minSunCosTheta - cosTheta;\n    float gaussianBloom = exp(-offset * 50000.0) * 0.5;\n    float invBloom = 1.0 / (0.05 + offset * 300.0) * 0.01;\n    return vec3(gaussianBloom+invBloom);\n}\n\n// 星空背景\nvec3 doBackgroundStars( in vec3 dir ) {\n    vec3 n  = abs( dir );\n    vec2 uv = ( n.x > n.y && n.x > n.z ) ? dir.yz / dir.x: \n            ( n.y > n.x && n.y > n.z ) ? dir.zx / dir.y:\n                                        dir.xy / dir.z;\n    \n    float f = 0.0;\n    \n    for( int i = 0 ; i < star_iterations; ++i ) {\n        uv = rotate( 1.07 * uv + vec2( 0.7 ), 0.5 );\n        \n        float t = 10. * uv.x * uv.y + uTime;\n        vec2 u = cos( 100. * uv ) * fbm( 10. * uv, 0.0 );\n        f += smoothstep( 0.534, 0.535, u.x * u.y );\n    }\n    \n    return f * col_star;\n}\n\nvec3 render( in vec2 uv, mat3 m ) {\n    //create view ray\n    vec3 rd  = m * normalize( vec3( uv, 1.0 ) );\n    \n    // background stars\n    vec3 c = doBackgroundStars( rd );\n    return c;\n}\n\nvec4 toLinear(vec4 sRGB) {\n    bvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n    vec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n    vec4 lower = sRGB/vec4(12.92);\n\n    return mix(higher, lower, cutoff);\n}\n\nvoid main() {\n    vec3 sunDir = getSunDir(0.);\n    vec3 viewPos = getViewPos(0.);\n\n    vec3 camDir = normalize(cameraDirection);\n    float camFOVWidth = PI/3.0;\n    // vec2 iResolution = vec2(1102, 1246);\n    float camWidthScale = 2.0*tan(camFOVWidth/2.0);\n    float camHeightScale = camWidthScale*iResolution.y/iResolution.x;\n\n    vec3 camRight = normalize(cross(camDir, upDirection));\n    vec3 camUp = normalize(cross(camRight, camDir));\n\n    // camRight = viewMatrix[0].xzy;\n    // camUp = viewMatrix[1].xzy;\n    // camDir = viewMatrix[2].xzy;\n    // vec2 xy = 2.0 * vWorldPosition.xy; // 2.0 * (fragCoord.xy / iResolution.xy) - 1.0;\n    vec2 xy = vWorldPosition.xy; // 2.0 * (gl_FragCoord.xy / iResolution.xy / 2.0) - 1.0;\n    // vec3 rayDir = normalize(camDir + camRight*xy.x*camWidthScale + camUp*xy.y*camHeightScale);\n    vec3 rayDir = normalize(vWorldPosition.xzy);\n    vec3 lum;\n\n    if (length(viewPos) < atmosphereRadiusMM * 1.0){\n        lum = getValFromSkyLUT(viewTexture, viewPos, rayDir, sunDir);\n    } else {\n    \n        // As mentioned in section 7 of the paper, switch to direct raymarching outside atmosphere\n        lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,\n                                scatteringTexture, scatteringResolution.xy,\n                                viewPos, rayDir, sunDir, float(numScatteringSteps));\n        \n        // This little bit of red helps to debug when the rendering switches to pure raymarching\n        // lum += vec3(1e-3,0.0,0.0);\n    }\n\n    // Tonemapping and gamma. Super ad-hoc, probably a better way to do this.\n    lum *= 100.0;\n    lum = jodieReinhardTonemap(lum);\n    lum = pow(lum, vec3(1.0/2.2));\n\n    // lum += sunWithBloom(rayDir, sunDir);\n    // Bloom should be added at the end, but this is subtle and works well.\n    vec3 sunLum = sunWithBloom(rayDir, sunDir);\n    // Use smoothstep to limit the effect, so it drops off to actual zero.\n    sunLum = smoothstep(0.002, 1.0, sunLum);\n    if (length(sunLum) > 0.0) {\n        if (rayIntersectSphere(viewPos, rayDir, groundRadiusMM) >= 0.0) {\n            sunLum *= 0.0;\n        } else {\n            // If the sun value is applied to this pixel, we need to calculate the transmittance to obscure it.\n            sunLum *= getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, viewPos, sunDir);\n        }\n    }\n    lum += sunLum;\n\n    if (sunDir.y < 0.0) {\n        vec2 uv = vUv - vec2(0.5);\n        \n        vec3 ww = normalize(vec3(1.04, 0.0, 2.628));\n        vec3 uu = normalize( cross( ww, vec3( 0.0, 1.0, 0.0 ) ) );\n        vec3 vv = normalize( cross( uu, ww ) );\n        mat3 m = mat3( uu, vv, ww );\n\n        // 星空\n        if (rayDir.y > 0.0 && uStarVisible) {\n            // 背景初始化颜色，渐变蓝黑色\n            lum += vec3( 0.035, 0.055, 0.085 );\n            lum += vec3( 0.02, 0.05, 0.15 ) * (1. - rayDir.y);\n\n            vec3 c = render( fract(uv * 30.0), m );\n\n            // c = pow( c, vec3( 0.4545 ) );\n\n            // 星空闪烁\n            float time = uTime / 20000.0;\n            float twinkle = sin((uv.x-time+cos(uv.y*20.+time))*20.);\n            twinkle *= cos((uv.y*.234-time*3.24+sin(uv.x*12.3+time*.243))*7.34);\n            twinkle = (twinkle + 1.)/2.;\n            lum += c * twinkle * (rayDir.y * 10.0) * (1.0 - pow(max(0.0, abs(-sunDir.y - 1.0) * 2.0 - 1.0), 2.0));\n        }\n\n        // 月亮\n        vec3 moonLum = moonWithBloom(rayDir, -sunDir) * 2.0;\n        if (length(moonLum) > 0.0) {\n            float alpha = clamp(smoothstep(0.0, 0.2, rayDir.y), 0.01, 1.0);\n            moonLum *= alpha;\n        }\n        lum += moonLum;\n\n    }\n\n    gl_FragColor = vec4(lum, 1.0);\n    gl_FragColor = toLinear(gl_FragColor);\n\n    // gl_FragColor.rgb = vWorldPosition;\n    // float viewDistance = sqrt(length(vec3(rayDir.x * 10., 0.1, rayDir.z * 10.)));\n    // vec2 cloudUV = rayDir.xz * viewDistance; //rayDir.xy * length(rayDir);\n    // // cloudUV *= mix(1., 10., clamp(sqrt(rayDir.x * rayDir.x + rayDir.y * rayDir.y), 0.0, 1.0));\n    // float cloudDensity = texture2D(tWeather, cloudUV * 10.0).x;\n    // gl_FragColor.xy = (rayDir.xy + 1.0) * 0.5;\n    // gl_FragColor.z += cloudDensity;\n    // Peek at the Transmittance LUT\n    // if (gl_FragCoord.x < skyLUTRes.x && gl_FragCoord.y < skyLUTRes.y) {\n        // gl_FragColor = vec4(8.*texture(viewTexture, gl_FragCoord.xy/skyLUTRes * 0.2).rgb,1.0);\n    // }\n    // fragColor = vec4(100.*texture(transmittanceTexture, fragCoord.xy/iResolution.xy).rgb,1.0);\n\n    // Peek at the Sky View LUT\n    // gl_FragColor = vec4(8.*texture(viewTexture, gl_FragCoord.xy/iResolution.xy / 2.).rgb,1.0);\n\n    // Peek at the Multiscattering LUT\n    // fragColor = vec4(100.*texture(scatteringTexture, fragCoord.xy/iResolution.xy).rgb,1.0);\n    // if (gl_FragCoord.x < msLUTRes.x && gl_FragCoord.y < msLUTRes.y) {\n    //     gl_FragColor = vec4(100.*texture(scatteringTexture, gl_FragCoord.xy/iResolution / 2.).rgb,1.0);\n    // }\n    // gl_FragColor = vec4(100.*texture(transmittanceTexture, gl_FragCoord.xy/transmittanceResolution * 0.1).rgb,1.0);\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}\n",
  },
  Xb = {
    uniforms: { altitude: { value: 2.8 }, viewHeight: { value: 2e-4 } },
    vertexShader: jb,
    fragmentShader:
      Wb +
      "\n#define GLSLIFY 1\n// Buffer A generates the Transmittance LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and\n// the value is the transmittance from that point to sun, through the atmosphere.\nvarying vec2 vUv;\nvec3 getSunTransmittance(vec3 pos, vec3 sunDir) {\n    if (rayIntersectSphere(pos, sunDir, groundRadiusMM) > 0.0) {\n        return vec3(0.0);\n    }\n\n    float atmoDist = rayIntersectSphere(pos, sunDir, atmosphereRadiusMM);\n    float t = 0.0;\n\n    vec3 transmittance = vec3(1.0);\n    for (float i = 0.0; i < sunTransmittanceSteps; i += 1.0) {\n        float newT = ((i + 0.3)/sunTransmittanceSteps)*atmoDist;\n        float dt = newT - t;\n        t = newT;\n\n        vec3 newPos = pos + t*sunDir;\n\n        vec3 rayleighScattering, extinction;\n        float mieScattering;\n        getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n        transmittance *= exp(-dt*extinction);\n    }\n    return transmittance;\n}\n\nvoid main() {\n    // if (gl_FragCoord.x >= (tLUTRes.x+1.5) || gl_FragCoord.y >= (tLUTRes.y+1.5)) {\n    //     return;\n    // }\n    float u = vUv.x; // clamp(gl_FragCoord.x, 0.0, tLUTRes.x-1.0)/tLUTRes.x;\n    float v = vUv.y; // clamp(gl_FragCoord.y, 0.0, tLUTRes.y-1.0)/tLUTRes.y;\n\n    float sunCosTheta = 2.0*u - 1.0;\n    float sunTheta = safeacos(sunCosTheta);\n    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);\n\n    vec3 pos = vec3(0.0, height, 0.0);\n    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));\n\n    gl_FragColor = vec4(getSunTransmittance(pos, sunDir), 1.0);\n}\n",
  },
  Yb = {
    uniforms: {
      altitude: { value: 2.8 },
      transmittanceTexture: { value: null },
      transmittanceResolution: { value: [256, 256] },
      viewHeight: { value: 2e-4 },
    },
    vertexShader: jb,
    fragmentShader:
      Wb +
      "\n#define GLSLIFY 1\n// Buffer B is the multiple-scattering LUT. Each pixel coordinate corresponds to a height and sun zenith angle, and\n// the value is the multiple scattering approximation (Psi_ms from the paper, Eq. 10).\nvarying vec2 vUv;\nuniform sampler2D transmittanceTexture;\nuniform vec2 transmittanceResolution;\nvec3 getSphericalDir(float theta, float phi) {\n     float cosPhi = cos(phi);\n     float sinPhi = sin(phi);\n     float cosTheta = cos(theta);\n     float sinTheta = sin(theta);\n     return vec3(sinPhi*sinTheta, cosPhi, sinPhi*cosTheta);\n}\n\n// Calculates Equation (5) and (7) from the paper.\nvoid getMulScattValues(vec3 pos, vec3 sunDir, out vec3 lumTotal, out vec3 fms) {\n    lumTotal = vec3(0.0);\n    fms = vec3(0.0);\n\n    float invSamples = 1.0/float(sqrtSamples*sqrtSamples);\n    for (int i = 0; i < sqrtSamples; i++) {\n        for (int j = 0; j < sqrtSamples; j++) {\n            // This integral is symmetric about theta = 0 (or theta = PI), so we\n            // only need to integrate from zero to PI, not zero to 2*PI.\n            float theta = PI * (float(i) + 0.5) / float(sqrtSamples);\n            float phi = safeacos(1.0 - 2.0*(float(j) + 0.5) / float(sqrtSamples));\n            vec3 rayDir = getSphericalDir(theta, phi);\n\n            float atmoDist = rayIntersectSphere(pos, rayDir, atmosphereRadiusMM);\n            float groundDist = rayIntersectSphere(pos, rayDir, groundRadiusMM);\n            float tMax = atmoDist;\n            if (groundDist > 0.0) {\n                tMax = groundDist;\n            }\n\n            float cosTheta = dot(rayDir, sunDir);\n\n            float miePhaseValue = getMiePhase(cosTheta);\n            float rayleighPhaseValue = getRayleighPhase(-cosTheta);\n\n            vec3 lum = vec3(0.0), lumFactor = vec3(0.0), transmittance = vec3(1.0);\n            float t = 0.0;\n            for (float stepI = 0.0; stepI < mulScattSteps; stepI += 1.0) {\n                float newT = ((stepI + 0.3)/mulScattSteps)*tMax;\n                float dt = newT - t;\n                t = newT;\n\n                vec3 newPos = pos + t*rayDir;\n\n                vec3 rayleighScattering, extinction;\n                float mieScattering;\n                getScatteringValues(newPos, rayleighScattering, mieScattering, extinction);\n\n                vec3 sampleTransmittance = exp(-dt*extinction);\n\n                // Integrate within each segment.\n                vec3 scatteringNoPhase = rayleighScattering + mieScattering;\n                vec3 scatteringF = (scatteringNoPhase - scatteringNoPhase * sampleTransmittance) / extinction;\n                lumFactor += transmittance*scatteringF;\n\n                // This is slightly different from the paper, but I think the paper has a mistake?\n                // In equation (6), I think S(x,w_s) should be S(x-tv,w_s).\n                vec3 sunTransmittance = getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, newPos, sunDir);\n\n                vec3 rayleighInScattering = rayleighScattering*rayleighPhaseValue;\n                float mieInScattering = mieScattering*miePhaseValue;\n                vec3 inScattering = (rayleighInScattering + mieInScattering)*sunTransmittance;\n\n                // Integrated scattering within path segment.\n                vec3 scatteringIntegral = (inScattering - inScattering * sampleTransmittance) / extinction;\n\n                lum += scatteringIntegral*transmittance;\n                transmittance *= sampleTransmittance;\n            }\n\n            if (groundDist > 0.0) {\n                vec3 hitPos = pos + groundDist*rayDir;\n                if (dot(pos, sunDir) > 0.0) {\n                    hitPos = normalize(hitPos)*groundRadiusMM;\n                    lum += transmittance*groundAlbedo*getValFromTLUT(transmittanceTexture, transmittanceResolution.xy, hitPos, sunDir);\n                }\n            }\n\n            fms += lumFactor*invSamples;\n            lumTotal += lum*invSamples;\n        }\n    }\n}\n\nvoid main() {\n    // if (fragCoord.x >= (msLUTRes.x+1.5) || fragCoord.y >= (msLUTRes.y+1.5)) {\n    //     return;\n    // }\n    float u = vUv.x; // clamp(fragCoord.x, 0.0, msLUTRes.x-1.0)/msLUTRes.x;\n    float v = vUv.y; // clamp(fragCoord.y, 0.0, msLUTRes.y-1.0)/msLUTRes.y;\n\n    float sunCosTheta = 2.0*u - 1.0;\n    float sunTheta = safeacos(sunCosTheta);\n    float height = mix(groundRadiusMM, atmosphereRadiusMM, v);\n\n    vec3 pos = vec3(0.0, height, 0.0);\n    vec3 sunDir = normalize(vec3(0.0, sunCosTheta, -sin(sunTheta)));\n\n    vec3 lum, f_ms;\n    getMulScattValues(pos, sunDir, lum, f_ms);\n\n    // Equation 10 from the paper.\n    vec3 psi = lum  / (1.0 - f_ms);\n    gl_FragColor = vec4(1. * psi, 1.0);\n    // gl_FragColor = vec4(vUv/ 1., 0.0, 1.0);\n}\n",
  },
  Kb = {
    uniforms: {
      altitude: { value: 2.8 },
      transmittanceTexture: { value: null },
      transmittanceResolution: { value: [256, 256] },
      scatteringTexture: { value: null },
      scatteringResolution: { value: [256, 256] },
      viewHeight: { value: 2e-4 },
      mixGrayFactor: { value: 0 },
    },
    vertexShader: jb,
    fragmentShader:
      Wb +
      "\n#define GLSLIFY 1\n// Buffer C calculates the actual sky-view! It's a lat-long map (or maybe altitude-azimuth is the better term),\n// but the latitude/altitude is non-linear to get more resolution near the horizon.\nvarying vec2 vUv;\nuniform sampler2D transmittanceTexture;\nuniform vec2 transmittanceResolution;\nuniform sampler2D scatteringTexture;\nuniform vec2 scatteringResolution;\nuniform float mixGrayFactor;\n\nvoid main() {\n    // if (fragCoord.x >= (skyLUTRes.x+1.5) || fragCoord.y >= (skyLUTRes.y+1.5)) {\n    //     return;\n    // }\n    float u = vUv.x; // clamp(fragCoord.x, 0.0, skyLUTRes.x-1.0)/skyLUTRes.x;\n    float v = vUv.y; // clamp(fragCoord.y, 0.0, skyLUTRes.y-1.0)/skyLUTRes.y;\n\n    float azimuthAngle = (u - 0.5)*2.0*PI;\n\n    // Non-linear mapping of altitude. See Section 5.3 of the paper.\n\n    float adjV;\n    if (v < 0.5) {\n\t\tfloat coord = 1.0 - 2.0*v;\n\t\tadjV = -coord*coord;\n\t} else {\n\t\tfloat coord = v*2.0 - 1.0;\n\t\tadjV = coord*coord;\n\t}\n\n    vec3 viewPos = getViewPos(0.);\n\n    float height = length(viewPos); vec3 up = viewPos / height;\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height) - 0.5*PI;\n    float altitudeAngle = adjV*0.5*PI - horizonAngle;\n\n    float cosAltitude = cos(altitudeAngle);\n    vec3 rayDir = vec3(cosAltitude*sin(azimuthAngle), sin(altitudeAngle), -cosAltitude*cos(azimuthAngle));\n\n    float sunAltitude = (0.5*PI) - acos(dot(getSunDir(0.), up));\n    vec3 sunDir = vec3(0.0, sin(sunAltitude), -cos(sunAltitude));\n\n    vec3 lum = raymarchScattering(transmittanceTexture, transmittanceResolution.xy,\n                                  scatteringTexture, scatteringResolution.xy,\n                                  viewPos, rayDir, sunDir, float(numScatteringSteps));\n    gl_FragColor = vec4(lum, 1.0);\n\n    if (mixGrayFactor > 0.0) {\n        lum = gl_FragColor.xyz;\n        vec3 gray = vec3((lum.x + lum.y + lum.z) / 3.0);\n        lum = mix(lum, gray, mixGrayFactor);\n        gl_FragColor = vec4(lum, 1.0);\n    }\n}\n",
  },
  Zb = {
    uniforms: {
      tDiffuse: { value: null },
      tDepth: { value: null },
      tNormal: { value: null },
      tAtmosphere: { value: null },
      cameraNear: { value: 0.1 },
      cameraFar: { value: 1e3 },
      projectionInverseMatrix: { value: new Matrix4() },
      viewInverseMatrix: { value: new Matrix4() },
      cameraPosition: { value: new Vector3() },
      altitude: { value: 2.8 },
      viewHeight: { value: 2e-4 },
    },
    fragmentShader:
      Wb +
      "\n#define GLSLIFY 1\n#include <mvt_depth_packing>\n#include <packing>\n\nvarying vec2 vUv;\nuniform sampler2D tDiffuse;\nuniform sampler2D tDepth;\n// uniform sampler2D tNormal;\nuniform sampler2D tAtmosphere;\nuniform float cameraNear;\nuniform float cameraFar;\nuniform mat4 projectionInverseMatrix;\nuniform mat4 viewInverseMatrix;\n// uniform vec3 cameraPosition;\n\nfloat getNoramlLength(vec3 normal) {\n    // if (normal.x < 0. || normal.y < 0. || normal.z < 0.) {\n    //     return 0.;\n    // }\n    return length(normal);\n}\n\nvoid main() {\n    float depthValue = texture2D(tDepth, vUv).x;\n    float depth = mvtGetDepthFromTexture(tDepth, vUv, cameraNear, cameraFar);\n    vec3 worldPosition = mvtGetWorldPostionByDepth(depth, vUv, projectionInverseMatrix, viewInverseMatrix); \n    vec3 viewPosition = mvtGetViewPostionByDepth(depth, vUv, projectionInverseMatrix);\n    vec3 viewFrom = vec3(cameraPosition);\n    // viewFrom = vec3(0, 0, 100);\n    vec3 viewTo = vec3(worldPosition.xy, 0.0);\n    // if (viewFrom.z - viewTo.z < 0.0) {\n    //     viewTo.z = viewFrom.z;\n    // }\n    vec3 viewDir = normalize(viewTo - viewFrom);\n    if (viewDir.z > -0.05) {\n        viewDir.z = -0.05;\n        viewDir = normalize(viewDir);\n    }\n    vec3 sunDir = getSunDir(0.);\n    vec3 viewPos = getViewPos(0.);\n    // viewPos = vec3(0, 0.0004, 0.0);\n\n    // vec4 viewNormal = texture2D(tNormal, vUv);\n    // vec3 normal = unpackRGBToNormal(viewNormal.xyz);\n    // float normalLength = length(viewNormal);\n\n    // 从50km高度到100km高度，大气层逐渐变淡\n    float ratio = 1.0 - clamp((cameraPosition.z - 50000.0) / 50000.0, 0.0, 1.0);\n    float viewRatio = 1.0 - dot(normalize(vec3(viewInverseMatrix[2])), vec3(0.0, 0.0, 1));\n    viewRatio = clamp((viewRatio - 0.3) * 1.5, 0.0, 1.0);\n    //ratio *= viewRatio;\n    // float planeDistance = length(worldPosition.xy - cameraPosition.xy);\n    // float planeRatio = (planeDistance - cameraPosition.z) / cameraPosition.z;\n    // ratio *= clamp(planeRatio, 0.0, 1.0);\n\n    // ratio = 1.0;\n    float depthThreshold = mix(0.996, 0.992, clamp(cameraPosition.z / 100000.0, 0.0, 1.0));\n    if (depthValue < depthThreshold && ratio > 0.0) {\n        vec3 lum = getValFromSkyLUT(tAtmosphere, viewPos, viewDir.xzy, sunDir);\n        lum *= 100.0;\n        lum = jodieReinhardTonemap(lum);\n        lum = pow(lum, vec3(1.0/2.2));\n        vec4 diffuse = texture2D(tDiffuse, vUv);\n        vec4 atmo = vec4(lum, 1.0);\n        float fogDepth = depthValue;\n        // fogDepth = exp(fogDepth);\n        // fogDepth = fogDepth * fogDepth;\n        float fogDensity = 1.;\n        // fogDepth = 1.0 - exp(- fogDensity * fogDensity * fogDepth * fogDepth);\n        float fogStart = 0.65;\n        fogDepth = clamp((fogDepth - fogStart) / (1.0 - fogStart), 0.0, 1.0);\n        // fogDepth = sqrt(fogDepth);\n        \n        gl_FragColor = mix(diffuse, atmo, fogDepth * ratio * viewRatio);\n        // gl_FragColor = vec4(atmo.xyz, 1.0);\n        // gl_FragColor = vec4(viewRatio, 0.0, 0.0, 1.0);\n    } \n    else {\n        gl_FragColor = texture2D(tDiffuse, vUv);\n    }\n\n    // gl_FragColor = vec4(normalLength, 0.0, 0.0, 1.0);\n}",
  };
class Jb extends En {
  constructor() {
    super(),
      publicField(this, "_fsQuad"),
      publicField(this, "_hasPaintedScatterBuffer"),
      publicField(this, "_scatteringMaterial"),
      publicField(this, "_scatteringRenderTarget"),
      publicField(this, "_transmittanceMaterial"),
      publicField(this, "_transmittanceRenderTarget"),
      publicField(this, "_viewMaterial"),
      publicField(this, "_viewRenderTarget"),
      (this.geometry = new Uo(1, 32, 32)),
      (this.frustumCulled = !1);
    const e = [256, 64],
      t = [32, 32],
      i = [400, 400],
      n = (this._transmittanceRenderTarget = new ut(e[0], e[1], {
        type: G,
        depthBuffer: !1,
      }));
    (n.texture.name = "SkyAtmosphere.transmittance"),
      (this._transmittanceMaterial = new ShaderMaterial({
        uniforms: In.clone(Xb.uniforms),
        vertexShader: Xb.vertexShader,
        fragmentShader: Xb.fragmentShader,
      }));
    const s = (this._scatteringRenderTarget = new ut(t[0], t[1], {
      type: G,
      depthBuffer: !1,
    }));
    (s.texture.name = "SkyAtmosphere.scattering"),
      (this._scatteringMaterial = new ShaderMaterial({
        uniforms: In.clone(Yb.uniforms),
        vertexShader: Yb.vertexShader,
        fragmentShader: Yb.fragmentShader,
      })),
      (this._scatteringMaterial.uniforms.transmittanceTexture.value =
        n.texture),
      (this._scatteringMaterial.uniforms.transmittanceResolution.value = [
        e[0],
        e[1],
      ]),
      (this._fsQuad = new fg(null));
    const r = (this._viewRenderTarget = new ut(i[0], i[1], {
      type: G,
      depthBuffer: !1,
    }));
    r.texture.name = "SkyAtmosphere.view";
    const a = (this._viewMaterial = new ShaderMaterial({
      uniforms: In.clone(Kb.uniforms),
      vertexShader: Kb.vertexShader,
      fragmentShader: Kb.fragmentShader,
    }));
    (a.uniforms.transmittanceTexture.value = n.texture),
      (a.uniforms.transmittanceResolution.value = [e[0], e[1]]),
      (a.uniforms.scatteringTexture.value = s.texture),
      (a.uniforms.scatteringResolution.value = [t[0], t[1]]);
    const o = (this.material = new ShaderMaterial({
      uniforms: In.clone(qb.uniforms),
      vertexShader: qb.vertexShader,
      fragmentShader: qb.fragmentShader,
      side: 2,
    }));
    (o.uniforms.transmittanceTexture.value = n.texture),
      (o.uniforms.transmittanceResolution.value = [e[0], e[1]]),
      (o.uniforms.scatteringTexture.value = s.texture),
      (o.uniforms.scatteringResolution.value = [t[0], t[1]]),
      (o.uniforms.viewTexture.value = r.texture),
      (o.uniforms.viewResolution.value = [i[0], i[1]]),
      Object.defineProperties(this.material, {
        isEmissive: {
          get: function () {
            return this.uniforms.isEmissive.value;
          },
          set: function (e) {
            this.uniforms.isEmissive.value = e;
          },
        },
        uTime: {
          get: function () {
            return this.uniforms.uTime.value;
          },
          set: function (e) {
            this.uniforms.uTime.value = e;
          },
        },
        uStarVisible: {
          get: function () {
            return this.uniforms.uStarVisible.value;
          },
          set: function (e) {
            this.uniforms.uStarVisible.value = e;
          },
        },
        uMoonMap: {
          get: function () {
            return this.uniforms.uMoonMap.value;
          },
          set: function (e) {
            this.uniforms.uMoonMap.value = e;
          },
        },
      }),
      (this._fsQuad = new fg(null)),
      this.scale.multiplyScalar(1e4),
      (this.altitude = 0);
  }
  onBeforeRender(e, t, i) {}
  updateRenderTargets(e, t) {
    const i = this._fsQuad;
    this._hasPaintedScatterBuffer ||
      ((i.material = this._transmittanceMaterial),
      e.setRenderTarget(this._transmittanceRenderTarget),
      e.clear(),
      i.render(e),
      (i.material = this._scatteringMaterial),
      e.setRenderTarget(this._scatteringRenderTarget),
      e.clear(),
      i.render(e),
      (this._hasPaintedScatterBuffer = !0)),
      (i.material = this._viewMaterial),
      e.setRenderTarget(this._viewRenderTarget),
      e.clear(),
      i.render(e),
      e.setRenderTarget(null);
  }
  dispose() {
    this.geometry.dispose(),
      this._transmittanceRenderTarget.dispose(),
      this._scatteringRenderTarget.dispose(),
      this._viewRenderTarget.dispose(),
      this._transmittanceMaterial.dispose(),
      this._scatteringMaterial.dispose(),
      this._viewMaterial.dispose(),
      this.material.dispose(),
      this._fsQuad.dispose();
  }
  get altitude() {
    return this.material.uniforms.altitude.value;
  }
  set altitude(e) {
    (this._transmittanceMaterial.uniforms.altitude.value = e),
      (this._scatteringMaterial.uniforms.altitude.value = e),
      (this._viewMaterial.uniforms.altitude.value = e),
      (this.material.uniforms.altitude.value = e);
  }
  get mixGrayFactor() {
    return this._viewMaterial.uniforms.mixGrayFactor.value;
  }
  set mixGrayFactor(e) {
    this._viewMaterial.uniforms.mixGrayFactor.value = e;
  }
}
const $b = {
    weatherMap: { value: null },
    noiseMap: { value: null },
    blueNoiseMap: { value: null },
    shapeNoiseMap: { value: null },
    coverage: { value: 0.8 },
    density: { value: 6 },
    time: { value: 0 },
    speed: { value: 1 },
    sizeScale: { value: 0.5 },
    skyMap: { value: null },
    sunLightMap: { value: null },
    skyAltitude: { value: 2.8 },
    thicknessBias: { value: 0 },
    thicknessScale: { value: 1 },
    mixGrayFactor: { value: 0 },
    sunColor: { value: [1, 0.95, 0.85] },
    isEmissive: { value: !1 },
  },
  eE =
    "#define GLSLIFY 1\nvarying vec3 vWorldPosition;\nvarying vec2 vUv;\nvoid main() {\n    vUv = uv;\n    // vWorldPosition = normalize(position);\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    // gl_Position = vec4(position.x * 2.0, position.y * 2.0, 1.0, 1.0);\n    float skyZ = mix(0.1, 0.002, clamp(length(position.xy) * 1.0, 0.0, 1.0));\n    // float skyZ = mix(0.1, 0.002, length(position.xy));\n    vWorldPosition = (modelMatrix * vec4(position.x, position.y, skyZ, 1.0)).xyz - vec3(cameraPosition.xy, cameraPosition.z);\n    vWorldPosition = normalize(vWorldPosition);\n    \n    vec3 worldPosition = (modelMatrix * vec4(position, 1.0)).xyz;\n    worldPosition -= cameraPosition;\n    float disToCenter = length(worldPosition.xy);\n    float c = sqrt(pow(6300000.0, 2.0) + pow(disToCenter, 2.0));\n    worldPosition.z = clamp(6300400.0 - c, 0.0, 400.0);\n    vWorldPosition = worldPosition / 1000.0;\n    // float radiusZ = clamp(sqrt(0.5 * 0.5 - pow(length(position.xy), 2.0)), 0.0, 0.5);\n    // vWorldPosition.z = clamp(sqrt(1.0 - pow(length(vWorldPosition.xy), 2.0)), 0.0, 1.0);\n    // vWorldPosition = normalize(vec3(position.x, position.y, skyZ * 1.));\n    // gl_Position = projectionMatrix * modelViewMatrix * vec4(vec3(position.x, position.y, skyZ), 1.0);\n    gl_Position = projectionMatrix * viewMatrix * vec4(worldPosition + vec3(cameraPosition.xyz), 1.0);\n    // gl_Position.z = gl_Position.w;\n}\n",
  tE =
    "#define GLSLIFY 1\n#include <common>\nvarying vec2 vUv;\nvarying vec3 vWorldPosition;\n\nuniform sampler2D weatherMap;\nuniform sampler2D noiseMap;\nuniform sampler2D blueNoiseMap;\nuniform sampler2D shapeNoiseMap;\nuniform sampler2D skyMap;\nuniform sampler2D sunLightMap;\nuniform float coverage;\nuniform float time;\nuniform float speed;\nuniform float sizeScale;\n// uniform float thinkness;\nuniform float thicknessBias;\nuniform float thicknessScale;\nuniform float density;\nuniform vec3 sunColor;\n\nuniform float skyAltitude;\nuniform float mixGrayFactor;\nconst float groundRadiusMM = 6.371;\n\nconst float cloud_inscatter = 0.2;\nconst float cloud_silver_intensity = 2.5;\nconst float cloud_silver_exponent = 2.0;\nconst float cloud_outscatter = 0.1;\nconst float cloud_in_vs_outscatter = 0.5;\nconst float cloud_beer = 1.0;\nconst float cloud_attuention_clampval = 0.2;\nconst float cloud_outscatter_ambient = 0.9;\nconst float cloud_ambient_minimum = 0.2;\n\nfloat safeacos(const float x) {\n    return acos(clamp(x, -1.0, 1.0));\n}\n\nvec3 getSunDir() {\n    return normalize(vec3(cos(skyAltitude), sin(skyAltitude), 0.0));\n}\n\nvec3 getValFromSkyLUT(vec3 rayDir, vec3 sunDir) {\n\n    vec3 viewPos = vec3(0.0, groundRadiusMM + 0.0004, 0.0);\n    float height = length(viewPos);\n    vec3 up = viewPos / height;\n\n    float horizonAngle = safeacos(sqrt(height * height - groundRadiusMM * groundRadiusMM) / height);\n    float altitudeAngle = horizonAngle - acos(dot(rayDir, up)); // Between -PI/2 and PI/2\n    float azimuthAngle; // Between 0 and 2*PI\n\n    vec3 right = cross(sunDir, up);\n    vec3 forward = cross(up, right);\n\n    vec3 projectedDir = normalize(rayDir - up*(dot(rayDir, up)));\n    float sinTheta = dot(projectedDir, right);\n    float cosTheta = dot(projectedDir, forward);\n    azimuthAngle = atan(sinTheta, cosTheta) + PI;\n\n    // Non-linear mapping of altitude angle. See Section 5.3 of the paper.\n    float v = 0.5 + 0.5*sign(altitudeAngle)*sqrt(abs(altitudeAngle)*2.0/PI);\n    vec2 uv = vec2(azimuthAngle / (2.0*PI), v);\n\n    // return rayDir; // vec3(rayDir.x, 0.0, 0.0);\n    return texture(skyMap, uv).rgb;\n}\n\nvec3 jodieReinhardTonemap(vec3 c){\n    // From: https://www.shadertoy.com/view/tdSXzD\n    float l = dot(c, vec3(0.2126, 0.7152, 0.0722));\n    vec3 tc = c / (c + 1.0);\n    return mix(c / (l + 1.0), tc, tc);\n}\n\nvec4 toLinear(vec4 sRGB)\n{\n\tbvec4 cutoff = lessThan(sRGB, vec4(0.04045));\n\tvec4 higher = pow((sRGB + vec4(0.055))/vec4(1.055), vec4(2.4));\n\tvec4 lower = sRGB/vec4(12.92);\n\n\treturn mix(higher, lower, cutoff);\n}\n\nfloat remap(float v, float l0, float h0, float ln, float hn) {\n    return ln + (v - l0) * (hn - ln) / (h0 - l0);\n}\n\nconst float slice = 1.0 / 128.0;\nvec4 texture3DNoise(sampler2D noiseTexture, vec2 uv, float z_percent) {\n    uv = mod(uv, 1.0);\n    uv.x *= slice;\n    float num = float(int(z_percent / slice));\n    float alpha = mod(z_percent, slice) / slice;\n    vec4 val1 = texture2D(noiseTexture, vec2(uv.x + num * slice, uv.y));\n    vec4 val2 = texture2D(noiseTexture, vec2(uv.x + (num + 1.0) * slice, uv.y));\n    return mix(val1, val2, alpha);\n}\n\nfloat getCloud(vec3 pos) {\n    vec2 cloudUV = pos.xy * 0.1;\n    float uvOffset = time / 1000000.0 * speed;\n    vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);\n    float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);\n    float ph = clamp((pos.z - 0.4) / 0.6, 0.0, 1.0);\n    float srb = saturate(remap(ph, 0.0, 0.007, 0.0, 1.0));\n    float wh = 1.0; // weatherColor.z;\n    float srt = saturate(remap(ph, wh * 0.2, wh, 1.0, 0.0));\n    float sa = srb * srt;\n    float drb = ph * saturate(remap(ph, 0.0, 0.15, 0.0, 1.0));\n    float drt = saturate(remap(ph, 0.9, 1.0, 1.0, 0.0));\n    float da = density * drb * drt /** weatherColor.w*/ * 2.0;\n    vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);\n    float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);\n    // vec4 texture3DNoise = texture3DNoise(shapeNoiseMap, cloudUV, ph);\n    // float sn_sample = texture3DNoise.x;\n    float sn = saturate(remap(sn_sample * sa, 1.0 - coverage * wmc, 1.0, 0.0, 1.0)) * da;\n    return sn;\n}\n\nfloat HG(float cos_angle, float g) {\n    float g2 = g * g;\n    float val = ((1.0 - g2) / pow( 1.0 + g2 - 2.0 * g * cos_angle, 1.5)) / 4.0 * 3.1415;\n    return val; \n}\nfloat InOutScatter(float cos_angle) {\n    float first_hg = HG(cos_angle, cloud_inscatter);\n    float second_hg = cloud_silver_intensity * pow(saturate(cos_angle), cloud_silver_exponent);\n    float in_scatter_hg = max(first_hg, second_hg); \n    float out_scatter_hg = HG(cos_angle, -cloud_outscatter);\n    return mix(in_scatter_hg, out_scatter_hg, cloud_in_vs_outscatter);\n}\nfloat Attenuation(float density_to_sun, float cos_angle){\n    float prim = exp(-cloud_beer * density_to_sun);\n    float scnd = exp(-cloud_beer * cloud_attuention_clampval) * 0.7;\n    // reduce clamping while facing the sun\n    float checkval = remap(cos_angle, 0.0, 1.0, scnd, scnd * 0.5); \n    return max(checkval, prim);\n}\nfloat OutScatterAmbient(float density,float percent_height){\n    float depth = cloud_outscatter_ambient * pow(density ,remap(percent_height, 0.3, 0.9, 0.5, 1.0));\n    float vertical = pow(saturate(remap(percent_height, 0.0, 0.3, 0.8, 1.0)), 0.8);\n    float out_scatter = depth * vertical;\n    out_scatter = 1.0 - saturate(out_scatter);\n    return out_scatter; \n}\n\nvec3 CalculateLight(vec3 sunLightColor, float density, float density_to_sun, float\n    cos_angle , float percent_height, float bluenoise, float dist_along_ray ){\n    float attenuation_prob = Attenuation(density_to_sun, cos_angle);\n    float ambient_out_scatter = OutScatterAmbient(density,percent_height);\n    // be calculated once for each march but gave no/tiny perf improvements.\n    float sun_highlight = InOutScatter(cos_angle);\n    float attenuation = attenuation_prob * sun_highlight * ambient_out_scatter;\n    //Ambient min (dist_along_ray used so that far away regions (huge steps ) arent calculated (wrongly))\n    attenuation = max(density * cloud_ambient_minimum * (1.0 - pow(saturate(dist_along_ray/4000.0), 2.0)), attenuation);\n    // combat banding a bit more\n    attenuation += bluenoise * 0.003;\n    vec3 ret_color = attenuation * sunLightColor;\n    return ret_color; \n}\n\n#ifndef MVT_CLOUD_VOLUMETRIC\nvec4 computePlanarCloud() {\n    vec2 cloudUV = vWorldPosition.xy * 0.1;\n    float uvOffset = time / 1000000.0 * speed;\n    vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);\n    float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);\n    // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);\n    // SNsample = R(snr, (sng ×0.625+snb ×0.25+sna ×0.125)−1, 1, 0, 1)\n    vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);\n    float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);\n    float sn = saturate(remap(sn_sample, 1.0 - coverage * wmc, 1.0, 0.0, 1.0));\n \n    float thickness = clamp(sn * thicknessScale + thicknessBias, 0.0, 1.0);\n    float cloudAlpha = clamp(thickness, 0.0, 1.0); // remap(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);\n    vec3 cloudColor = vec3(remap(clamp(cloudAlpha, 0.0, 1.0), 0.0, 1.0, 1.0, 0.6));\n\n    // 太阳散射，根据厚度发生变化\n    vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;\n    if (mixGrayFactor > 0.0) {\n        vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);\n        sunLightColor = mix(sunLightColor, gray, mixGrayFactor);\n    }\n    cloudColor = sunLightColor;\n    cloudColor = sunLightColor * (remap(thickness, 0.0, 1.0, 1.5, 0.5));\n    \n    // 天空大气颜色\n    vec3 sunDir = getSunDir();\n    vec3 rayDir = normalize(vWorldPosition.xzy);\n\n    cloudColor *= clamp(remap(dot(rayDir, sunDir), -1.0, 1.0, 0.75, 2.0), 0.75, 2.0);\n\n    vec3 atmosphereColor = getValFromSkyLUT(rayDir, sunDir);\n    atmosphereColor *= 100.0;\n    atmosphereColor = jodieReinhardTonemap(atmosphereColor);\n    atmosphereColor = pow(atmosphereColor, vec3(1.0/2.2));\n    atmosphereColor = toLinear(vec4(atmosphereColor, 1.0)).xyz;\n\n    float atmosphereColorFactor = remap(clamp(thickness, 0.5, 1.0), 0.5, 1.0, 0.0, 1.0);\n    atmosphereColorFactor = 0.5 - abs(0.5 - atmosphereColorFactor);\n    cloudColor = mix(cloudColor, atmosphereColor, atmosphereColorFactor);\n\n    // 和天空大气混合\n    cloudColor = mix(cloudColor, atmosphereColor, 1.0 - clamp((vWorldPosition.z + 0.02) * 10.0, 0.0, 1.0));\n\n    // cloudColor = atmosphereColor; // lum;\n    // vec3 cloudColor = texture2D(skyMap, cloudUV * 2.0).xyz * 10.0;\n    return vec4(cloudColor, cloudAlpha);\n}\n#endif\n\n#ifdef MVT_CLOUD_VOLUMETRIC\nvec4 computeVolumetricCloud() {\n    // vec2 cloudUV = vUv * 1.0;\n    // vec2 cloudUV = vWorldPosition.xy * 0.1;\n    // float uvOffset = time / 1000000.0 * speed;\n    // vec4 weatherColor = texture2D(weatherMap, cloudUV * sizeScale + uvOffset);\n    // float wmc = max(weatherColor.x, saturate(coverage - 0.5) * weatherColor.y * 2.0);\n    // // clouDensity = max(clouDensity, texture2D(noiseMap, cloudUV).x);\n    // // SNsample = R(snr, (sng ×0.625+snb ×0.25+sna ×0.125)−1, 1, 0, 1)\n    // vec4 noiseColor = texture2D(noiseMap, (cloudUV + uvOffset) * 10.0);\n    // float sn_sample = remap(noiseColor.x, noiseColor.y * 0.625 + noiseColor.z * 0.25 + 1.0 * 0.125 - 1.0, 1.0, 0.0, 1.0);\n    // float sn = saturate(remap(sn_sample, 1.0 - coverage * wmc, 1.0, 0.0, 1.0));\n\n    vec3 sunDir = getSunDir();\n    vec3 direction = normalize(vWorldPosition);\n    vec3 samplePos = vec3(vWorldPosition.xy, 0.4);\n    float directDensity = 0.0;\n    float sunDensity = 0.0;\n    vec3 cloudColor = vec3(0.0);\n\n    vec3 sunLightColor = texture(sunLightMap, vec2((1.0 + sin(skyAltitude)) * 0.5, 0.5)).xyz;\n    if (mixGrayFactor > 0.0) {\n        vec3 gray = vec3((sunLightColor.x + sunLightColor.y + sunLightColor.z) / 3.0);\n        sunLightColor = mix(sunLightColor, gray, mixGrayFactor);\n    }\n    float step = 0.6 / float(MVT_NUM_SAMPLE_STEPS);\n    vec2 cloudUV = samplePos.xy * 0.1;\n    for (int i = 0; i < MVT_NUM_SAMPLE_STEPS; i += 1) {\n        float blueNoise = (texture2D(blueNoiseMap, cloudUV) - 0.5).x * 0.1;\n        samplePos += direction * step * (1.0 + blueNoise);\n        float directSampleInfo = getCloud(samplePos);\n        directDensity += directSampleInfo;\n        vec3 sunPos = samplePos + sunDir * 0.05;\n        float sunSampleInfo = getCloud(sunPos);\n        sunDensity += directSampleInfo;\n        sunDensity += sunSampleInfo;\n\n        float ph = clamp((samplePos.z - 0.4) / 0.6, 0.0, 1.0);\n        cloudColor += CalculateLight(sunLightColor, (1.0 - directDensity) * 1.0, sunDensity * 0.5, dot(direction, sunDir.xzy), ph, 0.1, 10.0);\n    \n        // cloudColor += sunColor * clamp(1.0 - directSampleInfo - sunSampleInfo, 0.0, 1.0);\n        // cloudColor += CalculateLight(sunLightColor, 1.0 - directSampleInfo, sunSampleInfo, dot(direction, sunDir.xzy), ph, 0.1, float(i));\n        if (directDensity > 1.0) {\n            directDensity = 1.0;\n            break;\n        }\n    }\n    // float densityScale = 1.0 / sampleSteps * 20.0;\n    // float thickness = clamp(sn * thicknessScale + thicknessBias, 0.0, 1.0);\n    // directDensity /= float(MVT_NUM_SAMPLE_STEPS);\n    sunDensity /= float(MVT_NUM_SAMPLE_STEPS);\n    // cloudColor += CalculateLight(sunLightColor, directDensity, sunDensity, dot(direction, sunDir.xzy), 0.2, 0.1, 10.0);\n    float cloudAlpha = clamp(directDensity, 0.0, 1.0); // remap(clamp(sn, 0.0, 1. - thickness), 0.0, 1. - thickness, 0.0, 1.0);\n    // cloudColor = sunColor * dot(direction, sunDir) * exp(-0.3 * clamp(sunDensity, 0.0, 1.0));\n    // cloudColor = jodieReinhardTonemap(cloudColor);\n\n   \n    return vec4(cloudColor, cloudAlpha);\n}\n#endif\n\nvoid main() {\n    #ifdef MVT_CLOUD_VOLUMETRIC\n        gl_FragColor = computeVolumetricCloud();\n    #else\n        gl_FragColor = computePlanarCloud();\n    #endif\n    #include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}\n";
class iE extends En {
  constructor() {
    super(),
      (this.geometry = new Uo(2, 12, 12, 0, 2 * Math.PI, 0, Math.PI)),
      (this.frustumCulled = !1);
    ((this.material = new ShaderMaterial({
      uniforms: In.clone($b),
      vertexShader: eE,
      fragmentShader: tE,
      side: 2,
      transparent: !0,
      defines: { MVT_NUM_SAMPLE_STEPS: 4 },
    })).uniforms.sunLightMap.value = this.createGradientMap()),
      Object.defineProperties(this.material, {
        isEmissive: {
          get: function () {
            return this.uniforms.isEmissive.value;
          },
          set: function (e) {
            this.uniforms.isEmissive.value = e;
          },
        },
      }),
      this.rotateX(Math.PI / 2),
      this.scale.multiplyScalar(7e4);
  }
  createGradientMap() {
    let e = document.createElement("canvas");
    (e.width = 64), (e.height = 2);
    let t = e.getContext("2d"),
      i = t.createLinearGradient(0, 0, 64, 0);
    return (
      i.addColorStop(0, "rgb(0,0,0)"),
      i.addColorStop(0.45, "rgb(0,0,0)"),
      i.addColorStop(0.5, "rgb(200,30,10)"),
      i.addColorStop(0.52, "rgb(220,80,20)"),
      i.addColorStop(0.58, "rgb(255,255,255)"),
      i.addColorStop(1, "rgb(255,255,255)"),
      (t.fillStyle = i),
      t.fillRect(0, 0, 64, 2),
      (this._cachedGradientMap = new CanvasTexture(e)),
      this._cachedGradientMap
    );
  }
  dispose() {
    this._cachedGradientMap.dispose();
  }
  get speed() {
    return this.material.uniforms.speed.value;
  }
  set speed(e) {
    this.material.uniforms.speed.value = e;
  }
  get coverage() {
    return this.material.uniforms.coverage.value;
  }
  set coverage(e) {
    this.material.uniforms.coverage.value = e;
  }
  get density() {
    return this.material.uniforms.density.value;
  }
  set density(e) {
    this.material.uniforms.density.value = e;
  }
  get sizeScale() {
    return this.material.uniforms.sizeScale.value;
  }
  set sizeScale(e) {
    this.material.uniforms.sizeScale.value = e;
  }
  get skyAltitude() {
    return this.material.uniforms.skyAltitude.value;
  }
  set skyAltitude(e) {
    this.material.uniforms.skyAltitude.value = e;
  }
  get thicknessBias() {
    return this.material.uniforms.thicknessBias.value;
  }
  set thicknessBias(e) {
    this.material.uniforms.thicknessBias.value = e;
  }
  get thicknessScale() {
    return this.material.uniforms.thicknessScale.value;
  }
  set thicknessScale(e) {
    this.material.uniforms.thicknessScale.value = e;
  }
  get mixGrayFactor() {
    return this.material.uniforms.mixGrayFactor.value;
  }
  set mixGrayFactor(e) {
    this.material.uniforms.mixGrayFactor.value = e;
  }
  get sampleSteps() {
    return this.material.defines.MVT_NUM_SAMPLE_STEPS;
  }
  set sampleSteps(e) {
    e !== this.material.defines.MVT_NUM_SAMPLE_STEPS &&
      ((this.material.defines.MVT_NUM_SAMPLE_STEPS = parseInt(e, 10)),
      (this.material.needsUpdate = !0));
  }
  get volumetric() {
    return void 0 !== this.material.defines.MVT_CLOUD_VOLUMETRIC;
  }
  set volumetric(e) {
    e
      ? (this.material.defines.MVT_CLOUD_VOLUMETRIC = "")
      : delete this.material.defines.MVT_CLOUD_VOLUMETRIC,
      (this.material.needsUpdate = !0);
  }
}
class nE extends ug {
  constructor() {
    super(),
      (this.uniforms = In.clone(Zb.uniforms)),
      (this.material = new ShaderMaterial({
        defines: {},
        uniforms: this.uniforms,
        vertexShader: hg.vertexShader,
        fragmentShader: Zb.fragmentShader,
        depthTest: !1,
        depthWrite: !1,
      })),
      (this.needsSwap = !0),
      (this.fsQuad = new fg(null)),
      (this.needsDepthTexture = !0);
  }
  render(e, t, i) {
    const n = this.sky;
    if (!n) return;
    const s = this.rendering,
      r = s.camera,
      a = n.skyAtmosphere,
      o = this.uniforms;
    (o.altitude.value = a.altitude),
      (o.tDiffuse.value = i.texture),
      (o.tDepth.value = s.main.sceneRendering.depthTexture),
      (o.tNormal.value = s.main.sceneRendering.normalTexture),
      (o.tAtmosphere.value = a.material.uniforms.viewTexture.value),
      (o.viewHeight.value = a.material.uniforms.viewHeight.value),
      o.projectionInverseMatrix.value.copy(r.projectionMatrixInverse),
      o.viewInverseMatrix.value.copy(r.matrixWorld),
      (o.cameraNear.value = r.near),
      (o.cameraFar.value = r.far),
      o.cameraPosition.value.copy(r.position),
      (o.viewHeight.value = r.position.z / 1e6);
    const l = e.autoClear;
    (e.autoClear = !1),
      (this.fsQuad.material = this.material),
      e.setRenderTarget(this.renderToScreen ? null : t),
      e.clear(),
      this.fsQuad.render(e),
      (e.autoClear = l);
  }
  dispose() {
    this.material.dispose(), this.fsQuad.dispose();
  }
}
new zn(new Vector3(0, 0, 1), 0);
class sE extends Wm {
  constructor() {
    super(),
      publicField(this, "isUltraDynamicSky", !0),
      publicField(this, "_rtFlipCount", 0),
      publicField(this, "_skyNeedsUpdate", !0),
      publicField(this, "_staticEnvMapNeedsUpdate", !0),
      publicField(this, "_realtimeCapture", !0),
      publicField(this, "_envMapType", 2),
      publicField(this, "_PMREMGenerator", null),
      publicField(this, "_cloud", null),
      publicField(this, "_envRenderTarget1", null),
      publicField(this, "_envRenderTarget2", null),
      publicField(this, "_skyAtmosphere", null),
      publicField(this, "name", "UltraDynamicSky"),
      publicField(this, "dynamicCloud", !1),
      publicField(this, "updateRealtimeEnvironment", () => {
        const e = this.engine;
        if (
          ((this._skyAtmosphere.material.uStarVisible = !1),
          !this._envRenderTarget1)
        ) {
          this.disposeEnvRenderTarget(1),
            (this._PMREMGenerator = new ds(e.renderer));
          const t = (this._envRenderTarget1 = new ut(1, 1, {
            type: G,
            format: Q,
            colorSpace: me,
            depthBuffer: !1,
          }));
          (t.texture.mapping = M),
            (t.texture.name = "PMREM.cubeUv1"),
            (t.scissorTest = !0);
          const i = (this._envRenderTarget2 = new ut(1, 1, {
            type: G,
            format: Q,
            colorSpace: me,
            depthBuffer: !1,
          }));
          (i.texture.mapping = M),
            (i.texture.name = "PMREM.cubeUv2"),
            (i.scissorTest = !0),
            this._PMREMGenerator.prepareForRenderTarget(
              this._envRenderTarget1,
              this._envRenderTarget2,
              64
            );
        }
        e.rendering.objectsScene.visible = !1;
        const t = e.scene;
        let i = t.background;
        (t.background = {}),
          this._rtFlipCount % 2 == 0
            ? (this._PMREMGenerator.fromSceneToRenderTarget(
                e.scene,
                this._envRenderTarget1,
                this._envRenderTarget2,
                0,
                0.1,
                1e4
              ),
              (e.rendering.scene.environment = this._envRenderTarget1.texture))
            : (this._PMREMGenerator.fromSceneToRenderTarget(
                e.scene,
                this._envRenderTarget2,
                this._envRenderTarget1,
                0,
                0.1,
                1e4
              ),
              (e.rendering.scene.environment = this._envRenderTarget2.texture)),
          (t.background = i),
          (e.rendering.objectsScene.visible = !0),
          (this._skyAtmosphere.material.uStarVisible = !0);
      }),
      publicField(this, "disposeEnvRenderTarget", (e) => {
        this._envRenderTarget1 &&
          (this._envRenderTarget1.dispose(), (this._envRenderTarget1 = null)),
          this._envRenderTarget2 &&
            (this._envRenderTarget2.dispose(), (this._envRenderTarget2 = null));
      }),
      (this._affectWorld = !0);
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e), (this.engine = e), this.initEnv();
  }
  initEnv() {
    const e = this.engine,
      t = (this._skyAtmosphere = new Jb());
    (t.collisionDisabled = !0),
      (t.__isEnvironment = !0),
      (t.renderOrder = -100),
      e.add(t);
    const i = (this._cloud = new iE()),
      n = new yl(),
      s = n.load(Hm("assets/textures/cloud/weather_1.png"), (e) => {
        (s.wrapS = s.wrapT = w), (i.material.uniforms.weatherMap.value = s);
      }),
      r = n.load(Hm("assets/textures/cloud/shape_1.png"), (e) => {
        (r.wrapS = r.wrapT = w), (i.material.uniforms.noiseMap.value = r);
      }),
      a = n.load(Hm("assets/textures/cloud/blue_noise.png"), (e) => {
        (a.wrapS = a.wrapT = w), (i.material.uniforms.blueNoiseMap.value = a);
      }),
      o = n.load(Hm("assets/textures/cloud/3d_noise_128.png"), (e) => {
        (o.wrapS = o.wrapT = w), (i.material.uniforms.shapeNoiseMap.value = o);
      }),
      l = n.load(Hm("assets/textures/sky/moon/moonNoise.png"), (e) => {
        (l.wrapS = l.wrapT = w), (t.material.uMoonMap = l);
      });
    (i.material.uniforms.skyMap.value = t.material.uniforms.viewTexture.value),
      (i.__isEnvironment = !0),
      (i.renderOrder = -99),
      e.add(i);
    const h = (this._postPass = new nE());
    (h.renderOrder = 2e3),
      (h.sky = this),
      e.rendering.main.postprocessings.add(h);
  }
  onBeforeScenePrepareRender() {
    super.onBeforeScenePrepareRender();
    const e = this.engine,
      t = this._skyAtmosphere,
      i = this._cloud;
    (t.material.uTime = e.rendering.uniforms.elapsedTime.value),
      this._PMREMGenerator &&
        this._PMREMGenerator._renderer !== e.renderer &&
        ((this._PMREMGenerator._renderer = e.renderer),
        (t._hasPaintedScatterBuffer = !1),
        (this._skyNeedsUpdate = !0)),
      this._skyNeedsUpdate &&
        (t.updateRenderTargets(e.rendering.renderer, e.rendering.camera),
        (i.material.uniforms.skyAltitude.value = t.altitude)),
      this.dynamicCloud &&
        (i.material.uniforms.time.value =
          e.rendering.uniforms.elapsedTime.value),
      (this._skyNeedsUpdate || this.dynamicCloud) &&
        (t.position.set(0, 0, 0),
        t.updateMatrixWorld(),
        i.position.set(0, 0, 0),
        i.updateMatrixWorld(),
        this._affectWorld &&
          (e.rendering.stats.beginTimeStatsItem("Sky.CaptureEnvironment"),
          this.updateRealtimeEnvironment(),
          e.rendering.stats.endTimeStatsItem("Sky.CaptureEnvironment"))),
      this._affectWorld || (e.rendering.scene.environment = null),
      t.position.copy(e.rendering.camera.position),
      (t.position.z -= 0),
      i.position.copy(e.rendering.camera.position),
      (this._skyNeedsUpdate = !1);
  }
  updateLight() {
    if ((super.updateLight(), this._lensflare)) {
      const e = this._sunDirection.z,
        t = this._sunDirection.x;
      let i = 10 * this.engine.map.getCameraDistance();
      if (e > 0.01 && this.sunLight.intensity > 0.1 && i < 1e6) {
        this._lensflare.visible = !0;
        const [n, s] = this.engine.map.getProjectionCenter2D();
        this._lensflare.position.set(n + t * i, s, e * i);
      } else this._lensflare.visible = !1;
    }
  }
  onTimeChanged(e) {
    (this._skyAtmosphere.altitude = (e / 86400 - 0.25) * Math.PI * 2),
      (this._skyNeedsUpdate = !0);
  }
  getTextures() {
    return 2 === this._envMapType
      ? [this._envRenderTarget1.texture, this._envRenderTarget2.texture]
      : [];
  }
  set affectWorld(e) {
    this._affectWorld = e;
  }
  get affectWorld() {
    return this._affectWorld;
  }
  get cloudIntensity() {
    return this._cloud.coverage;
  }
  set cloudIntensity(e) {
    (this._cloud.coverage = e), (this._skyNeedsUpdate = !0);
  }
  get mixGrayFactor() {
    return this._skyAtmosphere.mixGrayFactor;
  }
  set mixGrayFactor(e) {
    (this._skyAtmosphere.mixGrayFactor = e),
      (this._cloud.mixGrayFactor = e),
      (this._skyNeedsUpdate = !0);
  }
  get realtimeCapture() {
    return this._realtimeCapture;
  }
  set realtimeCapture(e) {
    e !== this._realtimeCapture &&
      (console.warn("has not been supported"),
      (this._skyNeedsUpdate = !0),
      (this._realtimeCapture = e));
  }
  get skyAtmosphere() {
    return this._skyAtmosphere;
  }
  get clipUnderground() {
    return !1;
  }
  set clipUnderground(e) {
    console.warn("has not been supported");
  }
  get enablePostPass() {
    return this._postPass.enabled || !1;
  }
  set enablePostPass(e) {
    this._postPass && (this._postPass.enabled = e);
  }
  beforeRemoveFromEngine(e) {
    this.disposeEnvRenderTarget(this._realtimeCapture),
      e.remove(this._skyAtmosphere),
      e.remove(this._cloud),
      e.rendering.main.postprocessings.remove(this._postPass);
  }
  dispose() {
    super.dispose();
  }
}
class rE extends Wm {
  constructor(e = {}) {
    super(),
      publicField(this, "isSphereSky", !0),
      publicField(this, "_textureIsCube", !1),
      publicField(this, "_textureIsHDR", !1),
      publicField(this, "_textureURL", null),
      publicField(this, "_textureNames", null),
      publicField(this, "_affectWorld", !0),
      publicField(this, "_isVerticalTexture", null),
      publicField(this, "_mesh", null),
      publicField(this, "_material", null),
      publicField(this, "_sphereGeometry", null),
      publicField(this, "_engine", null),
      e.texture;
  }
  afterAddToEngine(e) {
    (this._engine = e), super.afterAddToEngine(e);
    const t = (this._sphereGeometry = new Uo(1, 32, 32)),
      i = (this._material = this.createMaterial()),
      n = (this._mesh = new En(t, i));
    (n.frustumCulled = !1),
      n.scale.setScalar(1e4),
      n.rotateX(Math.PI / 2),
      (n.renderOrder = -1e4),
      (n.raycast = () => {}),
      this.add(n);
  }
  createMaterial() {
    return new Oi();
  }
  onBeforeScenePrepareRender(e, t, i) {
    this._mesh.position.copy(i.position), super.onBeforeScenePrepareRender(e);
  }
}
const aE = {
  gradients: {
    value: [
      { stop: 0, color: new Color(1 / 255, 1 / 255, 1 / 255) },
      {
        stop: 0.01,
        color: new Color(41 / 255 / 4, 53 / 255 / 4, 93 / 255 / 4),
      },
      {
        stop: 0.03,
        color: new Color(41 / 255 / 8, 53 / 255 / 8, 93 / 255 / 8),
      },
      {
        stop: 0.09,
        color: new Color(41 / 255 / 32, 53 / 255 / 32, 93 / 255 / 32),
      },
      { stop: 0.15, color: new Color(1 / 255, 1 / 255, 1 / 255) },
    ],
  },
  isEmissive: { value: !1 },
};
class oE extends ShaderMaterial {
  constructor(e) {
    super(),
      (this.defines = { NUM_COLORS: 5 }),
      (this.uniforms = In.clone(aE)),
      (this.side = 2),
      (this.vertexShader =
        "#define GLSLIFY 1\nvarying vec2 vUv;\nvarying float vZ;\n\nvoid main()\n{\n    vec4 viewPos = modelViewMatrix * vec4(position, 1.0);\n    vUv = uv;\n    vZ = position.y;\n    gl_Position = projectionMatrix * viewPos;\n    gl_Position.z = gl_Position.w;\n}\n"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\nvarying vec2 vUv;\nvarying float vZ;\nuniform float zBottom;\nuniform float zTop;\nstruct ColorStop {\n    float stop;\n    vec3 color;\n};\nuniform ColorStop gradients[NUM_COLORS];\n\nvoid main() {\n\n    // float v = 0.01;\n    // if (vZ >= zTop) {\n    //     v = 0.98;\n    // }\n    // else if (vZ > zBottom) {\n    //     v = (vZ - zBottom) / (zTop - zBottom);\n    // }\n    // gl_FragColor = texture2D(map, vec2(0.5, vZ > 0. ? vZ * 2.0 : 0.));\n\n    vec3 outColor;\n    int last = NUM_COLORS - 1;\n    if (vZ <= gradients[0].stop) {\n        outColor = gradients[0].color;\n    }\n    else if (vZ >= gradients[last].stop) {\n        outColor = gradients[last].color;\n    }\n    else {\n        float startRatio;\n        float endRatio;\n        for (int i = 1; i < NUM_COLORS; i++) {\n            endRatio = gradients[i].stop;\n            if (vZ < endRatio) {\n                startRatio = gradients[i - 1].stop;\n                outColor = mix(gradients[i - 1].color, gradients[i].color, (vZ - startRatio) / (endRatio - startRatio));\n                break;\n            }\n        }\n    }\n   \n    gl_FragColor = vec4(outColor, 1.0);\n    #include <colorspace_fragment>\n}\n"),
      (this.depthWrite = !1),
      (this.depthTest = !1),
      (this.envMap = null),
      N_(this, ["isEmissive"]);
  }
  get gradients() {
    return this.uniforms.gradients.value;
  }
  set gradients(e) {
    (!Array.isArray(e) || e.length < 2) &&
      console.warn(
        "gradient must be an array and the length of gradients must be greater than 1"
      ),
      (this.defines.NUM_COLORS = e.length),
      e.sort((e, t) => e.stop < t.stop),
      (this.uniforms.gradients.value = e);
  }
}
class lE {
  constructor() {
    publicField(this, "_retryTimes", 3),
      publicField(this, "_queued", {}),
      publicField(this, "_cached", {});
  }
  async generate(e) {
    return {};
  }
  async get(e) {
    if (this._cached[e]) return this._cached[e];
    let t = !1;
    this._queued[e] || ((this._queued[e] = []), (t = !0));
    const i = new Promise((t, i) => {
        this._queued[e].push([t, i]);
      }),
      n = this._queued[e];
    if (t) {
      for (let t = 0; t < this._retryTimes; t++)
        try {
          const t = await this.generate(e);
          this._cached[e] = t;
          for (const e of n) e[0](t);
          break;
        } catch (s) {
          console.warn(s);
        }
      for (const e of n) e[1]();
    }
    return i;
  }
  get keys() {
    return Object.keys(this._cached);
  }
}
function hE(e, t) {
  if (0 === t)
    return (
      console.warn(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."
      ),
      e
    );
  if (2 === t || 1 === t) {
    let i = e.getIndex();
    if (null === i) {
      const t = [],
        n = e.getAttribute("position");
      if (void 0 === n)
        return (
          console.error(
            "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."
          ),
          e
        );
      for (let e = 0; e < n.count; e++) t.push(e);
      e.setIndex(t), (i = e.getIndex());
    }
    const n = i.count - 2,
      s = [];
    if (2 === t)
      for (let e = 1; e <= n; e++)
        s.push(i.getX(0)), s.push(i.getX(e)), s.push(i.getX(e + 1));
    else
      for (let e = 0; e < n; e++)
        e % 2 == 0
          ? (s.push(i.getX(e)), s.push(i.getX(e + 1)), s.push(i.getX(e + 2)))
          : (s.push(i.getX(e + 2)), s.push(i.getX(e + 1)), s.push(i.getX(e)));
    s.length / 3 !== n &&
      console.error(
        "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles."
      );
    const r = e.clone();
    return r.setIndex(s), r.clearGroups(), r;
  }
  return (
    console.error(
      "THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:",
      t
    ),
    e
  );
}
class cE extends pl {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (e) {
        return new gE(e);
      }),
      this.register(function (e) {
        return new SE(e);
      }),
      this.register(function (e) {
        return new CE(e);
      }),
      this.register(function (e) {
        return new ME(e);
      }),
      this.register(function (e) {
        return new vE(e);
      }),
      this.register(function (e) {
        return new AE(e);
      }),
      this.register(function (e) {
        return new yE(e);
      }),
      this.register(function (e) {
        return new xE(e);
      }),
      this.register(function (e) {
        return new mE(e);
      }),
      this.register(function (e) {
        return new bE(e);
      }),
      this.register(function (e) {
        return new _E(e);
      }),
      this.register(function (e) {
        return new EE(e);
      }),
      this.register(function (e) {
        return new pE(e);
      }),
      this.register(function (e) {
        return new wE(e);
      }),
      this.register(function (e) {
        return new TE(e);
      });
  }
  load(e, t, i, n) {
    const s = this;
    let r;
    (r =
      "" !== this.resourcePath
        ? this.resourcePath
        : "" !== this.path
        ? this.path
        : Bl.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (t) {
        n ? n(t) : console.error(t),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      o = new gl(this.manager);
    o.setPath(this.path),
      o.setResponseType("arraybuffer"),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (i) {
          try {
            s.parse(
              i,
              r,
              function (i) {
                t(i), s.manager.itemEnd(e);
              },
              a
            );
          } catch (Ym) {
            a(Ym);
          }
        },
        i,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      -1 !== this.pluginCallbacks.indexOf(e) &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, n) {
    let s;
    const r = {},
      a = {},
      o = new TextDecoder();
    if ("string" == typeof e) s = JSON.parse(e);
    else if (e instanceof ArrayBuffer) {
      if (o.decode(new Uint8Array(e, 0, 4)) === IE) {
        try {
          r[dE.KHR_BINARY_GLTF] = new DE(e);
        } catch (h) {
          return void (n && n(h));
        }
        s = JSON.parse(r[dE.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(o.decode(e));
    } else s = e;
    if (void 0 === s.asset || s.asset.version[0] < 2)
      return void (
        n &&
        n(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        )
      );
    const l = new nS(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const e = this.pluginCallbacks[c](l);
      (a[e.name] = e), (r[e.name] = !0);
    }
    if (s.extensionsUsed)
      for (let c = 0; c < s.extensionsUsed.length; ++c) {
        const e = s.extensionsUsed[c],
          t = s.extensionsRequired || [];
        switch (e) {
          case dE.KHR_MATERIALS_UNLIT:
            r[e] = new fE();
            break;
          case dE.KHR_DRACO_MESH_COMPRESSION:
            r[e] = new LE(s, this.dracoLoader);
            break;
          case dE.KHR_TEXTURE_TRANSFORM:
            r[e] = new FE();
            break;
          case dE.KHR_MESH_QUANTIZATION:
            r[e] = new NE();
            break;
          case dE.KHR_TEXTURE_BASISU:
            r[e] = new SE(l);
            break;
          default:
            t.indexOf(e) >= 0 &&
              void 0 === a[e] &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".');
        }
      }
    if (s.textures)
      for (let c = 0, u = s.textures.length; c < u; c++) {
        const e = s.textures[c];
        e.extensions &&
          e.extensions.KHR_texture_basisu &&
          "number" == typeof e.extensions.KHR_texture_basisu.source &&
          (e.source = e.source || e.extensions.KHR_texture_basisu.source);
        "image/ktx2" === s.images[e.source].mimeType &&
          ((r.KHR_texture_basisu = new SE(l)),
          (s.textures[c].extensions = { KHR_texture_basisu: e }));
      }
    l.setExtensions(r), l.setPlugins(a), l.parse(i, n);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (n, s) {
      i.parse(e, t, n, s);
    });
  }
}
function uE() {
  let e = {};
  return {
    get: function (t) {
      return e[t];
    },
    add: function (t, i) {
      e[t] = i;
    },
    remove: function (t) {
      delete e[t];
    },
    removeAll: function () {
      e = {};
    },
  };
}
const dE = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class pE {
  constructor(e) {
    (this.parser = e),
      (this.name = dE.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, n = t.length; i < n; i++) {
      const n = t[i];
      n.extensions &&
        n.extensions[this.name] &&
        void 0 !== n.extensions[this.name].light &&
        e._addNodeRef(this.cache, n.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let n = t.cache.get(i);
    if (n) return n;
    const s = t.json,
      r = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let a;
    const o = new Color(16777215);
    void 0 !== r.color && o.fromArray(r.color);
    const l = void 0 !== r.range ? r.range : 0;
    switch (r.type) {
      case "directional":
        (a = new Nl(o)), a.target.position.set(0, 0, -1), a.add(a.target);
        break;
      case "point":
        (a = new Ll(o)), (a.distance = l);
        break;
      case "spot":
        (a = new Tl(o)),
          (a.distance = l),
          (r.spot = r.spot || {}),
          (r.spot.innerConeAngle =
            void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0),
          (r.spot.outerConeAngle =
            void 0 !== r.spot.outerConeAngle
              ? r.spot.outerConeAngle
              : Math.PI / 4),
          (a.angle = r.spot.outerConeAngle),
          (a.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle),
          a.target.position.set(0, 0, -1),
          a.add(a.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + r.type);
    }
    return (
      a.position.set(0, 0, 0),
      (a.decay = 2),
      ZE(a, r),
      void 0 !== r.intensity && (a.intensity = r.intensity),
      (a.name = t.createUniqueName(r.name || "light_" + e)),
      (n = Promise.resolve(a)),
      t.cache.add(i, n),
      n
    );
  }
  getDependency(e, t) {
    if ("light" === e) return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      n = i.json.nodes[e],
      s = ((n.extensions && n.extensions[this.name]) || {}).light;
    return void 0 === s
      ? null
      : this._loadLight(s).then(function (e) {
          return i._getNodeRef(t.cache, s, e);
        });
  }
}
class fE {
  constructor() {
    this.name = dE.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Oi;
  }
  extendParams(e, t, i) {
    const n = [];
    (e.color = new Color(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const t = s.baseColorFactor;
        e.color.fromArray(t), (e.opacity = t[3]);
      }
      void 0 !== s.baseColorTexture &&
        n.push(i.assignTexture(e, "map", s.baseColorTexture, me));
    }
    return Promise.all(n);
  }
}
class mE {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const n = i.extensions[this.name].emissiveStrength;
    return void 0 !== n && (t.emissiveIntensity = n), Promise.resolve();
  }
}
class gE {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    if (
      (void 0 !== r.clearcoatFactor && (t.clearcoat = r.clearcoatFactor),
      void 0 !== r.clearcoatTexture &&
        s.push(i.assignTexture(t, "clearcoatMap", r.clearcoatTexture)),
      void 0 !== r.clearcoatRoughnessFactor &&
        (t.clearcoatRoughness = r.clearcoatRoughnessFactor),
      void 0 !== r.clearcoatRoughnessTexture &&
        s.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            r.clearcoatRoughnessTexture
          )
        ),
      void 0 !== r.clearcoatNormalTexture &&
        (s.push(
          i.assignTexture(t, "clearcoatNormalMap", r.clearcoatNormalTexture)
        ),
        void 0 !== r.clearcoatNormalTexture.scale))
    ) {
      const e = r.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Vector2(e, e);
    }
    return Promise.all(s);
  }
}
class _E {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    return (
      void 0 !== r.iridescenceFactor && (t.iridescence = r.iridescenceFactor),
      void 0 !== r.iridescenceTexture &&
        s.push(i.assignTexture(t, "iridescenceMap", r.iridescenceTexture)),
      void 0 !== r.iridescenceIor && (t.iridescenceIOR = r.iridescenceIor),
      void 0 === t.iridescenceThicknessRange &&
        (t.iridescenceThicknessRange = [100, 400]),
      void 0 !== r.iridescenceThicknessMinimum &&
        (t.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum),
      void 0 !== r.iridescenceThicknessMaximum &&
        (t.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum),
      void 0 !== r.iridescenceThicknessTexture &&
        s.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            r.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class vE {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new Color(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const r = n.extensions[this.name];
    return (
      void 0 !== r.sheenColorFactor &&
        t.sheenColor.fromArray(r.sheenColorFactor),
      void 0 !== r.sheenRoughnessFactor &&
        (t.sheenRoughness = r.sheenRoughnessFactor),
      void 0 !== r.sheenColorTexture &&
        s.push(i.assignTexture(t, "sheenColorMap", r.sheenColorTexture, me)),
      void 0 !== r.sheenRoughnessTexture &&
        s.push(
          i.assignTexture(t, "sheenRoughnessMap", r.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class AE {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    return (
      void 0 !== r.transmissionFactor &&
        (t.transmission = r.transmissionFactor),
      void 0 !== r.transmissionTexture &&
        s.push(i.assignTexture(t, "transmissionMap", r.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class yE {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    (t.thickness = void 0 !== r.thicknessFactor ? r.thicknessFactor : 0),
      void 0 !== r.thicknessTexture &&
        s.push(i.assignTexture(t, "thicknessMap", r.thicknessTexture)),
      (t.attenuationDistance = r.attenuationDistance || 1 / 0);
    const a = r.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new Color(a[0], a[1], a[2])), Promise.all(s);
  }
}
class xE {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const n = i.extensions[this.name];
    return (t.ior = void 0 !== n.ior ? n.ior : 1.5), Promise.resolve();
  }
}
class bE {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    (t.specularIntensity = void 0 !== r.specularFactor ? r.specularFactor : 1),
      void 0 !== r.specularTexture &&
        s.push(i.assignTexture(t, "specularIntensityMap", r.specularTexture));
    const a = r.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Color(a[0], a[1], a[2])),
      void 0 !== r.specularColorTexture &&
        s.push(
          i.assignTexture(t, "specularColorMap", r.specularColorTexture, me)
        ),
      Promise.all(s)
    );
  }
}
class EE {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    return (
      void 0 !== r.anisotropyStrength && (t.anisotropy = r.anisotropyStrength),
      void 0 !== r.anisotropyRotation &&
        (t.anisotropyRotation = r.anisotropyRotation),
      void 0 !== r.anisotropyTexture &&
        s.push(i.assignTexture(t, "anisotropyMap", r.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class SE {
  constructor(e) {
    (this.parser = e), (this.name = dE.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      n = i.textures[e];
    if (!n.extensions || !n.extensions[this.name]) return null;
    const s = n.extensions[this.name],
      r = t.options.ktx2Loader;
    if (!r) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, r);
  }
}
class CE {
  constructor(e) {
    (this.parser = e),
      (this.name = dE.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      n = i.json,
      s = n.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const r = s.extensions[t],
      a = n.images[r.source];
    let o = i.textureLoader;
    if (a.uri) {
      const e = i.options.manager.getHandler(a.uri);
      null !== e && (o = e);
    }
    return this.detectSupport().then(function (s) {
      if (s) return i.loadTextureImage(e, r.source, o);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(1 === t.height);
              });
        })),
      this.isSupported
    );
  }
}
class ME {
  constructor(e) {
    (this.parser = e),
      (this.name = dE.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      n = i.json,
      s = n.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const r = s.extensions[t],
      a = n.images[r.source];
    let o = i.textureLoader;
    if (a.uri) {
      const e = i.options.manager.getHandler(a.uri);
      null !== e && (o = e);
    }
    return this.detectSupport().then(function (s) {
      if (s) return i.loadTextureImage(e, r.source, o);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(1 === t.height);
              });
        })),
      this.isSupported
    );
  }
}
class wE {
  constructor(e) {
    (this.name = dE.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const e = i.extensions[this.name],
        n = this.parser.getDependency("buffer", e.buffer),
        s = this.parser.options.meshoptDecoder;
      if (!s || !s.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return n.then(function (t) {
        const i = e.byteOffset || 0,
          n = e.byteLength || 0,
          r = e.count,
          a = e.byteStride,
          o = new Uint8Array(t, i, n);
        return s.decodeGltfBufferAsync
          ? s
              .decodeGltfBufferAsync(r, a, o, e.mode, e.filter)
              .then(function (e) {
                return e.buffer;
              })
          : s.ready.then(function () {
              const t = new ArrayBuffer(r * a);
              return (
                s.decodeGltfBuffer(
                  new Uint8Array(t),
                  r,
                  a,
                  o,
                  e.mode,
                  e.filter
                ),
                t
              );
            });
      });
    }
    return null;
  }
}
class TE {
  constructor(e) {
    (this.name = dE.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || void 0 === i.mesh)
      return null;
    const n = t.meshes[i.mesh];
    for (const o of n.primitives)
      if (
        o.mode !== UE.TRIANGLES &&
        o.mode !== UE.TRIANGLE_STRIP &&
        o.mode !== UE.TRIANGLE_FAN &&
        void 0 !== o.mode
      )
        return null;
    const s = i.extensions[this.name].attributes,
      r = [],
      a = {};
    for (const o in s)
      r.push(
        this.parser
          .getDependency("accessor", s[o])
          .then((e) => ((a[o] = e), a[o]))
      );
    return r.length < 1
      ? null
      : (r.push(this.parser.createNodeMesh(e)),
        Promise.all(r).then((e) => {
          const t = e.pop(),
            i = t.isGroup ? t.children : [t],
            n = e[0].count,
            s = [];
          for (const r of i) {
            const e = new Matrix4(),
              t = new Vector3(),
              i = new Quaternion(),
              o = new Vector3(1, 1, 1),
              l = new eo(r.geometry, r.material, n);
            for (let s = 0; s < n; s++)
              a.TRANSLATION && t.fromBufferAttribute(a.TRANSLATION, s),
                a.ROTATION && i.fromBufferAttribute(a.ROTATION, s),
                a.SCALE && o.fromBufferAttribute(a.SCALE, s),
                l.setMatrixAt(s, e.compose(t, i, o));
            for (const n in a)
              "TRANSLATION" !== n &&
                "ROTATION" !== n &&
                "SCALE" !== n &&
                r.geometry.setAttribute(n, a[n]);
            Object3D.prototype.copy.call(l, r),
              this.parser.assignFinalMaterial(l),
              s.push(l);
          }
          return t.isGroup ? (t.clear(), t.add(...s), t) : s[0];
        }));
  }
}
const IE = "glTF",
  RE = 1313821514,
  PE = 5130562;
class DE {
  constructor(e) {
    (this.name = dE.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, 12),
      i = new TextDecoder();
    if (
      ((this.header = {
        magic: i.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== IE)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - 12,
      s = new DataView(e, 12);
    let r = 0;
    for (; r < n; ) {
      const t = s.getUint32(r, !0);
      r += 4;
      const n = s.getUint32(r, !0);
      if (((r += 4), n === RE)) {
        const n = new Uint8Array(e, 12 + r, t);
        this.content = i.decode(n);
      } else if (n === PE) {
        const i = 12 + r;
        this.body = e.slice(i, i + t);
      }
      r += t;
    }
    if (null === this.content)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class LE {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = dE.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json,
      n = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      r = e.extensions[this.name].attributes,
      a = {},
      o = {},
      l = {};
    for (const h in r) {
      const e = HE[h] || h.toLowerCase();
      a[e] = r[h];
    }
    for (const h in e.attributes) {
      const t = HE[h] || h.toLowerCase();
      if (void 0 !== r[h]) {
        const n = i.accessors[e.attributes[h]],
          s = zE[n.componentType];
        (l[t] = s.name), (o[t] = !0 === n.normalized);
      }
    }
    return t.getDependency("bufferView", s).then(function (e) {
      return new Promise(function (t) {
        n.decodeDracoFile(
          e,
          function (e) {
            for (const t in e.attributes) {
              const i = e.attributes[t],
                n = o[t];
              void 0 !== n && (i.normalized = n);
            }
            t(e);
          },
          a,
          l
        );
      });
    });
  }
}
class FE {
  constructor() {
    this.name = dE.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (void 0 !== t.texCoord && t.texCoord !== e.channel) ||
      void 0 !== t.offset ||
      void 0 !== t.rotation ||
      void 0 !== t.scale
      ? ((e = e.clone()),
        void 0 !== t.texCoord && (e.channel = t.texCoord),
        void 0 !== t.offset && e.offset.fromArray(t.offset),
        void 0 !== t.rotation && (e.rotation = t.rotation),
        void 0 !== t.scale && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0),
        e)
      : e;
  }
}
class NE {
  constructor() {
    this.name = dE.KHR_MESH_QUANTIZATION;
  }
}
class BE extends Ko {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      n = this.valueSize,
      s = e * n * 3 + n;
    for (let r = 0; r !== n; r++) t[r] = i[s + r];
    return t;
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      a = this.valueSize,
      o = 2 * a,
      l = 3 * a,
      h = n - t,
      c = (i - t) / h,
      u = c * c,
      d = u * c,
      p = e * l,
      f = p - l,
      m = -2 * d + 3 * u,
      g = d - u,
      _ = 1 - m,
      v = g - u + c;
    for (let A = 0; A !== a; A++) {
      const e = r[f + A + a],
        t = r[f + A + o] * h,
        i = r[p + A + a],
        n = r[p + A] * h;
      s[A] = _ * e + v * t + m * i + g * n;
    }
    return s;
  }
}
const kE = new Quaternion();
class OE extends BE {
  interpolate_(e, t, i, n) {
    const s = super.interpolate_(e, t, i, n);
    return kE.fromArray(s).normalize().toArray(s), s;
  }
}
const UE = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  zE = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  GE = { 9728: R, 9729: L, 9984: P, 9985: F, 9986: D, 9987: N },
  VE = { 33071: T, 33648: I, 10497: w },
  QE = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  HE = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  jE = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  WE = { CUBICSPLINE: void 0, LINEAR: ae, STEP: re },
  qE = "OPAQUE",
  XE = "MASK",
  YE = "BLEND";
function KE(e, t, i) {
  for (const n in i.extensions)
    void 0 === e[n] &&
      ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
      (t.userData.gltfExtensions[n] = i.extensions[n]));
}
function ZE(e, t) {
  void 0 !== t.extras &&
    ("object" == typeof t.extras
      ? Object.assign(e.userData, t.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
        ));
}
function JE(e, t) {
  if ((e.updateMorphTargets(), void 0 !== t.weights))
    for (let i = 0, n = t.weights.length; i < n; i++)
      e.morphTargetInfluences[i] = t.weights[i];
  if (t.extras && Array.isArray(t.extras.targetNames)) {
    const i = t.extras.targetNames;
    if (e.morphTargetInfluences.length === i.length) {
      e.morphTargetDictionary = {};
      for (let t = 0, n = i.length; t < n; t++)
        e.morphTargetDictionary[i[t]] = t;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function $E(e) {
  let t;
  const i = e.extensions && e.extensions[dE.KHR_DRACO_MESH_COMPRESSION];
  if (
    ((t = i
      ? "draco:" + i.bufferView + ":" + i.indices + ":" + eS(i.attributes)
      : e.indices + ":" + eS(e.attributes) + ":" + e.mode),
    void 0 !== e.targets)
  )
    for (let n = 0, s = e.targets.length; n < s; n++)
      t += ":" + eS(e.targets[n]);
  return t;
}
function eS(e) {
  let t = "";
  const i = Object.keys(e).sort();
  for (let n = 0, s = i.length; n < s; n++) t += i[n] + ":" + e[i[n]] + ";";
  return t;
}
function tS(e) {
  switch (e) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
const iS = new Matrix4();
class nS {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new uE()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let i = !1,
      n = !1,
      s = -1;
    "undefined" != typeof navigator &&
      ((i = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)),
      (n = navigator.userAgent.indexOf("Firefox") > -1),
      (s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      "undefined" == typeof createImageBitmap || i || (n && s < 98)
        ? (this.textureLoader = new yl(this.options.manager))
        : (this.textureLoader = new Ol(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new gl(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      "use-credentials" === this.options.crossOrigin &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      n = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (e) {
        return e._markDefs && e._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (e) {
          return e.beforeRoot && e.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (t) {
          const r = {
            scene: t[0][n.scene || 0],
            scenes: t[0],
            animations: t[1],
            cameras: t[2],
            asset: n.asset,
            parser: i,
            userData: {},
          };
          KE(s, r, n),
            ZE(r, n),
            Promise.all(
              i._invokeAll(function (e) {
                return e.afterRoot && e.afterRoot(r);
              })
            ).then(function () {
              e(r);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const i = t[n].joints;
      for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0;
    }
    for (let n = 0, s = e.length; n < s; n++) {
      const t = e[n];
      void 0 !== t.mesh &&
        (this._addNodeRef(this.meshCache, t.mesh),
        void 0 !== t.skin && (i[t.mesh].isSkinnedMesh = !0)),
        void 0 !== t.camera && this._addNodeRef(this.cameraCache, t.camera);
    }
  }
  _addNodeRef(e, t) {
    void 0 !== t &&
      (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const n = i.clone(),
      s = (e, t) => {
        const i = this.associations.get(e);
        null != i && this.associations.set(t, i);
        for (const [n, r] of e.children.entries()) s(r, t.children[n]);
      };
    return s(i, n), (n.name += "_instance_" + e.uses[t]++), n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const n = e(t[i]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let n = this.cache.get(i);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function (e) {
            return e.loadNode && e.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function (e) {
            return e.loadMesh && e.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function (e) {
            return e.loadBufferView && e.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function (e) {
            return e.loadMaterial && e.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function (e) {
            return e.loadTexture && e.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function (e) {
            return e.loadAnimation && e.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (
            ((n = this._invokeOne(function (i) {
              return i != this && i.getDependency && i.getDependency(e, t);
            })),
            !n)
          )
            throw new Error("Unknown type: " + e);
      }
      this.cache.add(i, n);
    }
    return n;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
      (t = Promise.all(
        n.map(function (t, n) {
          return i.getDependency(e, n);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && "arraybuffer" !== t.type)
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (void 0 === t.uri && 0 === e)
      return Promise.resolve(this.extensions[dE.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function (e, s) {
      i.load(Bl.resolveURL(t.uri, n.path), e, void 0, function () {
        s(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (e) {
      const i = t.byteLength || 0,
        n = t.byteOffset || 0;
      return e.slice(n, n + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      n = this.json.accessors[e];
    if (void 0 === n.bufferView && void 0 === n.sparse) {
      const e = QE[n.type],
        t = zE[n.componentType],
        i = !0 === n.normalized,
        s = new t(n.count * e);
      return Promise.resolve(new Wi(s, e, i));
    }
    const s = [];
    return (
      void 0 !== n.bufferView
        ? s.push(this.getDependency("bufferView", n.bufferView))
        : s.push(null),
      void 0 !== n.sparse &&
        (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
      Promise.all(s).then(function (e) {
        const s = e[0],
          r = QE[n.type],
          a = zE[n.componentType],
          o = a.BYTES_PER_ELEMENT,
          l = o * r,
          h = n.byteOffset || 0,
          c =
            void 0 !== n.bufferView
              ? i.bufferViews[n.bufferView].byteStride
              : void 0,
          u = !0 === n.normalized;
        let d, p;
        if (c && c !== l) {
          const e = Math.floor(h / c),
            i =
              "InterleavedBuffer:" +
              n.bufferView +
              ":" +
              n.componentType +
              ":" +
              e +
              ":" +
              n.count;
          let l = t.cache.get(i);
          l ||
            ((d = new a(s, e * c, (n.count * c) / o)),
            (l = new Ta(d, c / o)),
            t.cache.add(i, l)),
            (p = new Ra(l, r, (h % c) / o, u));
        } else (d = null === s ? new a(n.count * r) : new a(s, h, n.count * r)), (p = new Wi(d, r, u));
        if (void 0 !== n.sparse) {
          const t = QE.SCALAR,
            i = zE[n.sparse.indices.componentType],
            o = n.sparse.indices.byteOffset || 0,
            l = n.sparse.values.byteOffset || 0,
            h = new i(e[1], o, n.sparse.count * t),
            c = new a(e[2], l, n.sparse.count * r);
          null !== s && (p = new Wi(p.array.slice(), p.itemSize, p.normalized));
          for (let e = 0, n = h.length; e < n; e++) {
            const t = h[e];
            if (
              (p.setX(t, c[e * r]),
              r >= 2 && p.setY(t, c[e * r + 1]),
              r >= 3 && p.setZ(t, c[e * r + 2]),
              r >= 4 && p.setW(t, c[e * r + 3]),
              r >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return p;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      n = t.textures[e].source,
      s = t.images[n],
      r = this.extensions;
    let a = this.textureLoader;
    if ("image/ktx2" === s.mimeType && r[dE.KHR_TEXTURE_BASISU])
      return r[dE.KHR_TEXTURE_BASISU].loadTexture(e);
    if (s.uri) {
      const e = i.manager.getHandler(s.uri);
      null !== e && (a = e);
    }
    return this.loadTextureImage(e, n, a);
  }
  loadTextureImage(e, t, i) {
    const n = this,
      s = this.json,
      r = s.textures[e],
      a = s.images[t],
      o = (a.uri || a.bufferView) + ":" + r.sampler;
    if (this.textureCache[o]) return this.textureCache[o];
    const l = this.loadImageSource(t, i)
      .then(function (t) {
        (t.flipY = !1),
          (t.name = r.name || a.name || ""),
          "" === t.name &&
            "string" == typeof a.uri &&
            !1 === a.uri.startsWith("data:image/") &&
            (t.name = a.uri);
        const i = (s.samplers || {})[r.sampler] || {};
        return (
          (t.magFilter = GE[i.magFilter] || L),
          (t.minFilter = GE[i.minFilter] || N),
          (t.wrapS = VE[i.wrapS] || w),
          (t.wrapT = VE[i.wrapT] || w),
          n.associations.set(t, { textures: e }),
          t
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[o] = l), l;
  }
  loadImageSource(e, t) {
    const i = this,
      n = this.json,
      s = this.options;
    if (void 0 !== this.sourceCache[e])
      return this.sourceCache[e].then((e) => e.clone());
    const r = n.images[e],
      a = self.URL || self.webkitURL;
    let o = r.uri || "",
      l = !1;
    if (void 0 !== r.bufferView)
      o = i.getDependency("bufferView", r.bufferView).then(function (e) {
        l = !0;
        const t = new Blob([e], { type: r.mimeType });
        return (o = a.createObjectURL(t)), o;
      });
    else if (void 0 === r.uri)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const h = Promise.resolve(o)
      .then(function (e) {
        return new Promise(function (i, n) {
          let r = i;
          !0 === t.isImageBitmapLoader &&
            (r = function (e) {
              const t = new Texture(e);
              (t.needsUpdate = !0), i(t);
            }),
            t.load(Bl.resolveURL(e, s.path), r, void 0, n);
        });
      })
      .then(function (e) {
        var t;
        return (
          !0 === l && a.revokeObjectURL(o),
          (e.userData.mimeType =
            r.mimeType ||
            ((t = r.uri).search(/\.jpe?g($|\?)/i) > 0 ||
            0 === t.search(/^data\:image\/jpeg/)
              ? "image/jpeg"
              : t.search(/\.webp($|\?)/i) > 0 ||
                0 === t.search(/^data\:image\/webp/)
              ? "image/webp"
              : "image/png")),
          e
        );
      })
      .catch(function (e) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", o), e);
      });
    return (this.sourceCache[e] = h), h;
  }
  assignTexture(e, t, i, n) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (r) {
      if (!r) return null;
      if (
        (void 0 !== i.texCoord &&
          i.texCoord > 0 &&
          ((r = r.clone()).channel = i.texCoord),
        s.extensions[dE.KHR_TEXTURE_TRANSFORM])
      ) {
        const e =
          void 0 !== i.extensions
            ? i.extensions[dE.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (e) {
          const t = s.associations.get(r);
          (r = s.extensions[dE.KHR_TEXTURE_TRANSFORM].extendTexture(r, e)),
            s.associations.set(r, t);
        }
      }
      return void 0 !== n && (r.colorSpace = n), (e[t] = r), r;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const n = void 0 === t.attributes.tangent,
      s = void 0 !== t.attributes.color,
      r = void 0 === t.attributes.normal;
    if (e.isPoints) {
      const e = "PointsMaterial:" + i.uuid;
      let t = this.cache.get(e);
      t ||
        ((t = new po()),
        Material.prototype.copy.call(t, i),
        t.color.copy(i.color),
        (t.map = i.map),
        (t.sizeAttenuation = !1),
        this.cache.add(e, t)),
        (i = t);
    } else if (e.isLine) {
      const e = "LineBasicMaterial:" + i.uuid;
      let t = this.cache.get(e);
      t ||
        ((t = new to()),
        Material.prototype.copy.call(t, i),
        t.color.copy(i.color),
        (t.map = i.map),
        this.cache.add(e, t)),
        (i = t);
    }
    if (n || s || r) {
      let e = "ClonedMaterial:" + i.uuid + ":";
      n && (e += "derivative-tangents:"),
        s && (e += "vertex-colors:"),
        r && (e += "flat-shading:");
      let t = this.cache.get(e);
      t ||
        ((t = i.clone()),
        s && (t.vertexColors = !0),
        r && (t.flatShading = !0),
        n &&
          (t.normalScale && (t.normalScale.y *= -1),
          t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
        this.cache.add(e, t),
        this.associations.set(t, this.associations.get(i))),
        (i = t);
    }
    e.material = i;
  }
  getMaterialType() {
    return Vo;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      n = this.extensions,
      s = i.materials[e];
    let r;
    const a = {},
      o = [];
    if ((s.extensions || {})[dE.KHR_MATERIALS_UNLIT]) {
      const e = n[dE.KHR_MATERIALS_UNLIT];
      (r = e.getMaterialType()), o.push(e.extendParams(a, s, t));
    } else {
      const i = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new Color(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(i.baseColorFactor))
      ) {
        const e = i.baseColorFactor;
        a.color.fromArray(e), (a.opacity = e[3]);
      }
      void 0 !== i.baseColorTexture &&
        o.push(t.assignTexture(a, "map", i.baseColorTexture, me)),
        (a.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1),
        (a.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1),
        void 0 !== i.metallicRoughnessTexture &&
          (o.push(
            t.assignTexture(a, "metalnessMap", i.metallicRoughnessTexture)
          ),
          o.push(
            t.assignTexture(a, "roughnessMap", i.metallicRoughnessTexture)
          )),
        (r = this._invokeOne(function (t) {
          return t.getMaterialType && t.getMaterialType(e);
        })),
        o.push(
          Promise.all(
            this._invokeAll(function (t) {
              return t.extendMaterialParams && t.extendMaterialParams(e, a);
            })
          )
        );
    }
    !0 === s.doubleSided && (a.side = 2);
    const l = s.alphaMode || qE;
    if (
      (l === YE
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          l === XE &&
            (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
      void 0 !== s.normalTexture &&
        r !== Oi &&
        (o.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new Vector2(1, 1)),
        void 0 !== s.normalTexture.scale))
    ) {
      const e = s.normalTexture.scale;
      a.normalScale.set(e, e);
    }
    return (
      void 0 !== s.occlusionTexture &&
        r !== Oi &&
        (o.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        void 0 !== s.occlusionTexture.strength &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      void 0 !== s.emissiveFactor &&
        r !== Oi &&
        (a.emissive = new Color().fromArray(s.emissiveFactor)),
      void 0 !== s.emissiveTexture &&
        r !== Oi &&
        o.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, me)),
      Promise.all(o).then(function () {
        const i = new r(a);
        return (
          s.name && (i.name = s.name),
          ZE(i, s),
          t.associations.set(i, { materials: e }),
          s.extensions && KE(n, i, s),
          i
        );
      })
    );
  }
  createUniqueName(e) {
    const t = Xl.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      n = this.primitiveCache;
    function s(e) {
      return i[dE.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(e, t)
        .then(function (i) {
          return sS(i, e, t);
        });
    }
    const r = [];
    for (let a = 0, o = e.length; a < o; a++) {
      const i = e[a],
        o = $E(i),
        l = n[o];
      if (l) r.push(l.promise);
      else {
        let e;
        (e =
          i.extensions && i.extensions[dE.KHR_DRACO_MESH_COMPRESSION]
            ? s(i)
            : sS(new rn(), i, t)),
          (n[o] = { primitive: i, promise: e }),
          r.push(e);
      }
    }
    return Promise.all(r);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      n = this.extensions,
      s = i.meshes[e],
      r = s.primitives,
      a = [];
    for (let l = 0, c = r.length; l < c; l++) {
      const e =
        void 0 === r[l].material
          ? (void 0 === (o = this.cache).DefaultMaterial &&
              (o.DefaultMaterial = new Vo({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: h,
              })),
            o.DefaultMaterial)
          : this.getDependency("material", r[l].material);
      a.push(e);
    }
    var o;
    return (
      a.push(t.loadGeometries(r)),
      Promise.all(a).then(function (i) {
        const a = i.slice(0, i.length - 1),
          o = i[i.length - 1],
          l = [];
        for (let c = 0, u = o.length; c < u; c++) {
          const i = o[c],
            h = r[c];
          let u;
          const d = a[c];
          if (
            h.mode === UE.TRIANGLES ||
            h.mode === UE.TRIANGLE_STRIP ||
            h.mode === UE.TRIANGLE_FAN ||
            void 0 === h.mode
          )
            (u = !0 === s.isSkinnedMesh ? new za(i, d) : new En(i, d)),
              !0 === u.isSkinnedMesh && u.normalizeSkinWeights(),
              h.mode === UE.TRIANGLE_STRIP
                ? (u.geometry = hE(u.geometry, 1))
                : h.mode === UE.TRIANGLE_FAN &&
                  (u.geometry = hE(u.geometry, 2));
          else if (h.mode === UE.LINES) u = new co(i, d);
          else if (h.mode === UE.LINE_STRIP) u = new oo(i, d);
          else if (h.mode === UE.LINE_LOOP) u = new uo(i, d);
          else {
            if (h.mode !== UE.POINTS)
              throw new Error(
                "THREE.GLTFLoader: Primitive mode unsupported: " + h.mode
              );
            u = new vo(i, d);
          }
          Object.keys(u.geometry.morphAttributes).length > 0 && JE(u, s),
            (u.name = t.createUniqueName(s.name || "mesh_" + e)),
            ZE(u, s),
            h.extensions && KE(n, u, h),
            t.assignFinalMaterial(u),
            l.push(u);
        }
        for (let n = 0, s = l.length; n < s; n++)
          t.associations.set(l[n], { meshes: e, primitives: n });
        if (1 === l.length) return s.extensions && KE(n, l[0], s), l[0];
        const h = new va();
        s.extensions && KE(n, h, s), t.associations.set(h, { meshes: e });
        for (let e = 0, t = l.length; e < t; e++) h.add(l[e]);
        return h;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      n = i[i.type];
    if (n)
      return (
        "perspective" === i.type
          ? (t = new Dn(
              ze.radToDeg(n.yfov),
              n.aspectRatio || 1,
              n.znear || 1,
              n.zfar || 2e6
            ))
          : "orthographic" === i.type &&
            (t = new ns(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)),
        i.name && (t.name = this.createUniqueName(i.name)),
        ZE(t, i),
        Promise.resolve(t)
      );
    console.warn("THREE.GLTFLoader: Missing camera parameters.");
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = [];
    for (let n = 0, s = t.joints.length; n < s; n++)
      i.push(this._loadNodeShallow(t.joints[n]));
    return (
      void 0 !== t.inverseBindMatrices
        ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (e) {
        const i = e.pop(),
          n = e,
          s = [],
          r = [];
        for (let a = 0, o = n.length; a < o; a++) {
          const e = n[a];
          if (e) {
            s.push(e);
            const t = new Matrix4();
            null !== i && t.fromArray(i.array, 16 * a), r.push(t);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[a]
            );
        }
        return new ja(s, r);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json.animations[e],
      i = t.name ? t.name : "animation_" + e,
      n = [],
      s = [],
      r = [],
      a = [],
      o = [];
    for (let l = 0, h = t.channels.length; l < h; l++) {
      const e = t.channels[l],
        i = t.samplers[e.sampler],
        h = e.target,
        c = h.node,
        u = void 0 !== t.parameters ? t.parameters[i.input] : i.input,
        d = void 0 !== t.parameters ? t.parameters[i.output] : i.output;
      void 0 !== h.node &&
        (n.push(this.getDependency("node", c)),
        s.push(this.getDependency("accessor", u)),
        r.push(this.getDependency("accessor", d)),
        a.push(i),
        o.push(h));
    }
    return Promise.all([
      Promise.all(n),
      Promise.all(s),
      Promise.all(r),
      Promise.all(a),
      Promise.all(o),
    ]).then(function (e) {
      const t = e[0],
        n = e[1],
        s = e[2],
        r = e[3],
        a = e[4],
        o = [];
      for (let i = 0, l = t.length; i < l; i++) {
        const e = t[i],
          l = n[i],
          h = s[i],
          c = r[i],
          u = a[i];
        if (void 0 === e) continue;
        let d;
        switch ((e.updateMatrix(), jE[u.path])) {
          case jE.weights:
            d = nl;
            break;
          case jE.rotation:
            d = rl;
            break;
          default:
            d = ol;
        }
        const p = e.name ? e.name : e.uuid,
          f = void 0 !== c.interpolation ? WE[c.interpolation] : ae,
          m = [];
        jE[u.path] === jE.weights
          ? e.traverse(function (e) {
              e.morphTargetInfluences && m.push(e.name ? e.name : e.uuid);
            })
          : m.push(p);
        let g = h.array;
        if (h.normalized) {
          const e = tS(g.constructor),
            t = new Float32Array(g.length);
          for (let i = 0, n = g.length; i < n; i++) t[i] = g[i] * e;
          g = t;
        }
        for (let t = 0, i = m.length; t < i; t++) {
          const e = new d(m[t] + "." + jE[u.path], l.array, g, f);
          "CUBICSPLINE" === c.interpolation &&
            ((e.createInterpolant = function (e) {
              return new (this instanceof rl ? OE : BE)(
                this.times,
                this.values,
                this.getValueSize() / 3,
                e
              );
            }),
            (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline =
              !0)),
            o.push(e);
        }
      }
      return new ll(i, void 0, o);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      n = t.nodes[e];
    return void 0 === n.mesh
      ? null
      : i.getDependency("mesh", n.mesh).then(function (e) {
          const t = i._getNodeRef(i.meshCache, n.mesh, e);
          return (
            void 0 !== n.weights &&
              t.traverse(function (e) {
                if (e.isMesh)
                  for (let t = 0, i = n.weights.length; t < i; t++)
                    e.morphTargetInfluences[t] = n.weights[t];
              }),
            t
          );
        });
  }
  loadNode(e) {
    const t = this,
      i = this.json.nodes[e],
      n = t._loadNodeShallow(e),
      s = [],
      r = i.children || [];
    for (let o = 0, l = r.length; o < l; o++)
      s.push(t.getDependency("node", r[o]));
    const a =
      void 0 === i.skin
        ? Promise.resolve(null)
        : t.getDependency("skin", i.skin);
    return Promise.all([n, Promise.all(s), a]).then(function (e) {
      const t = e[0],
        i = e[1],
        n = e[2];
      null !== n &&
        t.traverse(function (e) {
          e.isSkinnedMesh && e.bind(n, iS);
        });
      for (let s = 0, r = i.length; s < r; s++) t.add(i[s]);
      return t;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      i = this.extensions,
      n = this;
    if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
    const s = t.nodes[e],
      r = s.name ? n.createUniqueName(s.name) : "",
      a = [],
      o = n._invokeOne(function (t) {
        return t.createNodeMesh && t.createNodeMesh(e);
      });
    return (
      o && a.push(o),
      void 0 !== s.camera &&
        a.push(
          n.getDependency("camera", s.camera).then(function (e) {
            return n._getNodeRef(n.cameraCache, s.camera, e);
          })
        ),
      n
        ._invokeAll(function (t) {
          return t.createNodeAttachment && t.createNodeAttachment(e);
        })
        .forEach(function (e) {
          a.push(e);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (t) {
        let a;
        if (
          ((a =
            !0 === s.isBone
              ? new Ga()
              : t.length > 1
              ? new va()
              : 1 === t.length
              ? t[0]
              : new Object3D()),
          a !== t[0])
        )
          for (let e = 0, i = t.length; e < i; e++) a.add(t[e]);
        if (
          (s.name && ((a.userData.name = s.name), (a.name = r)),
          ZE(a, s),
          s.extensions && KE(i, a, s),
          void 0 !== s.matrix)
        ) {
          const e = new Matrix4();
          e.fromArray(s.matrix), a.applyMatrix4(e);
        } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);
        return (
          n.associations.has(a) || n.associations.set(a, {}),
          (n.associations.get(a).nodes = e),
          a
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      i = this.json.scenes[e],
      n = this,
      s = new va();
    i.name && (s.name = n.createUniqueName(i.name)),
      ZE(s, i),
      i.extensions && KE(t, s, i);
    const r = i.nodes || [],
      a = [];
    for (let o = 0, l = r.length; o < l; o++)
      a.push(n.getDependency("node", r[o]));
    return Promise.all(a).then(function (e) {
      for (let t = 0, i = e.length; t < i; t++) s.add(e[t]);
      return (
        (n.associations = ((e) => {
          const t = new Map();
          for (const [i, s] of n.associations)
            (i instanceof Material || i instanceof Texture) && t.set(i, s);
          return (
            e.traverse((e) => {
              const i = n.associations.get(e);
              null != i && t.set(e, i);
            }),
            t
          );
        })(s)),
        s
      );
    });
  }
}
function sS(e, t, i) {
  const n = t.attributes,
    s = [];
  function r(t, n) {
    return i.getDependency("accessor", t).then(function (t) {
      e.setAttribute(n, t);
    });
  }
  for (const a in n) {
    const t = HE[a] || a.toLowerCase();
    t in e.attributes || s.push(r(n[a], t));
  }
  if (void 0 !== t.indices && !e.index) {
    const n = i.getDependency("accessor", t.indices).then(function (t) {
      e.setIndex(t);
    });
    s.push(n);
  }
  return (
    ZE(e, t),
    (function (e, t, i) {
      const n = t.attributes,
        s = new Box3();
      if (void 0 === n.POSITION) return;
      {
        const e = i.json.accessors[n.POSITION],
          t = e.min,
          r = e.max;
        if (void 0 === t || void 0 === r)
          return void console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
        if (
          (s.set(new Vector3(t[0], t[1], t[2]), new Vector3(r[0], r[1], r[2])),
          e.normalized)
        ) {
          const t = tS(zE[e.componentType]);
          s.min.multiplyScalar(t), s.max.multiplyScalar(t);
        }
      }
      const r = t.targets;
      if (void 0 !== r) {
        const e = new Vector3(),
          t = new Vector3();
        for (let n = 0, s = r.length; n < s; n++) {
          const s = r[n];
          if (void 0 !== s.POSITION) {
            const n = i.json.accessors[s.POSITION],
              r = n.min,
              a = n.max;
            if (void 0 !== r && void 0 !== a) {
              if (
                (t.setX(Math.max(Math.abs(r[0]), Math.abs(a[0]))),
                t.setY(Math.max(Math.abs(r[1]), Math.abs(a[1]))),
                t.setZ(Math.max(Math.abs(r[2]), Math.abs(a[2]))),
                n.normalized)
              ) {
                const e = tS(zE[n.componentType]);
                t.multiplyScalar(e);
              }
              e.max(t);
            } else
              console.warn(
                "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
              );
          }
        }
        s.expandByVector(e);
      }
      e.boundingBox = s;
      const a = new kt();
      s.getCenter(a.center),
        (a.radius = s.min.distanceTo(s.max) / 2),
        (e.boundingSphere = a);
    })(e, t, i),
    Promise.all(s).then(function () {
      return void 0 !== t.targets
        ? (function (e, t, i) {
            let n = !1,
              s = !1,
              r = !1;
            for (let h = 0, c = t.length; h < c; h++) {
              const e = t[h];
              if (
                (void 0 !== e.POSITION && (n = !0),
                void 0 !== e.NORMAL && (s = !0),
                void 0 !== e.COLOR_0 && (r = !0),
                n && s && r)
              )
                break;
            }
            if (!n && !s && !r) return Promise.resolve(e);
            const a = [],
              o = [],
              l = [];
            for (let h = 0, c = t.length; h < c; h++) {
              const c = t[h];
              if (n) {
                const t =
                  void 0 !== c.POSITION
                    ? i.getDependency("accessor", c.POSITION)
                    : e.attributes.position;
                a.push(t);
              }
              if (s) {
                const t =
                  void 0 !== c.NORMAL
                    ? i.getDependency("accessor", c.NORMAL)
                    : e.attributes.normal;
                o.push(t);
              }
              if (r) {
                const t =
                  void 0 !== c.COLOR_0
                    ? i.getDependency("accessor", c.COLOR_0)
                    : e.attributes.color;
                l.push(t);
              }
            }
            return Promise.all([
              Promise.all(a),
              Promise.all(o),
              Promise.all(l),
            ]).then(function (t) {
              const i = t[0],
                a = t[1],
                o = t[2];
              return (
                n && (e.morphAttributes.position = i),
                s && (e.morphAttributes.normal = a),
                r && (e.morphAttributes.color = o),
                (e.morphTargetsRelative = !0),
                e
              );
            });
          })(e, t.targets, i)
        : e;
    })
  );
}
var rS = (function () {
  var e = new Uint8Array([
      0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0,
      1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7,
      0, 65, 0, 253, 15, 26, 11,
    ]),
    t = new Uint8Array([
      32, 0, 65, 2, 1, 106, 34, 33, 3, 128, 11, 4, 13, 64, 6, 253, 10, 7, 15,
      116, 127, 5, 8, 12, 40, 16, 19, 54, 20, 9, 27, 255, 113, 17, 42, 67, 24,
      23, 146, 148, 18, 14, 22, 45, 70, 69, 56, 114, 101, 21, 25, 63, 75, 136,
      108, 28, 118, 29, 73, 115,
    ]);
  if ("object" != typeof WebAssembly) return { supported: !1 };
  var i,
    n = WebAssembly.validate(e)
      ? "b9H79TebbbeKl9Gbb9Gvuuuuueu9Giuuub9Geueuikqbbebeedddilve9Weeeviebeoweuec:q;Aekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbdY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVblE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtboK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbrL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbwl79IV9RbDq;t9tqlbzik9:evu8Jjjjjbcz9Rhbcbheincbhdcbhiinabcwfadfaicjuaead4ceGglE86bbaialfhiadcefgdcw9hmbkaec:q:yjjbfai86bbaecitc:q1jjbfab8Piw83ibaecefgecjd9hmbkk;h8JlHud97euo978Jjjjjbcj;kb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Rad;8qbbcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhwcbhDinaDae9pmeawaeaD9RaDawfae6Egqcsfgoc9WGgkci2hxakcethmaocl4cifcd4hPabaDad2fhscbhzdnincehHalhOcbhAdninaraO9RaP6miavcj;cbfaAak2fhCaOaPfhlcbhidnakc;ab6mbaral9Rc;Gb6mbcbhoinaCaofhidndndndndnaOaoco4fRbbgXciGPlbedibkaipxbbbbbbbbbbbbbbbbpklbxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklbalczfhlkdndndndndnaXcd4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklzxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklzalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklzalczfhlkdndndndndnaXcl4ciGPlbedibkaipxbbbbbbbbbbbbbbbbpklaxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklaalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaialpbbbpklaalczfhlkdndndndndnaXco4Plbedibkaipxbbbbbbbbbbbbbbbbpkl8WxikaialpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalclfaYpQbfaXc:q:yjjbfRbbfhlxdkaialpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibaXc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgXcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spkl8WalcwfaYpQbfaXc:q:yjjbfRbbfhlxekaialpbbbpkl8Walczfhlkaoc;abfhiaocjefak0meaihoaral9Rc;Fb0mbkkdndnaiak9pmbaici4hoinaral9RcK6mdaCaifhXdndndndndnaOaico4fRbbaocoG4ciGPlbedibkaXpxbbbbbbbbbbbbbbbbpklbxikaXalpbblalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLgQcdp:meaQpmbzeHdOiAlCvXoQrLpxiiiiiiiiiiiiiiiip9ogLpxiiiiiiiiiiiiiiiip8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalclfaYpQbfaKc:q:yjjbfRbbfhlxdkaXalpbbwalpbbbgQclp:meaQpmbzeHdOiAlCvXoQrLpxssssssssssssssssp9ogLpxssssssssssssssssp8JgQp5b9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibaKc:q:yjjbfpbbbgYaYpmbbbbbbbbbbbbbbbbaQp5e9cjF;8;4;W;G;ab9:9cU1:NgKcitc:q1jjbfpbibp9UpmbedilvorzHOACXQLpPaLaQp9spklbalcwfaYpQbfaKc:q:yjjbfRbbfhlxekaXalpbbbpklbalczfhlkaocdfhoaiczfgiak6mbkkalTmbaAci6hHalhOaAcefgohAaoclSmdxekkcbhlaHceGmdkdnakTmbavcjdfazfhiavazfpbdbhYcbhXinaiavcj;cbfaXfgopblbgLcep9TaLpxeeeeeeeeeeeeeeeegQp9op9Hp9rgLaoakfpblbg8Acep9Ta8AaQp9op9Hp9rg8ApmbzeHdOiAlCvXoQrLgEaoamfpblbg3cep9Ta3aQp9op9Hp9rg3aoaxfpblbg5cep9Ta5aQp9op9Hp9rg5pmbzeHdOiAlCvXoQrLg8EpmbezHdiOAlvCXorQLgQaQpmbedibedibedibediaYp9UgYp9AdbbaiadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaEa8EpmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwKDYq8AkEx3m5P8Es8FgLa3a5pmwKDYq8AkEx3m5P8Es8Fg8ApmbezHdiOAlvCXorQLgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfgoaYaLa8ApmwDKYqk8AExm35Ps8E8FgQaQpmbedibedibedibedip9UgYp9AdbbaoadfgoaYaQaQpmlvorlvorlvorlvorp9UgYp9AdbbaoadfgoaYaQaQpmwDqkwDqkwDqkwDqkp9UgYp9AdbbaoadfgoaYaQaQpmxmPsxmPsxmPsxmPsp9UgYp9AdbbaoadfhiaXczfgXak6mbkkazclfgzad6mbkasavcjdfaqad2;8qbbavavcjdfaqcufad2fad;8qbbaqaDfhDc9:hoalmexikkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;kbf8Kjjjjbaokwbz:bjjjbk;uzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecje;8kbavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:EPliuo97eue978Jjjjjbca9Rhidndnadcl9hmbdnaec98GglTmbcbhvabhdinadadpbbbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpkbbadczfhdavclfgval6mbkkalae9pmeaiaeciGgvcdtgdVcbczad9R;8kbaiabalcdtfglad;8qbbdnavTmbaiaipblbgocKp:RecKp:Sep;6egraocwp:RecKp:Sep;6earp;Geaoczp:RecKp:Sep;6egwp;Gep;Kep;LegDpxbbbbbbbbbbbbbbbbp:2egqarpxbbbjbbbjbbbjbbbjgkp9op9rp;Kegrpxbb;:9cbb;:9cbb;:9cbb;:9cararp;MeaDaDp;Meawaqawakp9op9rp;Kegrarp;Mep;Kep;Kep;Jep;Negwp;Mepxbbn0bbn0bbn0bbn0gqp;KepxFbbbFbbbFbbbFbbbp9oaopxbbbFbbbFbbbFbbbFp9op9qarawp;Meaqp;Kecwp:RepxbFbbbFbbbFbbbFbbp9op9qaDawp;Meaqp;Keczp:RepxbbFbbbFbbbFbbbFbp9op9qpklbkalaiad;8qbbskdnaec98GgxTmbcbhvabhdinadczfglalpbbbgopxbbbbbbFFbbbbbbFFgkp9oadpbbbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpkbbadaDakp9oawaopmbezHdiOAlvCXorQLp9qpkbbadcafhdavclfgvax6mbkkaxae9pmbaiaeciGgvcitgdfcbcaad9R;8kbaiabaxcitfglad;8qbbdnavTmbaiaipblzgopxbbbbbbFFbbbbbbFFgkp9oaipblbgDaopmlvorxmPsCXQL358E8FpxFubbFubbFubbFubbp9op;6eaDaopmbediwDqkzHOAKY8AEgoczp:Sep;6egrp;Geaoczp:Reczp:Sep;6egwp;Gep;Kep;Legopxb;:FSb;:FSb;:FSb;:FSawaopxbbbbbbbbbbbbbbbbp:2egqawpxbbbjbbbjbbbjbbbjgmp9op9rp;Kegwawp;Meaoaop;Mearaqaramp9op9rp;Kegoaop;Mep;Kep;Kep;Jep;Negrp;Mepxbbn0bbn0bbn0bbn0gqp;Keczp:Reawarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9op9qgwaoarp;Meaqp;KepxFFbbFFbbFFbbFFbbp9ogopmwDKYqk8AExm35Ps8E8Fp9qpklzaiaDakp9oawaopmbezHdiOAlvCXorQLp9qpklbkalaiad;8qbbkk;4wllue97euv978Jjjjjbc8W9Rhidnaec98GglTmbcbhvabhoinaiaopbbbgraoczfgwpbbbgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklbaopxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblbpEb:T:j83ibaocwfarp5eaipblbpEe:T:j83ibawaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblbpEd:T:j83ibaocKfakp5eaipblbpEi:T:j83ibaocafhoavclfgval6mbkkdnalae9pmbaiaeciGgvcitgofcbcaao9R;8kbaiabalcitfgwao;8qbbdnavTmbaiaipblbgraipblzgDpmlvorxmPsCXQL358E8Fgqczp:Segkclp:RepklaaipxbbjZbbjZbbjZbbjZpx;Zl81Z;Zl81Z;Zl81Z;Zl81Zakpxibbbibbbibbbibbbp9qp;6ep;NegkaraDpmbediwDqkzHOAKY8AEgrczp:Reczp:Sep;6ep;MegDaDp;Meakarczp:Sep;6ep;Megxaxp;Meakaqczp:Reczp:Sep;6ep;Megqaqp;Mep;Kep;Kep;Lepxbbbbbbbbbbbbbbbbp:4ep;Jepxb;:FSb;:FSb;:FSb;:FSgkp;Mepxbbn0bbn0bbn0bbn0grp;KepxFFbbFFbbFFbbFFbbgmp9oaxakp;Mearp;Keczp:Rep9qgxaqakp;Mearp;Keczp:ReaDakp;Mearp;Keamp9op9qgkpmbezHdiOAlvCXorQLgrp5baipblapEb:T:j83ibaiarp5eaipblapEe:T:j83iwaiaxakpmwDKYqk8AExm35Ps8E8Fgkp5baipblapEd:T:j83izaiakp5eaipblapEi:T:j83iKkawaiao;8qbbkk:Pddiue978Jjjjjbc;ab9Rhidnadcd4ae2glc98GgvTmbcbhdabheinaeaepbbbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepkbbaeczfheadclfgdav6mbkkdnaval9pmbaialciGgdcdtgeVcbc;abae9R;8kbaiabavcdtfgvae;8qbbdnadTmbaiaipblbgocwp:Recwp:Sep;6eaocep:SepxbbjZbbjZbbjZbbjZp:UepxbbjFbbjFbbjFbbjFp9op;Mepklbkavaiae;8qbbkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaikkkebcjwklz9Tbb"
      : "b9H79Tebbbe8Fv9Gbb9Gvuuuuueu9Giuuub9Geueu9Giuuueuikqbeeedddillviebeoweuec:q;iekr;leDo9TW9T9VV95dbH9F9F939H79T9F9J9H229F9Jt9VV7bb8A9TW79O9V9Wt9F9KW9J9V9KW9wWVtW949c919M9MWVbeY9TW79O9V9Wt9F9KW9J9V9KW69U9KW949c919M9MWVbdE9TW79O9V9Wt9F9KW9J9V9KW69U9KW949tWG91W9U9JWbiL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9p9JtblK9TW79O9V9Wt9F9KW9J9V9KWS9P2tWV9r919HtbvL9TW79O9V9Wt9F9KW9J9V9KWS9P2tWVT949Wbol79IV9Rbrq:P8Yqdbk;3sezu8Jjjjjbcj;eb9Rgv8Kjjjjbc9:hodnadcefal0mbcuhoaiRbbc:Ge9hmbavaialfgrad9Radz1jjjbhwcj;abad9UhoaicefhldnadTmbaoc;WFbGgocjdaocjd6EhDcbhqinaqae9pmeaDaeaq9RaqaDfae6Egkcsfgocl4cifcd4hxdndndndnaoc9WGgmTmbcbhPcehsawcjdfhzalhHinaraH9Rax6midnaraHaxfgl9RcK6mbczhoinawcj;cbfaogifgoc9WfhOdndndndndnaHaic9WfgAco4fRbbaAci4coG4ciGPlbedibkaO9cb83ibaOcwf9cb83ibxikaOalRblalRbbgAco4gCaCciSgCE86bbaocGfalclfaCfgORbbaAcl4ciGgCaCciSgCE86bbaocVfaOaCfgORbbaAcd4ciGgCaCciSgCE86bbaoc7faOaCfgORbbaAciGgAaAciSgAE86bbaoctfaOaAfgARbbalRbegOco4gCaCciSgCE86bbaoc91faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc4faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc93faAaCfgARbbaOciGgOaOciSgOE86bbaoc94faAaOfgARbbalRbdgOco4gCaCciSgCE86bbaoc95faAaCfgARbbaOcl4ciGgCaCciSgCE86bbaoc96faAaCfgARbbaOcd4ciGgCaCciSgCE86bbaoc97faAaCfgARbbaOciGgOaOciSgOE86bbaoc98faAaOfgORbbalRbiglco4gAaAciSgAE86bbaoc99faOaAfgORbbalcl4ciGgAaAciSgAE86bbaoc9:faOaAfgORbbalcd4ciGgAaAciSgAE86bbaocufaOaAfgoRbbalciGglalciSglE86bbaoalfhlxdkaOalRbwalRbbgAcl4gCaCcsSgCE86bbaocGfalcwfaCfgORbbaAcsGgAaAcsSgAE86bbaocVfaOaAfgORbbalRbegAcl4gCaCcsSgCE86bbaoc7faOaCfgORbbaAcsGgAaAcsSgAE86bbaoctfaOaAfgORbbalRbdgAcl4gCaCcsSgCE86bbaoc91faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc4faOaAfgORbbalRbigAcl4gCaCcsSgCE86bbaoc93faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc94faOaAfgORbbalRblgAcl4gCaCcsSgCE86bbaoc95faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc96faOaAfgORbbalRbvgAcl4gCaCcsSgCE86bbaoc97faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc98faOaAfgORbbalRbogAcl4gCaCcsSgCE86bbaoc99faOaCfgORbbaAcsGgAaAcsSgAE86bbaoc9:faOaAfgORbbalRbrglcl4gAaAcsSgAE86bbaocufaOaAfgoRbbalcsGglalcsSglE86bbaoalfhlxekaOal8Pbb83bbaOcwfalcwf8Pbb83bbalczfhlkdnaiam9pmbaiczfhoaral9RcL0mekkaiam6mialTmidnakTmbawaPfRbbhOcbhoazhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkkazcefhzaPcefgPad6hsalhHaPad9hmexvkkcbhlasceGmdxikalaxad2fhCdnakTmbcbhHcehsawcjdfhminaral9Rax6mialTmdalaxfhlawaHfRbbhOcbhoamhiinaiawcj;cbfaofRbbgAce4cbaAceG9R7aOfgO86bbaiadfhiaocefgoak9hmbkamcefhmaHcefgHad6hsaHad9hmbkaChlxikcbhocehsinaral9Rax6mdalTmealaxfhlaocefgoad6hsadao9hmbkaChlxdkcbhlasceGTmekc9:hoxikabaqad2fawcjdfakad2z1jjjb8Aawawcjdfakcufad2fadz1jjjb8Aakaqfhqalmbkc9:hoxekcbc99aral9Radcaadca0ESEhokavcj;ebf8Kjjjjbaok;yzeHu8Jjjjjbc;ae9Rgv8Kjjjjbc9:hodnaeci9UgrcHfal0mbcuhoaiRbbgwc;WeGc;Ge9hmbawcsGgDce0mbavc;abfcFecjez:jjjjb8AavcUf9cu83ibavc8Wf9cu83ibavcyf9cu83ibavcaf9cu83ibavcKf9cu83ibavczf9cu83ibav9cu83iwav9cu83ibaialfc9WfhqaicefgwarfhodnaeTmbcmcsaDceSEhkcbhxcbhmcbhDcbhicbhlindnaoaq9nmbc9:hoxikdndnawRbbgrc;Ve0mbavc;abfalarcl4cu7fcsGcitfgPydlhsaPydbhzdnarcsGgPak9pmbavaiarcu7fcsGcdtfydbaxaPEhraPThPdndnadcd9hmbabaDcetfgHaz87ebaHcdfas87ebaHclfar87ebxekabaDcdtfgHazBdbaHclfasBdbaHcwfarBdbkaxaPfhxavc;abfalcitfgHarBdbaHasBdlavaicdtfarBdbavc;abfalcefcsGglcitfgHazBdbaHarBdlaiaPfhialcefhlxdkdndnaPcsSmbamaPfaPc987fcefhmxekaocefhrao8SbbgPcFeGhHdndnaPcu9mmbarhoxekaocvfhoaHcFbGhHcrhPdninar8SbbgOcFbGaPtaHVhHaOcu9kmearcefhraPcrfgPc8J9hmbxdkkarcefhokaHce4cbaHceG9R7amfhmkdndnadcd9hmbabaDcetfgraz87ebarcdfas87ebarclfam87ebxekabaDcdtfgrazBdbarclfasBdbarcwfamBdbkavc;abfalcitfgramBdbarasBdlavaicdtfamBdbavc;abfalcefcsGglcitfgrazBdbaramBdlaicefhialcefhlxekdnarcpe0mbaxcefgOavaiaqarcsGfRbbgPcl49RcsGcdtfydbaPcz6gHEhravaiaP9RcsGcdtfydbaOaHfgsaPcsGgOEhPaOThOdndnadcd9hmbabaDcetfgzax87ebazcdfar87ebazclfaP87ebxekabaDcdtfgzaxBdbazclfarBdbazcwfaPBdbkavaicdtfaxBdbavc;abfalcitfgzarBdbazaxBdlavaicefgicsGcdtfarBdbavc;abfalcefcsGcitfgzaPBdbazarBdlavaiaHfcsGgicdtfaPBdbavc;abfalcdfcsGglcitfgraxBdbaraPBdlalcefhlaiaOfhiasaOfhxxekaxcbaoRbbgzEgAarc;:eSgrfhsazcsGhCazcl4hXdndnazcs0mbascefhOxekashOavaiaX9RcsGcdtfydbhskdndnaCmbaOcefhxxekaOhxavaiaz9RcsGcdtfydbhOkdndnarTmbaocefhrxekaocdfhrao8SbegHcFeGhPdnaHcu9kmbaocofhAaPcFbGhPcrhodninar8SbbgHcFbGaotaPVhPaHcu9kmearcefhraocrfgoc8J9hmbkaAhrxekarcefhrkaPce4cbaPceG9R7amfgmhAkdndnaXcsSmbarhPxekarcefhPar8SbbgocFeGhHdnaocu9kmbarcvfhsaHcFbGhHcrhodninaP8SbbgrcFbGaotaHVhHarcu9kmeaPcefhPaocrfgoc8J9hmbkashPxekaPcefhPkaHce4cbaHceG9R7amfgmhskdndnaCcsSmbaPhoxekaPcefhoaP8SbbgrcFeGhHdnarcu9kmbaPcvfhOaHcFbGhHcrhrdninao8SbbgPcFbGartaHVhHaPcu9kmeaocefhoarcrfgrc8J9hmbkaOhoxekaocefhokaHce4cbaHceG9R7amfgmhOkdndnadcd9hmbabaDcetfgraA87ebarcdfas87ebarclfaO87ebxekabaDcdtfgraABdbarclfasBdbarcwfaOBdbkavc;abfalcitfgrasBdbaraABdlavaicdtfaABdbavc;abfalcefcsGcitfgraOBdbarasBdlavaicefgicsGcdtfasBdbavc;abfalcdfcsGcitfgraABdbaraOBdlavaiazcz6aXcsSVfgicsGcdtfaOBdbaiaCTaCcsSVfhialcifhlkawcefhwalcsGhlaicsGhiaDcifgDae6mbkkcbc99aoaqSEhokavc;aef8Kjjjjbaok:llevu8Jjjjjbcz9Rhvc9:hodnaecvfal0mbcuhoaiRbbc;:eGc;qe9hmbav9cb83iwaicefhraialfc98fhwdnaeTmbdnadcdSmbcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcdtfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfglBdbaoalBdbaDcefgDae9hmbxdkkcbhDindnaraw6mbc9:skarcefhoar8SbbglcFeGhidndnalcu9mmbaohrxekarcvfhraicFbGhicrhldninao8SbbgdcFbGaltaiVhiadcu9kmeaocefhoalcrfglc8J9hmbxdkkaocefhrkabaDcetfaicd4cbaice4ceG9R7avcwfaiceGcdtVgoydbfgl87ebaoalBdbaDcefgDae9hmbkkcbc99arawSEhokaok:Lvoeue99dud99eud99dndnadcl9hmbaeTmeindndnabcdfgd8Sbb:Yab8Sbbgi:Ygl:l:tabcefgv8Sbbgo:Ygr:l:tgwJbb;:9cawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai86bbdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad86bbdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad86bbabclfhbaecufgembxdkkaeTmbindndnabclfgd8Ueb:Yab8Uebgi:Ygl:l:tabcdfgv8Uebgo:Ygr:l:tgwJb;:FSawawNJbbbbawawJbbbb9GgDEgq:mgkaqaicb9iEalMgwawNakaqaocb9iEarMgqaqNMM:r:vglNJbbbZJbbb:;aDEMgr:lJbbb9p9DTmbar:Ohixekcjjjj94hikadai87ebdndnaqalNJbbbZJbbb:;aqJbbbb9GEMgq:lJbbb9p9DTmbaq:Ohdxekcjjjj94hdkavad87ebdndnawalNJbbbZJbbb:;awJbbbb9GEMgw:lJbbb9p9DTmbaw:Ohdxekcjjjj94hdkabad87ebabcwfhbaecufgembkkk;siliui99iue99dnaeTmbcbhiabhlindndnJ;Zl81Zalcof8UebgvciV:Y:vgoal8Ueb:YNgrJb;:FSNJbbbZJbbb:;arJbbbb9GEMgw:lJbbb9p9DTmbaw:OhDxekcjjjj94hDkalclf8Uebhqalcdf8UebhkabavcefciGaiVcetfaD87ebdndnaoak:YNgwJb;:FSNJbbbZJbbb:;awJbbbb9GEMgx:lJbbb9p9DTmbax:Ohkxekcjjjj94hkkabavcdfciGaiVcetfak87ebdndnaoaq:YNgoJb;:FSNJbbbZJbbb:;aoJbbbb9GEMgx:lJbbb9p9DTmbax:Ohqxekcjjjj94hqkabavcufciGaiVcetfaq87ebdndnJbbjZararN:tawawN:taoaoN:tgrJbbbbarJbbbb9GE:rJb;:FSNJbbbZMgr:lJbbb9p9DTmbar:Ohqxekcjjjj94hqkabavciGaiVcetfaq87ebalcwfhlaiclfhiaecufgembkkk9mbdnadcd4ae2geTmbinababydbgdcwtcw91:Yadce91cjjj;8ifcjjj98G::NUdbabclfhbaecufgembkkk9teiucbcbydj1jjbgeabcifc98GfgbBdj1jjbdndnabZbcztgd9nmbcuhiabad9RcFFifcz4nbcuSmekaehikaik;LeeeudndnaeabVciGTmbabhixekdndnadcz9pmbabhixekabhiinaiaeydbBdbaiclfaeclfydbBdbaicwfaecwfydbBdbaicxfaecxfydbBdbaiczfhiaeczfheadc9Wfgdcs0mbkkadcl6mbinaiaeydbBdbaeclfheaiclfhiadc98fgdci0mbkkdnadTmbinaiaeRbb86bbaicefhiaecefheadcufgdmbkkabk;aeedudndnabciGTmbabhixekaecFeGc:b:c:ew2hldndnadcz9pmbabhixekabhiinaialBdbaicxfalBdbaicwfalBdbaiclfalBdbaiczfhiadc9Wfgdcs0mbkkadcl6mbinaialBdbaiclfhiadc98fgdci0mbkkdnadTmbinaiae86bbaicefhiadcufgdmbkkabkkkebcjwklz9Kbb",
    s = WebAssembly.instantiate(r(n), {}).then(function (e) {
      (i = e.instance).exports.__wasm_call_ctors();
    });
  function r(e) {
    for (var i = new Uint8Array(e.length), n = 0; n < e.length; ++n) {
      var s = e.charCodeAt(n);
      i[n] = s > 96 ? s - 97 : s > 64 ? s - 39 : s + 4;
    }
    var r = 0;
    for (n = 0; n < e.length; ++n)
      i[r++] = i[n] < 60 ? t[i[n]] : 64 * (i[n] - 60) + i[++n];
    return i.buffer.slice(0, r);
  }
  function a(e, t, n, s, r, a) {
    var o = i.exports.sbrk,
      l = (n + 3) & -4,
      h = o(l * s),
      c = o(r.length),
      u = new Uint8Array(i.exports.memory.buffer);
    u.set(r, c);
    var d = e(h, n, s, c, r.length);
    if (
      (0 == d && a && a(h, l, s),
      t.set(u.subarray(h, h + n * s)),
      o(h - o(0)),
      0 != d)
    )
      throw new Error("Malformed buffer data: " + d);
  }
  var o = {
      NONE: "",
      OCTAHEDRAL: "meshopt_decodeFilterOct",
      QUATERNION: "meshopt_decodeFilterQuat",
      EXPONENTIAL: "meshopt_decodeFilterExp",
    },
    l = {
      ATTRIBUTES: "meshopt_decodeVertexBuffer",
      TRIANGLES: "meshopt_decodeIndexBuffer",
      INDICES: "meshopt_decodeIndexSequence",
    },
    h = [],
    c = 0;
  function u(e) {
    var t = { object: new Worker(e), pending: 0, requests: {} };
    return (
      (t.object.onmessage = function (e) {
        var i = e.data;
        (t.pending -= i.count),
          t.requests[i.id][i.action](i.value),
          delete t.requests[i.id];
      }),
      t
    );
  }
  function d(e) {
    for (
      var t =
          "var instance; var ready = WebAssembly.instantiate(new Uint8Array([" +
          new Uint8Array(r(n)) +
          "]), {}).then(function(result) { instance = result.instance; instance.exports.__wasm_call_ctors(); });self.onmessage = workerProcess;" +
          a.toString() +
          p.toString(),
        i = new Blob([t], { type: "text/javascript" }),
        s = URL.createObjectURL(i),
        o = 0;
      o < e;
      ++o
    )
      h[o] = u(s);
    URL.revokeObjectURL(s);
  }
  function p(e) {
    s.then(function () {
      var t = e.data;
      try {
        var n = new Uint8Array(t.count * t.size);
        a(i.exports[t.mode], n, t.count, t.size, t.source, i.exports[t.filter]),
          self.postMessage(
            { id: t.id, count: t.count, action: "resolve", value: n },
            [n.buffer]
          );
      } catch (s) {
        self.postMessage({
          id: t.id,
          count: t.count,
          action: "reject",
          value: s,
        });
      }
    });
  }
  return {
    ready: s,
    supported: !0,
    useWorkers: function (e) {
      d(e);
    },
    decodeVertexBuffer: function (e, t, n, s, r) {
      a(i.exports.meshopt_decodeVertexBuffer, e, t, n, s, i.exports[o[r]]);
    },
    decodeIndexBuffer: function (e, t, n, s) {
      a(i.exports.meshopt_decodeIndexBuffer, e, t, n, s);
    },
    decodeIndexSequence: function (e, t, n, s) {
      a(i.exports.meshopt_decodeIndexSequence, e, t, n, s);
    },
    decodeGltfBuffer: function (e, t, n, s, r, h) {
      a(i.exports[l[r]], e, t, n, s, i.exports[o[h]]);
    },
    decodeGltfBufferAsync: function (e, t, n, r, u) {
      return h.length > 0
        ? (function (e, t, i, n, s) {
            for (var r = h[0], a = 1; a < h.length; ++a)
              h[a].pending < r.pending && (r = h[a]);
            return new Promise(function (a, o) {
              var l = new Uint8Array(i),
                h = c++;
              (r.pending += e),
                (r.requests[h] = { resolve: a, reject: o }),
                r.object.postMessage(
                  { id: h, count: e, size: t, source: l, mode: n, filter: s },
                  [l.buffer]
                );
            });
          })(e, t, n, l[r], o[u])
        : s.then(function () {
            var s = new Uint8Array(e * t);
            return a(i.exports[l[r]], s, e, t, n, i.exports[o[u]]), s;
          });
    },
  };
})();
const aS = new WeakMap();
function oS() {
  let e, t;
  function i(e, t, i, n, s, r) {
    const a = r.num_components(),
      o = i.num_points() * a,
      l = o * s.BYTES_PER_ELEMENT,
      h = (function (e, t) {
        switch (t) {
          case Float32Array:
            return e.DT_FLOAT32;
          case Int8Array:
            return e.DT_INT8;
          case Int16Array:
            return e.DT_INT16;
          case Int32Array:
            return e.DT_INT32;
          case Uint8Array:
            return e.DT_UINT8;
          case Uint16Array:
            return e.DT_UINT16;
          case Uint32Array:
            return e.DT_UINT32;
        }
      })(e, s),
      c = e._malloc(l);
    t.GetAttributeDataArrayForAllPoints(i, r, h, l, c);
    const u = new s(e.HEAPF32.buffer, c, o).slice();
    return e._free(c), { name: n, array: u, itemSize: a };
  }
  onmessage = function (n) {
    const s = n.data;
    switch (s.type) {
      case "init":
        (e = s.decoderConfig),
          (t = new Promise(function (t) {
            (e.onModuleLoaded = function (e) {
              t({ draco: e });
            }),
              DracoDecoderModule(e);
          }));
        break;
      case "decode":
        const n = s.buffer,
          r = s.taskConfig;
        t.then((e) => {
          const t = e.draco,
            a = new t.Decoder();
          try {
            const e = (function (e, t, n, s) {
                const r = s.attributeIDs,
                  a = s.attributeTypes;
                let o, l;
                const h = t.GetEncodedGeometryType(n);
                if (h === e.TRIANGULAR_MESH)
                  (o = new e.Mesh()),
                    (l = t.DecodeArrayToMesh(n, n.byteLength, o));
                else {
                  if (h !== e.POINT_CLOUD)
                    throw new Error(
                      "THREE.DRACOLoader: Unexpected geometry type."
                    );
                  (o = new e.PointCloud()),
                    (l = t.DecodeArrayToPointCloud(n, n.byteLength, o));
                }
                if (!l.ok() || 0 === o.ptr)
                  throw new Error(
                    "THREE.DRACOLoader: Decoding failed: " + l.error_msg()
                  );
                const c = { index: null, attributes: [] };
                for (const u in r) {
                  const n = self[a[u]];
                  let l, h;
                  if (s.useUniqueIDs)
                    (h = r[u]), (l = t.GetAttributeByUniqueId(o, h));
                  else {
                    if (((h = t.GetAttributeId(o, e[r[u]])), -1 === h))
                      continue;
                    l = t.GetAttribute(o, h);
                  }
                  const d = i(e, t, o, u, n, l);
                  "color" === u && (d.vertexColorSpace = s.vertexColorSpace),
                    c.attributes.push(d);
                }
                h === e.TRIANGULAR_MESH &&
                  (c.index = (function (e, t, i) {
                    const n = i.num_faces(),
                      s = 3 * n,
                      r = 4 * s,
                      a = e._malloc(r);
                    t.GetTrianglesUInt32Array(i, r, a);
                    const o = new Uint32Array(e.HEAPF32.buffer, a, s).slice();
                    return e._free(a), { array: o, itemSize: 1 };
                  })(e, t, o));
                return e.destroy(o), c;
              })(t, a, new Int8Array(n), r),
              o = e.attributes.map((e) => e.array.buffer);
            e.index && o.push(e.index.array.buffer),
              self.postMessage({ type: "decode", id: s.id, geometry: e }, o);
          } catch (o) {
            console.error(o),
              self.postMessage({ type: "error", id: s.id, error: o.message });
          } finally {
            t.destroy(a);
          }
        });
    }
  };
}
class lS {
  constructor(e = 4) {
    (this.pool = e),
      (this.queue = []),
      (this.workers = []),
      (this.workersResolve = []),
      (this.workerStatus = 0);
  }
  _initWorker(e) {
    if (!this.workers[e]) {
      const t = this.workerCreator();
      t.addEventListener("message", this._onMessage.bind(this, e)),
        (this.workers[e] = t);
    }
  }
  _getIdleWorker() {
    for (let e = 0; e < this.pool; e++)
      if (!(this.workerStatus & (1 << e))) return e;
    return -1;
  }
  _onMessage(e, t) {
    const i = this.workersResolve[e];
    if ((i && i(t), this.queue.length)) {
      const { resolve: t, msg: i, transfer: n } = this.queue.shift();
      (this.workersResolve[e] = t), this.workers[e].postMessage(i, n);
    } else this.workerStatus ^= 1 << e;
  }
  setWorkerCreator(e) {
    this.workerCreator = e;
  }
  setWorkerLimit(e) {
    this.pool = e;
  }
  postMessage(e, t) {
    return new Promise((i) => {
      const n = this._getIdleWorker();
      -1 !== n
        ? (this._initWorker(n),
          (this.workerStatus |= 1 << n),
          (this.workersResolve[n] = i),
          this.workers[n].postMessage(e, t))
        : this.queue.push({ resolve: i, msg: e, transfer: t });
    });
  }
  dispose() {
    this.workers.forEach((e) => e.terminate()),
      (this.workersResolve.length = 0),
      (this.workers.length = 0),
      (this.queue.length = 0),
      (this.workerStatus = 0);
  }
}
const hS = 2,
  cS = 0,
  uS = 1,
  dS = 10;
class pS {
  constructor() {
    (this.vkFormat = 0),
      (this.typeSize = 1),
      (this.pixelWidth = 0),
      (this.pixelHeight = 0),
      (this.pixelDepth = 0),
      (this.layerCount = 0),
      (this.faceCount = 1),
      (this.supercompressionScheme = 0),
      (this.levels = []),
      (this.dataFormatDescriptor = [
        {
          vendorId: 0,
          descriptorType: 0,
          descriptorBlockSize: 0,
          versionNumber: 2,
          colorModel: 0,
          colorPrimaries: 1,
          transferFunction: 2,
          flags: 0,
          texelBlockDimension: [0, 0, 0, 0],
          bytesPlane: [0, 0, 0, 0, 0, 0, 0, 0],
          samples: [],
        },
      ]),
      (this.keyValue = {}),
      (this.globalData = null);
  }
}
class fS {
  constructor(e, t, i, n) {
    (this._dataView = new DataView(e.buffer, e.byteOffset + t, i)),
      (this._littleEndian = n),
      (this._offset = 0);
  }
  _nextUint8() {
    const e = this._dataView.getUint8(this._offset);
    return (this._offset += 1), e;
  }
  _nextUint16() {
    const e = this._dataView.getUint16(this._offset, this._littleEndian);
    return (this._offset += 2), e;
  }
  _nextUint32() {
    const e = this._dataView.getUint32(this._offset, this._littleEndian);
    return (this._offset += 4), e;
  }
  _nextUint64() {
    const e =
      this._dataView.getUint32(this._offset, this._littleEndian) +
      2 ** 32 * this._dataView.getUint32(this._offset + 4, this._littleEndian);
    return (this._offset += 8), e;
  }
  _nextInt32() {
    const e = this._dataView.getInt32(this._offset, this._littleEndian);
    return (this._offset += 4), e;
  }
  _skip(e) {
    return (this._offset += e), this;
  }
  _scan(e, t = 0) {
    const i = this._offset;
    let n = 0;
    for (; this._dataView.getUint8(this._offset) !== t && n < e; )
      n++, this._offset++;
    return (
      n < e && this._offset++,
      new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + i, n)
    );
  }
}
const mS = [171, 75, 84, 88, 32, 50, 48, 187, 13, 10, 26, 10];
function gS(e) {
  return "undefined" != typeof TextDecoder
    ? new TextDecoder().decode(e)
    : Buffer.from(e).toString("utf8");
}
let _S, vS, AS;
const yS = {
  env: {
    emscripten_notify_memory_growth: function (e) {
      AS = new Uint8Array(vS.exports.memory.buffer);
    },
  },
};
class xS {
  init() {
    return (
      _S ||
      ((_S =
        "undefined" != typeof fetch
          ? fetch("data:application/wasm;base64," + bS)
              .then((e) => e.arrayBuffer())
              .then((e) => WebAssembly.instantiate(e, yS))
              .then(this._init)
          : WebAssembly.instantiate(Buffer.from(bS, "base64"), yS).then(
              this._init
            )),
      _S)
    );
  }
  _init(e) {
    (vS = e.instance), yS.env.emscripten_notify_memory_growth(0);
  }
  decode(e, t = 0) {
    if (!vS) throw new Error("ZSTDDecoder: Await .init() before decoding.");
    const i = e.byteLength,
      n = vS.exports.malloc(i);
    AS.set(e, n), (t = t || Number(vS.exports.ZSTD_findDecompressedSize(n, i)));
    const s = vS.exports.malloc(t),
      r = vS.exports.ZSTD_decompress(s, t, n, i),
      a = AS.slice(s, s + r);
    return vS.exports.free(n), vS.exports.free(s), a;
  }
}
const bS =
    "AGFzbQEAAAABpQEVYAF/AX9gAn9/AGADf39/AX9gBX9/f39/AX9gAX8AYAJ/fwF/YAR/f39/AX9gA39/fwBgBn9/f39/fwF/YAd/f39/f39/AX9gAn9/AX5gAn5+AX5gAABgBX9/f39/AGAGf39/f39/AGAIf39/f39/f38AYAl/f39/f39/f38AYAABf2AIf39/f39/f38Bf2ANf39/f39/f39/f39/fwF/YAF/AX4CJwEDZW52H2Vtc2NyaXB0ZW5fbm90aWZ5X21lbW9yeV9ncm93dGgABANpaAEFAAAFAgEFCwACAQABAgIFBQcAAwABDgsBAQcAEhMHAAUBDAQEAAANBwQCAgYCBAgDAwMDBgEACQkHBgICAAYGAgQUBwYGAwIGAAMCAQgBBwUGCgoEEQAEBAEIAwgDBQgDEA8IAAcABAUBcAECAgUEAQCAAgYJAX8BQaCgwAILB2AHBm1lbW9yeQIABm1hbGxvYwAoBGZyZWUAJgxaU1REX2lzRXJyb3IAaBlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplAFQPWlNURF9kZWNvbXByZXNzAEoGX3N0YXJ0ACQJBwEAQQELASQKussBaA8AIAAgACgCBCABajYCBAsZACAAKAIAIAAoAgRBH3F0QQAgAWtBH3F2CwgAIABBiH9LC34BBH9BAyEBIAAoAgQiA0EgTQRAIAAoAggiASAAKAIQTwRAIAAQDQ8LIAAoAgwiAiABRgRAQQFBAiADQSBJGw8LIAAgASABIAJrIANBA3YiBCABIARrIAJJIgEbIgJrIgQ2AgggACADIAJBA3RrNgIEIAAgBCgAADYCAAsgAQsUAQF/IAAgARACIQIgACABEAEgAgv3AQECfyACRQRAIABCADcCACAAQQA2AhAgAEIANwIIQbh/DwsgACABNgIMIAAgAUEEajYCECACQQRPBEAgACABIAJqIgFBfGoiAzYCCCAAIAMoAAA2AgAgAUF/ai0AACIBBEAgAEEIIAEQFGs2AgQgAg8LIABBADYCBEF/DwsgACABNgIIIAAgAS0AACIDNgIAIAJBfmoiBEEBTQRAIARBAWtFBEAgACABLQACQRB0IANyIgM2AgALIAAgAS0AAUEIdCADajYCAAsgASACakF/ai0AACIBRQRAIABBADYCBEFsDwsgAEEoIAEQFCACQQN0ams2AgQgAgsWACAAIAEpAAA3AAAgACABKQAINwAICy8BAX8gAUECdEGgHWooAgAgACgCAEEgIAEgACgCBGprQR9xdnEhAiAAIAEQASACCyEAIAFCz9bTvtLHq9lCfiAAfEIfiUKHla+vmLbem55/fgsdAQF/IAAoAgggACgCDEYEfyAAKAIEQSBGBUEACwuCBAEDfyACQYDAAE8EQCAAIAEgAhBnIAAPCyAAIAJqIQMCQCAAIAFzQQNxRQRAAkAgAkEBSARAIAAhAgwBCyAAQQNxRQRAIAAhAgwBCyAAIQIDQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADTw0BIAJBA3ENAAsLAkAgA0F8cSIEQcAASQ0AIAIgBEFAaiIFSw0AA0AgAiABKAIANgIAIAIgASgCBDYCBCACIAEoAgg2AgggAiABKAIMNgIMIAIgASgCEDYCECACIAEoAhQ2AhQgAiABKAIYNgIYIAIgASgCHDYCHCACIAEoAiA2AiAgAiABKAIkNgIkIAIgASgCKDYCKCACIAEoAiw2AiwgAiABKAIwNgIwIAIgASgCNDYCNCACIAEoAjg2AjggAiABKAI8NgI8IAFBQGshASACQUBrIgIgBU0NAAsLIAIgBE8NAQNAIAIgASgCADYCACABQQRqIQEgAkEEaiICIARJDQALDAELIANBBEkEQCAAIQIMAQsgA0F8aiIEIABJBEAgACECDAELIAAhAgNAIAIgAS0AADoAACACIAEtAAE6AAEgAiABLQACOgACIAIgAS0AAzoAAyABQQRqIQEgAkEEaiICIARNDQALCyACIANJBEADQCACIAEtAAA6AAAgAUEBaiEBIAJBAWoiAiADRw0ACwsgAAsMACAAIAEpAAA3AAALQQECfyAAKAIIIgEgACgCEEkEQEEDDwsgACAAKAIEIgJBB3E2AgQgACABIAJBA3ZrIgE2AgggACABKAAANgIAQQALDAAgACABKAIANgAAC/cCAQJ/AkAgACABRg0AAkAgASACaiAASwRAIAAgAmoiBCABSw0BCyAAIAEgAhALDwsgACABc0EDcSEDAkACQCAAIAFJBEAgAwRAIAAhAwwDCyAAQQNxRQRAIAAhAwwCCyAAIQMDQCACRQ0EIAMgAS0AADoAACABQQFqIQEgAkF/aiECIANBAWoiA0EDcQ0ACwwBCwJAIAMNACAEQQNxBEADQCACRQ0FIAAgAkF/aiICaiIDIAEgAmotAAA6AAAgA0EDcQ0ACwsgAkEDTQ0AA0AgACACQXxqIgJqIAEgAmooAgA2AgAgAkEDSw0ACwsgAkUNAgNAIAAgAkF/aiICaiABIAJqLQAAOgAAIAINAAsMAgsgAkEDTQ0AIAIhBANAIAMgASgCADYCACABQQRqIQEgA0EEaiEDIARBfGoiBEEDSw0ACyACQQNxIQILIAJFDQADQCADIAEtAAA6AAAgA0EBaiEDIAFBAWohASACQX9qIgINAAsLIAAL8wICAn8BfgJAIAJFDQAgACACaiIDQX9qIAE6AAAgACABOgAAIAJBA0kNACADQX5qIAE6AAAgACABOgABIANBfWogAToAACAAIAE6AAIgAkEHSQ0AIANBfGogAToAACAAIAE6AAMgAkEJSQ0AIABBACAAa0EDcSIEaiIDIAFB/wFxQYGChAhsIgE2AgAgAyACIARrQXxxIgRqIgJBfGogATYCACAEQQlJDQAgAyABNgIIIAMgATYCBCACQXhqIAE2AgAgAkF0aiABNgIAIARBGUkNACADIAE2AhggAyABNgIUIAMgATYCECADIAE2AgwgAkFwaiABNgIAIAJBbGogATYCACACQWhqIAE2AgAgAkFkaiABNgIAIAQgA0EEcUEYciIEayICQSBJDQAgAa0iBUIghiAFhCEFIAMgBGohAQNAIAEgBTcDGCABIAU3AxAgASAFNwMIIAEgBTcDACABQSBqIQEgAkFgaiICQR9LDQALCyAACy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAIajYCACADCy8BAn8gACgCBCAAKAIAQQJ0aiICLQACIQMgACACLwEAIAEgAi0AAxAFajYCACADCx8AIAAgASACKAIEEAg2AgAgARAEGiAAIAJBCGo2AgQLCAAgAGdBH3MLugUBDX8jAEEQayIKJAACfyAEQQNNBEAgCkEANgIMIApBDGogAyAEEAsaIAAgASACIApBDGpBBBAVIgBBbCAAEAMbIAAgACAESxsMAQsgAEEAIAEoAgBBAXRBAmoQECENQVQgAygAACIGQQ9xIgBBCksNABogAiAAQQVqNgIAIAMgBGoiAkF8aiEMIAJBeWohDiACQXtqIRAgAEEGaiELQQQhBSAGQQR2IQRBICAAdCIAQQFyIQkgASgCACEPQQAhAiADIQYCQANAIAlBAkggAiAPS3JFBEAgAiEHAkAgCARAA0AgBEH//wNxQf//A0YEQCAHQRhqIQcgBiAQSQR/IAZBAmoiBigAACAFdgUgBUEQaiEFIARBEHYLIQQMAQsLA0AgBEEDcSIIQQNGBEAgBUECaiEFIARBAnYhBCAHQQNqIQcMAQsLIAcgCGoiByAPSw0EIAVBAmohBQNAIAIgB0kEQCANIAJBAXRqQQA7AQAgAkEBaiECDAELCyAGIA5LQQAgBiAFQQN1aiIHIAxLG0UEQCAHKAAAIAVBB3EiBXYhBAwCCyAEQQJ2IQQLIAYhBwsCfyALQX9qIAQgAEF/anEiBiAAQQF0QX9qIgggCWsiEUkNABogBCAIcSIEQQAgESAEIABIG2shBiALCyEIIA0gAkEBdGogBkF/aiIEOwEAIAlBASAGayAEIAZBAUgbayEJA0AgCSAASARAIABBAXUhACALQX9qIQsMAQsLAn8gByAOS0EAIAcgBSAIaiIFQQN1aiIGIAxLG0UEQCAFQQdxDAELIAUgDCIGIAdrQQN0awshBSACQQFqIQIgBEUhCCAGKAAAIAVBH3F2IQQMAQsLQWwgCUEBRyAFQSBKcg0BGiABIAJBf2o2AgAgBiAFQQdqQQN1aiADawwBC0FQCyEAIApBEGokACAACwkAQQFBBSAAGwsMACAAIAEoAAA2AAALqgMBCn8jAEHwAGsiCiQAIAJBAWohDiAAQQhqIQtBgIAEIAVBf2p0QRB1IQxBACECQQEhBkEBIAV0IglBf2oiDyEIA0AgAiAORkUEQAJAIAEgAkEBdCINai8BACIHQf//A0YEQCALIAhBA3RqIAI2AgQgCEF/aiEIQQEhBwwBCyAGQQAgDCAHQRB0QRB1ShshBgsgCiANaiAHOwEAIAJBAWohAgwBCwsgACAFNgIEIAAgBjYCACAJQQN2IAlBAXZqQQNqIQxBACEAQQAhBkEAIQIDQCAGIA5GBEADQAJAIAAgCUYNACAKIAsgAEEDdGoiASgCBCIGQQF0aiICIAIvAQAiAkEBajsBACABIAUgAhAUayIIOgADIAEgAiAIQf8BcXQgCWs7AQAgASAEIAZBAnQiAmooAgA6AAIgASACIANqKAIANgIEIABBAWohAAwBCwsFIAEgBkEBdGouAQAhDUEAIQcDQCAHIA1ORQRAIAsgAkEDdGogBjYCBANAIAIgDGogD3EiAiAISw0ACyAHQQFqIQcMAQsLIAZBAWohBgwBCwsgCkHwAGokAAsjAEIAIAEQCSAAhUKHla+vmLbem55/fkLj3MqV/M7y9YV/fAsQACAAQn43AwggACABNgIACyQBAX8gAARAIAEoAgQiAgRAIAEoAgggACACEQEADwsgABAmCwsfACAAIAEgAi8BABAINgIAIAEQBBogACACQQRqNgIEC0oBAX9BoCAoAgAiASAAaiIAQX9MBEBBiCBBMDYCAEF/DwsCQCAAPwBBEHRNDQAgABBmDQBBiCBBMDYCAEF/DwtBoCAgADYCACABC9cBAQh/Qbp/IQoCQCACKAIEIgggAigCACIJaiIOIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQ0gACABQWBqIg8gCyAJQQAQKSADIAkgC2o2AgACQAJAIAwgBCAFa00EQCANIQUMAQsgDCAEIAZrSw0CIAcgDSAFayIAaiIBIAhqIAdNBEAgBCABIAgQDxoMAgsgBCABQQAgAGsQDyEBIAIgACAIaiIINgIEIAEgAGshBAsgBCAPIAUgCEEBECkLIA4hCgsgCgubAgEBfyMAQYABayINJAAgDSADNgJ8AkAgAkEDSwRAQX8hCQwBCwJAAkACQAJAIAJBAWsOAwADAgELIAZFBEBBuH8hCQwEC0FsIQkgBS0AACICIANLDQMgACAHIAJBAnQiAmooAgAgAiAIaigCABA7IAEgADYCAEEBIQkMAwsgASAJNgIAQQAhCQwCCyAKRQRAQWwhCQwCC0EAIQkgC0UgDEEZSHINAUEIIAR0QQhqIQBBACECA0AgAiAATw0CIAJBQGshAgwAAAsAC0FsIQkgDSANQfwAaiANQfgAaiAFIAYQFSICEAMNACANKAJ4IgMgBEsNACAAIA0gDSgCfCAHIAggAxAYIAEgADYCACACIQkLIA1BgAFqJAAgCQsLACAAIAEgAhALGgsQACAALwAAIAAtAAJBEHRyCy8AAn9BuH8gAUEISQ0AGkFyIAAoAAQiAEF3Sw0AGkG4fyAAQQhqIgAgACABSxsLCwkAIAAgATsAAAsDAAELigYBBX8gACAAKAIAIgVBfnE2AgBBACAAIAVBAXZqQYQgKAIAIgQgAEYbIQECQAJAIAAoAgQiAkUNACACKAIAIgNBAXENACACQQhqIgUgA0EBdkF4aiIDQQggA0EISxtnQR9zQQJ0QYAfaiIDKAIARgRAIAMgAigCDDYCAAsgAigCCCIDBEAgAyACKAIMNgIECyACKAIMIgMEQCADIAIoAgg2AgALIAIgAigCACAAKAIAQX5xajYCAEGEICEAAkACQCABRQ0AIAEgAjYCBCABKAIAIgNBAXENASADQQF2QXhqIgNBCCADQQhLG2dBH3NBAnRBgB9qIgMoAgAgAUEIakYEQCADIAEoAgw2AgALIAEoAggiAwRAIAMgASgCDDYCBAsgASgCDCIDBEAgAyABKAIINgIAQYQgKAIAIQQLIAIgAigCACABKAIAQX5xajYCACABIARGDQAgASABKAIAQQF2akEEaiEACyAAIAI2AgALIAIoAgBBAXZBeGoiAEEIIABBCEsbZ0Efc0ECdEGAH2oiASgCACEAIAEgBTYCACACIAA2AgwgAkEANgIIIABFDQEgACAFNgIADwsCQCABRQ0AIAEoAgAiAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAigCACABQQhqRgRAIAIgASgCDDYCAAsgASgCCCICBEAgAiABKAIMNgIECyABKAIMIgIEQCACIAEoAgg2AgBBhCAoAgAhBAsgACAAKAIAIAEoAgBBfnFqIgI2AgACQCABIARHBEAgASABKAIAQQF2aiAANgIEIAAoAgAhAgwBC0GEICAANgIACyACQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgIoAgAhASACIABBCGoiAjYCACAAIAE2AgwgAEEANgIIIAFFDQEgASACNgIADwsgBUEBdkF4aiIBQQggAUEISxtnQR9zQQJ0QYAfaiICKAIAIQEgAiAAQQhqIgI2AgAgACABNgIMIABBADYCCCABRQ0AIAEgAjYCAAsLDgAgAARAIABBeGoQJQsLgAIBA38CQCAAQQ9qQXhxQYQgKAIAKAIAQQF2ayICEB1Bf0YNAAJAQYQgKAIAIgAoAgAiAUEBcQ0AIAFBAXZBeGoiAUEIIAFBCEsbZ0Efc0ECdEGAH2oiASgCACAAQQhqRgRAIAEgACgCDDYCAAsgACgCCCIBBEAgASAAKAIMNgIECyAAKAIMIgFFDQAgASAAKAIINgIAC0EBIQEgACAAKAIAIAJBAXRqIgI2AgAgAkEBcQ0AIAJBAXZBeGoiAkEIIAJBCEsbZ0Efc0ECdEGAH2oiAygCACECIAMgAEEIaiIDNgIAIAAgAjYCDCAAQQA2AgggAkUNACACIAM2AgALIAELtwIBA38CQAJAIABBASAAGyICEDgiAA0AAkACQEGEICgCACIARQ0AIAAoAgAiA0EBcQ0AIAAgA0EBcjYCACADQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgAgAEEIakYEQCABIAAoAgw2AgALIAAoAggiAQRAIAEgACgCDDYCBAsgACgCDCIBBEAgASAAKAIINgIACyACECchAkEAIQFBhCAoAgAhACACDQEgACAAKAIAQX5xNgIAQQAPCyACQQ9qQXhxIgMQHSICQX9GDQIgAkEHakF4cSIAIAJHBEAgACACaxAdQX9GDQMLAkBBhCAoAgAiAUUEQEGAICAANgIADAELIAAgATYCBAtBhCAgADYCACAAIANBAXRBAXI2AgAMAQsgAEUNAQsgAEEIaiEBCyABC7kDAQJ/IAAgA2ohBQJAIANBB0wEQANAIAAgBU8NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwAAAsACyAEQQFGBEACQCAAIAJrIgZBB00EQCAAIAItAAA6AAAgACACLQABOgABIAAgAi0AAjoAAiAAIAItAAM6AAMgAEEEaiACIAZBAnQiBkHAHmooAgBqIgIQFyACIAZB4B5qKAIAayECDAELIAAgAhAMCyACQQhqIQIgAEEIaiEACwJAAkACQAJAIAUgAU0EQCAAIANqIQEgBEEBRyAAIAJrQQ9Kcg0BA0AgACACEAwgAkEIaiECIABBCGoiACABSQ0ACwwFCyAAIAFLBEAgACEBDAQLIARBAUcgACACa0EPSnINASAAIQMgAiEEA0AgAyAEEAwgBEEIaiEEIANBCGoiAyABSQ0ACwwCCwNAIAAgAhAHIAJBEGohAiAAQRBqIgAgAUkNAAsMAwsgACEDIAIhBANAIAMgBBAHIARBEGohBCADQRBqIgMgAUkNAAsLIAIgASAAa2ohAgsDQCABIAVPDQEgASACLQAAOgAAIAFBAWohASACQQFqIQIMAAALAAsLQQECfyAAIAAoArjgASIDNgLE4AEgACgCvOABIQQgACABNgK84AEgACABIAJqNgK44AEgACABIAQgA2tqNgLA4AELpgEBAX8gACAAKALs4QEQFjYCyOABIABCADcD+OABIABCADcDuOABIABBwOABakIANwMAIABBqNAAaiIBQYyAgOAANgIAIABBADYCmOIBIABCADcDiOEBIABCAzcDgOEBIABBrNABakHgEikCADcCACAAQbTQAWpB6BIoAgA2AgAgACABNgIMIAAgAEGYIGo2AgggACAAQaAwajYCBCAAIABBEGo2AgALYQEBf0G4fyEDAkAgAUEDSQ0AIAIgABAhIgFBA3YiADYCCCACIAFBAXE2AgQgAiABQQF2QQNxIgM2AgACQCADQX9qIgFBAksNAAJAIAFBAWsOAgEAAgtBbA8LIAAhAwsgAwsMACAAIAEgAkEAEC4LiAQCA38CfiADEBYhBCAAQQBBKBAQIQAgBCACSwRAIAQPCyABRQRAQX8PCwJAAkAgA0EBRg0AIAEoAAAiBkGo6r5pRg0AQXYhAyAGQXBxQdDUtMIBRw0BQQghAyACQQhJDQEgAEEAQSgQECEAIAEoAAQhASAAQQE2AhQgACABrTcDAEEADwsgASACIAMQLyIDIAJLDQAgACADNgIYQXIhAyABIARqIgVBf2otAAAiAkEIcQ0AIAJBIHEiBkUEQEFwIQMgBS0AACIFQacBSw0BIAVBB3GtQgEgBUEDdkEKaq2GIgdCA4h+IAd8IQggBEEBaiEECyACQQZ2IQMgAkECdiEFAkAgAkEDcUF/aiICQQJLBEBBACECDAELAkACQAJAIAJBAWsOAgECAAsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAVBAXEhBQJ+AkACQAJAIANBf2oiA0ECTQRAIANBAWsOAgIDAQtCfyAGRQ0DGiABIARqMQAADAMLIAEgBGovAACtQoACfAwCCyABIARqKAAArQwBCyABIARqKQAACyEHIAAgBTYCICAAIAI2AhwgACAHNwMAQQAhAyAAQQA2AhQgACAHIAggBhsiBzcDCCAAIAdCgIAIIAdCgIAIVBs+AhALIAMLWwEBf0G4fyEDIAIQFiICIAFNBH8gACACakF/ai0AACIAQQNxQQJ0QaAeaigCACACaiAAQQZ2IgFBAnRBsB5qKAIAaiAAQSBxIgBFaiABRSAAQQV2cWoFQbh/CwsdACAAKAKQ4gEQWiAAQQA2AqDiASAAQgA3A5DiAQu1AwEFfyMAQZACayIKJABBuH8hBgJAIAVFDQAgBCwAACIIQf8BcSEHAkAgCEF/TARAIAdBgn9qQQF2IgggBU8NAkFsIQYgB0GBf2oiBUGAAk8NAiAEQQFqIQdBACEGA0AgBiAFTwRAIAUhBiAIIQcMAwUgACAGaiAHIAZBAXZqIgQtAABBBHY6AAAgACAGQQFyaiAELQAAQQ9xOgAAIAZBAmohBgwBCwAACwALIAcgBU8NASAAIARBAWogByAKEFMiBhADDQELIAYhBEEAIQYgAUEAQTQQECEJQQAhBQNAIAQgBkcEQCAAIAZqIggtAAAiAUELSwRAQWwhBgwDBSAJIAFBAnRqIgEgASgCAEEBajYCACAGQQFqIQZBASAILQAAdEEBdSAFaiEFDAILAAsLQWwhBiAFRQ0AIAUQFEEBaiIBQQxLDQAgAyABNgIAQQFBASABdCAFayIDEBQiAXQgA0cNACAAIARqIAFBAWoiADoAACAJIABBAnRqIgAgACgCAEEBajYCACAJKAIEIgBBAkkgAEEBcXINACACIARBAWo2AgAgB0EBaiEGCyAKQZACaiQAIAYLxhEBDH8jAEHwAGsiBSQAQWwhCwJAIANBCkkNACACLwAAIQogAi8AAiEJIAIvAAQhByAFQQhqIAQQDgJAIAMgByAJIApqakEGaiIMSQ0AIAUtAAohCCAFQdgAaiACQQZqIgIgChAGIgsQAw0BIAVBQGsgAiAKaiICIAkQBiILEAMNASAFQShqIAIgCWoiAiAHEAYiCxADDQEgBUEQaiACIAdqIAMgDGsQBiILEAMNASAAIAFqIg9BfWohECAEQQRqIQZBASELIAAgAUEDakECdiIDaiIMIANqIgIgA2oiDiEDIAIhBCAMIQcDQCALIAMgEElxBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgCS0AAyELIAcgBiAFQUBrIAgQAkECdGoiCS8BADsAACAFQUBrIAktAAIQASAJLQADIQogBCAGIAVBKGogCBACQQJ0aiIJLwEAOwAAIAVBKGogCS0AAhABIAktAAMhCSADIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgDS0AAyENIAAgC2oiCyAGIAVB2ABqIAgQAkECdGoiAC8BADsAACAFQdgAaiAALQACEAEgAC0AAyEAIAcgCmoiCiAGIAVBQGsgCBACQQJ0aiIHLwEAOwAAIAVBQGsgBy0AAhABIActAAMhByAEIAlqIgkgBiAFQShqIAgQAkECdGoiBC8BADsAACAFQShqIAQtAAIQASAELQADIQQgAyANaiIDIAYgBUEQaiAIEAJBAnRqIg0vAQA7AAAgBUEQaiANLQACEAEgACALaiEAIAcgCmohByAEIAlqIQQgAyANLQADaiEDIAVB2ABqEA0gBUFAaxANciAFQShqEA1yIAVBEGoQDXJFIQsMAQsLIAQgDksgByACS3INAEFsIQsgACAMSw0BIAxBfWohCQNAQQAgACAJSSAFQdgAahAEGwRAIAAgBiAFQdgAaiAIEAJBAnRqIgovAQA7AAAgBUHYAGogCi0AAhABIAAgCi0AA2oiACAGIAVB2ABqIAgQAkECdGoiCi8BADsAACAFQdgAaiAKLQACEAEgACAKLQADaiEADAEFIAxBfmohCgNAIAVB2ABqEAQgACAKS3JFBEAgACAGIAVB2ABqIAgQAkECdGoiCS8BADsAACAFQdgAaiAJLQACEAEgACAJLQADaiEADAELCwNAIAAgCk0EQCAAIAYgBUHYAGogCBACQQJ0aiIJLwEAOwAAIAVB2ABqIAktAAIQASAAIAktAANqIQAMAQsLAkAgACAMTw0AIAAgBiAFQdgAaiAIEAIiAEECdGoiDC0AADoAACAMLQADQQFGBEAgBUHYAGogDC0AAhABDAELIAUoAlxBH0sNACAFQdgAaiAGIABBAnRqLQACEAEgBSgCXEEhSQ0AIAVBIDYCXAsgAkF9aiEMA0BBACAHIAxJIAVBQGsQBBsEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiIAIAYgBUFAayAIEAJBAnRqIgcvAQA7AAAgBUFAayAHLQACEAEgACAHLQADaiEHDAEFIAJBfmohDANAIAVBQGsQBCAHIAxLckUEQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwNAIAcgDE0EQCAHIAYgBUFAayAIEAJBAnRqIgAvAQA7AAAgBUFAayAALQACEAEgByAALQADaiEHDAELCwJAIAcgAk8NACAHIAYgBUFAayAIEAIiAEECdGoiAi0AADoAACACLQADQQFGBEAgBUFAayACLQACEAEMAQsgBSgCREEfSw0AIAVBQGsgBiAAQQJ0ai0AAhABIAUoAkRBIUkNACAFQSA2AkQLIA5BfWohAgNAQQAgBCACSSAFQShqEAQbBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2oiACAGIAVBKGogCBACQQJ0aiIELwEAOwAAIAVBKGogBC0AAhABIAAgBC0AA2ohBAwBBSAOQX5qIQIDQCAFQShqEAQgBCACS3JFBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsDQCAEIAJNBEAgBCAGIAVBKGogCBACQQJ0aiIALwEAOwAAIAVBKGogAC0AAhABIAQgAC0AA2ohBAwBCwsCQCAEIA5PDQAgBCAGIAVBKGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBKGogAi0AAhABDAELIAUoAixBH0sNACAFQShqIAYgAEECdGotAAIQASAFKAIsQSFJDQAgBUEgNgIsCwNAQQAgAyAQSSAFQRBqEAQbBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2oiACAGIAVBEGogCBACQQJ0aiICLwEAOwAAIAVBEGogAi0AAhABIAAgAi0AA2ohAwwBBSAPQX5qIQIDQCAFQRBqEAQgAyACS3JFBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsDQCADIAJNBEAgAyAGIAVBEGogCBACQQJ0aiIALwEAOwAAIAVBEGogAC0AAhABIAMgAC0AA2ohAwwBCwsCQCADIA9PDQAgAyAGIAVBEGogCBACIgBBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAVBEGogAi0AAhABDAELIAUoAhRBH0sNACAFQRBqIAYgAEECdGotAAIQASAFKAIUQSFJDQAgBUEgNgIUCyABQWwgBUHYAGoQCiAFQUBrEApxIAVBKGoQCnEgBUEQahAKcRshCwwJCwAACwALAAALAAsAAAsACwAACwALQWwhCwsgBUHwAGokACALC7UEAQ5/IwBBEGsiBiQAIAZBBGogABAOQVQhBQJAIARB3AtJDQAgBi0ABCEHIANB8ARqQQBB7AAQECEIIAdBDEsNACADQdwJaiIJIAggBkEIaiAGQQxqIAEgAhAxIhAQA0UEQCAGKAIMIgQgB0sNASADQdwFaiEPIANBpAVqIREgAEEEaiESIANBqAVqIQEgBCEFA0AgBSICQX9qIQUgCCACQQJ0aigCAEUNAAsgAkEBaiEOQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgASALaiAKNgIAIAVBAWohBSAKIAxqIQoMAQsLIAEgCjYCAEEAIQUgBigCCCELA0AgBSALRkUEQCABIAUgCWotAAAiDEECdGoiDSANKAIAIg1BAWo2AgAgDyANQQF0aiINIAw6AAEgDSAFOgAAIAVBAWohBQwBCwtBACEBIANBADYCqAUgBEF/cyAHaiEJQQEhBQNAIAUgDk9FBEAgCCAFQQJ0IgtqKAIAIQwgAyALaiABNgIAIAwgBSAJanQgAWohASAFQQFqIQUMAQsLIAcgBEEBaiIBIAJrIgRrQQFqIQgDQEEBIQUgBCAIT0UEQANAIAUgDk9FBEAgBUECdCIJIAMgBEE0bGpqIAMgCWooAgAgBHY2AgAgBUEBaiEFDAELCyAEQQFqIQQMAQsLIBIgByAPIAogESADIAIgARBkIAZBAToABSAGIAc6AAYgACAGKAIENgIACyAQIQULIAZBEGokACAFC8ENAQt/IwBB8ABrIgUkAEFsIQkCQCADQQpJDQAgAi8AACEKIAIvAAIhDCACLwAEIQYgBUEIaiAEEA4CQCADIAYgCiAMampBBmoiDUkNACAFLQAKIQcgBUHYAGogAkEGaiICIAoQBiIJEAMNASAFQUBrIAIgCmoiAiAMEAYiCRADDQEgBUEoaiACIAxqIgIgBhAGIgkQAw0BIAVBEGogAiAGaiADIA1rEAYiCRADDQEgACABaiIOQX1qIQ8gBEEEaiEGQQEhCSAAIAFBA2pBAnYiAmoiCiACaiIMIAJqIg0hAyAMIQQgCiECA0AgCSADIA9JcQRAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAACAGIAVBQGsgBxACQQF0aiIILQAAIQsgBUFAayAILQABEAEgAiALOgAAIAYgBUEoaiAHEAJBAXRqIggtAAAhCyAFQShqIAgtAAEQASAEIAs6AAAgBiAFQRBqIAcQAkEBdGoiCC0AACELIAVBEGogCC0AARABIAMgCzoAACAGIAVB2ABqIAcQAkEBdGoiCC0AACELIAVB2ABqIAgtAAEQASAAIAs6AAEgBiAFQUBrIAcQAkEBdGoiCC0AACELIAVBQGsgCC0AARABIAIgCzoAASAGIAVBKGogBxACQQF0aiIILQAAIQsgBUEoaiAILQABEAEgBCALOgABIAYgBUEQaiAHEAJBAXRqIggtAAAhCyAFQRBqIAgtAAEQASADIAs6AAEgA0ECaiEDIARBAmohBCACQQJqIQIgAEECaiEAIAkgBUHYAGoQDUVxIAVBQGsQDUVxIAVBKGoQDUVxIAVBEGoQDUVxIQkMAQsLIAQgDUsgAiAMS3INAEFsIQkgACAKSw0BIApBfWohCQNAIAVB2ABqEAQgACAJT3JFBEAgBiAFQdgAaiAHEAJBAXRqIggtAAAhCyAFQdgAaiAILQABEAEgACALOgAAIAYgBUHYAGogBxACQQF0aiIILQAAIQsgBUHYAGogCC0AARABIAAgCzoAASAAQQJqIQAMAQsLA0AgBUHYAGoQBCAAIApPckUEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCwNAIAAgCkkEQCAGIAVB2ABqIAcQAkEBdGoiCS0AACEIIAVB2ABqIAktAAEQASAAIAg6AAAgAEEBaiEADAELCyAMQX1qIQADQCAFQUBrEAQgAiAAT3JFBEAgBiAFQUBrIAcQAkEBdGoiCi0AACEJIAVBQGsgCi0AARABIAIgCToAACAGIAVBQGsgBxACQQF0aiIKLQAAIQkgBUFAayAKLQABEAEgAiAJOgABIAJBAmohAgwBCwsDQCAFQUBrEAQgAiAMT3JFBEAgBiAFQUBrIAcQAkEBdGoiAC0AACEKIAVBQGsgAC0AARABIAIgCjoAACACQQFqIQIMAQsLA0AgAiAMSQRAIAYgBUFAayAHEAJBAXRqIgAtAAAhCiAFQUBrIAAtAAEQASACIAo6AAAgAkEBaiECDAELCyANQX1qIQADQCAFQShqEAQgBCAAT3JFBEAgBiAFQShqIAcQAkEBdGoiAi0AACEKIAVBKGogAi0AARABIAQgCjoAACAGIAVBKGogBxACQQF0aiICLQAAIQogBUEoaiACLQABEAEgBCAKOgABIARBAmohBAwBCwsDQCAFQShqEAQgBCANT3JFBEAgBiAFQShqIAcQAkEBdGoiAC0AACECIAVBKGogAC0AARABIAQgAjoAACAEQQFqIQQMAQsLA0AgBCANSQRAIAYgBUEoaiAHEAJBAXRqIgAtAAAhAiAFQShqIAAtAAEQASAEIAI6AAAgBEEBaiEEDAELCwNAIAVBEGoQBCADIA9PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIAYgBUEQaiAHEAJBAXRqIgAtAAAhAiAFQRBqIAAtAAEQASADIAI6AAEgA0ECaiEDDAELCwNAIAVBEGoQBCADIA5PckUEQCAGIAVBEGogBxACQQF0aiIALQAAIQIgBUEQaiAALQABEAEgAyACOgAAIANBAWohAwwBCwsDQCADIA5JBEAgBiAFQRBqIAcQAkEBdGoiAC0AACECIAVBEGogAC0AARABIAMgAjoAACADQQFqIQMMAQsLIAFBbCAFQdgAahAKIAVBQGsQCnEgBUEoahAKcSAFQRBqEApxGyEJDAELQWwhCQsgBUHwAGokACAJC8oCAQR/IwBBIGsiBSQAIAUgBBAOIAUtAAIhByAFQQhqIAIgAxAGIgIQA0UEQCAEQQRqIQIgACABaiIDQX1qIQQDQCAFQQhqEAQgACAET3JFBEAgAiAFQQhqIAcQAkEBdGoiBi0AACEIIAVBCGogBi0AARABIAAgCDoAACACIAVBCGogBxACQQF0aiIGLQAAIQggBUEIaiAGLQABEAEgACAIOgABIABBAmohAAwBCwsDQCAFQQhqEAQgACADT3JFBEAgAiAFQQhqIAcQAkEBdGoiBC0AACEGIAVBCGogBC0AARABIAAgBjoAACAAQQFqIQAMAQsLA0AgACADT0UEQCACIAVBCGogBxACQQF0aiIELQAAIQYgBUEIaiAELQABEAEgACAGOgAAIABBAWohAAwBCwsgAUFsIAVBCGoQChshAgsgBUEgaiQAIAILtgMBCX8jAEEQayIGJAAgBkEANgIMIAZBADYCCEFUIQQCQAJAIANBQGsiDCADIAZBCGogBkEMaiABIAIQMSICEAMNACAGQQRqIAAQDiAGKAIMIgcgBi0ABEEBaksNASAAQQRqIQogBkEAOgAFIAYgBzoABiAAIAYoAgQ2AgAgB0EBaiEJQQEhBANAIAQgCUkEQCADIARBAnRqIgEoAgAhACABIAU2AgAgACAEQX9qdCAFaiEFIARBAWohBAwBCwsgB0EBaiEHQQAhBSAGKAIIIQkDQCAFIAlGDQEgAyAFIAxqLQAAIgRBAnRqIgBBASAEdEEBdSILIAAoAgAiAWoiADYCACAHIARrIQhBACEEAkAgC0EDTQRAA0AgBCALRg0CIAogASAEakEBdGoiACAIOgABIAAgBToAACAEQQFqIQQMAAALAAsDQCABIABPDQEgCiABQQF0aiIEIAg6AAEgBCAFOgAAIAQgCDoAAyAEIAU6AAIgBCAIOgAFIAQgBToABCAEIAg6AAcgBCAFOgAGIAFBBGohAQwAAAsACyAFQQFqIQUMAAALAAsgAiEECyAGQRBqJAAgBAutAQECfwJAQYQgKAIAIABHIAAoAgBBAXYiAyABa0F4aiICQXhxQQhHcgR/IAIFIAMQJ0UNASACQQhqC0EQSQ0AIAAgACgCACICQQFxIAAgAWpBD2pBeHEiASAAa0EBdHI2AgAgASAANgIEIAEgASgCAEEBcSAAIAJBAXZqIAFrIgJBAXRyNgIAQYQgIAEgAkH/////B3FqQQRqQYQgKAIAIABGGyABNgIAIAEQJQsLygIBBX8CQAJAAkAgAEEIIABBCEsbZ0EfcyAAaUEBR2oiAUEESSAAIAF2cg0AIAFBAnRB/B5qKAIAIgJFDQADQCACQXhqIgMoAgBBAXZBeGoiBSAATwRAIAIgBUEIIAVBCEsbZ0Efc0ECdEGAH2oiASgCAEYEQCABIAIoAgQ2AgALDAMLIARBHksNASAEQQFqIQQgAigCBCICDQALC0EAIQMgAUEgTw0BA0AgAUECdEGAH2ooAgAiAkUEQCABQR5LIQIgAUEBaiEBIAJFDQEMAwsLIAIgAkF4aiIDKAIAQQF2QXhqIgFBCCABQQhLG2dBH3NBAnRBgB9qIgEoAgBGBEAgASACKAIENgIACwsgAigCACIBBEAgASACKAIENgIECyACKAIEIgEEQCABIAIoAgA2AgALIAMgAygCAEEBcjYCACADIAAQNwsgAwvhCwINfwV+IwBB8ABrIgckACAHIAAoAvDhASIINgJcIAEgAmohDSAIIAAoAoDiAWohDwJAAkAgBUUEQCABIQQMAQsgACgCxOABIRAgACgCwOABIREgACgCvOABIQ4gAEEBNgKM4QFBACEIA0AgCEEDRwRAIAcgCEECdCICaiAAIAJqQazQAWooAgA2AkQgCEEBaiEIDAELC0FsIQwgB0EYaiADIAQQBhADDQEgB0EsaiAHQRhqIAAoAgAQEyAHQTRqIAdBGGogACgCCBATIAdBPGogB0EYaiAAKAIEEBMgDUFgaiESIAEhBEEAIQwDQCAHKAIwIAcoAixBA3RqKQIAIhRCEIinQf8BcSEIIAcoAkAgBygCPEEDdGopAgAiFUIQiKdB/wFxIQsgBygCOCAHKAI0QQN0aikCACIWQiCIpyEJIBVCIIghFyAUQiCIpyECAkAgFkIQiKdB/wFxIgNBAk8EQAJAIAZFIANBGUlyRQRAIAkgB0EYaiADQSAgBygCHGsiCiAKIANLGyIKEAUgAyAKayIDdGohCSAHQRhqEAQaIANFDQEgB0EYaiADEAUgCWohCQwBCyAHQRhqIAMQBSAJaiEJIAdBGGoQBBoLIAcpAkQhGCAHIAk2AkQgByAYNwNIDAELAkAgA0UEQCACBEAgBygCRCEJDAMLIAcoAkghCQwBCwJAAkAgB0EYakEBEAUgCSACRWpqIgNBA0YEQCAHKAJEQX9qIgMgA0VqIQkMAQsgA0ECdCAHaigCRCIJIAlFaiEJIANBAUYNAQsgByAHKAJINgJMCwsgByAHKAJENgJIIAcgCTYCRAsgF6chAyALBEAgB0EYaiALEAUgA2ohAwsgCCALakEUTwRAIAdBGGoQBBoLIAgEQCAHQRhqIAgQBSACaiECCyAHQRhqEAQaIAcgB0EYaiAUQhiIp0H/AXEQCCAUp0H//wNxajYCLCAHIAdBGGogFUIYiKdB/wFxEAggFadB//8DcWo2AjwgB0EYahAEGiAHIAdBGGogFkIYiKdB/wFxEAggFqdB//8DcWo2AjQgByACNgJgIAcoAlwhCiAHIAk2AmggByADNgJkAkACQAJAIAQgAiADaiILaiASSw0AIAIgCmoiEyAPSw0AIA0gBGsgC0Egak8NAQsgByAHKQNoNwMQIAcgBykDYDcDCCAEIA0gB0EIaiAHQdwAaiAPIA4gESAQEB4hCwwBCyACIARqIQggBCAKEAcgAkERTwRAIARBEGohAgNAIAIgCkEQaiIKEAcgAkEQaiICIAhJDQALCyAIIAlrIQIgByATNgJcIAkgCCAOa0sEQCAJIAggEWtLBEBBbCELDAILIBAgAiAOayICaiIKIANqIBBNBEAgCCAKIAMQDxoMAgsgCCAKQQAgAmsQDyEIIAcgAiADaiIDNgJkIAggAmshCCAOIQILIAlBEE8EQCADIAhqIQMDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALDAELAkAgCUEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgCUECdCIDQcAeaigCAGoiAhAXIAIgA0HgHmooAgBrIQIgBygCZCEDDAELIAggAhAMCyADQQlJDQAgAyAIaiEDIAhBCGoiCCACQQhqIgJrQQ9MBEADQCAIIAIQDCACQQhqIQIgCEEIaiIIIANJDQAMAgALAAsDQCAIIAIQByACQRBqIQIgCEEQaiIIIANJDQALCyAHQRhqEAQaIAsgDCALEAMiAhshDCAEIAQgC2ogAhshBCAFQX9qIgUNAAsgDBADDQFBbCEMIAdBGGoQBEECSQ0BQQAhCANAIAhBA0cEQCAAIAhBAnQiAmpBrNABaiACIAdqKAJENgIAIAhBAWohCAwBCwsgBygCXCEIC0G6fyEMIA8gCGsiACANIARrSw0AIAQEfyAEIAggABALIABqBUEACyABayEMCyAHQfAAaiQAIAwLkRcCFn8FfiMAQdABayIHJAAgByAAKALw4QEiCDYCvAEgASACaiESIAggACgCgOIBaiETAkACQCAFRQRAIAEhAwwBCyAAKALE4AEhESAAKALA4AEhFSAAKAK84AEhDyAAQQE2AozhAUEAIQgDQCAIQQNHBEAgByAIQQJ0IgJqIAAgAmpBrNABaigCADYCVCAIQQFqIQgMAQsLIAcgETYCZCAHIA82AmAgByABIA9rNgJoQWwhECAHQShqIAMgBBAGEAMNASAFQQQgBUEESBshFyAHQTxqIAdBKGogACgCABATIAdBxABqIAdBKGogACgCCBATIAdBzABqIAdBKGogACgCBBATQQAhBCAHQeAAaiEMIAdB5ABqIQoDQCAHQShqEARBAksgBCAXTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEJIAcoAkggBygCREEDdGopAgAiH0IgiKchCCAeQiCIISAgHUIgiKchAgJAIB9CEIinQf8BcSIDQQJPBEACQCAGRSADQRlJckUEQCAIIAdBKGogA0EgIAcoAixrIg0gDSADSxsiDRAFIAMgDWsiA3RqIQggB0EoahAEGiADRQ0BIAdBKGogAxAFIAhqIQgMAQsgB0EoaiADEAUgCGohCCAHQShqEAQaCyAHKQJUISEgByAINgJUIAcgITcDWAwBCwJAIANFBEAgAgRAIAcoAlQhCAwDCyAHKAJYIQgMAQsCQAJAIAdBKGpBARAFIAggAkVqaiIDQQNGBEAgBygCVEF/aiIDIANFaiEIDAELIANBAnQgB2ooAlQiCCAIRWohCCADQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAg2AlQLICCnIQMgCQRAIAdBKGogCRAFIANqIQMLIAkgC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgAmohAgsgB0EoahAEGiAHIAcoAmggAmoiCSADajYCaCAKIAwgCCAJSxsoAgAhDSAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogB0EoaiAfQhiIp0H/AXEQCCEOIAdB8ABqIARBBHRqIgsgCSANaiAIazYCDCALIAg2AgggCyADNgIEIAsgAjYCACAHIA4gH6dB//8DcWo2AkQgBEEBaiEEDAELCyAEIBdIDQEgEkFgaiEYIAdB4ABqIRogB0HkAGohGyABIQMDQCAHQShqEARBAksgBCAFTnJFBEAgBygCQCAHKAI8QQN0aikCACIdQhCIp0H/AXEhCyAHKAJQIAcoAkxBA3RqKQIAIh5CEIinQf8BcSEIIAcoAkggBygCREEDdGopAgAiH0IgiKchCSAeQiCIISAgHUIgiKchDAJAIB9CEIinQf8BcSICQQJPBEACQCAGRSACQRlJckUEQCAJIAdBKGogAkEgIAcoAixrIgogCiACSxsiChAFIAIgCmsiAnRqIQkgB0EoahAEGiACRQ0BIAdBKGogAhAFIAlqIQkMAQsgB0EoaiACEAUgCWohCSAHQShqEAQaCyAHKQJUISEgByAJNgJUIAcgITcDWAwBCwJAIAJFBEAgDARAIAcoAlQhCQwDCyAHKAJYIQkMAQsCQAJAIAdBKGpBARAFIAkgDEVqaiICQQNGBEAgBygCVEF/aiICIAJFaiEJDAELIAJBAnQgB2ooAlQiCSAJRWohCSACQQFGDQELIAcgBygCWDYCXAsLIAcgBygCVDYCWCAHIAk2AlQLICCnIRQgCARAIAdBKGogCBAFIBRqIRQLIAggC2pBFE8EQCAHQShqEAQaCyALBEAgB0EoaiALEAUgDGohDAsgB0EoahAEGiAHIAcoAmggDGoiGSAUajYCaCAbIBogCSAZSxsoAgAhHCAHIAdBKGogHUIYiKdB/wFxEAggHadB//8DcWo2AjwgByAHQShqIB5CGIinQf8BcRAIIB6nQf//A3FqNgJMIAdBKGoQBBogByAHQShqIB9CGIinQf8BcRAIIB+nQf//A3FqNgJEIAcgB0HwAGogBEEDcUEEdGoiDSkDCCIdNwPIASAHIA0pAwAiHjcDwAECQAJAAkAgBygCvAEiDiAepyICaiIWIBNLDQAgAyAHKALEASIKIAJqIgtqIBhLDQAgEiADayALQSBqTw0BCyAHIAcpA8gBNwMQIAcgBykDwAE3AwggAyASIAdBCGogB0G8AWogEyAPIBUgERAeIQsMAQsgAiADaiEIIAMgDhAHIAJBEU8EQCADQRBqIQIDQCACIA5BEGoiDhAHIAJBEGoiAiAISQ0ACwsgCCAdpyIOayECIAcgFjYCvAEgDiAIIA9rSwRAIA4gCCAVa0sEQEFsIQsMAgsgESACIA9rIgJqIhYgCmogEU0EQCAIIBYgChAPGgwCCyAIIBZBACACaxAPIQggByACIApqIgo2AsQBIAggAmshCCAPIQILIA5BEE8EQCAIIApqIQoDQCAIIAIQByACQRBqIQIgCEEQaiIIIApJDQALDAELAkAgDkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgDkECdCIKQcAeaigCAGoiAhAXIAIgCkHgHmooAgBrIQIgBygCxAEhCgwBCyAIIAIQDAsgCkEJSQ0AIAggCmohCiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAKSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAKSQ0ACwsgCxADBEAgCyEQDAQFIA0gDDYCACANIBkgHGogCWs2AgwgDSAJNgIIIA0gFDYCBCAEQQFqIQQgAyALaiEDDAILAAsLIAQgBUgNASAEIBdrIQtBACEEA0AgCyAFSARAIAcgB0HwAGogC0EDcUEEdGoiAikDCCIdNwPIASAHIAIpAwAiHjcDwAECQAJAAkAgBygCvAEiDCAepyICaiIKIBNLDQAgAyAHKALEASIJIAJqIhBqIBhLDQAgEiADayAQQSBqTw0BCyAHIAcpA8gBNwMgIAcgBykDwAE3AxggAyASIAdBGGogB0G8AWogEyAPIBUgERAeIRAMAQsgAiADaiEIIAMgDBAHIAJBEU8EQCADQRBqIQIDQCACIAxBEGoiDBAHIAJBEGoiAiAISQ0ACwsgCCAdpyIGayECIAcgCjYCvAEgBiAIIA9rSwRAIAYgCCAVa0sEQEFsIRAMAgsgESACIA9rIgJqIgwgCWogEU0EQCAIIAwgCRAPGgwCCyAIIAxBACACaxAPIQggByACIAlqIgk2AsQBIAggAmshCCAPIQILIAZBEE8EQCAIIAlqIQYDQCAIIAIQByACQRBqIQIgCEEQaiIIIAZJDQALDAELAkAgBkEHTQRAIAggAi0AADoAACAIIAItAAE6AAEgCCACLQACOgACIAggAi0AAzoAAyAIQQRqIAIgBkECdCIGQcAeaigCAGoiAhAXIAIgBkHgHmooAgBrIQIgBygCxAEhCQwBCyAIIAIQDAsgCUEJSQ0AIAggCWohBiAIQQhqIgggAkEIaiICa0EPTARAA0AgCCACEAwgAkEIaiECIAhBCGoiCCAGSQ0ADAIACwALA0AgCCACEAcgAkEQaiECIAhBEGoiCCAGSQ0ACwsgEBADDQMgC0EBaiELIAMgEGohAwwBCwsDQCAEQQNHBEAgACAEQQJ0IgJqQazQAWogAiAHaigCVDYCACAEQQFqIQQMAQsLIAcoArwBIQgLQbp/IRAgEyAIayIAIBIgA2tLDQAgAwR/IAMgCCAAEAsgAGoFQQALIAFrIRALIAdB0AFqJAAgEAslACAAQgA3AgAgAEEAOwEIIABBADoACyAAIAE2AgwgACACOgAKC7QFAQN/IwBBMGsiBCQAIABB/wFqIgVBfWohBgJAIAMvAQIEQCAEQRhqIAEgAhAGIgIQAw0BIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahASOgAAIAMgBEEIaiAEQRhqEBI6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0FIAEgBEEQaiAEQRhqEBI6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBSABIARBCGogBEEYahASOgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEjoAACABIAJqIABrIQIMAwsgAyAEQRBqIARBGGoQEjoAAiADIARBCGogBEEYahASOgADIANBBGohAwwAAAsACyAEQRhqIAEgAhAGIgIQAw0AIARBEGogBEEYaiADEBwgBEEIaiAEQRhqIAMQHCAAIQMDQAJAIARBGGoQBCADIAZPckUEQCADIARBEGogBEEYahAROgAAIAMgBEEIaiAEQRhqEBE6AAEgBEEYahAERQ0BIANBAmohAwsgBUF+aiEFAn8DQEG6fyECIAMiASAFSw0EIAEgBEEQaiAEQRhqEBE6AAAgAUEBaiEDIARBGGoQBEEDRgRAQQIhAiAEQQhqDAILIAMgBUsNBCABIARBCGogBEEYahAROgABIAFBAmohA0EDIQIgBEEYahAEQQNHDQALIARBEGoLIQUgAyAFIARBGGoQEToAACABIAJqIABrIQIMAgsgAyAEQRBqIARBGGoQEToAAiADIARBCGogBEEYahAROgADIANBBGohAwwAAAsACyAEQTBqJAAgAgtpAQF/An8CQAJAIAJBB00NACABKAAAQbfIwuF+Rw0AIAAgASgABDYCmOIBQWIgAEEQaiABIAIQPiIDEAMNAhogAEKBgICAEDcDiOEBIAAgASADaiACIANrECoMAQsgACABIAIQKgtBAAsLrQMBBn8jAEGAAWsiAyQAQWIhCAJAIAJBCUkNACAAQZjQAGogAUEIaiIEIAJBeGogAEGY0AAQMyIFEAMiBg0AIANBHzYCfCADIANB/ABqIANB+ABqIAQgBCAFaiAGGyIEIAEgAmoiAiAEaxAVIgUQAw0AIAMoAnwiBkEfSw0AIAMoAngiB0EJTw0AIABBiCBqIAMgBkGAC0GADCAHEBggA0E0NgJ8IAMgA0H8AGogA0H4AGogBCAFaiIEIAIgBGsQFSIFEAMNACADKAJ8IgZBNEsNACADKAJ4IgdBCk8NACAAQZAwaiADIAZBgA1B4A4gBxAYIANBIzYCfCADIANB/ABqIANB+ABqIAQgBWoiBCACIARrEBUiBRADDQAgAygCfCIGQSNLDQAgAygCeCIHQQpPDQAgACADIAZBwBBB0BEgBxAYIAQgBWoiBEEMaiIFIAJLDQAgAiAFayEFQQAhAgNAIAJBA0cEQCAEKAAAIgZBf2ogBU8NAiAAIAJBAnRqQZzQAWogBjYCACACQQFqIQIgBEEEaiEEDAELCyAEIAFrIQgLIANBgAFqJAAgCAtGAQN/IABBCGohAyAAKAIEIQJBACEAA0AgACACdkUEQCABIAMgAEEDdGotAAJBFktqIQEgAEEBaiEADAELCyABQQggAmt0C4YDAQV/Qbh/IQcCQCADRQ0AIAItAAAiBEUEQCABQQA2AgBBAUG4fyADQQFGGw8LAn8gAkEBaiIFIARBGHRBGHUiBkF/Sg0AGiAGQX9GBEAgA0EDSA0CIAUvAABBgP4BaiEEIAJBA2oMAQsgA0ECSA0BIAItAAEgBEEIdHJBgIB+aiEEIAJBAmoLIQUgASAENgIAIAVBAWoiASACIANqIgNLDQBBbCEHIABBEGogACAFLQAAIgVBBnZBI0EJIAEgAyABa0HAEEHQEUHwEiAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBmCBqIABBCGogBUEEdkEDcUEfQQggASABIAZqIAgbIgEgAyABa0GAC0GADEGAFyAAKAKM4QEgACgCnOIBIAQQHyIGEAMiCA0AIABBoDBqIABBBGogBUECdkEDcUE0QQkgASABIAZqIAgbIgEgAyABa0GADUHgDkGQGSAAKAKM4QEgACgCnOIBIAQQHyIAEAMNACAAIAFqIAJrIQcLIAcLrQMBCn8jAEGABGsiCCQAAn9BUiACQf8BSw0AGkFUIANBDEsNABogAkEBaiELIABBBGohCUGAgAQgA0F/anRBEHUhCkEAIQJBASEEQQEgA3QiB0F/aiIMIQUDQCACIAtGRQRAAkAgASACQQF0Ig1qLwEAIgZB//8DRgRAIAkgBUECdGogAjoAAiAFQX9qIQVBASEGDAELIARBACAKIAZBEHRBEHVKGyEECyAIIA1qIAY7AQAgAkEBaiECDAELCyAAIAQ7AQIgACADOwEAIAdBA3YgB0EBdmpBA2ohBkEAIQRBACECA0AgBCALRkUEQCABIARBAXRqLgEAIQpBACEAA0AgACAKTkUEQCAJIAJBAnRqIAQ6AAIDQCACIAZqIAxxIgIgBUsNAAsgAEEBaiEADAELCyAEQQFqIQQMAQsLQX8gAg0AGkEAIQIDfyACIAdGBH9BAAUgCCAJIAJBAnRqIgAtAAJBAXRqIgEgAS8BACIBQQFqOwEAIAAgAyABEBRrIgU6AAMgACABIAVB/wFxdCAHazsBACACQQFqIQIMAQsLCyEFIAhBgARqJAAgBQvjBgEIf0FsIQcCQCACQQNJDQACQAJAAkACQCABLQAAIgNBA3EiCUEBaw4DAwEAAgsgACgCiOEBDQBBYg8LIAJBBUkNAkEDIQYgASgAACEFAn8CQAJAIANBAnZBA3EiCEF+aiIEQQFNBEAgBEEBaw0BDAILIAVBDnZB/wdxIQQgBUEEdkH/B3EhAyAIRQwCCyAFQRJ2IQRBBCEGIAVBBHZB//8AcSEDQQAMAQsgBUEEdkH//w9xIgNBgIAISw0DIAEtAARBCnQgBUEWdnIhBEEFIQZBAAshBSAEIAZqIgogAksNAgJAIANBgQZJDQAgACgCnOIBRQ0AQQAhAgNAIAJBg4ABSw0BIAJBQGshAgwAAAsACwJ/IAlBA0YEQCABIAZqIQEgAEHw4gFqIQIgACgCDCEGIAUEQCACIAMgASAEIAYQXwwCCyACIAMgASAEIAYQXQwBCyAAQbjQAWohAiABIAZqIQEgAEHw4gFqIQYgAEGo0ABqIQggBQRAIAggBiADIAEgBCACEF4MAQsgCCAGIAMgASAEIAIQXAsQAw0CIAAgAzYCgOIBIABBATYCiOEBIAAgAEHw4gFqNgLw4QEgCUECRgRAIAAgAEGo0ABqNgIMCyAAIANqIgBBiOMBakIANwAAIABBgOMBakIANwAAIABB+OIBakIANwAAIABB8OIBakIANwAAIAoPCwJ/AkACQAJAIANBAnZBA3FBf2oiBEECSw0AIARBAWsOAgACAQtBASEEIANBA3YMAgtBAiEEIAEvAABBBHYMAQtBAyEEIAEQIUEEdgsiAyAEaiIFQSBqIAJLBEAgBSACSw0CIABB8OIBaiABIARqIAMQCyEBIAAgAzYCgOIBIAAgATYC8OEBIAEgA2oiAEIANwAYIABCADcAECAAQgA3AAggAEIANwAAIAUPCyAAIAM2AoDiASAAIAEgBGo2AvDhASAFDwsCfwJAAkACQCADQQJ2QQNxQX9qIgRBAksNACAEQQFrDgIAAgELQQEhByADQQN2DAILQQIhByABLwAAQQR2DAELIAJBBEkgARAhIgJBj4CAAUtyDQFBAyEHIAJBBHYLIQIgAEHw4gFqIAEgB2otAAAgAkEgahAQIQEgACACNgKA4gEgACABNgLw4QEgB0EBaiEHCyAHC0sAIABC+erQ0OfJoeThADcDICAAQgA3AxggAELP1tO+0ser2UI3AxAgAELW64Lu6v2J9eAANwMIIABCADcDACAAQShqQQBBKBAQGgviAgICfwV+IABBKGoiASAAKAJIaiECAn4gACkDACIDQiBaBEAgACkDECIEQgeJIAApAwgiBUIBiXwgACkDGCIGQgyJfCAAKQMgIgdCEol8IAUQGSAEEBkgBhAZIAcQGQwBCyAAKQMYQsXP2bLx5brqJ3wLIAN8IQMDQCABQQhqIgAgAk0EQEIAIAEpAAAQCSADhUIbiUKHla+vmLbem55/fkLj3MqV/M7y9YV/fCEDIAAhAQwBCwsCQCABQQRqIgAgAksEQCABIQAMAQsgASgAAK1Ch5Wvr5i23puef34gA4VCF4lCz9bTvtLHq9lCfkL5893xmfaZqxZ8IQMLA0AgACACSQRAIAAxAABCxc/ZsvHluuonfiADhUILiUKHla+vmLbem55/fiEDIABBAWohAAwBCwsgA0IhiCADhULP1tO+0ser2UJ+IgNCHYggA4VC+fPd8Zn2masWfiIDQiCIIAOFC+8CAgJ/BH4gACAAKQMAIAKtfDcDAAJAAkAgACgCSCIDIAJqIgRBH00EQCABRQ0BIAAgA2pBKGogASACECAgACgCSCACaiEEDAELIAEgAmohAgJ/IAMEQCAAQShqIgQgA2ogAUEgIANrECAgACAAKQMIIAQpAAAQCTcDCCAAIAApAxAgACkAMBAJNwMQIAAgACkDGCAAKQA4EAk3AxggACAAKQMgIABBQGspAAAQCTcDICAAKAJIIQMgAEEANgJIIAEgA2tBIGohAQsgAUEgaiACTQsEQCACQWBqIQMgACkDICEFIAApAxghBiAAKQMQIQcgACkDCCEIA0AgCCABKQAAEAkhCCAHIAEpAAgQCSEHIAYgASkAEBAJIQYgBSABKQAYEAkhBSABQSBqIgEgA00NAAsgACAFNwMgIAAgBjcDGCAAIAc3AxAgACAINwMICyABIAJPDQEgAEEoaiABIAIgAWsiBBAgCyAAIAQ2AkgLCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQEBogAwVBun8LCy8BAX8gAEUEQEG2f0EAIAMbDwtBun8hBCADIAFNBH8gACACIAMQCxogAwVBun8LC6gCAQZ/IwBBEGsiByQAIABB2OABaikDAEKAgIAQViEIQbh/IQUCQCAEQf//B0sNACAAIAMgBBBCIgUQAyIGDQAgACgCnOIBIQkgACAHQQxqIAMgAyAFaiAGGyIKIARBACAFIAYbayIGEEAiAxADBEAgAyEFDAELIAcoAgwhBCABRQRAQbp/IQUgBEEASg0BCyAGIANrIQUgAyAKaiEDAkAgCQRAIABBADYCnOIBDAELAkACQAJAIARBBUgNACAAQdjgAWopAwBCgICACFgNAAwBCyAAQQA2ApziAQwBCyAAKAIIED8hBiAAQQA2ApziASAGQRRPDQELIAAgASACIAMgBSAEIAgQOSEFDAELIAAgASACIAMgBSAEIAgQOiEFCyAHQRBqJAAgBQtnACAAQdDgAWogASACIAAoAuzhARAuIgEQAwRAIAEPC0G4fyECAkAgAQ0AIABB7OABaigCACIBBEBBYCECIAAoApjiASABRw0BC0EAIQIgAEHw4AFqKAIARQ0AIABBkOEBahBDCyACCycBAX8QVyIERQRAQUAPCyAEIAAgASACIAMgBBBLEE8hACAEEFYgAAs/AQF/AkACQAJAIAAoAqDiAUEBaiIBQQJLDQAgAUEBaw4CAAECCyAAEDBBAA8LIABBADYCoOIBCyAAKAKU4gELvAMCB38BfiMAQRBrIgkkAEG4fyEGAkAgBCgCACIIQQVBCSAAKALs4QEiBRtJDQAgAygCACIHQQFBBSAFGyAFEC8iBRADBEAgBSEGDAELIAggBUEDakkNACAAIAcgBRBJIgYQAw0AIAEgAmohCiAAQZDhAWohCyAIIAVrIQIgBSAHaiEHIAEhBQNAIAcgAiAJECwiBhADDQEgAkF9aiICIAZJBEBBuH8hBgwCCyAJKAIAIghBAksEQEFsIQYMAgsgB0EDaiEHAn8CQAJAAkAgCEEBaw4CAgABCyAAIAUgCiAFayAHIAYQSAwCCyAFIAogBWsgByAGEEcMAQsgBSAKIAVrIActAAAgCSgCCBBGCyIIEAMEQCAIIQYMAgsgACgC8OABBEAgCyAFIAgQRQsgAiAGayECIAYgB2ohByAFIAhqIQUgCSgCBEUNAAsgACkD0OABIgxCf1IEQEFsIQYgDCAFIAFrrFINAQsgACgC8OABBEBBaiEGIAJBBEkNASALEEQhDCAHKAAAIAynRw0BIAdBBGohByACQXxqIQILIAMgBzYCACAEIAI2AgAgBSABayEGCyAJQRBqJAAgBgsuACAAECsCf0EAQQAQAw0AGiABRSACRXJFBEBBYiAAIAEgAhA9EAMNARoLQQALCzcAIAEEQCAAIAAoAsTgASABKAIEIAEoAghqRzYCnOIBCyAAECtBABADIAFFckUEQCAAIAEQWwsL0QIBB38jAEEQayIGJAAgBiAENgIIIAYgAzYCDCAFBEAgBSgCBCEKIAUoAgghCQsgASEIAkACQANAIAAoAuzhARAWIQsCQANAIAQgC0kNASADKAAAQXBxQdDUtMIBRgRAIAMgBBAiIgcQAw0EIAQgB2shBCADIAdqIQMMAQsLIAYgAzYCDCAGIAQ2AggCQCAFBEAgACAFEE5BACEHQQAQA0UNAQwFCyAAIAogCRBNIgcQAw0ECyAAIAgQUCAMQQFHQQAgACAIIAIgBkEMaiAGQQhqEEwiByIDa0EAIAMQAxtBCkdyRQRAQbh/IQcMBAsgBxADDQMgAiAHayECIAcgCGohCEEBIQwgBigCDCEDIAYoAgghBAwBCwsgBiADNgIMIAYgBDYCCEG4fyEHIAQNASAIIAFrIQcMAQsgBiADNgIMIAYgBDYCCAsgBkEQaiQAIAcLRgECfyABIAAoArjgASICRwRAIAAgAjYCxOABIAAgATYCuOABIAAoArzgASEDIAAgATYCvOABIAAgASADIAJrajYCwOABCwutAgIEfwF+IwBBQGoiBCQAAkACQCACQQhJDQAgASgAAEFwcUHQ1LTCAUcNACABIAIQIiEBIABCADcDCCAAQQA2AgQgACABNgIADAELIARBGGogASACEC0iAxADBEAgACADEBoMAQsgAwRAIABBuH8QGgwBCyACIAQoAjAiA2shAiABIANqIQMDQAJAIAAgAyACIARBCGoQLCIFEAMEfyAFBSACIAVBA2oiBU8NAUG4fwsQGgwCCyAGQQFqIQYgAiAFayECIAMgBWohAyAEKAIMRQ0ACyAEKAI4BEAgAkEDTQRAIABBuH8QGgwCCyADQQRqIQMLIAQoAighAiAEKQMYIQcgAEEANgIEIAAgAyABazYCACAAIAIgBmytIAcgB0J/URs3AwgLIARBQGskAAslAQF/IwBBEGsiAiQAIAIgACABEFEgAigCACEAIAJBEGokACAAC30BBH8jAEGQBGsiBCQAIARB/wE2AggCQCAEQRBqIARBCGogBEEMaiABIAIQFSIGEAMEQCAGIQUMAQtBVCEFIAQoAgwiB0EGSw0AIAMgBEEQaiAEKAIIIAcQQSIFEAMNACAAIAEgBmogAiAGayADEDwhBQsgBEGQBGokACAFC4cBAgJ/An5BABAWIQMCQANAIAEgA08EQAJAIAAoAABBcHFB0NS0wgFGBEAgACABECIiAhADRQ0BQn4PCyAAIAEQVSIEQn1WDQMgBCAFfCIFIARUIQJCfiEEIAINAyAAIAEQUiICEAMNAwsgASACayEBIAAgAmohAAwBCwtCfiAFIAEbIQQLIAQLPwIBfwF+IwBBMGsiAiQAAn5CfiACQQhqIAAgARAtDQAaQgAgAigCHEEBRg0AGiACKQMICyEDIAJBMGokACADC40BAQJ/IwBBMGsiASQAAkAgAEUNACAAKAKI4gENACABIABB/OEBaigCADYCKCABIAApAvThATcDICAAEDAgACgCqOIBIQIgASABKAIoNgIYIAEgASkDIDcDECACIAFBEGoQGyAAQQA2AqjiASABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALKgECfyMAQRBrIgAkACAAQQA2AgggAEIANwMAIAAQWCEBIABBEGokACABC4cBAQN/IwBBEGsiAiQAAkAgACgCAEUgACgCBEVzDQAgAiAAKAIINgIIIAIgACkCADcDAAJ/IAIoAgAiAQRAIAIoAghBqOMJIAERBQAMAQtBqOMJECgLIgFFDQAgASAAKQIANwL04QEgAUH84QFqIAAoAgg2AgAgARBZIAEhAwsgAkEQaiQAIAMLywEBAn8jAEEgayIBJAAgAEGBgIDAADYCtOIBIABBADYCiOIBIABBADYC7OEBIABCADcDkOIBIABBADYCpOMJIABBADYC3OIBIABCADcCzOIBIABBADYCvOIBIABBADYCxOABIABCADcCnOIBIABBpOIBakIANwIAIABBrOIBakEANgIAIAFCADcCECABQgA3AhggASABKQMYNwMIIAEgASkDEDcDACABKAIIQQh2QQFxIQIgAEEANgLg4gEgACACNgKM4gEgAUEgaiQAC3YBA38jAEEwayIBJAAgAARAIAEgAEHE0AFqIgIoAgA2AiggASAAKQK80AE3AyAgACgCACEDIAEgAigCADYCGCABIAApArzQATcDECADIAFBEGoQGyABIAEoAig2AgggASABKQMgNwMAIAAgARAbCyABQTBqJAALzAEBAX8gACABKAK00AE2ApjiASAAIAEoAgQiAjYCwOABIAAgAjYCvOABIAAgAiABKAIIaiICNgK44AEgACACNgLE4AEgASgCuNABBEAgAEKBgICAEDcDiOEBIAAgAUGk0ABqNgIMIAAgAUGUIGo2AgggACABQZwwajYCBCAAIAFBDGo2AgAgAEGs0AFqIAFBqNABaigCADYCACAAQbDQAWogAUGs0AFqKAIANgIAIABBtNABaiABQbDQAWooAgA2AgAPCyAAQgA3A4jhAQs7ACACRQRAQbp/DwsgBEUEQEFsDwsgAiAEEGAEQCAAIAEgAiADIAQgBRBhDwsgACABIAIgAyAEIAUQZQtGAQF/IwBBEGsiBSQAIAVBCGogBBAOAn8gBS0ACQRAIAAgASACIAMgBBAyDAELIAAgASACIAMgBBA0CyEAIAVBEGokACAACzQAIAAgAyAEIAUQNiIFEAMEQCAFDwsgBSAESQR/IAEgAiADIAVqIAQgBWsgABA1BUG4fwsLRgEBfyMAQRBrIgUkACAFQQhqIAQQDgJ/IAUtAAkEQCAAIAEgAiADIAQQYgwBCyAAIAEgAiADIAQQNQshACAFQRBqJAAgAAtZAQF/QQ8hAiABIABJBEAgAUEEdCAAbiECCyAAQQh2IgEgAkEYbCIAQYwIaigCAGwgAEGICGooAgBqIgJBA3YgAmogAEGACGooAgAgAEGECGooAgAgAWxqSQs3ACAAIAMgBCAFQYAQEDMiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQMgVBuH8LC78DAQN/IwBBIGsiBSQAIAVBCGogAiADEAYiAhADRQRAIAAgAWoiB0F9aiEGIAUgBBAOIARBBGohAiAFLQACIQMDQEEAIAAgBkkgBUEIahAEGwRAIAAgAiAFQQhqIAMQAkECdGoiBC8BADsAACAFQQhqIAQtAAIQASAAIAQtAANqIgQgAiAFQQhqIAMQAkECdGoiAC8BADsAACAFQQhqIAAtAAIQASAEIAAtAANqIQAMAQUgB0F+aiEEA0AgBUEIahAEIAAgBEtyRQRAIAAgAiAFQQhqIAMQAkECdGoiBi8BADsAACAFQQhqIAYtAAIQASAAIAYtAANqIQAMAQsLA0AgACAES0UEQCAAIAIgBUEIaiADEAJBAnRqIgYvAQA7AAAgBUEIaiAGLQACEAEgACAGLQADaiEADAELCwJAIAAgB08NACAAIAIgBUEIaiADEAIiA0ECdGoiAC0AADoAACAALQADQQFGBEAgBUEIaiAALQACEAEMAQsgBSgCDEEfSw0AIAVBCGogAiADQQJ0ai0AAhABIAUoAgxBIUkNACAFQSA2AgwLIAFBbCAFQQhqEAobIQILCwsgBUEgaiQAIAILkgIBBH8jAEFAaiIJJAAgCSADQTQQCyEDAkAgBEECSA0AIAMgBEECdGooAgAhCSADQTxqIAgQIyADQQE6AD8gAyACOgA+QQAhBCADKAI8IQoDQCAEIAlGDQEgACAEQQJ0aiAKNgEAIARBAWohBAwAAAsAC0EAIQkDQCAGIAlGRQRAIAMgBSAJQQF0aiIKLQABIgtBAnRqIgwoAgAhBCADQTxqIAotAABBCHQgCGpB//8DcRAjIANBAjoAPyADIAcgC2siCiACajoAPiAEQQEgASAKa3RqIQogAygCPCELA0AgACAEQQJ0aiALNgEAIARBAWoiBCAKSQ0ACyAMIAo2AgAgCUEBaiEJDAELCyADQUBrJAALowIBCX8jAEHQAGsiCSQAIAlBEGogBUE0EAsaIAcgBmshDyAHIAFrIRADQAJAIAMgCkcEQEEBIAEgByACIApBAXRqIgYtAAEiDGsiCGsiC3QhDSAGLQAAIQ4gCUEQaiAMQQJ0aiIMKAIAIQYgCyAPTwRAIAAgBkECdGogCyAIIAUgCEE0bGogCCAQaiIIQQEgCEEBShsiCCACIAQgCEECdGooAgAiCEEBdGogAyAIayAHIA4QYyAGIA1qIQgMAgsgCUEMaiAOECMgCUEBOgAPIAkgCDoADiAGIA1qIQggCSgCDCELA0AgBiAITw0CIAAgBkECdGogCzYBACAGQQFqIQYMAAALAAsgCUHQAGokAA8LIAwgCDYCACAKQQFqIQoMAAALAAs0ACAAIAMgBCAFEDYiBRADBEAgBQ8LIAUgBEkEfyABIAIgAyAFaiAEIAVrIAAQNAVBuH8LCyMAIAA/AEEQdGtB//8DakEQdkAAQX9GBEBBAA8LQQAQAEEBCzsBAX8gAgRAA0AgACABIAJBgCAgAkGAIEkbIgMQCyEAIAFBgCBqIQEgAEGAIGohACACIANrIgINAAsLCwYAIAAQAwsLqBUJAEGICAsNAQAAAAEAAAACAAAAAgBBoAgLswYBAAAAAQAAAAIAAAACAAAAJgAAAIIAAAAhBQAASgAAAGcIAAAmAAAAwAEAAIAAAABJBQAASgAAAL4IAAApAAAALAIAAIAAAABJBQAASgAAAL4IAAAvAAAAygIAAIAAAACKBQAASgAAAIQJAAA1AAAAcwMAAIAAAACdBQAASgAAAKAJAAA9AAAAgQMAAIAAAADrBQAASwAAAD4KAABEAAAAngMAAIAAAABNBgAASwAAAKoKAABLAAAAswMAAIAAAADBBgAATQAAAB8NAABNAAAAUwQAAIAAAAAjCAAAUQAAAKYPAABUAAAAmQQAAIAAAABLCQAAVwAAALESAABYAAAA2gQAAIAAAABvCQAAXQAAACMUAABUAAAARQUAAIAAAABUCgAAagAAAIwUAABqAAAArwUAAIAAAAB2CQAAfAAAAE4QAAB8AAAA0gIAAIAAAABjBwAAkQAAAJAHAACSAAAAAAAAAAEAAAABAAAABQAAAA0AAAAdAAAAPQAAAH0AAAD9AAAA/QEAAP0DAAD9BwAA/Q8AAP0fAAD9PwAA/X8AAP3/AAD9/wEA/f8DAP3/BwD9/w8A/f8fAP3/PwD9/38A/f//AP3//wH9//8D/f//B/3//w/9//8f/f//P/3//38AAAAAAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAkAAAAKAAAACwAAAAwAAAANAAAADgAAAA8AAAAQAAAAEQAAABIAAAATAAAAFAAAABUAAAAWAAAAFwAAABgAAAAZAAAAGgAAABsAAAAcAAAAHQAAAB4AAAAfAAAAIAAAACEAAAAiAAAAIwAAACUAAAAnAAAAKQAAACsAAAAvAAAAMwAAADsAAABDAAAAUwAAAGMAAACDAAAAAwEAAAMCAAADBAAAAwgAAAMQAAADIAAAA0AAAAOAAAADAAEAQeAPC1EBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAEAAAABQAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAQcQQC4sBAQAAAAIAAAADAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABIAAAAUAAAAFgAAABgAAAAcAAAAIAAAACgAAAAwAAAAQAAAAIAAAAAAAQAAAAIAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAAAAQBBkBIL5gQBAAAAAQAAAAEAAAABAAAAAgAAAAIAAAADAAAAAwAAAAQAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAAAEAAAAEAAAACAAAAAAAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBgBcLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBkBkLhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBpB0L2QEBAAAAAwAAAAcAAAAPAAAAHwAAAD8AAAB/AAAA/wAAAP8BAAD/AwAA/wcAAP8PAAD/HwAA/z8AAP9/AAD//wAA//8BAP//AwD//wcA//8PAP//HwD//z8A//9/AP///wD///8B////A////wf///8P////H////z////9/AAAAAAEAAAACAAAABAAAAAAAAAACAAAABAAAAAgAAAAAAAAAAQAAAAIAAAABAAAABAAAAAQAAAAEAAAABAAAAAgAAAAIAAAACAAAAAcAAAAIAAAACQAAAAoAAAALAEGgIAsDwBBQ",
  ES = new WeakMap();
let SS,
  CS = 0;
class MS extends pl {
  constructor(e) {
    super(e),
      (this.transcoderPath = ""),
      (this.transcoderBinary = null),
      (this.transcoderPending = null),
      (this.workerPool = new lS()),
      (this.workerSourceURL = ""),
      (this.workerConfig = null),
      "undefined" != typeof MSC_TRANSCODER &&
        console.warn(
          'THREE.KTX2Loader: Please update to latest "basis_transcoder". "msc_basis_transcoder" is no longer supported in three.js r125+.'
        );
  }
  setTranscoderPath(e) {
    return (this.transcoderPath = e), this;
  }
  setWorkerLimit(e) {
    return this.workerPool.setWorkerLimit(e), this;
  }
  detectSupport(e) {
    return (
      !0 === e.isWebGPURenderer
        ? (this.workerConfig = {
            astcSupported: e.hasFeature("texture-compression-astc"),
            etc1Supported: !1,
            etc2Supported: e.hasFeature("texture-compression-etc2"),
            dxtSupported: e.hasFeature("texture-compression-bc"),
            bptcSupported: !1,
            pvrtcSupported: !1,
          })
        : ((this.workerConfig = {
            astcSupported: e.extensions.has("WEBGL_compressed_texture_astc"),
            etc1Supported: e.extensions.has("WEBGL_compressed_texture_etc1"),
            etc2Supported: e.extensions.has("WEBGL_compressed_texture_etc"),
            dxtSupported: e.extensions.has("WEBGL_compressed_texture_s3tc"),
            bptcSupported: e.extensions.has("EXT_texture_compression_bptc"),
            pvrtcSupported:
              e.extensions.has("WEBGL_compressed_texture_pvrtc") ||
              e.extensions.has("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          }),
          e.capabilities.isWebGL2 && (this.workerConfig.etc1Supported = !1)),
      this
    );
  }
  init() {
    if (!this.transcoderPending) {
      const e = new gl(this.manager);
      e.setPath(this.transcoderPath),
        e.setWithCredentials(this.withCredentials);
      const t = e.loadAsync("basis_transcoder.js"),
        i = new gl(this.manager);
      i.setPath(this.transcoderPath),
        i.setResponseType("arraybuffer"),
        i.setWithCredentials(this.withCredentials);
      const n = i.loadAsync("basis_transcoder.wasm");
      (this.transcoderPending = Promise.all([t, n]).then(([e, t]) => {
        const i = MS.BasisWorker.toString(),
          n = [
            "/* constants */",
            "let _EngineFormat = " + JSON.stringify(MS.EngineFormat),
            "let _TranscoderFormat = " + JSON.stringify(MS.TranscoderFormat),
            "let _BasisFormat = " + JSON.stringify(MS.BasisFormat),
            "/* basis_transcoder.js */",
            e,
            "/* worker */",
            i.substring(i.indexOf("{") + 1, i.lastIndexOf("}")),
          ].join("\n");
        (this.workerSourceURL = URL.createObjectURL(new Blob([n]))),
          (this.transcoderBinary = t),
          this.workerPool.setWorkerCreator(() => {
            const e = new Worker(this.workerSourceURL),
              t = this.transcoderBinary.slice(0);
            return (
              e.postMessage(
                {
                  type: "init",
                  config: this.workerConfig,
                  transcoderBinary: t,
                },
                [t]
              ),
              e
            );
          });
      })),
        CS > 0 &&
          console.warn(
            "THREE.KTX2Loader: Multiple active KTX2 loaders may cause performance issues. Use a single KTX2Loader instance, or call .dispose() on old instances."
          ),
        CS++;
    }
    return this.transcoderPending;
  }
  load(e, t, i, n) {
    if (null === this.workerConfig)
      throw new Error(
        "THREE.KTX2Loader: Missing initialization with `.detectSupport( renderer )`."
      );
    const s = new gl(this.manager);
    s.setResponseType("arraybuffer"),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (e) => {
          if (ES.has(e)) {
            return ES.get(e).promise.then(t).catch(n);
          }
          this._createTexture(e)
            .then((e) => (t ? t(e) : null))
            .catch(n);
        },
        i,
        n
      );
  }
  _createTextureFrom(e, t) {
    const {
      faces: i,
      width: n,
      height: s,
      format: r,
      type: a,
      error: o,
      dfdFlags: l,
    } = e;
    if ("error" === a) return Promise.reject(o);
    let h;
    if (6 === t.faceCount) h = new bo(i, r, B);
    else {
      const e = i[0].mipmaps;
      h =
        t.layerCount > 1
          ? new xo(e, n, s, t.layerCount, r, B)
          : new yo(e, n, s, r, B);
    }
    return (
      (h.minFilter = 1 === i[0].mipmaps.length ? L : N),
      (h.magFilter = L),
      (h.generateMipmaps = !1),
      (h.needsUpdate = !0),
      (h.colorSpace = RS(t)),
      (h.premultiplyAlpha = !!(1 & l)),
      h
    );
  }
  async _createTexture(e, t = {}) {
    const i = (function (e) {
      const t = new Uint8Array(e.buffer, e.byteOffset, mS.length);
      if (
        t[0] !== mS[0] ||
        t[1] !== mS[1] ||
        t[2] !== mS[2] ||
        t[3] !== mS[3] ||
        t[4] !== mS[4] ||
        t[5] !== mS[5] ||
        t[6] !== mS[6] ||
        t[7] !== mS[7] ||
        t[8] !== mS[8] ||
        t[9] !== mS[9] ||
        t[10] !== mS[10] ||
        t[11] !== mS[11]
      )
        throw new Error("Missing KTX 2.0 identifier.");
      const i = new pS(),
        n = 17 * Uint32Array.BYTES_PER_ELEMENT,
        s = new fS(e, mS.length, n, !0);
      (i.vkFormat = s._nextUint32()),
        (i.typeSize = s._nextUint32()),
        (i.pixelWidth = s._nextUint32()),
        (i.pixelHeight = s._nextUint32()),
        (i.pixelDepth = s._nextUint32()),
        (i.layerCount = s._nextUint32()),
        (i.faceCount = s._nextUint32());
      const r = s._nextUint32();
      i.supercompressionScheme = s._nextUint32();
      const a = s._nextUint32(),
        o = s._nextUint32(),
        l = s._nextUint32(),
        h = s._nextUint32(),
        c = s._nextUint64(),
        u = s._nextUint64(),
        d = new fS(e, mS.length + n, 3 * r * 8, !0);
      for (let L = 0; L < r; L++)
        i.levels.push({
          levelData: new Uint8Array(
            e.buffer,
            e.byteOffset + d._nextUint64(),
            d._nextUint64()
          ),
          uncompressedByteLength: d._nextUint64(),
        });
      const p = new fS(e, a, o, !0),
        f = {
          vendorId: p._skip(4)._nextUint16(),
          descriptorType: p._nextUint16(),
          versionNumber: p._nextUint16(),
          descriptorBlockSize: p._nextUint16(),
          colorModel: p._nextUint8(),
          colorPrimaries: p._nextUint8(),
          transferFunction: p._nextUint8(),
          flags: p._nextUint8(),
          texelBlockDimension: [
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
          ],
          bytesPlane: [
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
          ],
          samples: [],
        },
        m = (f.descriptorBlockSize / 4 - 6) / 4;
      for (let L = 0; L < m; L++) {
        const e = {
          bitOffset: p._nextUint16(),
          bitLength: p._nextUint8(),
          channelType: p._nextUint8(),
          samplePosition: [
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
            p._nextUint8(),
          ],
          sampleLower: -1 / 0,
          sampleUpper: 1 / 0,
        };
        64 & e.channelType
          ? ((e.sampleLower = p._nextInt32()), (e.sampleUpper = p._nextInt32()))
          : ((e.sampleLower = p._nextUint32()),
            (e.sampleUpper = p._nextUint32())),
          (f.samples[L] = e);
      }
      (i.dataFormatDescriptor.length = 0), i.dataFormatDescriptor.push(f);
      const g = new fS(e, l, h, !0);
      for (; g._offset < h; ) {
        const e = g._nextUint32(),
          t = g._scan(e),
          n = gS(t),
          s = g._scan(e - t.byteLength);
        (i.keyValue[n] = n.match(/^ktx/i) ? gS(s) : s),
          g._offset % 4 && g._skip(4 - (g._offset % 4));
      }
      if (u <= 0) return i;
      const _ = new fS(e, c, u, !0),
        v = _._nextUint16(),
        A = _._nextUint16(),
        y = _._nextUint32(),
        x = _._nextUint32(),
        b = _._nextUint32(),
        E = _._nextUint32(),
        S = [];
      for (let L = 0; L < r; L++)
        S.push({
          imageFlags: _._nextUint32(),
          rgbSliceByteOffset: _._nextUint32(),
          rgbSliceByteLength: _._nextUint32(),
          alphaSliceByteOffset: _._nextUint32(),
          alphaSliceByteLength: _._nextUint32(),
        });
      const C = c + _._offset,
        M = C + y,
        w = M + x,
        T = w + b,
        I = new Uint8Array(e.buffer, e.byteOffset + C, y),
        R = new Uint8Array(e.buffer, e.byteOffset + M, x),
        P = new Uint8Array(e.buffer, e.byteOffset + w, b),
        D = new Uint8Array(e.buffer, e.byteOffset + T, E);
      return (
        (i.globalData = {
          endpointCount: v,
          selectorCount: A,
          imageDescs: S,
          endpointsData: I,
          selectorsData: R,
          tablesData: P,
          extendedData: D,
        }),
        i
      );
    })(new Uint8Array(e));
    if (0 !== i.vkFormat)
      return (async function (e) {
        const { vkFormat: t } = e;
        if (void 0 === TS[t])
          throw new Error("THREE.KTX2Loader: Unsupported vkFormat.");
        let i;
        2 === e.supercompressionScheme &&
          (SS ||
            (SS = new Promise(async (e) => {
              const t = new xS();
              await t.init(), e(t);
            })),
          (i = await SS));
        const n = [];
        for (let r = 0; r < e.levels.length; r++) {
          const s = Math.max(1, e.pixelWidth >> r),
            a = Math.max(1, e.pixelHeight >> r),
            o = e.pixelDepth ? Math.max(1, e.pixelDepth >> r) : 0,
            l = e.levels[r];
          let h, c;
          if (0 === e.supercompressionScheme) h = l.levelData;
          else {
            if (2 !== e.supercompressionScheme)
              throw new Error(
                "THREE.KTX2Loader: Unsupported supercompressionScheme."
              );
            h = i.decode(l.levelData, l.uncompressedByteLength);
          }
          (c =
            IS[t] === z
              ? new Float32Array(
                  h.buffer,
                  h.byteOffset,
                  h.byteLength / Float32Array.BYTES_PER_ELEMENT
                )
              : IS[t] === G
              ? new Uint16Array(
                  h.buffer,
                  h.byteOffset,
                  h.byteLength / Uint16Array.BYTES_PER_ELEMENT
                )
              : h),
            n.push({ data: c, width: s, height: a, depth: o });
        }
        let s;
        if (wS.has(TS[t]))
          s =
            0 === e.pixelDepth
              ? new Va(n, e.pixelWidth, e.pixelHeight)
              : new pt(n, e.pixelWidth, e.pixelHeight, e.pixelDepth);
        else {
          if (e.pixelDepth > 0)
            throw new Error("THREE.KTX2Loader: Unsupported pixelDepth.");
          s = new yo(n, e.pixelWidth, e.pixelHeight);
        }
        return (
          (s.mipmaps = n),
          (s.type = IS[t]),
          (s.format = TS[t]),
          (s.colorSpace = RS(e)),
          (s.needsUpdate = !0),
          Promise.resolve(s)
        );
      })(i);
    const n = t,
      s = this.init()
        .then(() =>
          this.workerPool.postMessage(
            { type: "transcode", buffer: e, taskConfig: n },
            [e]
          )
        )
        .then((e) => this._createTextureFrom(e.data, i));
    return ES.set(e, { promise: s }), s;
  }
  dispose() {
    return (
      this.workerPool.dispose(),
      this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
      CS--,
      this
    );
  }
}
(MS.BasisFormat = { ETC1S: 0, UASTC_4x4: 1 }),
  (MS.TranscoderFormat = {
    ETC1: 0,
    ETC2: 1,
    BC1: 2,
    BC3: 3,
    BC4: 4,
    BC5: 5,
    BC7_M6_OPAQUE_ONLY: 6,
    BC7_M5: 7,
    PVRTC1_4_RGB: 8,
    PVRTC1_4_RGBA: 9,
    ASTC_4x4: 10,
    ATC_RGB: 11,
    ATC_RGBA_INTERPOLATED_ALPHA: 12,
    RGBA32: 13,
    RGB565: 14,
    BGR565: 15,
    RGBA4444: 16,
  }),
  (MS.EngineFormat = {
    RGBAFormat: Q,
    RGBA_ASTC_4x4_Format: ie,
    RGBA_BPTC_Format: se,
    RGBA_ETC2_EAC_Format: te,
    RGBA_PVRTC_4BPPV1_Format: $,
    RGBA_S3TC_DXT5_Format: Z,
    RGB_ETC1_Format: 36196,
    RGB_ETC2_Format: ee,
    RGB_PVRTC_4BPPV1_Format: J,
    RGB_S3TC_DXT1_Format: X,
  }),
  (MS.BasisWorker = function () {
    let e, t, i;
    const n = _EngineFormat,
      s = _TranscoderFormat,
      r = _BasisFormat;
    self.addEventListener("message", function (a) {
      const u = a.data;
      switch (u.type) {
        case "init":
          (e = u.config),
            (d = u.transcoderBinary),
            (t = new Promise((e) => {
              (i = { wasmBinary: d, onRuntimeInitialized: e }), BASIS(i);
            }).then(() => {
              i.initializeBasis(),
                void 0 === i.KTX2File &&
                  console.warn(
                    "THREE.KTX2Loader: Please update Basis Universal transcoder."
                  );
            }));
          break;
        case "transcode":
          t.then(() => {
            try {
              const {
                faces: t,
                buffers: a,
                width: d,
                height: p,
                hasAlpha: f,
                format: m,
                dfdFlags: g,
              } = (function (t) {
                const a = new i.KTX2File(new Uint8Array(t));
                function u() {
                  a.close(), a.delete();
                }
                if (!a.isValid())
                  throw (
                    (u(),
                    new Error(
                      "THREE.KTX2Loader:\tInvalid or unsupported .ktx2 file"
                    ))
                  );
                const d = a.isUASTC() ? r.UASTC_4x4 : r.ETC1S,
                  p = a.getWidth(),
                  f = a.getHeight(),
                  m = a.getLayers() || 1,
                  g = a.getLevels(),
                  _ = a.getFaces(),
                  v = a.getHasAlpha(),
                  A = a.getDFDFlags(),
                  { transcoderFormat: y, engineFormat: x } = (function (
                    t,
                    i,
                    a,
                    c
                  ) {
                    let u, d;
                    const p = t === r.ETC1S ? o : l;
                    for (let n = 0; n < p.length; n++) {
                      const s = p[n];
                      if (
                        e[s.if] &&
                        s.basisFormat.includes(t) &&
                        !(c && s.transcoderFormat.length < 2) &&
                        (!s.needsPowerOfTwo || (h(i) && h(a)))
                      )
                        return (
                          (u = s.transcoderFormat[c ? 1 : 0]),
                          (d = s.engineFormat[c ? 1 : 0]),
                          { transcoderFormat: u, engineFormat: d }
                        );
                    }
                    return (
                      console.warn(
                        "THREE.KTX2Loader: No suitable compressed texture format found. Decoding to RGBA32."
                      ),
                      (u = s.RGBA32),
                      (d = n.RGBAFormat),
                      { transcoderFormat: u, engineFormat: d }
                    );
                  })(d, p, f, v);
                if (!p || !f || !g)
                  throw (u(), new Error("THREE.KTX2Loader:\tInvalid texture"));
                if (!a.startTranscoding())
                  throw (
                    (u(),
                    new Error("THREE.KTX2Loader: .startTranscoding failed"))
                  );
                const b = [],
                  E = [];
                for (let e = 0; e < _; e++) {
                  const t = [];
                  for (let i = 0; i < g; i++) {
                    const n = [];
                    let s, r;
                    for (let t = 0; t < m; t++) {
                      const o = a.getImageLevelInfo(i, t, e);
                      0 !== e ||
                        0 !== i ||
                        0 !== t ||
                        (o.origWidth % 4 == 0 && o.origHeight % 4 == 0) ||
                        console.warn(
                          "THREE.KTX2Loader: ETC1S and UASTC textures should use multiple-of-four dimensions."
                        ),
                        g > 1
                          ? ((s = o.origWidth), (r = o.origHeight))
                          : ((s = o.width), (r = o.height));
                      const l = new Uint8Array(
                        a.getImageTranscodedSizeInBytes(i, t, 0, y)
                      );
                      if (!a.transcodeImage(l, i, t, e, y, 0, -1, -1))
                        throw (
                          (u(),
                          new Error(
                            "THREE.KTX2Loader: .transcodeImage failed."
                          ))
                        );
                      n.push(l);
                    }
                    const o = c(n);
                    t.push({ data: o, width: s, height: r }), E.push(o.buffer);
                  }
                  b.push({ mipmaps: t, width: p, height: f, format: x });
                }
                return (
                  u(),
                  {
                    faces: b,
                    buffers: E,
                    width: p,
                    height: f,
                    hasAlpha: v,
                    format: x,
                    dfdFlags: A,
                  }
                );
              })(u.buffer);
              self.postMessage(
                {
                  type: "transcode",
                  id: u.id,
                  faces: t,
                  width: d,
                  height: p,
                  hasAlpha: f,
                  format: m,
                  dfdFlags: g,
                },
                a
              );
            } catch (t) {
              console.error(t),
                self.postMessage({ type: "error", id: u.id, error: t.message });
            }
          });
      }
      var d;
    });
    const a = [
        {
          if: "astcSupported",
          basisFormat: [r.UASTC_4x4],
          transcoderFormat: [s.ASTC_4x4, s.ASTC_4x4],
          engineFormat: [n.RGBA_ASTC_4x4_Format, n.RGBA_ASTC_4x4_Format],
          priorityETC1S: 1 / 0,
          priorityUASTC: 1,
          needsPowerOfTwo: !1,
        },
        {
          if: "bptcSupported",
          basisFormat: [r.ETC1S, r.UASTC_4x4],
          transcoderFormat: [s.BC7_M5, s.BC7_M5],
          engineFormat: [n.RGBA_BPTC_Format, n.RGBA_BPTC_Format],
          priorityETC1S: 3,
          priorityUASTC: 2,
          needsPowerOfTwo: !1,
        },
        {
          if: "dxtSupported",
          basisFormat: [r.ETC1S, r.UASTC_4x4],
          transcoderFormat: [s.BC1, s.BC3],
          engineFormat: [n.RGB_S3TC_DXT1_Format, n.RGBA_S3TC_DXT5_Format],
          priorityETC1S: 4,
          priorityUASTC: 5,
          needsPowerOfTwo: !1,
        },
        {
          if: "etc2Supported",
          basisFormat: [r.ETC1S, r.UASTC_4x4],
          transcoderFormat: [s.ETC1, s.ETC2],
          engineFormat: [n.RGB_ETC2_Format, n.RGBA_ETC2_EAC_Format],
          priorityETC1S: 1,
          priorityUASTC: 3,
          needsPowerOfTwo: !1,
        },
        {
          if: "etc1Supported",
          basisFormat: [r.ETC1S, r.UASTC_4x4],
          transcoderFormat: [s.ETC1],
          engineFormat: [n.RGB_ETC1_Format],
          priorityETC1S: 2,
          priorityUASTC: 4,
          needsPowerOfTwo: !1,
        },
        {
          if: "pvrtcSupported",
          basisFormat: [r.ETC1S, r.UASTC_4x4],
          transcoderFormat: [s.PVRTC1_4_RGB, s.PVRTC1_4_RGBA],
          engineFormat: [n.RGB_PVRTC_4BPPV1_Format, n.RGBA_PVRTC_4BPPV1_Format],
          priorityETC1S: 5,
          priorityUASTC: 6,
          needsPowerOfTwo: !0,
        },
      ],
      o = a.sort(function (e, t) {
        return e.priorityETC1S - t.priorityETC1S;
      }),
      l = a.sort(function (e, t) {
        return e.priorityUASTC - t.priorityUASTC;
      });
    function h(e) {
      return e <= 2 || (0 == (e & (e - 1)) && 0 !== e);
    }
    function c(e) {
      if (1 === e.length) return e[0];
      let t = 0;
      for (let s = 0; s < e.length; s++) {
        t += e[s].byteLength;
      }
      const i = new Uint8Array(t);
      let n = 0;
      for (let s = 0; s < e.length; s++) {
        const t = e[s];
        i.set(t, n), (n += t.byteLength);
      }
      return i;
    }
  });
const wS = new Set([Q, q, W]),
  TS = {
    109: Q,
    97: Q,
    37: Q,
    43: Q,
    103: q,
    83: q,
    16: q,
    22: q,
    100: W,
    76: W,
    15: W,
    9: W,
    166: ne,
    165: ne,
  },
  IS = {
    109: z,
    97: G,
    37: B,
    43: B,
    103: z,
    83: G,
    16: B,
    22: B,
    100: z,
    76: G,
    15: B,
    9: B,
    166: B,
    165: B,
  };
function RS(e) {
  const t = e.dataFormatDescriptor[0];
  return t.colorPrimaries === uS
    ? t.transferFunction === hS
      ? me
      : ge
    : t.colorPrimaries === dS
    ? t.transferFunction === hS
      ? _e
      : ve
    : (t.colorPrimaries === cS ||
        console.warn(
          `THREE.KTX2Loader: Unsupported color primaries, "${t.colorPrimaries}"`
        ),
      fe);
}
let PS = new cE(),
  DS = new cE();
DS.setMeshoptDecoder(rS);
const LS = new MS(),
  FS = new WebGLRenderer();
LS.detectSupport(FS),
  (LS.setWorkerLimit = 4),
  LS.setTranscoderPath(Hm("assets/libs/basis/"));
const NS = new (class extends pl {
  constructor(e) {
    super(e),
      (this.decoderPath = ""),
      (this.decoderConfig = {}),
      (this.decoderBinary = null),
      (this.decoderPending = null),
      (this.workerLimit = 4),
      (this.workerPool = []),
      (this.workerNextTaskID = 1),
      (this.workerSourceURL = ""),
      (this.defaultAttributeIDs = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD",
      }),
      (this.defaultAttributeTypes = {
        position: "Float32Array",
        normal: "Float32Array",
        color: "Float32Array",
        uv: "Float32Array",
      });
  }
  setDecoderPath(e) {
    return (this.decoderPath = e), this;
  }
  setDecoderConfig(e) {
    return (this.decoderConfig = e), this;
  }
  setWorkerLimit(e) {
    return (this.workerLimit = e), this;
  }
  load(e, t, i, n) {
    const s = new gl(this.manager);
    s.setPath(this.path),
      s.setResponseType("arraybuffer"),
      s.setRequestHeader(this.requestHeader),
      s.setWithCredentials(this.withCredentials),
      s.load(
        e,
        (e) => {
          this.parse(e, t, n);
        },
        i,
        n
      );
  }
  parse(e, t, i) {
    this.decodeDracoFile(e, t, null, null, me).catch(i);
  }
  decodeDracoFile(e, t, i, n, s = ge) {
    const r = {
      attributeIDs: i || this.defaultAttributeIDs,
      attributeTypes: n || this.defaultAttributeTypes,
      useUniqueIDs: !!i,
      vertexColorSpace: s,
    };
    return this.decodeGeometry(e, r).then(t);
  }
  decodeGeometry(e, t) {
    const i = JSON.stringify(t);
    if (aS.has(e)) {
      const t = aS.get(e);
      if (t.key === i) return t.promise;
      if (0 === e.byteLength)
        throw new Error(
          "THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred."
        );
    }
    let n;
    const s = this.workerNextTaskID++,
      r = e.byteLength,
      a = this._getWorker(s, r)
        .then(
          (i) => (
            (n = i),
            new Promise((i, r) => {
              (n._callbacks[s] = { resolve: i, reject: r }),
                n.postMessage(
                  { type: "decode", id: s, taskConfig: t, buffer: e },
                  [e]
                );
            })
          )
        )
        .then((e) => this._createGeometry(e.geometry));
    return (
      a
        .catch(() => !0)
        .then(() => {
          n && s && this._releaseTask(n, s);
        }),
      aS.set(e, { key: i, promise: a }),
      a
    );
  }
  _createGeometry(e) {
    const t = new rn();
    e.index && t.setIndex(new Wi(e.index.array, 1));
    for (let i = 0; i < e.attributes.length; i++) {
      const n = e.attributes[i],
        s = n.name,
        r = n.array,
        a = n.itemSize,
        o = new Wi(r, a);
      "color" === s &&
        (this._assignVertexColorSpace(o, n.vertexColorSpace),
        (o.normalized = r instanceof Float32Array == !1)),
        t.setAttribute(s, o);
    }
    return t;
  }
  _assignVertexColorSpace(e, t) {
    if (t !== me) return;
    const i = new Color();
    for (let n = 0, s = e.count; n < s; n++)
      i.fromBufferAttribute(e, n).convertSRGBToLinear(),
        e.setXYZ(n, i.r, i.g, i.b);
  }
  _loadLibrary(e, t) {
    const i = new gl(this.manager);
    return (
      i.setPath(this.decoderPath),
      i.setResponseType(t),
      i.setWithCredentials(this.withCredentials),
      new Promise((t, n) => {
        i.load(e, t, void 0, n);
      })
    );
  }
  preload() {
    return this._initDecoder(), this;
  }
  _initDecoder() {
    if (this.decoderPending) return this.decoderPending;
    const e =
        "object" != typeof WebAssembly || "js" === this.decoderConfig.type,
      t = [];
    return (
      e
        ? t.push(this._loadLibrary("draco_decoder.js", "text"))
        : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")),
          t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))),
      (this.decoderPending = Promise.all(t).then((t) => {
        const i = t[0];
        e || (this.decoderConfig.wasmBinary = t[1]);
        const n = oS.toString(),
          s = [
            "/* draco decoder */",
            i,
            "",
            "/* worker */",
            n.substring(n.indexOf("{") + 1, n.lastIndexOf("}")),
          ].join("\n");
        this.workerSourceURL = URL.createObjectURL(new Blob([s]));
      })),
      this.decoderPending
    );
  }
  _getWorker(e, t) {
    return this._initDecoder().then(() => {
      if (this.workerPool.length < this.workerLimit) {
        const e = new Worker(this.workerSourceURL);
        (e._callbacks = {}),
          (e._taskCosts = {}),
          (e._taskLoad = 0),
          e.postMessage({ type: "init", decoderConfig: this.decoderConfig }),
          (e.onmessage = function (t) {
            const i = t.data;
            switch (i.type) {
              case "decode":
                e._callbacks[i.id].resolve(i);
                break;
              case "error":
                e._callbacks[i.id].reject(i);
                break;
              default:
                console.error(
                  'THREE.DRACOLoader: Unexpected message, "' + i.type + '"'
                );
            }
          }),
          this.workerPool.push(e);
      } else
        this.workerPool.sort(function (e, t) {
          return e._taskLoad > t._taskLoad ? -1 : 1;
        });
      const i = this.workerPool[this.workerPool.length - 1];
      return (i._taskCosts[e] = t), (i._taskLoad += t), i;
    });
  }
  _releaseTask(e, t) {
    (e._taskLoad -= e._taskCosts[t]),
      delete e._callbacks[t],
      delete e._taskCosts[t];
  }
  debug() {
    console.log(
      "Task load: ",
      this.workerPool.map((e) => e._taskLoad)
    );
  }
  dispose() {
    for (let e = 0; e < this.workerPool.length; ++e)
      this.workerPool[e].terminate();
    return (
      (this.workerPool.length = 0),
      "" !== this.workerSourceURL && URL.revokeObjectURL(this.workerSourceURL),
      this
    );
  }
})();
NS.setDecoderPath(Hm("assets/libs/draco/gltf/")),
  NS.setDecoderConfig({ type: "js" }),
  DS.setDRACOLoader(NS),
  DS.setKTX2Loader(LS),
  DS.setMeshoptDecoder(rS);
const BS = {};
function kS(e) {
  if (!BS[e]) {
    const t = Math.random(),
      i = 0.5 + 0.5 * Math.random(),
      n = 0.375 + 0.25 * Math.random();
    BS[e] = new Color().setHSL(t, i, n);
  }
  return BS[e];
}
function OS(e) {
  let t;
  try {
    t = new URL(e, "http://fakehost.com/");
  } catch (s) {
    return null;
  }
  const i = t.pathname.split("/").pop(),
    n = i.lastIndexOf(".");
  if (-1 === n || n === i.length - 1) return null;
  return i.substring(n + 1);
}
class US {
  constructor() {
    (this.maxSize = 800),
      (this.minSize = 600),
      (this.unloadPercent = 0.05),
      (this.itemSet = new Map()),
      (this.itemList = []),
      (this.usedSet = new Set()),
      (this.callbacks = new Map()),
      (this.unloadPriorityCallback = null);
    const e = this.itemSet;
    this.defaultPriorityCallback = (t) => e.get(t);
  }
  isFull() {
    return this.itemSet.size >= this.maxSize;
  }
  add(e, t) {
    const i = this.itemSet;
    if (i.has(e)) return !1;
    if (this.isFull()) return !1;
    const n = this.usedSet,
      s = this.itemList,
      r = this.callbacks;
    return s.push(e), n.add(e), i.set(e, Date.now()), r.set(e, t), !0;
  }
  remove(e) {
    const t = this.usedSet,
      i = this.itemSet,
      n = this.itemList,
      s = this.callbacks;
    if (i.has(e)) {
      s.get(e)(e);
      const r = n.indexOf(e);
      return n.splice(r, 1), t.delete(e), i.delete(e), s.delete(e), !0;
    }
    return !1;
  }
  markUsed(e) {
    const t = this.itemSet,
      i = this.usedSet;
    t.has(e) && !i.has(e) && (t.set(e, Date.now()), i.add(e));
  }
  markAllUnused() {
    this.usedSet.clear();
  }
  unloadUnusedContent() {
    const e = this.unloadPercent,
      t = this.minSize,
      i = this.itemList,
      n = this.itemSet,
      s = this.usedSet,
      r = this.callbacks,
      a = i.length - s.size,
      o = i.length - t,
      l = this.unloadPriorityCallback || this.defaultPriorityCallback;
    if (o > 0 && a > 0) {
      i.sort((e, t) => {
        const i = s.has(e),
          n = s.has(t);
        return i && n ? 0 : i || n ? (i ? 1 : -1) : l(t) - l(e);
      });
      const h = Math.min(o, a),
        c = Math.max(t * e, h * e);
      let u = Math.min(c, a);
      u = Math.ceil(u);
      const d = i.splice(0, u);
      for (let e = 0, t = d.length; e < t; e++) {
        const t = d[e];
        r.get(t)(t), n.delete(t), r.delete(t);
      }
    }
  }
  scheduleUnload(e = !0) {
    var t;
    this.scheduled ||
      ((this.scheduled = !0),
      (t = () => {
        (this.scheduled = !1),
          this.unloadUnusedContent(),
          e && this.markAllUnused();
      }),
      Promise.resolve().then(t));
  }
}
class zS {
  constructor() {
    (this.maxJobs = 6),
      (this.items = []),
      (this.callbacks = new Map()),
      (this.currJobs = 0),
      (this.scheduled = !1),
      (this.autoUpdate = !0),
      (this.priorityCallback = () => {
        throw new Error(
          "PriorityQueue: PriorityCallback function not defined."
        );
      }),
      (this.schedulingCallback = (e) => {
        requestAnimationFrame(e);
      }),
      (this._runjobs = () => {
        this.tryRunJobs(), (this.scheduled = !1);
      });
  }
  sort() {
    const e = this.priorityCallback;
    this.items.sort(e);
  }
  add(e, t) {
    return new Promise((i, n) => {
      const s = this.items,
        r = this.callbacks;
      s.push(e),
        r.set(e, (...e) =>
          t(...e)
            .then(i)
            .catch(n)
        ),
        this.autoUpdate && this.scheduleJobRun();
    });
  }
  remove(e) {
    const t = this.items,
      i = this.callbacks,
      n = t.indexOf(e);
    -1 !== n && (t.splice(n, 1), i.delete(e));
  }
  tryRunJobs() {
    this.sort();
    const e = this.items,
      t = this.callbacks,
      i = this.maxJobs;
    let n = this.currJobs;
    for (; i > n && e.length > 0; ) {
      n++;
      const i = e.pop(),
        s = t.get(i);
      t.delete(i),
        s(i)
          .then(() => {
            this.currJobs--, this.autoUpdate && this.scheduleJobRun();
          })
          .catch(() => {
            this.currJobs--, this.autoUpdate && this.scheduleJobRun();
          });
    }
    this.currJobs = n;
  }
  scheduleJobRun() {
    this.scheduled ||
      (this.schedulingCallback(this._runjobs), (this.scheduled = !0));
  }
}
const GS = 3,
  VS = 4,
  QS = 6378137;
function HS(e) {
  return e === GS || e === VS;
}
function jS(e, t) {
  return e.__lastFrameVisited === t && e.__used;
}
function WS(e, t) {
  e.__lastFrameVisited !== t &&
    ((e.__lastFrameVisited = t),
    (e.__used = !1),
    (e.__inFrustum = !1),
    (e.__isLeaf = !1),
    (e.__visible = !1),
    (e.__active = !1),
    (e.__error = 1 / 0),
    (e.__distanceFromCamera = 1 / 0),
    (e.__childrenWereVisible = !1),
    (e.__allChildrenLoaded = !1));
}
function qS(e, t, i) {
  if ((WS(e, t), (e.__used = !0), i.markUsed(e), e.__contentEmpty)) {
    const n = e.children;
    for (let e = 0, s = n.length; e < s; e++) qS(n[e], t, i);
  }
}
function XS(e, t, i) {
  if (e.__contentEmpty && (!e.__externalTileSet || HS(e.__loadingState))) {
    const n = e.children;
    for (let e = 0, s = n.length; e < s; e++) {
      const s = n[e];
      (s.__depthFromRenderedParent = t), XS(s, t, i);
    }
  } else i.requestTileContents(e);
}
function YS(e, t = null, i = null, n = null, s = 0) {
  if (t && t(e, n, s)) return void (i && i(e, n, s));
  const r = e.children;
  for (let a = 0, o = r.length; a < o; a++) YS(r[a], t, i, e, s + 1);
  i && i(e, n, s);
}
function KS(e, t) {
  const i = t.stats,
    n = t.frameCount,
    s = t.errorTarget,
    r = t.maxDepth,
    a = t.loadSiblings,
    o = t.lruCache,
    l = t.stopAtEmptyTiles;
  WS(e, n);
  if (!1 === t.tileInView(e)) return !1;
  if (
    ((e.__used = !0),
    o.markUsed(e),
    (e.__inFrustum = !0),
    i.inFrustum++,
    (l || !e.__contentEmpty) && !e.__externalTileSet)
  ) {
    t.calculateError(e);
    if (e.__error <= s) return !0;
    if (t.maxDepth > 0 && e.__depth + 1 >= r) return !0;
  }
  let h = !1;
  const c = e.children;
  for (let u = 0, d = c.length; u < d; u++) {
    const e = KS(c[u], t);
    h = h || e;
  }
  if (h && a)
    for (let u = 0, d = c.length; u < d; u++) {
      qS(c[u], n, o);
    }
  return !0;
}
function ZS(e, t) {
  const i = t.stats,
    n = t.frameCount;
  if (!jS(e, n)) return;
  i.used++;
  const s = e.children;
  let r = !1;
  for (let a = 0, o = s.length; a < o; a++) {
    const e = s[a];
    r = r || jS(e, n);
  }
  if (r) {
    let i = !1,
      r = !0;
    for (let e = 0, a = s.length; e < a; e++) {
      const a = s[e];
      if (
        (ZS(a, t),
        (i = i || a.__wasSetVisible || a.__childrenWereVisible),
        jS(a, n))
      ) {
        const e =
          a.__allChildrenLoaded ||
          (!a.__contentEmpty && HS(a.__loadingState)) ||
          (a.__externalTileSet && a.__loadingState === VS);
        r = r && e;
      }
    }
    (e.__childrenWereVisible = i), (e.__allChildrenLoaded = r);
  } else e.__isLeaf = !0;
}
function JS(e, t) {
  const i = t.stats,
    n = t.frameCount;
  if (!jS(e, n)) return;
  const s = e.parent,
    r = s ? s.__depthFromRenderedParent : -1;
  e.__depthFromRenderedParent = r;
  const a = t.lruCache;
  if (e.__isLeaf)
    return (
      e.__depthFromRenderedParent++,
      void (e.__loadingState === GS
        ? (e.__inFrustum && ((e.__visible = !0), i.visible++),
          (e.__active = !0),
          i.active++)
        : a.isFull() ||
          (e.__contentEmpty && !e.__externalTileSet) ||
          t.requestTileContents(e))
    );
  const o = (t.errorTarget + 1) * t.errorThreshold,
    l = e.__error <= o,
    h = l || "ADD" === e.refine,
    c = !e.__contentEmpty,
    u = c || e.__externalTileSet,
    d = HS(e.__loadingState) && u,
    p = e.__childrenWereVisible,
    f = e.children,
    m = e.__allChildrenLoaded;
  if (
    (h && c && e.__depthFromRenderedParent++,
    h && !d && !a.isFull() && u && t.requestTileContents(e),
    ((l && !m && !p && d) || ("ADD" === e.refine && d)) &&
      (e.__inFrustum && ((e.__visible = !0), i.visible++),
      (e.__active = !0),
      i.active++),
    "ADD" !== e.refine && l && !m && d)
  )
    for (let g = 0, _ = f.length; g < _; g++) {
      const i = f[g];
      jS(i, n) &&
        !a.isFull() &&
        ((i.__depthFromRenderedParent = e.__depthFromRenderedParent + 1),
        XS(i, i.__depthFromRenderedParent, t));
    }
  else
    for (let g = 0, _ = f.length; g < _; g++) {
      const e = f[g];
      jS(e, n) && JS(e, t);
    }
}
function $S(e, t) {
  const i = jS(e, t.frameCount);
  if (i || e.__usedLastFrame) {
    let n = !1,
      s = !1;
    i &&
      ((n = e.__active),
      (s = (t.displayActiveTiles && e.__active) || e.__visible)),
      e.__contentEmpty ||
        e.__loadingState !== GS ||
        (e.__wasSetActive !== n && t.setTileActive(e, n),
        e.__wasSetVisible !== s && t.setTileVisible(e, s)),
      (e.__wasSetActive = n),
      (e.__wasSetVisible = s),
      (e.__usedLastFrame = i);
    const r = e.children;
    for (let e = 0, i = r.length; e < i; e++) {
      $S(r[e], t);
    }
  }
}
const eC = (e, t) =>
    e.__depth !== t.__depth
      ? e.__depth > t.__depth
        ? -1
        : 1
      : e.__inFrustum !== t.__inFrustum
      ? e.__inFrustum
        ? 1
        : -1
      : e.__used !== t.__used
      ? e.__used
        ? 1
        : -1
      : e.__error !== t.__error
      ? e.__error > t.__error
        ? 1
        : -1
      : e.__distanceFromCamera !== t.__distanceFromCamera
      ? e.__distanceFromCamera > t.__distanceFromCamera
        ? -1
        : 1
      : 0,
  tC = (e) => 1 / (e.__depthFromRenderedParent + 1);
class iC {
  get rootTileSet() {
    const e = this.tileSets[this.rootURL];
    return !e || e instanceof Promise ? null : e;
  }
  get root() {
    const e = this.rootTileSet;
    return e ? e.root : null;
  }
  constructor(e) {
    (this.tileSets = {}),
      (this.rootURL = e),
      (this.fetchOptions = {}),
      (this.preprocessURL = null);
    const t = new US();
    t.unloadPriorityCallback = tC;
    const i = new zS();
    (i.maxJobs = 4), (i.priorityCallback = eC);
    const n = new zS();
    (n.maxJobs = 1),
      (n.priorityCallback = eC),
      (this.lruCache = t),
      (this.downloadQueue = i),
      (this.parseQueue = n),
      (this.stats = {
        parsing: 0,
        downloading: 0,
        failed: 0,
        inFrustum: 0,
        used: 0,
        active: 0,
        visible: 0,
      }),
      (this.frameCount = 0),
      (this.errorTarget = 6),
      (this.errorThreshold = 1 / 0),
      (this.loadSiblings = !0),
      (this.displayActiveTiles = !1),
      (this.maxDepth = 1 / 0),
      (this.stopAtEmptyTiles = !0);
  }
  traverse(e, t) {
    const i = this.tileSets[this.rootURL];
    i && i.root && YS(i.root, e, t);
  }
  update() {
    const e = this.stats,
      t = this.lruCache,
      i = this.tileSets,
      n = i[this.rootURL];
    if (!(this.rootURL in i)) return void this.loadRootTileSet(this.rootURL);
    if (!n || !n.root) return;
    const s = n.root;
    (e.inFrustum = 0),
      (e.used = 0),
      (e.active = 0),
      (e.visible = 0),
      this.frameCount++,
      KS(s, this),
      ZS(s, this),
      JS(s, this),
      $S(s, this),
      t.scheduleUnload();
  }
  parseTile(e, t, i) {
    return null;
  }
  disposeTile(e) {}
  preprocessNode(e, t, i) {
    e.content &&
      (!("uri" in e.content) &&
        "url" in e.content &&
        ((e.content.uri = e.content.url), delete e.content.url),
      e.content.uri &&
        (e.content.uri = new URL(e.content.uri, i + "/").toString()),
      e.content.boundingVolume &&
        !(
          "box" in e.content.boundingVolume ||
          "sphere" in e.content.boundingVolume ||
          "region" in e.content.boundingVolume
        ) &&
        delete e.content.boundingVolume),
      (e.parent = t),
      (e.children = e.children || []);
    if (e.content && e.content.uri) {
      const t = OS(e.content.uri),
        i = Boolean(t && "json" === t.toLowerCase());
      (e.__externalTileSet = i), (e.__contentEmpty = i);
    } else (e.__externalTileSet = !1), (e.__contentEmpty = !0);
    (e.__distanceFromCamera = 1 / 0),
      (e.__error = 1 / 0),
      (e.__inFrustum = !1),
      (e.__isLeaf = !1),
      (e.__usedLastFrame = !1),
      (e.__used = !1),
      (e.__wasSetVisible = !1),
      (e.__visible = !1),
      (e.__childrenWereVisible = !1),
      (e.__allChildrenLoaded = !1),
      (e.__wasSetActive = !1),
      (e.__active = !1),
      (e.__loadingState = 0),
      (e.__loadIndex = 0),
      (e.__loadAbort = null),
      (e.__depthFromRenderedParent = -1),
      null === t
        ? ((e.__depth = 0), (e.refine = e.refine || "REPLACE"))
        : ((e.__depth = t.__depth + 1), (e.refine = e.refine || t.refine));
  }
  setTileActive(e, t) {}
  setTileVisible(e, t) {}
  calculateError(e) {
    return 0;
  }
  tileInView(e) {
    return !0;
  }
  resetFailedTiles() {
    const e = this.stats;
    0 !== e.failed &&
      (this.traverse((e) => {
        e.__loadingState === VS && (e.__loadingState = 0);
      }),
      (e.failed = 0));
  }
  fetchTileSet(e, t, i = null) {
    return fetch(e, t)
      .then((t) => {
        if (t.ok) return t.json();
        throw new Error(
          `TilesRenderer: Failed to load tileset "${e}" with status ${t.status} : ${t.statusText}`
        );
      })
      .then((t) => {
        const n = t.asset.version;
        console.assert(
          "1.0" === n || "0.0" === n,
          'asset.version is expected to be a string of "1.0" or "0.0"'
        );
        let s = e.replace(/\/[^\/]*\/?$/, "");
        return (
          (s = new URL(s, window.location.href).toString()),
          YS(
            t.root,
            (e, t) => this.preprocessNode(e, t, s),
            null,
            i,
            i ? i.__depth : 0
          ),
          t
        );
      });
  }
  loadRootTileSet(e) {
    const t = this.tileSets;
    if (e in t)
      return t[e] instanceof Error
        ? Promise.reject(t[e])
        : Promise.resolve(t[e]);
    {
      const i = this.fetchTileSet(
        this.preprocessURL ? this.preprocessURL(e) : e,
        this.fetchOptions
      ).then((i) => {
        t[e] = i;
      });
      return (
        i.catch((i) => {
          console.error(i), (t[e] = i);
        }),
        (t[e] = i),
        i
      );
    }
  }
  requestTileContents(e) {
    if (0 !== e.__loadingState) return;
    const t = this.stats,
      i = this.lruCache,
      n = this.downloadQueue,
      s = this.parseQueue,
      r = e.__externalTileSet;
    i.add(e, (e) => {
      1 === e.__loadingState
        ? (e.__loadAbort.abort(), (e.__loadAbort = null))
        : r
        ? (e.children.length = 0)
        : this.disposeTile(e),
        1 === e.__loadingState
          ? t.downloading--
          : 2 === e.__loadingState && t.parsing--,
        (e.__loadingState = 0),
        e.__loadIndex++,
        s.remove(e),
        n.remove(e);
    }),
      e.__loadIndex++;
    const a = e.__loadIndex,
      o = new AbortController(),
      l = o.signal;
    t.downloading++, (e.__loadAbort = o), (e.__loadingState = 1);
    const h = (r) => {
      e.__loadIndex === a &&
        ("AbortError" !== r.name
          ? (s.remove(e),
            n.remove(e),
            2 === e.__loadingState
              ? t.parsing--
              : 1 === e.__loadingState && t.downloading--,
            t.failed++,
            console.error(
              `TilesRenderer : Failed to load tile at url "${e.content.uri}".`
            ),
            console.error(r),
            (e.__loadingState = VS))
          : i.remove(e));
    };
    r
      ? n
          .add(e, (e) => {
            if (e.__loadIndex !== a) return Promise.resolve();
            const t = this.preprocessURL
              ? this.preprocessURL(e.content.uri)
              : e.content.uri;
            return this.fetchTileSet(
              t,
              Object.assign({ signal: l }, this.fetchOptions),
              e
            );
          })
          .then((i) => {
            e.__loadIndex === a &&
              (t.downloading--,
              (e.__loadAbort = null),
              (e.__loadingState = GS),
              e.children.push(i.root));
          })
          .catch(h)
      : n
          .add(e, (e) => {
            if (e.__loadIndex !== a) return Promise.resolve();
            const t = this.preprocessURL
              ? this.preprocessURL(e.content.uri)
              : e.content.uri;
            return fetch(t, Object.assign({ signal: l }, this.fetchOptions));
          })
          .then((t) => {
            if (e.__loadIndex === a) {
              if (t.ok) return t.arrayBuffer();
              throw new Error(
                `Failed to load model with error code ${t.status}`
              );
            }
          })
          .then((i) => {
            if (e.__loadIndex === a)
              return (
                t.downloading--,
                t.parsing++,
                (e.__loadAbort = null),
                (e.__loadingState = 2),
                s.add(e, (e) => {
                  if (e.__loadIndex !== a) return Promise.resolve();
                  const t = OS(e.content.uri);
                  return this.parseTile(i, e, t);
                })
              );
          })
          .then(() => {
            e.__loadIndex === a &&
              (t.parsing--,
              (e.__loadingState = GS),
              e.__wasSetVisible && this.setTileVisible(e, !0),
              e.__wasSetActive && this.setTileActive(e, !0));
          })
          .catch(h);
  }
  dispose() {
    const e = this.lruCache;
    this.traverse((t) => {
      e.remove(t);
    }),
      (this.stats = {
        parsing: 0,
        downloading: 0,
        failed: 0,
        inFrustum: 0,
        used: 0,
        active: 0,
        visible: 0,
      }),
      (this.frameCount = 0);
  }
}
function nC(e) {
  return new TextDecoder().decode(e);
}
class sC {
  constructor(e, t, i, n) {
    (this.buffer = e), (this.binOffset = t + i), (this.binLength = n);
    let s = null;
    if (0 !== i) {
      const n = new Uint8Array(e, t, i);
      s = JSON.parse(nC(n));
    } else s = {};
    this.header = s;
  }
  getKeys() {
    return Object.keys(this.header);
  }
  getData(e, t, i = null, n = null) {
    const s = this.header;
    if (!(e in s)) return null;
    const r = s[e];
    if (r instanceof Object) {
      if (Array.isArray(r)) return r;
      {
        const { buffer: s, binOffset: a, binLength: o } = this,
          l = r.byteOffset || 0,
          h = r.type || n,
          c = r.componentType || i;
        if ("type" in r && n && r.type !== n)
          throw new Error(
            "FeatureTable: Specified type does not match expected type."
          );
        let u, d;
        switch (h) {
          case "SCALAR":
            u = 1;
            break;
          case "VEC2":
            u = 2;
            break;
          case "VEC3":
            u = 3;
            break;
          case "VEC4":
            u = 4;
            break;
          default:
            throw new Error(
              `FeatureTable : Feature type not provided for "${e}".`
            );
        }
        const p = a + l,
          f = t * u;
        switch (c) {
          case "BYTE":
            d = new Int8Array(s, p, f);
            break;
          case "UNSIGNED_BYTE":
            d = new Uint8Array(s, p, f);
            break;
          case "SHORT":
            d = new Int16Array(s, p, f);
            break;
          case "UNSIGNED_SHORT":
            d = new Uint16Array(s, p, f);
            break;
          case "INT":
            d = new Int32Array(s, p, f);
            break;
          case "UNSIGNED_INT":
            d = new Uint32Array(s, p, f);
            break;
          case "FLOAT":
            d = new Float32Array(s, p, f);
            break;
          case "DOUBLE":
            d = new Float64Array(s, p, f);
            break;
          default:
            throw new Error(
              `FeatureTable : Feature component type not provided for "${e}".`
            );
        }
        if (p + f * d.BYTES_PER_ELEMENT > a + o)
          throw new Error(
            "FeatureTable: Feature data read outside binary body length."
          );
        return d;
      }
    }
    return r;
  }
  getBuffer(e, t) {
    const { buffer: i, binOffset: n } = this;
    return i.slice(n + e, n + e + t);
  }
}
class rC extends sC {
  constructor(e, t, i, n, s) {
    super(e, i, n, s), (this.batchSize = t);
  }
  getData(e, t = null, i = null) {
    return super.getData(e, this.batchSize, t, i);
  }
}
class aC {
  constructor() {
    (this.fetchOptions = {}), (this.workingPath = "");
  }
  load(e) {
    return fetch(e, this.fetchOptions)
      .then((t) => {
        if (!t.ok)
          throw new Error(
            `Failed to load file "${e}" with status ${t.status} : ${t.statusText}`
          );
        return t.arrayBuffer();
      })
      .then(
        (t) => (
          "" === this.workingPath &&
            (this.workingPath = this.workingPathForURL(e)),
          this.parse(t)
        )
      );
  }
  resolveExternalURL(e) {
    return /^[^\\/]/.test(e) ? this.workingPath + "/" + e : e;
  }
  workingPathForURL(e) {
    const t = e.split(/[\\/]/g);
    t.pop();
    return t.join("/") + "/";
  }
  parse(e) {
    throw new Error("LoaderBase: Parse not implemented.");
  }
}
function oC(e) {
  let t;
  if (
    ((t = e instanceof DataView ? e : new DataView(e)),
    "{" === String.fromCharCode(t.getUint8(0)))
  )
    return null;
  let i = "";
  for (let n = 0; n < 4; n++) i += String.fromCharCode(t.getUint8(n));
  return i;
}
class lC extends aC {
  parse(e) {
    const t = new DataView(e),
      i = oC(t);
    console.assert("b3dm" === i);
    const n = t.getUint32(4, !0);
    console.assert(1 === n);
    const s = t.getUint32(8, !0);
    console.assert(s === e.byteLength);
    const r = t.getUint32(12, !0),
      a = t.getUint32(16, !0),
      o = t.getUint32(20, !0),
      l = t.getUint32(24, !0),
      h = e.slice(28, 28 + r + a),
      c = new sC(h, 0, r, a),
      u = 28 + r + a,
      d = e.slice(u, u + o + l),
      p = new rC(d, c.getData("BATCH_LENGTH"), 0, o, l),
      f = u + o + l;
    return {
      version: n,
      featureTable: c,
      batchTable: p,
      glbBytes: new Uint8Array(e, f, s - f),
    };
  }
}
class hC extends pl {
  constructor(e) {
    super(e),
      (this.dracoLoader = null),
      (this.ktx2Loader = null),
      (this.meshoptDecoder = null),
      (this.pluginCallbacks = []),
      this.register(function (e) {
        return new mC(e);
      }),
      this.register(function (e) {
        return new EC(e);
      }),
      this.register(function (e) {
        return new SC(e);
      }),
      this.register(function (e) {
        return new CC(e);
      }),
      this.register(function (e) {
        return new _C(e);
      }),
      this.register(function (e) {
        return new vC(e);
      }),
      this.register(function (e) {
        return new AC(e);
      }),
      this.register(function (e) {
        return new yC(e);
      }),
      this.register(function (e) {
        return new fC(e);
      }),
      this.register(function (e) {
        return new xC(e);
      }),
      this.register(function (e) {
        return new gC(e);
      }),
      this.register(function (e) {
        return new bC(e);
      }),
      this.register(function (e) {
        return new dC(e);
      }),
      this.register(function (e) {
        return new MC(e);
      }),
      this.register(function (e) {
        return new wC(e);
      });
  }
  load(e, t, i, n) {
    const s = this;
    let r;
    (r =
      "" !== this.resourcePath
        ? this.resourcePath
        : "" !== this.path
        ? this.path
        : Bl.extractUrlBase(e)),
      this.manager.itemStart(e);
    const a = function (t) {
        n ? n(t) : console.error(t),
          s.manager.itemError(e),
          s.manager.itemEnd(e);
      },
      o = new gl(this.manager);
    o.setPath(this.path),
      o.setResponseType("arraybuffer"),
      o.setRequestHeader(this.requestHeader),
      o.setWithCredentials(this.withCredentials),
      o.load(
        e,
        function (i) {
          try {
            s.parse(
              i,
              r,
              function (i) {
                t(i), s.manager.itemEnd(e);
              },
              a
            );
          } catch (Ym) {
            a(Ym);
          }
        },
        i,
        a
      );
  }
  setDRACOLoader(e) {
    return (this.dracoLoader = e), this;
  }
  setDDSLoader() {
    throw new Error(
      'THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".'
    );
  }
  setKTX2Loader(e) {
    return (this.ktx2Loader = e), this;
  }
  setMeshoptDecoder(e) {
    return (this.meshoptDecoder = e), this;
  }
  register(e) {
    return (
      -1 === this.pluginCallbacks.indexOf(e) && this.pluginCallbacks.push(e),
      this
    );
  }
  unregister(e) {
    return (
      -1 !== this.pluginCallbacks.indexOf(e) &&
        this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
      this
    );
  }
  parse(e, t, i, n) {
    let s;
    const r = {},
      a = {},
      o = new TextDecoder();
    if ("string" == typeof e) s = JSON.parse(e);
    else if (e instanceof ArrayBuffer) {
      if (o.decode(new Uint8Array(e, 0, 4)) === TC) {
        try {
          r[uC.KHR_BINARY_GLTF] = new PC(e);
        } catch (h) {
          return void (n && n(h));
        }
        s = JSON.parse(r[uC.KHR_BINARY_GLTF].content);
      } else s = JSON.parse(o.decode(e));
    } else s = e;
    if (void 0 === s.asset || s.asset.version[0] < 2)
      return void (
        n &&
        n(
          new Error(
            "THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."
          )
        )
      );
    const l = new iM(s, {
      path: t || this.resourcePath || "",
      crossOrigin: this.crossOrigin,
      requestHeader: this.requestHeader,
      manager: this.manager,
      ktx2Loader: this.ktx2Loader,
      meshoptDecoder: this.meshoptDecoder,
    });
    l.fileLoader.setRequestHeader(this.requestHeader);
    for (let c = 0; c < this.pluginCallbacks.length; c++) {
      const e = this.pluginCallbacks[c](l);
      (a[e.name] = e), (r[e.name] = !0);
    }
    if (s.extensionsUsed)
      for (let c = 0; c < s.extensionsUsed.length; ++c) {
        const e = s.extensionsUsed[c],
          t = s.extensionsRequired || [];
        switch (e) {
          case uC.KHR_MATERIALS_UNLIT:
            r[e] = new pC();
            break;
          case uC.KHR_DRACO_MESH_COMPRESSION:
            r[e] = new DC(s, this.dracoLoader);
            break;
          case uC.KHR_TEXTURE_TRANSFORM:
            r[e] = new LC();
            break;
          case uC.KHR_MESH_QUANTIZATION:
            r[e] = new FC();
            break;
          default:
            t.indexOf(e) >= 0 &&
              void 0 === a[e] &&
              console.warn('THREE.GLTFLoader: Unknown extension "' + e + '".');
        }
      }
    l.setExtensions(r), l.setPlugins(a), l.parse(i, n);
  }
  parseAsync(e, t) {
    const i = this;
    return new Promise(function (n, s) {
      i.parse(e, t, n, s);
    });
  }
}
function cC() {
  let e = {};
  return {
    get: function (t) {
      return e[t];
    },
    add: function (t, i) {
      e[t] = i;
    },
    remove: function (t) {
      delete e[t];
    },
    removeAll: function () {
      e = {};
    },
  };
}
const uC = {
  KHR_BINARY_GLTF: "KHR_binary_glTF",
  KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
  KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
  KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
  KHR_MATERIALS_IOR: "KHR_materials_ior",
  KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
  KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
  KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
  KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
  KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
  KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
  KHR_MATERIALS_VOLUME: "KHR_materials_volume",
  KHR_TEXTURE_BASISU: "KHR_texture_basisu",
  KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
  KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
  KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
  EXT_TEXTURE_WEBP: "EXT_texture_webp",
  EXT_TEXTURE_AVIF: "EXT_texture_avif",
  EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
  EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing",
};
class dC {
  constructor(e) {
    (this.parser = e),
      (this.name = uC.KHR_LIGHTS_PUNCTUAL),
      (this.cache = { refs: {}, uses: {} });
  }
  _markDefs() {
    const e = this.parser,
      t = this.parser.json.nodes || [];
    for (let i = 0, n = t.length; i < n; i++) {
      const n = t[i];
      n.extensions &&
        n.extensions[this.name] &&
        void 0 !== n.extensions[this.name].light &&
        e._addNodeRef(this.cache, n.extensions[this.name].light);
    }
  }
  _loadLight(e) {
    const t = this.parser,
      i = "light:" + e;
    let n = t.cache.get(i);
    if (n) return n;
    const s = t.json,
      r = (((s.extensions && s.extensions[this.name]) || {}).lights || [])[e];
    let a;
    const o = new Color(16777215);
    void 0 !== r.color && o.setRGB(...r.color, ge);
    const l = void 0 !== r.range ? r.range : 0;
    switch (r.type) {
      case "directional":
        (a = new Nl(o)), a.target.position.set(0, 0, -1), a.add(a.target);
        break;
      case "point":
        (a = new Ll(o)), (a.distance = l);
        break;
      case "spot":
        (a = new Tl(o)),
          (a.distance = l),
          (r.spot = r.spot || {}),
          (r.spot.innerConeAngle =
            void 0 !== r.spot.innerConeAngle ? r.spot.innerConeAngle : 0),
          (r.spot.outerConeAngle =
            void 0 !== r.spot.outerConeAngle
              ? r.spot.outerConeAngle
              : Math.PI / 4),
          (a.angle = r.spot.outerConeAngle),
          (a.penumbra = 1 - r.spot.innerConeAngle / r.spot.outerConeAngle),
          a.target.position.set(0, 0, -1),
          a.add(a.target);
        break;
      default:
        throw new Error("THREE.GLTFLoader: Unexpected light type: " + r.type);
    }
    return (
      a.position.set(0, 0, 0),
      (a.decay = 2),
      KC(a, r),
      void 0 !== r.intensity && (a.intensity = r.intensity),
      (a.name = t.createUniqueName(r.name || "light_" + e)),
      (n = Promise.resolve(a)),
      t.cache.add(i, n),
      n
    );
  }
  getDependency(e, t) {
    if ("light" === e) return this._loadLight(t);
  }
  createNodeAttachment(e) {
    const t = this,
      i = this.parser,
      n = i.json.nodes[e],
      s = ((n.extensions && n.extensions[this.name]) || {}).light;
    return void 0 === s
      ? null
      : this._loadLight(s).then(function (e) {
          return i._getNodeRef(t.cache, s, e);
        });
  }
}
class pC {
  constructor() {
    this.name = uC.KHR_MATERIALS_UNLIT;
  }
  getMaterialType() {
    return Oi;
  }
  extendParams(e, t, i) {
    const n = [];
    (e.color = new Color(1, 1, 1)), (e.opacity = 1);
    const s = t.pbrMetallicRoughness;
    if (s) {
      if (Array.isArray(s.baseColorFactor)) {
        const t = s.baseColorFactor;
        e.color.setRGB(...t, ge), (e.opacity = t[3]);
      }
      void 0 !== s.baseColorTexture &&
        n.push(i.assignTexture(e, "map", s.baseColorTexture, me));
    }
    return Promise.all(n);
  }
}
class fC {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_MATERIALS_EMISSIVE_STRENGTH);
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const n = i.extensions[this.name].emissiveStrength;
    return void 0 !== n && (t.emissiveIntensity = n), Promise.resolve();
  }
}
class mC {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_MATERIALS_CLEARCOAT);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    if (
      (void 0 !== r.clearcoatFactor && (t.clearcoat = r.clearcoatFactor),
      void 0 !== r.clearcoatTexture &&
        s.push(i.assignTexture(t, "clearcoatMap", r.clearcoatTexture)),
      void 0 !== r.clearcoatRoughnessFactor &&
        (t.clearcoatRoughness = r.clearcoatRoughnessFactor),
      void 0 !== r.clearcoatRoughnessTexture &&
        s.push(
          i.assignTexture(
            t,
            "clearcoatRoughnessMap",
            r.clearcoatRoughnessTexture
          )
        ),
      void 0 !== r.clearcoatNormalTexture &&
        (s.push(
          i.assignTexture(t, "clearcoatNormalMap", r.clearcoatNormalTexture)
        ),
        void 0 !== r.clearcoatNormalTexture.scale))
    ) {
      const e = r.clearcoatNormalTexture.scale;
      t.clearcoatNormalScale = new Vector2(e, e);
    }
    return Promise.all(s);
  }
}
class gC {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_MATERIALS_IRIDESCENCE);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    return (
      void 0 !== r.iridescenceFactor && (t.iridescence = r.iridescenceFactor),
      void 0 !== r.iridescenceTexture &&
        s.push(i.assignTexture(t, "iridescenceMap", r.iridescenceTexture)),
      void 0 !== r.iridescenceIor && (t.iridescenceIOR = r.iridescenceIor),
      void 0 === t.iridescenceThicknessRange &&
        (t.iridescenceThicknessRange = [100, 400]),
      void 0 !== r.iridescenceThicknessMinimum &&
        (t.iridescenceThicknessRange[0] = r.iridescenceThicknessMinimum),
      void 0 !== r.iridescenceThicknessMaximum &&
        (t.iridescenceThicknessRange[1] = r.iridescenceThicknessMaximum),
      void 0 !== r.iridescenceThicknessTexture &&
        s.push(
          i.assignTexture(
            t,
            "iridescenceThicknessMap",
            r.iridescenceThicknessTexture
          )
        ),
      Promise.all(s)
    );
  }
}
class _C {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_MATERIALS_SHEEN);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [];
    (t.sheenColor = new Color(0, 0, 0)), (t.sheenRoughness = 0), (t.sheen = 1);
    const r = n.extensions[this.name];
    return (
      void 0 !== r.sheenColorFactor &&
        t.sheenColor.setRGB(...r.sheenColorFactor, ge),
      void 0 !== r.sheenRoughnessFactor &&
        (t.sheenRoughness = r.sheenRoughnessFactor),
      void 0 !== r.sheenColorTexture &&
        s.push(i.assignTexture(t, "sheenColorMap", r.sheenColorTexture, me)),
      void 0 !== r.sheenRoughnessTexture &&
        s.push(
          i.assignTexture(t, "sheenRoughnessMap", r.sheenRoughnessTexture)
        ),
      Promise.all(s)
    );
  }
}
class vC {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_MATERIALS_TRANSMISSION);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    return (
      void 0 !== r.transmissionFactor &&
        (t.transmission = r.transmissionFactor),
      void 0 !== r.transmissionTexture &&
        s.push(i.assignTexture(t, "transmissionMap", r.transmissionTexture)),
      Promise.all(s)
    );
  }
}
class AC {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_MATERIALS_VOLUME);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    (t.thickness = void 0 !== r.thicknessFactor ? r.thicknessFactor : 0),
      void 0 !== r.thicknessTexture &&
        s.push(i.assignTexture(t, "thicknessMap", r.thicknessTexture)),
      (t.attenuationDistance = r.attenuationDistance || 1 / 0);
    const a = r.attenuationColor || [1, 1, 1];
    return (t.attenuationColor = new Color().setRGB(...a, ge)), Promise.all(s);
  }
}
class yC {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_MATERIALS_IOR);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser.json.materials[e];
    if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
    const n = i.extensions[this.name];
    return (t.ior = void 0 !== n.ior ? n.ior : 1.5), Promise.resolve();
  }
}
class xC {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_MATERIALS_SPECULAR);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    (t.specularIntensity = void 0 !== r.specularFactor ? r.specularFactor : 1),
      void 0 !== r.specularTexture &&
        s.push(i.assignTexture(t, "specularIntensityMap", r.specularTexture));
    const a = r.specularColorFactor || [1, 1, 1];
    return (
      (t.specularColor = new Color().setRGB(...a, ge)),
      void 0 !== r.specularColorTexture &&
        s.push(
          i.assignTexture(t, "specularColorMap", r.specularColorTexture, me)
        ),
      Promise.all(s)
    );
  }
}
class bC {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_MATERIALS_ANISOTROPY);
  }
  getMaterialType(e) {
    const t = this.parser.json.materials[e];
    return t.extensions && t.extensions[this.name] ? Qo : null;
  }
  extendMaterialParams(e, t) {
    const i = this.parser,
      n = i.json.materials[e];
    if (!n.extensions || !n.extensions[this.name]) return Promise.resolve();
    const s = [],
      r = n.extensions[this.name];
    return (
      void 0 !== r.anisotropyStrength && (t.anisotropy = r.anisotropyStrength),
      void 0 !== r.anisotropyRotation &&
        (t.anisotropyRotation = r.anisotropyRotation),
      void 0 !== r.anisotropyTexture &&
        s.push(i.assignTexture(t, "anisotropyMap", r.anisotropyTexture)),
      Promise.all(s)
    );
  }
}
class EC {
  constructor(e) {
    (this.parser = e), (this.name = uC.KHR_TEXTURE_BASISU);
  }
  loadTexture(e) {
    const t = this.parser,
      i = t.json,
      n = i.textures[e];
    if (!n.extensions || !n.extensions[this.name]) return null;
    const s = n.extensions[this.name],
      r = t.options.ktx2Loader;
    if (!r) {
      if (i.extensionsRequired && i.extensionsRequired.indexOf(this.name) >= 0)
        throw new Error(
          "THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures"
        );
      return null;
    }
    return t.loadTextureImage(e, s.source, r);
  }
}
class SC {
  constructor(e) {
    (this.parser = e),
      (this.name = uC.EXT_TEXTURE_WEBP),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      n = i.json,
      s = n.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const r = s.extensions[t],
      a = n.images[r.source];
    let o = i.textureLoader;
    if (a.uri) {
      const e = i.options.manager.getHandler(a.uri);
      null !== e && (o = e);
    }
    return this.detectSupport().then(function (s) {
      if (s) return i.loadTextureImage(e, r.source, o);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: WebP required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA"),
            (t.onload = t.onerror =
              function () {
                e(1 === t.height);
              });
        })),
      this.isSupported
    );
  }
}
class CC {
  constructor(e) {
    (this.parser = e),
      (this.name = uC.EXT_TEXTURE_AVIF),
      (this.isSupported = null);
  }
  loadTexture(e) {
    const t = this.name,
      i = this.parser,
      n = i.json,
      s = n.textures[e];
    if (!s.extensions || !s.extensions[t]) return null;
    const r = s.extensions[t],
      a = n.images[r.source];
    let o = i.textureLoader;
    if (a.uri) {
      const e = i.options.manager.getHandler(a.uri);
      null !== e && (o = e);
    }
    return this.detectSupport().then(function (s) {
      if (s) return i.loadTextureImage(e, r.source, o);
      if (n.extensionsRequired && n.extensionsRequired.indexOf(t) >= 0)
        throw new Error(
          "THREE.GLTFLoader: AVIF required by asset but unsupported."
        );
      return i.loadTexture(e);
    });
  }
  detectSupport() {
    return (
      this.isSupported ||
        (this.isSupported = new Promise(function (e) {
          const t = new Image();
          (t.src =
            "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI="),
            (t.onload = t.onerror =
              function () {
                e(1 === t.height);
              });
        })),
      this.isSupported
    );
  }
}
class MC {
  constructor(e) {
    (this.name = uC.EXT_MESHOPT_COMPRESSION), (this.parser = e);
  }
  loadBufferView(e) {
    const t = this.parser.json,
      i = t.bufferViews[e];
    if (i.extensions && i.extensions[this.name]) {
      const e = i.extensions[this.name],
        n = this.parser.getDependency("buffer", e.buffer),
        s = this.parser.options.meshoptDecoder;
      if (!s || !s.supported) {
        if (
          t.extensionsRequired &&
          t.extensionsRequired.indexOf(this.name) >= 0
        )
          throw new Error(
            "THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files"
          );
        return null;
      }
      return n.then(function (t) {
        const i = e.byteOffset || 0,
          n = e.byteLength || 0,
          r = e.count,
          a = e.byteStride,
          o = new Uint8Array(t, i, n);
        return s.decodeGltfBufferAsync
          ? s
              .decodeGltfBufferAsync(r, a, o, e.mode, e.filter)
              .then(function (e) {
                return e.buffer;
              })
          : s.ready.then(function () {
              const t = new ArrayBuffer(r * a);
              return (
                s.decodeGltfBuffer(
                  new Uint8Array(t),
                  r,
                  a,
                  o,
                  e.mode,
                  e.filter
                ),
                t
              );
            });
      });
    }
    return null;
  }
}
class wC {
  constructor(e) {
    (this.name = uC.EXT_MESH_GPU_INSTANCING), (this.parser = e);
  }
  createNodeMesh(e) {
    const t = this.parser.json,
      i = t.nodes[e];
    if (!i.extensions || !i.extensions[this.name] || void 0 === i.mesh)
      return null;
    const n = t.meshes[i.mesh];
    for (const o of n.primitives)
      if (
        o.mode !== OC.TRIANGLES &&
        o.mode !== OC.TRIANGLE_STRIP &&
        o.mode !== OC.TRIANGLE_FAN &&
        void 0 !== o.mode
      )
        return null;
    const s = i.extensions[this.name].attributes,
      r = [],
      a = {};
    for (const o in s)
      r.push(
        this.parser
          .getDependency("accessor", s[o])
          .then((e) => ((a[o] = e), a[o]))
      );
    return r.length < 1
      ? null
      : (r.push(this.parser.createNodeMesh(e)),
        Promise.all(r).then((e) => {
          const t = e.pop(),
            i = t.isGroup ? t.children : [t],
            n = e[0].count,
            s = [];
          for (const r of i) {
            const e = new Matrix4(),
              t = new Vector3(),
              i = new Quaternion(),
              o = new Vector3(1, 1, 1),
              l = new eo(r.geometry, r.material, n);
            for (let s = 0; s < n; s++)
              a.TRANSLATION && t.fromBufferAttribute(a.TRANSLATION, s),
                a.ROTATION && i.fromBufferAttribute(a.ROTATION, s),
                a.SCALE && o.fromBufferAttribute(a.SCALE, s),
                l.setMatrixAt(s, e.compose(t, i, o));
            for (const n in a)
              "TRANSLATION" !== n &&
                "ROTATION" !== n &&
                "SCALE" !== n &&
                r.geometry.setAttribute(n, a[n]);
            Object3D.prototype.copy.call(l, r),
              this.parser.assignFinalMaterial(l),
              s.push(l);
          }
          return t.isGroup ? (t.clear(), t.add(...s), t) : s[0];
        }));
  }
}
const TC = "glTF",
  IC = 1313821514,
  RC = 5130562;
class PC {
  constructor(e) {
    (this.name = uC.KHR_BINARY_GLTF), (this.content = null), (this.body = null);
    const t = new DataView(e, 0, 12),
      i = new TextDecoder();
    if (
      ((this.header = {
        magic: i.decode(new Uint8Array(e.slice(0, 4))),
        version: t.getUint32(4, !0),
        length: t.getUint32(8, !0),
      }),
      this.header.magic !== TC)
    )
      throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
    if (this.header.version < 2)
      throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
    const n = this.header.length - 12,
      s = new DataView(e, 12);
    let r = 0;
    for (; r < n; ) {
      const t = s.getUint32(r, !0);
      r += 4;
      const n = s.getUint32(r, !0);
      if (((r += 4), n === IC)) {
        const n = new Uint8Array(e, 12 + r, t);
        this.content = i.decode(n);
      } else if (n === RC) {
        const i = 12 + r;
        this.body = e.slice(i, i + t);
      }
      r += t;
    }
    if (null === this.content)
      throw new Error("THREE.GLTFLoader: JSON content not found.");
  }
}
class DC {
  constructor(e, t) {
    if (!t)
      throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
    (this.name = uC.KHR_DRACO_MESH_COMPRESSION),
      (this.json = e),
      (this.dracoLoader = t),
      this.dracoLoader.preload();
  }
  decodePrimitive(e, t) {
    const i = this.json,
      n = this.dracoLoader,
      s = e.extensions[this.name].bufferView,
      r = e.extensions[this.name].attributes,
      a = {},
      o = {},
      l = {};
    for (const h in r) {
      const e = QC[h] || h.toLowerCase();
      a[e] = r[h];
    }
    for (const h in e.attributes) {
      const t = QC[h] || h.toLowerCase();
      if (void 0 !== r[h]) {
        const n = i.accessors[e.attributes[h]],
          s = UC[n.componentType];
        (l[t] = s.name), (o[t] = !0 === n.normalized);
      }
    }
    return t.getDependency("bufferView", s).then(function (e) {
      return new Promise(function (t) {
        n.decodeDracoFile(
          e,
          function (e) {
            for (const t in e.attributes) {
              const i = e.attributes[t],
                n = o[t];
              void 0 !== n && (i.normalized = n);
            }
            t(e);
          },
          a,
          l
        );
      });
    });
  }
}
class LC {
  constructor() {
    this.name = uC.KHR_TEXTURE_TRANSFORM;
  }
  extendTexture(e, t) {
    return (void 0 !== t.texCoord && t.texCoord !== e.channel) ||
      void 0 !== t.offset ||
      void 0 !== t.rotation ||
      void 0 !== t.scale
      ? ((e = e.clone()),
        void 0 !== t.texCoord && (e.channel = t.texCoord),
        void 0 !== t.offset && e.offset.fromArray(t.offset),
        void 0 !== t.rotation && (e.rotation = t.rotation),
        void 0 !== t.scale && e.repeat.fromArray(t.scale),
        (e.needsUpdate = !0),
        e)
      : e;
  }
}
class FC {
  constructor() {
    this.name = uC.KHR_MESH_QUANTIZATION;
  }
}
class NC extends Ko {
  constructor(e, t, i, n) {
    super(e, t, i, n);
  }
  copySampleValue_(e) {
    const t = this.resultBuffer,
      i = this.sampleValues,
      n = this.valueSize,
      s = e * n * 3 + n;
    for (let r = 0; r !== n; r++) t[r] = i[s + r];
    return t;
  }
  interpolate_(e, t, i, n) {
    const s = this.resultBuffer,
      r = this.sampleValues,
      a = this.valueSize,
      o = 2 * a,
      l = 3 * a,
      h = n - t,
      c = (i - t) / h,
      u = c * c,
      d = u * c,
      p = e * l,
      f = p - l,
      m = -2 * d + 3 * u,
      g = d - u,
      _ = 1 - m,
      v = g - u + c;
    for (let A = 0; A !== a; A++) {
      const e = r[f + A + a],
        t = r[f + A + o] * h,
        i = r[p + A + a],
        n = r[p + A] * h;
      s[A] = _ * e + v * t + m * i + g * n;
    }
    return s;
  }
}
const BC = new Quaternion();
class kC extends NC {
  interpolate_(e, t, i, n) {
    const s = super.interpolate_(e, t, i, n);
    return BC.fromArray(s).normalize().toArray(s), s;
  }
}
const OC = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123,
  },
  UC = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array,
  },
  zC = { 9728: R, 9729: L, 9984: P, 9985: F, 9986: D, 9987: N },
  GC = { 33071: T, 33648: I, 10497: w },
  VC = { SCALAR: 1, VEC2: 2, VEC3: 3, VEC4: 4, MAT2: 4, MAT3: 9, MAT4: 16 },
  QC = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex",
  },
  HC = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences",
  },
  jC = { CUBICSPLINE: void 0, LINEAR: ae, STEP: re },
  WC = "OPAQUE",
  qC = "MASK",
  XC = "BLEND";
function YC(e, t, i) {
  for (const n in i.extensions)
    void 0 === e[n] &&
      ((t.userData.gltfExtensions = t.userData.gltfExtensions || {}),
      (t.userData.gltfExtensions[n] = i.extensions[n]));
}
function KC(e, t) {
  void 0 !== t.extras &&
    ("object" == typeof t.extras
      ? Object.assign(e.userData, t.extras)
      : console.warn(
          "THREE.GLTFLoader: Ignoring primitive type .extras, " + t.extras
        ));
}
function ZC(e, t) {
  if ((e.updateMorphTargets(), void 0 !== t.weights))
    for (let i = 0, n = t.weights.length; i < n; i++)
      e.morphTargetInfluences[i] = t.weights[i];
  if (t.extras && Array.isArray(t.extras.targetNames)) {
    const i = t.extras.targetNames;
    if (e.morphTargetInfluences.length === i.length) {
      e.morphTargetDictionary = {};
      for (let t = 0, n = i.length; t < n; t++)
        e.morphTargetDictionary[i[t]] = t;
    } else
      console.warn(
        "THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names."
      );
  }
}
function JC(e) {
  let t;
  const i = e.extensions && e.extensions[uC.KHR_DRACO_MESH_COMPRESSION];
  if (
    ((t = i
      ? "draco:" + i.bufferView + ":" + i.indices + ":" + $C(i.attributes)
      : e.indices + ":" + $C(e.attributes) + ":" + e.mode),
    void 0 !== e.targets)
  )
    for (let n = 0, s = e.targets.length; n < s; n++)
      t += ":" + $C(e.targets[n]);
  return t;
}
function $C(e) {
  let t = "";
  const i = Object.keys(e).sort();
  for (let n = 0, s = i.length; n < s; n++) t += i[n] + ":" + e[i[n]] + ";";
  return t;
}
function eM(e) {
  switch (e) {
    case Int8Array:
      return 1 / 127;
    case Uint8Array:
      return 1 / 255;
    case Int16Array:
      return 1 / 32767;
    case Uint16Array:
      return 1 / 65535;
    default:
      throw new Error(
        "THREE.GLTFLoader: Unsupported normalized accessor component type."
      );
  }
}
const tM = new Matrix4();
class iM {
  constructor(e = {}, t = {}) {
    (this.json = e),
      (this.extensions = {}),
      (this.plugins = {}),
      (this.options = t),
      (this.cache = new cC()),
      (this.associations = new Map()),
      (this.primitiveCache = {}),
      (this.nodeCache = {}),
      (this.meshCache = { refs: {}, uses: {} }),
      (this.cameraCache = { refs: {}, uses: {} }),
      (this.lightCache = { refs: {}, uses: {} }),
      (this.sourceCache = {}),
      (this.textureCache = {}),
      (this.nodeNamesUsed = {});
    let i = !1,
      n = !1,
      s = -1;
    "undefined" != typeof navigator &&
      ((i = !0 === /^((?!chrome|android).)*safari/i.test(navigator.userAgent)),
      (n = navigator.userAgent.indexOf("Firefox") > -1),
      (s = n ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1)),
      "undefined" == typeof createImageBitmap || i || (n && s < 98)
        ? (this.textureLoader = new yl(this.options.manager))
        : (this.textureLoader = new Ol(this.options.manager)),
      this.textureLoader.setCrossOrigin(this.options.crossOrigin),
      this.textureLoader.setRequestHeader(this.options.requestHeader),
      (this.fileLoader = new gl(this.options.manager)),
      this.fileLoader.setResponseType("arraybuffer"),
      "use-credentials" === this.options.crossOrigin &&
        this.fileLoader.setWithCredentials(!0);
  }
  setExtensions(e) {
    this.extensions = e;
  }
  setPlugins(e) {
    this.plugins = e;
  }
  parse(e, t) {
    const i = this,
      n = this.json,
      s = this.extensions;
    this.cache.removeAll(),
      (this.nodeCache = {}),
      this._invokeAll(function (e) {
        return e._markDefs && e._markDefs();
      }),
      Promise.all(
        this._invokeAll(function (e) {
          return e.beforeRoot && e.beforeRoot();
        })
      )
        .then(function () {
          return Promise.all([
            i.getDependencies("scene"),
            i.getDependencies("animation"),
            i.getDependencies("camera"),
          ]);
        })
        .then(function (t) {
          const r = {
            scene: t[0][n.scene || 0],
            scenes: t[0],
            animations: t[1],
            cameras: t[2],
            asset: n.asset,
            parser: i,
            userData: {},
          };
          YC(s, r, n),
            KC(r, n),
            Promise.all(
              i._invokeAll(function (e) {
                return e.afterRoot && e.afterRoot(r);
              })
            ).then(function () {
              e(r);
            });
        })
        .catch(t);
  }
  _markDefs() {
    const e = this.json.nodes || [],
      t = this.json.skins || [],
      i = this.json.meshes || [];
    for (let n = 0, s = t.length; n < s; n++) {
      const i = t[n].joints;
      for (let t = 0, n = i.length; t < n; t++) e[i[t]].isBone = !0;
    }
    for (let n = 0, s = e.length; n < s; n++) {
      const t = e[n];
      void 0 !== t.mesh &&
        (this._addNodeRef(this.meshCache, t.mesh),
        void 0 !== t.skin && (i[t.mesh].isSkinnedMesh = !0)),
        void 0 !== t.camera && this._addNodeRef(this.cameraCache, t.camera);
    }
  }
  _addNodeRef(e, t) {
    void 0 !== t &&
      (void 0 === e.refs[t] && (e.refs[t] = e.uses[t] = 0), e.refs[t]++);
  }
  _getNodeRef(e, t, i) {
    if (e.refs[t] <= 1) return i;
    const n = i.clone(),
      s = (e, t) => {
        const i = this.associations.get(e);
        null != i && this.associations.set(t, i);
        for (const [n, r] of e.children.entries()) s(r, t.children[n]);
      };
    return s(i, n), (n.name += "_instance_" + e.uses[t]++), n;
  }
  _invokeOne(e) {
    const t = Object.values(this.plugins);
    t.push(this);
    for (let i = 0; i < t.length; i++) {
      const n = e(t[i]);
      if (n) return n;
    }
    return null;
  }
  _invokeAll(e) {
    const t = Object.values(this.plugins);
    t.unshift(this);
    const i = [];
    for (let n = 0; n < t.length; n++) {
      const s = e(t[n]);
      s && i.push(s);
    }
    return i;
  }
  getDependency(e, t) {
    const i = e + ":" + t;
    let n = this.cache.get(i);
    if (!n) {
      switch (e) {
        case "scene":
          n = this.loadScene(t);
          break;
        case "node":
          n = this._invokeOne(function (e) {
            return e.loadNode && e.loadNode(t);
          });
          break;
        case "mesh":
          n = this._invokeOne(function (e) {
            return e.loadMesh && e.loadMesh(t);
          });
          break;
        case "accessor":
          n = this.loadAccessor(t);
          break;
        case "bufferView":
          n = this._invokeOne(function (e) {
            return e.loadBufferView && e.loadBufferView(t);
          });
          break;
        case "buffer":
          n = this.loadBuffer(t);
          break;
        case "material":
          n = this._invokeOne(function (e) {
            return e.loadMaterial && e.loadMaterial(t);
          });
          break;
        case "texture":
          n = this._invokeOne(function (e) {
            return e.loadTexture && e.loadTexture(t);
          });
          break;
        case "skin":
          n = this.loadSkin(t);
          break;
        case "animation":
          n = this._invokeOne(function (e) {
            return e.loadAnimation && e.loadAnimation(t);
          });
          break;
        case "camera":
          n = this.loadCamera(t);
          break;
        default:
          if (
            ((n = this._invokeOne(function (i) {
              return i != this && i.getDependency && i.getDependency(e, t);
            })),
            !n)
          )
            throw new Error("Unknown type: " + e);
      }
      this.cache.add(i, n);
    }
    return n;
  }
  getDependencies(e) {
    let t = this.cache.get(e);
    if (!t) {
      const i = this,
        n = this.json[e + ("mesh" === e ? "es" : "s")] || [];
      (t = Promise.all(
        n.map(function (t, n) {
          return i.getDependency(e, n);
        })
      )),
        this.cache.add(e, t);
    }
    return t;
  }
  loadBuffer(e) {
    const t = this.json.buffers[e],
      i = this.fileLoader;
    if (t.type && "arraybuffer" !== t.type)
      throw new Error(
        "THREE.GLTFLoader: " + t.type + " buffer type is not supported."
      );
    if (void 0 === t.uri && 0 === e)
      return Promise.resolve(this.extensions[uC.KHR_BINARY_GLTF].body);
    const n = this.options;
    return new Promise(function (e, s) {
      i.load(Bl.resolveURL(t.uri, n.path), e, void 0, function () {
        s(
          new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".')
        );
      });
    });
  }
  loadBufferView(e) {
    const t = this.json.bufferViews[e];
    return this.getDependency("buffer", t.buffer).then(function (e) {
      const i = t.byteLength || 0,
        n = t.byteOffset || 0;
      return e.slice(n, n + i);
    });
  }
  loadAccessor(e) {
    const t = this,
      i = this.json,
      n = this.json.accessors[e];
    if (void 0 === n.bufferView && void 0 === n.sparse) {
      const e = VC[n.type],
        t = UC[n.componentType],
        i = !0 === n.normalized,
        s = new t(n.count * e);
      return Promise.resolve(new Wi(s, e, i));
    }
    const s = [];
    return (
      void 0 !== n.bufferView
        ? s.push(this.getDependency("bufferView", n.bufferView))
        : s.push(null),
      void 0 !== n.sparse &&
        (s.push(this.getDependency("bufferView", n.sparse.indices.bufferView)),
        s.push(this.getDependency("bufferView", n.sparse.values.bufferView))),
      Promise.all(s).then(function (e) {
        const s = e[0],
          r = VC[n.type],
          a = UC[n.componentType],
          o = a.BYTES_PER_ELEMENT,
          l = o * r,
          h = n.byteOffset || 0,
          c =
            void 0 !== n.bufferView
              ? i.bufferViews[n.bufferView].byteStride
              : void 0,
          u = !0 === n.normalized;
        let d, p;
        if (c && c !== l) {
          const e = Math.floor(h / c),
            i =
              "InterleavedBuffer:" +
              n.bufferView +
              ":" +
              n.componentType +
              ":" +
              e +
              ":" +
              n.count;
          let l = t.cache.get(i);
          l ||
            ((d = new a(s, e * c, (n.count * c) / o)),
            (l = new Ta(d, c / o)),
            t.cache.add(i, l)),
            (p = new Ra(l, r, (h % c) / o, u));
        } else (d = null === s ? new a(n.count * r) : new a(s, h, n.count * r)), (p = new Wi(d, r, u));
        if (void 0 !== n.sparse) {
          const t = VC.SCALAR,
            i = UC[n.sparse.indices.componentType],
            o = n.sparse.indices.byteOffset || 0,
            l = n.sparse.values.byteOffset || 0,
            h = new i(e[1], o, n.sparse.count * t),
            c = new a(e[2], l, n.sparse.count * r);
          null !== s && (p = new Wi(p.array.slice(), p.itemSize, p.normalized));
          for (let e = 0, n = h.length; e < n; e++) {
            const t = h[e];
            if (
              (p.setX(t, c[e * r]),
              r >= 2 && p.setY(t, c[e * r + 1]),
              r >= 3 && p.setZ(t, c[e * r + 2]),
              r >= 4 && p.setW(t, c[e * r + 3]),
              r >= 5)
            )
              throw new Error(
                "THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute."
              );
          }
        }
        return p;
      })
    );
  }
  loadTexture(e) {
    const t = this.json,
      i = this.options,
      n = t.textures[e].source,
      s = t.images[n];
    let r = this.textureLoader;
    if (s.uri) {
      const e = i.manager.getHandler(s.uri);
      null !== e && (r = e);
    }
    return this.loadTextureImage(e, n, r);
  }
  loadTextureImage(e, t, i) {
    const n = this,
      s = this.json,
      r = s.textures[e],
      a = s.images[t],
      o = (a.uri || a.bufferView) + ":" + r.sampler;
    if (this.textureCache[o]) return this.textureCache[o];
    const l = this.loadImageSource(t, i)
      .then(function (t) {
        (t.flipY = !1),
          (t.name = r.name || a.name || ""),
          "" === t.name &&
            "string" == typeof a.uri &&
            !1 === a.uri.startsWith("data:image/") &&
            (t.name = a.uri);
        const i = (s.samplers || {})[r.sampler] || {};
        return (
          (t.magFilter = zC[i.magFilter] || L),
          (t.minFilter = zC[i.minFilter] || N),
          (t.wrapS = GC[i.wrapS] || w),
          (t.wrapT = GC[i.wrapT] || w),
          n.associations.set(t, { textures: e }),
          t
        );
      })
      .catch(function () {
        return null;
      });
    return (this.textureCache[o] = l), l;
  }
  loadImageSource(e, t) {
    const i = this,
      n = this.json,
      s = this.options;
    if (void 0 !== this.sourceCache[e])
      return this.sourceCache[e].then((e) => e.clone());
    const r = n.images[e],
      a = self.URL || self.webkitURL;
    let o = r.uri || "",
      l = !1;
    if (void 0 !== r.bufferView)
      o = i.getDependency("bufferView", r.bufferView).then(function (e) {
        l = !0;
        const t = new Blob([e], { type: r.mimeType });
        return (o = a.createObjectURL(t)), o;
      });
    else if (void 0 === r.uri)
      throw new Error(
        "THREE.GLTFLoader: Image " + e + " is missing URI and bufferView"
      );
    const h = Promise.resolve(o)
      .then(function (e) {
        return new Promise(function (i, n) {
          let r = i;
          !0 === t.isImageBitmapLoader &&
            (r = function (e) {
              const t = new Texture(e);
              (t.needsUpdate = !0), i(t);
            }),
            t.load(Bl.resolveURL(e, s.path), r, void 0, n);
        });
      })
      .then(function (e) {
        var t;
        return (
          !0 === l && a.revokeObjectURL(o),
          (e.userData.mimeType =
            r.mimeType ||
            ((t = r.uri).search(/\.jpe?g($|\?)/i) > 0 ||
            0 === t.search(/^data\:image\/jpeg/)
              ? "image/jpeg"
              : t.search(/\.webp($|\?)/i) > 0 ||
                0 === t.search(/^data\:image\/webp/)
              ? "image/webp"
              : "image/png")),
          e
        );
      })
      .catch(function (e) {
        throw (console.error("THREE.GLTFLoader: Couldn't load texture", o), e);
      });
    return (this.sourceCache[e] = h), h;
  }
  assignTexture(e, t, i, n) {
    const s = this;
    return this.getDependency("texture", i.index).then(function (r) {
      if (!r) return null;
      if (
        (void 0 !== i.texCoord &&
          i.texCoord > 0 &&
          ((r = r.clone()).channel = i.texCoord),
        s.extensions[uC.KHR_TEXTURE_TRANSFORM])
      ) {
        const e =
          void 0 !== i.extensions
            ? i.extensions[uC.KHR_TEXTURE_TRANSFORM]
            : void 0;
        if (e) {
          const t = s.associations.get(r);
          (r = s.extensions[uC.KHR_TEXTURE_TRANSFORM].extendTexture(r, e)),
            s.associations.set(r, t);
        }
      }
      return void 0 !== n && (r.colorSpace = n), (e[t] = r), r;
    });
  }
  assignFinalMaterial(e) {
    const t = e.geometry;
    let i = e.material;
    const n = void 0 === t.attributes.tangent,
      s = void 0 !== t.attributes.color,
      r = void 0 === t.attributes.normal;
    if (e.isPoints) {
      const e = "PointsMaterial:" + i.uuid;
      let t = this.cache.get(e);
      t ||
        ((t = new po()),
        Material.prototype.copy.call(t, i),
        t.color.copy(i.color),
        (t.map = i.map),
        (t.sizeAttenuation = !1),
        this.cache.add(e, t)),
        (i = t);
    } else if (e.isLine) {
      const e = "LineBasicMaterial:" + i.uuid;
      let t = this.cache.get(e);
      t ||
        ((t = new to()),
        Material.prototype.copy.call(t, i),
        t.color.copy(i.color),
        (t.map = i.map),
        this.cache.add(e, t)),
        (i = t);
    }
    if (n || s || r) {
      let e = "ClonedMaterial:" + i.uuid + ":";
      n && (e += "derivative-tangents:"),
        s && (e += "vertex-colors:"),
        r && (e += "flat-shading:");
      let t = this.cache.get(e);
      t ||
        ((t = i.clone()),
        s && (t.vertexColors = !0),
        r && (t.flatShading = !0),
        n &&
          (t.normalScale && (t.normalScale.y *= -1),
          t.clearcoatNormalScale && (t.clearcoatNormalScale.y *= -1)),
        this.cache.add(e, t),
        this.associations.set(t, this.associations.get(i))),
        (i = t);
    }
    e.material = i;
  }
  getMaterialType() {
    return Vo;
  }
  loadMaterial(e) {
    const t = this,
      i = this.json,
      n = this.extensions,
      s = i.materials[e];
    let r;
    const a = {},
      o = [];
    if ((s.extensions || {})[uC.KHR_MATERIALS_UNLIT]) {
      const e = n[uC.KHR_MATERIALS_UNLIT];
      (r = e.getMaterialType()), o.push(e.extendParams(a, s, t));
    } else {
      const i = s.pbrMetallicRoughness || {};
      if (
        ((a.color = new Color(1, 1, 1)),
        (a.opacity = 1),
        Array.isArray(i.baseColorFactor))
      ) {
        const e = i.baseColorFactor;
        a.color.setRGB(e[0], e[1], e[2], ge), (a.opacity = e[3]);
      }
      void 0 !== i.baseColorTexture &&
        o.push(t.assignTexture(a, "map", i.baseColorTexture, me)),
        (a.metalness = void 0 !== i.metallicFactor ? i.metallicFactor : 1),
        (a.roughness = void 0 !== i.roughnessFactor ? i.roughnessFactor : 1),
        void 0 !== i.metallicRoughnessTexture &&
          (o.push(
            t.assignTexture(a, "metalnessMap", i.metallicRoughnessTexture)
          ),
          o.push(
            t.assignTexture(a, "roughnessMap", i.metallicRoughnessTexture)
          )),
        (r = this._invokeOne(function (t) {
          return t.getMaterialType && t.getMaterialType(e);
        })),
        o.push(
          Promise.all(
            this._invokeAll(function (t) {
              return t.extendMaterialParams && t.extendMaterialParams(e, a);
            })
          )
        );
    }
    !0 === s.doubleSided && (a.side = 2);
    const l = s.alphaMode || WC;
    if (
      (l === XC
        ? ((a.transparent = !0), (a.depthWrite = !1))
        : ((a.transparent = !1),
          l === qC &&
            (a.alphaTest = void 0 !== s.alphaCutoff ? s.alphaCutoff : 0.5)),
      void 0 !== s.normalTexture &&
        r !== Oi &&
        (o.push(t.assignTexture(a, "normalMap", s.normalTexture)),
        (a.normalScale = new Vector2(1, 1)),
        void 0 !== s.normalTexture.scale))
    ) {
      const e = s.normalTexture.scale;
      a.normalScale.set(e, e);
    }
    return (
      void 0 !== s.occlusionTexture &&
        r !== Oi &&
        (o.push(t.assignTexture(a, "aoMap", s.occlusionTexture)),
        void 0 !== s.occlusionTexture.strength &&
          (a.aoMapIntensity = s.occlusionTexture.strength)),
      void 0 !== s.emissiveFactor &&
        r !== Oi &&
        (a.emissive = new Color().setRGB(...s.emissiveFactor, ge)),
      void 0 !== s.emissiveTexture &&
        r !== Oi &&
        o.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, me)),
      Promise.all(o).then(function () {
        const i = new r(a);
        return (
          s.name && (i.name = s.name),
          KC(i, s),
          t.associations.set(i, { materials: e }),
          s.extensions && YC(n, i, s),
          i
        );
      })
    );
  }
  createUniqueName(e) {
    const t = Xl.sanitizeNodeName(e || "");
    return t in this.nodeNamesUsed
      ? t + "_" + ++this.nodeNamesUsed[t]
      : ((this.nodeNamesUsed[t] = 0), t);
  }
  loadGeometries(e) {
    const t = this,
      i = this.extensions,
      n = this.primitiveCache;
    function s(e) {
      return i[uC.KHR_DRACO_MESH_COMPRESSION]
        .decodePrimitive(e, t)
        .then(function (i) {
          return nM(i, e, t);
        });
    }
    const r = [];
    for (let a = 0, o = e.length; a < o; a++) {
      const i = e[a],
        o = JC(i),
        l = n[o];
      if (l) r.push(l.promise);
      else {
        let e;
        (e =
          i.extensions && i.extensions[uC.KHR_DRACO_MESH_COMPRESSION]
            ? s(i)
            : nM(new rn(), i, t)),
          (n[o] = { primitive: i, promise: e }),
          r.push(e);
      }
    }
    return Promise.all(r);
  }
  loadMesh(e) {
    const t = this,
      i = this.json,
      n = this.extensions,
      s = i.meshes[e],
      r = s.primitives,
      a = [];
    for (let l = 0, c = r.length; l < c; l++) {
      const e =
        void 0 === r[l].material
          ? (void 0 === (o = this.cache).DefaultMaterial &&
              (o.DefaultMaterial = new Vo({
                color: 16777215,
                emissive: 0,
                metalness: 1,
                roughness: 1,
                transparent: !1,
                depthTest: !0,
                side: h,
              })),
            o.DefaultMaterial)
          : this.getDependency("material", r[l].material);
      a.push(e);
    }
    var o;
    return (
      a.push(t.loadGeometries(r)),
      Promise.all(a).then(function (i) {
        const a = i.slice(0, i.length - 1),
          o = i[i.length - 1],
          l = [];
        for (let c = 0, u = o.length; c < u; c++) {
          const i = o[c],
            h = r[c];
          let u;
          const d = a[c];
          if (
            h.mode === OC.TRIANGLES ||
            h.mode === OC.TRIANGLE_STRIP ||
            h.mode === OC.TRIANGLE_FAN ||
            void 0 === h.mode
          )
            (u = !0 === s.isSkinnedMesh ? new za(i, d) : new En(i, d)),
              !0 === u.isSkinnedMesh && u.normalizeSkinWeights(),
              h.mode === OC.TRIANGLE_STRIP
                ? (u.geometry = hE(u.geometry, 1))
                : h.mode === OC.TRIANGLE_FAN &&
                  (u.geometry = hE(u.geometry, 2));
          else if (h.mode === OC.LINES) u = new co(i, d);
          else if (h.mode === OC.LINE_STRIP) u = new oo(i, d);
          else if (h.mode === OC.LINE_LOOP) u = new uo(i, d);
          else {
            if (h.mode !== OC.POINTS)
              throw new Error(
                "THREE.GLTFLoader: Primitive mode unsupported: " + h.mode
              );
            u = new vo(i, d);
          }
          Object.keys(u.geometry.morphAttributes).length > 0 && ZC(u, s),
            (u.name = t.createUniqueName(s.name || "mesh_" + e)),
            KC(u, s),
            h.extensions && YC(n, u, h),
            t.assignFinalMaterial(u),
            l.push(u);
        }
        for (let n = 0, s = l.length; n < s; n++)
          t.associations.set(l[n], { meshes: e, primitives: n });
        if (1 === l.length) return s.extensions && YC(n, l[0], s), l[0];
        const h = new va();
        s.extensions && YC(n, h, s), t.associations.set(h, { meshes: e });
        for (let e = 0, t = l.length; e < t; e++) h.add(l[e]);
        return h;
      })
    );
  }
  loadCamera(e) {
    let t;
    const i = this.json.cameras[e],
      n = i[i.type];
    if (n)
      return (
        "perspective" === i.type
          ? (t = new Dn(
              ze.radToDeg(n.yfov),
              n.aspectRatio || 1,
              n.znear || 1,
              n.zfar || 2e6
            ))
          : "orthographic" === i.type &&
            (t = new ns(-n.xmag, n.xmag, n.ymag, -n.ymag, n.znear, n.zfar)),
        i.name && (t.name = this.createUniqueName(i.name)),
        KC(t, i),
        Promise.resolve(t)
      );
    console.warn("THREE.GLTFLoader: Missing camera parameters.");
  }
  loadSkin(e) {
    const t = this.json.skins[e],
      i = [];
    for (let n = 0, s = t.joints.length; n < s; n++)
      i.push(this._loadNodeShallow(t.joints[n]));
    return (
      void 0 !== t.inverseBindMatrices
        ? i.push(this.getDependency("accessor", t.inverseBindMatrices))
        : i.push(null),
      Promise.all(i).then(function (e) {
        const i = e.pop(),
          n = e,
          s = [],
          r = [];
        for (let a = 0, o = n.length; a < o; a++) {
          const e = n[a];
          if (e) {
            s.push(e);
            const t = new Matrix4();
            null !== i && t.fromArray(i.array, 16 * a), r.push(t);
          } else
            console.warn(
              'THREE.GLTFLoader: Joint "%s" could not be found.',
              t.joints[a]
            );
        }
        return new ja(s, r);
      })
    );
  }
  loadAnimation(e) {
    const t = this.json,
      i = this,
      n = t.animations[e],
      s = n.name ? n.name : "animation_" + e,
      r = [],
      a = [],
      o = [],
      l = [],
      h = [];
    for (let c = 0, u = n.channels.length; c < u; c++) {
      const e = n.channels[c],
        t = n.samplers[e.sampler],
        i = e.target,
        s = i.node,
        u = void 0 !== n.parameters ? n.parameters[t.input] : t.input,
        d = void 0 !== n.parameters ? n.parameters[t.output] : t.output;
      void 0 !== i.node &&
        (r.push(this.getDependency("node", s)),
        a.push(this.getDependency("accessor", u)),
        o.push(this.getDependency("accessor", d)),
        l.push(t),
        h.push(i));
    }
    return Promise.all([
      Promise.all(r),
      Promise.all(a),
      Promise.all(o),
      Promise.all(l),
      Promise.all(h),
    ]).then(function (e) {
      const t = e[0],
        n = e[1],
        r = e[2],
        a = e[3],
        o = e[4],
        l = [];
      for (let s = 0, h = t.length; s < h; s++) {
        const e = t[s],
          h = n[s],
          c = r[s],
          u = a[s],
          d = o[s];
        if (void 0 === e) continue;
        e.updateMatrix && e.updateMatrix();
        const p = i._createAnimationTracks(e, h, c, u, d);
        if (p) for (let t = 0; t < p.length; t++) l.push(p[t]);
      }
      return new ll(s, void 0, l);
    });
  }
  createNodeMesh(e) {
    const t = this.json,
      i = this,
      n = t.nodes[e];
    return void 0 === n.mesh
      ? null
      : i.getDependency("mesh", n.mesh).then(function (e) {
          const t = i._getNodeRef(i.meshCache, n.mesh, e);
          return (
            void 0 !== n.weights &&
              t.traverse(function (e) {
                if (e.isMesh)
                  for (let t = 0, i = n.weights.length; t < i; t++)
                    e.morphTargetInfluences[t] = n.weights[t];
              }),
            t
          );
        });
  }
  loadNode(e) {
    const t = this,
      i = this.json.nodes[e],
      n = t._loadNodeShallow(e),
      s = [],
      r = i.children || [];
    for (let o = 0, l = r.length; o < l; o++)
      s.push(t.getDependency("node", r[o]));
    const a =
      void 0 === i.skin
        ? Promise.resolve(null)
        : t.getDependency("skin", i.skin);
    return Promise.all([n, Promise.all(s), a]).then(function (e) {
      const t = e[0],
        i = e[1],
        n = e[2];
      null !== n &&
        t.traverse(function (e) {
          e.isSkinnedMesh && e.bind(n, tM);
        });
      for (let s = 0, r = i.length; s < r; s++) t.add(i[s]);
      return t;
    });
  }
  _loadNodeShallow(e) {
    const t = this.json,
      i = this.extensions,
      n = this;
    if (void 0 !== this.nodeCache[e]) return this.nodeCache[e];
    const s = t.nodes[e],
      r = s.name ? n.createUniqueName(s.name) : "",
      a = [],
      o = n._invokeOne(function (t) {
        return t.createNodeMesh && t.createNodeMesh(e);
      });
    return (
      o && a.push(o),
      void 0 !== s.camera &&
        a.push(
          n.getDependency("camera", s.camera).then(function (e) {
            return n._getNodeRef(n.cameraCache, s.camera, e);
          })
        ),
      n
        ._invokeAll(function (t) {
          return t.createNodeAttachment && t.createNodeAttachment(e);
        })
        .forEach(function (e) {
          a.push(e);
        }),
      (this.nodeCache[e] = Promise.all(a).then(function (t) {
        let a;
        if (
          ((a =
            !0 === s.isBone
              ? new Ga()
              : t.length > 1
              ? new va()
              : 1 === t.length
              ? t[0]
              : new Object3D()),
          a !== t[0])
        )
          for (let e = 0, i = t.length; e < i; e++) a.add(t[e]);
        if (
          (s.name && ((a.userData.name = s.name), (a.name = r)),
          KC(a, s),
          s.extensions && YC(i, a, s),
          void 0 !== s.matrix)
        ) {
          const e = new Matrix4();
          e.fromArray(s.matrix), a.applyMatrix4(e);
        } else void 0 !== s.translation && a.position.fromArray(s.translation), void 0 !== s.rotation && a.quaternion.fromArray(s.rotation), void 0 !== s.scale && a.scale.fromArray(s.scale);
        return (
          n.associations.has(a) || n.associations.set(a, {}),
          (n.associations.get(a).nodes = e),
          a
        );
      })),
      this.nodeCache[e]
    );
  }
  loadScene(e) {
    const t = this.extensions,
      i = this.json.scenes[e],
      n = this,
      s = new va();
    i.name && (s.name = n.createUniqueName(i.name)),
      KC(s, i),
      i.extensions && YC(t, s, i);
    const r = i.nodes || [],
      a = [];
    for (let o = 0, l = r.length; o < l; o++)
      a.push(n.getDependency("node", r[o]));
    return Promise.all(a).then(function (e) {
      for (let t = 0, i = e.length; t < i; t++) s.add(e[t]);
      return (
        (n.associations = ((e) => {
          const t = new Map();
          for (const [i, s] of n.associations)
            (i instanceof Material || i instanceof Texture) && t.set(i, s);
          return (
            e.traverse((e) => {
              const i = n.associations.get(e);
              null != i && t.set(e, i);
            }),
            t
          );
        })(s)),
        s
      );
    });
  }
  _createAnimationTracks(e, t, i, n, s) {
    const r = [],
      a = e.name ? e.name : e.uuid,
      o = [];
    let l;
    switch (
      (HC[s.path] === HC.weights
        ? e.traverse(function (e) {
            e.morphTargetInfluences && o.push(e.name ? e.name : e.uuid);
          })
        : o.push(a),
      HC[s.path])
    ) {
      case HC.weights:
        l = nl;
        break;
      case HC.rotation:
        l = rl;
        break;
      case HC.position:
      case HC.scale:
        l = ol;
        break;
      default:
        if (1 === i.itemSize) l = nl;
        else l = ol;
    }
    const h = void 0 !== n.interpolation ? jC[n.interpolation] : ae,
      c = this._getArrayFromAccessor(i);
    for (let u = 0, d = o.length; u < d; u++) {
      const e = new l(o[u] + "." + HC[s.path], t.array, c, h);
      "CUBICSPLINE" === n.interpolation &&
        this._createCubicSplineTrackInterpolant(e),
        r.push(e);
    }
    return r;
  }
  _getArrayFromAccessor(e) {
    let t = e.array;
    if (e.normalized) {
      const e = eM(t.constructor),
        i = new Float32Array(t.length);
      for (let n = 0, s = t.length; n < s; n++) i[n] = t[n] * e;
      t = i;
    }
    return t;
  }
  _createCubicSplineTrackInterpolant(e) {
    (e.createInterpolant = function (e) {
      return new (this instanceof rl ? kC : NC)(
        this.times,
        this.values,
        this.getValueSize() / 3,
        e
      );
    }),
      (e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0);
  }
}
function nM(e, t, i) {
  const n = t.attributes,
    s = [];
  function r(t, n) {
    return i.getDependency("accessor", t).then(function (t) {
      e.setAttribute(n, t);
    });
  }
  for (const a in n) {
    const t = QC[a] || a.toLowerCase();
    t in e.attributes || s.push(r(n[a], t));
  }
  if (void 0 !== t.indices && !e.index) {
    const n = i.getDependency("accessor", t.indices).then(function (t) {
      e.setIndex(t);
    });
    s.push(n);
  }
  return (
    KC(e, t),
    (function (e, t, i) {
      const n = t.attributes,
        s = new Box3();
      if (void 0 === n.POSITION) return;
      {
        const e = i.json.accessors[n.POSITION],
          t = e.min,
          r = e.max;
        if (void 0 === t || void 0 === r)
          return void console.warn(
            "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
          );
        if (
          (s.set(new Vector3(t[0], t[1], t[2]), new Vector3(r[0], r[1], r[2])),
          e.normalized)
        ) {
          const t = eM(UC[e.componentType]);
          s.min.multiplyScalar(t), s.max.multiplyScalar(t);
        }
      }
      const r = t.targets;
      if (void 0 !== r) {
        const e = new Vector3(),
          t = new Vector3();
        for (let n = 0, s = r.length; n < s; n++) {
          const s = r[n];
          if (void 0 !== s.POSITION) {
            const n = i.json.accessors[s.POSITION],
              r = n.min,
              a = n.max;
            if (void 0 !== r && void 0 !== a) {
              if (
                (t.setX(Math.max(Math.abs(r[0]), Math.abs(a[0]))),
                t.setY(Math.max(Math.abs(r[1]), Math.abs(a[1]))),
                t.setZ(Math.max(Math.abs(r[2]), Math.abs(a[2]))),
                n.normalized)
              ) {
                const e = eM(UC[n.componentType]);
                t.multiplyScalar(e);
              }
              e.max(t);
            } else
              console.warn(
                "THREE.GLTFLoader: Missing min/max properties for accessor POSITION."
              );
          }
        }
        s.expandByVector(e);
      }
      e.boundingBox = s;
      const a = new kt();
      s.getCenter(a.center),
        (a.radius = s.min.distanceTo(s.max) / 2),
        (e.boundingSphere = a);
    })(e, t, i),
    Promise.all(s).then(function () {
      return void 0 !== t.targets
        ? (function (e, t, i) {
            let n = !1,
              s = !1,
              r = !1;
            for (let h = 0, c = t.length; h < c; h++) {
              const e = t[h];
              if (
                (void 0 !== e.POSITION && (n = !0),
                void 0 !== e.NORMAL && (s = !0),
                void 0 !== e.COLOR_0 && (r = !0),
                n && s && r)
              )
                break;
            }
            if (!n && !s && !r) return Promise.resolve(e);
            const a = [],
              o = [],
              l = [];
            for (let h = 0, c = t.length; h < c; h++) {
              const c = t[h];
              if (n) {
                const t =
                  void 0 !== c.POSITION
                    ? i.getDependency("accessor", c.POSITION)
                    : e.attributes.position;
                a.push(t);
              }
              if (s) {
                const t =
                  void 0 !== c.NORMAL
                    ? i.getDependency("accessor", c.NORMAL)
                    : e.attributes.normal;
                o.push(t);
              }
              if (r) {
                const t =
                  void 0 !== c.COLOR_0
                    ? i.getDependency("accessor", c.COLOR_0)
                    : e.attributes.color;
                l.push(t);
              }
            }
            return Promise.all([
              Promise.all(a),
              Promise.all(o),
              Promise.all(l),
            ]).then(function (t) {
              const i = t[0],
                a = t[1],
                o = t[2];
              return (
                n && (e.morphAttributes.position = i),
                s && (e.morphAttributes.normal = a),
                r && (e.morphAttributes.color = o),
                (e.morphTargetsRelative = !0),
                e
              );
            });
          })(e, t.targets, i)
        : e;
    })
  );
}
class sM extends lC {
  constructor(e = dl) {
    super(), (this.manager = e), (this.adjustmentTransform = new Matrix4());
  }
  parse(e) {
    const t = super.parse(e),
      i = t.glbBytes.slice().buffer;
    return new Promise((e, n) => {
      const s = this.manager,
        r = this.fetchOptions,
        a = s.getHandler("path.gltf") || new hC(s);
      "include" === r.credentials &&
        "cors" === r.mode &&
        a.setCrossOrigin("use-credentials"),
        "credentials" in r && a.setWithCredentials("include" === r.credentials),
        r.headers && a.setRequestHeader(r.headers);
      let o = this.workingPath;
      !/[\\/]$/.test(o) && o.length && (o += "/");
      const l = this.adjustmentTransform;
      a.parse(
        i,
        o,
        (i) => {
          const { batchTable: n, featureTable: s } = t,
            { scene: r } = i,
            a = s.getData("RTC_CENTER");
          a &&
            ((r.position.x += a[0]),
            (r.position.y += a[1]),
            (r.position.z += a[2])),
            i.scene.updateMatrix(),
            i.scene.matrix.multiply(l),
            i.scene.matrix.decompose(
              i.scene.position,
              i.scene.quaternion,
              i.scene.scale
            ),
            (i.batchTable = n),
            (i.featureTable = s),
            (r.batchTable = n),
            (r.featureTable = s),
            e(i);
        },
        n
      );
    });
  }
}
class rM extends aC {
  parse(e) {
    const t = new DataView(e),
      i = oC(t);
    console.assert("pnts" === i);
    const n = t.getUint32(4, !0);
    console.assert(1 === n);
    const s = t.getUint32(8, !0);
    console.assert(s === e.byteLength);
    const r = t.getUint32(12, !0),
      a = t.getUint32(16, !0),
      o = t.getUint32(20, !0),
      l = t.getUint32(24, !0),
      h = e.slice(28, 28 + r + a),
      c = new sC(h, 0, r, a),
      u = 28 + r + a,
      d = e.slice(u, u + o + l),
      p = new rC(
        d,
        c.getData("BATCH_LENGTH") || c.getData("POINTS_LENGTH"),
        0,
        o,
        l
      );
    return Promise.resolve({ version: n, featureTable: c, batchTable: p });
  }
}
const aM = { RGB: "color", POSITION: "position" };
class oM extends rM {
  constructor(e = dl) {
    super(), (this.manager = e);
  }
  parse(e) {
    return super.parse(e).then(async (e) => {
      const { featureTable: t } = e,
        i = new po(),
        n = t.header.extensions;
      let s;
      if (n && n["3DTILES_draco_point_compression"]) {
        const {
            byteOffset: e,
            byteLength: r,
            properties: a,
          } = n["3DTILES_draco_point_compression"],
          o = this.manager.getHandler("draco.drc");
        if (null == o)
          throw new Error("PNTSLoader: dracoLoader not available.");
        const l = {};
        for (const t in a)
          if (t in aM && t in a) {
            l[aM[t]] = a[t];
          }
        const h = {
            attributeIDs: l,
            attributeTypes: { position: "Float32Array", color: "Uint8Array" },
            useUniqueIDs: !0,
          },
          c = t.getBuffer(e, r);
        (s = await o.decodeGeometry(c, h)),
          s.attributes.color && (i.vertexColors = !0);
      } else {
        const e = t.getData("POINTS_LENGTH"),
          n = t.getData("POSITION", e, "FLOAT", "VEC3"),
          r = t.getData("RGB", e, "UNSIGNED_BYTE", "VEC3");
        (s = new rn()),
          s.setAttribute("position", new Wi(n, 3, !1)),
          null !== r &&
            (s.setAttribute("color", new Wi(r, 3, !0)), (i.vertexColors = !0));
      }
      [
        "QUANTIZED_VOLUME_OFFSET",
        "QUANTIZED_VOLUME_SCALE",
        "CONSTANT_RGBA",
        "BATCH_LENGTH",
        "POSITION_QUANTIZED",
        "RGBA",
        "RGB565",
        "NORMAL",
        "NORMAL_OCT16P",
      ].forEach((e) => {
        e in t.header &&
          console.warn(
            `PNTSLoader: Unsupported FeatureTable feature "${e}" detected.`
          );
      });
      const r = new vo(s, i);
      (e.scene = r), (e.scene.featureTable = t);
      const a = t.getData("RTC_CENTER");
      return (
        a &&
          ((e.scene.position.x += a[0]),
          (e.scene.position.y += a[1]),
          (e.scene.position.z += a[2])),
        e
      );
    });
  }
}
class lM extends aC {
  parse(e) {
    const t = new DataView(e),
      i = oC(t);
    console.assert("i3dm" === i);
    const n = t.getUint32(4, !0);
    console.assert(1 === n);
    const s = t.getUint32(8, !0);
    console.assert(s === e.byteLength);
    const r = t.getUint32(12, !0),
      a = t.getUint32(16, !0),
      o = t.getUint32(20, !0),
      l = t.getUint32(24, !0),
      h = t.getUint32(28, !0),
      c = e.slice(32, 32 + r + a),
      u = new sC(c, 0, r, a),
      d = 32 + r + a,
      p = e.slice(d, d + o + l),
      f = new rC(p, u.getData("INSTANCES_LENGTH"), 0, o, l),
      m = d + o + l,
      g = new Uint8Array(e, m, s - m);
    let _ = null,
      v = null;
    if (h) (_ = g), (v = Promise.resolve());
    else {
      const e = this.resolveExternalURL(nC(g));
      v = fetch(e, this.fetchOptions)
        .then((t) => {
          if (!t.ok)
            throw new Error(
              `I3DMLoaderBase : Failed to load file "${e}" with status ${t.status} : ${t.statusText}`
            );
          return t.arrayBuffer();
        })
        .then((e) => {
          _ = new Uint8Array(e);
        });
    }
    return v.then(() => ({
      version: n,
      featureTable: u,
      batchTable: f,
      glbBytes: _,
    }));
  }
}
const hM = new Vector3(),
  cM = new Vector3(),
  uM = new Vector3(),
  dM = new Vector3(),
  pM = new Quaternion(),
  fM = new Vector3(),
  mM = new Matrix4();
class gM extends lM {
  constructor(e = dl) {
    super(), (this.manager = e), (this.adjustmentTransform = new Matrix4());
  }
  resolveExternalURL(e) {
    return this.manager.resolveURL(super.resolveExternalURL(e));
  }
  parse(e) {
    return super.parse(e).then((e) => {
      const { featureTable: t, batchTable: i } = e,
        n = e.glbBytes.slice().buffer;
      return new Promise((e, s) => {
        const r = this.fetchOptions,
          a = this.manager,
          o = a.getHandler("path.gltf") || new hC(a);
        "include" === r.credentials &&
          "cors" === r.mode &&
          o.setCrossOrigin("use-credentials"),
          "credentials" in r &&
            o.setWithCredentials("include" === r.credentials),
          r.headers && o.setRequestHeader(r.headers);
        let l = this.workingPath;
        /[\\/]$/.test(l) || (l += "/");
        const h = this.adjustmentTransform;
        o.parse(
          n,
          l,
          (n) => {
            const s = t.getData("INSTANCES_LENGTH"),
              r = t.getData("POSITION", s, "FLOAT", "VEC3"),
              a = t.getData("NORMAL_UP", s, "FLOAT", "VEC3"),
              o = t.getData("NORMAL_RIGHT", s, "FLOAT", "VEC3"),
              l = t.getData("SCALE_NON_UNIFORM", s, "FLOAT", "VEC3"),
              c = t.getData("SCALE", s, "FLOAT", "SCALAR");
            [
              "RTC_CENTER",
              "QUANTIZED_VOLUME_OFFSET",
              "QUANTIZED_VOLUME_SCALE",
              "EAST_NORTH_UP",
              "POSITION_QUANTIZED",
              "NORMAL_UP_OCT32P",
              "NORMAL_RIGHT_OCT32P",
            ].forEach((e) => {
              e in t.header &&
                console.warn(
                  `I3DMLoader: Unsupported FeatureTable feature "${e}" detected.`
                );
            });
            const u = new Map(),
              d = [];
            n.scene.traverse((e) => {
              if (e.isMesh) {
                const { geometry: t, material: i } = e,
                  n = new eo(t, i, s);
                n.position.copy(e.position),
                  n.rotation.copy(e.rotation),
                  n.scale.copy(e.scale),
                  d.push(n),
                  u.set(e, n);
              }
            });
            const p = new Vector3();
            for (let e = 0; e < s; e++)
              (p.x += r[3 * e + 0] / s),
                (p.y += r[3 * e + 1] / s),
                (p.z += r[3 * e + 2] / s);
            u.forEach((e, t) => {
              const i = t.parent;
              i &&
                (i.remove(t),
                i.add(e),
                e.updateMatrixWorld(),
                e.position.copy(p).applyMatrix4(e.matrixWorld));
            });
            for (let e = 0; e < s; e++) {
              dM.set(
                r[3 * e + 0] - p.x,
                r[3 * e + 1] - p.y,
                r[3 * e + 2] - p.z
              ),
                a
                  ? (cM.set(a[3 * e + 0], a[3 * e + 1], a[3 * e + 2]),
                    uM.set(o[3 * e + 0], o[3 * e + 1], o[3 * e + 2]),
                    hM.crossVectors(uM, cM).normalize(),
                    mM.makeBasis(uM, cM, hM),
                    pM.setFromRotationMatrix(mM))
                  : pM.set(0, 0, 0, 1),
                c
                  ? fM.setScalar(c[e])
                  : l
                  ? fM.set(l[3 * e + 0], l[3 * e + 1], l[3 * e + 2])
                  : fM.set(1, 1, 1),
                mM.compose(dM, pM, fM).multiply(h);
              for (let t = 0, i = d.length; t < i; t++) {
                d[t].setMatrixAt(e, mM);
              }
            }
            (n.batchTable = i),
              (n.featureTable = t),
              (n.scene.batchTable = i),
              (n.scene.featureTable = t),
              e(n);
          },
          s
        );
      });
    });
  }
}
class _M extends aC {
  parse(e) {
    const t = new DataView(e),
      i = oC(t);
    console.assert("cmpt" === i, 'CMPTLoader: The magic bytes equal "cmpt".');
    const n = t.getUint32(4, !0);
    console.assert(
      1 === n,
      'CMPTLoader: The version listed in the header is "1".'
    );
    const s = t.getUint32(8, !0);
    console.assert(
      s === e.byteLength,
      "CMPTLoader: The contents buffer length listed in the header matches the file."
    );
    const r = t.getUint32(12, !0),
      a = [];
    let o = 16;
    for (let l = 0; l < r; l++) {
      const t = new DataView(e, o, 12),
        i = oC(t),
        n = t.getUint32(4, !0),
        s = t.getUint32(8, !0),
        r = new Uint8Array(e, o, s);
      a.push({ type: i, buffer: r, version: n }), (o += s);
    }
    return { version: n, tiles: a };
  }
}
class vM extends _M {
  constructor(e = dl) {
    super(), (this.manager = e), (this.adjustmentTransform = new Matrix4());
  }
  parse(e) {
    const t = super.parse(e),
      i = this.manager,
      n = this.adjustmentTransform,
      s = [];
    for (const r in t.tiles) {
      const { type: e, buffer: a } = t.tiles[r];
      switch (e) {
        case "b3dm": {
          const e = a.slice(),
            t = new sM(i);
          (t.workingPath = this.workingPath),
            (t.fetchOptions = this.fetchOptions),
            t.adjustmentTransform.copy(n);
          const r = t.parse(e.buffer);
          s.push(r);
          break;
        }
        case "pnts": {
          const e = a.slice(),
            t = new oM(i);
          (t.workingPath = this.workingPath),
            (t.fetchOptions = this.fetchOptions);
          const n = t.parse(e.buffer);
          s.push(n);
          break;
        }
        case "i3dm": {
          const e = a.slice(),
            t = new gM(i);
          (t.workingPath = this.workingPath),
            (t.fetchOptions = this.fetchOptions),
            t.adjustmentTransform.copy(n);
          const r = t.parse(e.buffer);
          s.push(r);
          break;
        }
      }
    }
    return Promise.all(s).then((e) => {
      const t = new va();
      return (
        e.forEach((e) => {
          t.add(e.scene);
        }),
        { tiles: e, scene: t }
      );
    });
  }
}
class AM {
  constructor() {
    this.name = "CESIUM_RTC";
  }
  afterRoot(e) {
    if (e.parser.json.extensions && e.parser.json.extensions.CESIUM_RTC) {
      const { center: t } = e.parser.json.extensions.CESIUM_RTC;
      t &&
        ((e.scene.position.x += t[0]),
        (e.scene.position.y += t[1]),
        (e.scene.position.z += t[2]));
    }
  }
}
class yM extends aC {
  constructor(e = dl) {
    super(), (this.manager = e);
  }
  parse(e) {
    return new Promise((t, i) => {
      const n = this.manager,
        s = this.fetchOptions;
      let r = n.getHandler("path.gltf") || n.getHandler("path.glb");
      r ||
        ((r = new hC(n)),
        r.register(() => new AM()),
        "include" === s.credentials &&
          "cors" === s.mode &&
          r.setCrossOrigin("use-credentials"),
        "credentials" in s && r.setWithCredentials("include" === s.credentials),
        s.headers && r.setRequestHeader(s.headers));
      let a = r.resourcePath || r.path || this.workingPath;
      !/[\\/]$/.test(a) && a.length && (a += "/"),
        r.parse(
          e,
          a,
          (e) => {
            t(e);
          },
          i
        );
    });
  }
}
const xM = new Matrix4();
class bM extends va {
  constructor(e) {
    super(), (this.name = "TilesRenderer.TilesGroup"), (this.tilesRenderer = e);
  }
  raycast(e, t) {
    this.tilesRenderer.optimizeRaycast && this.tilesRenderer.raycast(e, t);
  }
  updateMatrixWorld(e) {
    if (
      (this.matrixAutoUpdate && this.updateMatrix(),
      this.matrixWorldNeedsUpdate || e)
    ) {
      null === this.parent
        ? xM.copy(this.matrix)
        : xM.multiplyMatrices(this.parent.matrixWorld, this.matrix),
        (this.matrixWorldNeedsUpdate = !1);
      const e = xM.elements,
        t = this.matrixWorld.elements;
      let i = !1;
      for (let n = 0; n < 16; n++) {
        const s = e[n],
          r = t[n];
        if (Math.abs(s - r) > Number.EPSILON) {
          i = !0;
          break;
        }
      }
      if (i) {
        this.matrixWorld.copy(xM);
        const e = this.children;
        for (let t = 0, i = e.length; t < i; t++) e[t].updateMatrixWorld();
      }
    }
  }
}
function EM(e) {
  const { x: t, y: i, z: n } = e;
  (e.x = n), (e.y = t), (e.z = i);
}
const SM = new (class {
    constructor(e = 1, t = 0, i = 0) {
      return (this.radius = e), (this.phi = t), (this.theta = i), this;
    }
    set(e, t, i) {
      return (this.radius = e), (this.phi = t), (this.theta = i), this;
    }
    copy(e) {
      return (
        (this.radius = e.radius),
        (this.phi = e.phi),
        (this.theta = e.theta),
        this
      );
    }
    makeSafe() {
      const e = 1e-6;
      return (this.phi = Math.max(e, Math.min(Math.PI - e, this.phi))), this;
    }
    setFromVector3(e) {
      return this.setFromCartesianCoords(e.x, e.y, e.z);
    }
    setFromCartesianCoords(e, t, i) {
      return (
        (this.radius = Math.sqrt(e * e + t * t + i * i)),
        0 === this.radius
          ? ((this.theta = 0), (this.phi = 0))
          : ((this.theta = Math.atan2(e, i)),
            (this.phi = Math.acos(De(t / this.radius, -1, 1)))),
        this
      );
    }
    clone() {
      return new this.constructor().copy(this);
    }
  })(),
  CM = new Vector3(),
  MM = new Vector3();
class wM {
  constructor(e = 1, t = 1, i = 1) {
    this.radius = new Vector3(e, t, i);
  }
  getCartographicToPosition(e, t, i, n) {
    const s = this.radius;
    SM.set(1, -e + Math.PI / 2, t),
      CM.setFromSpherical(SM).normalize(),
      EM(CM),
      MM.copy(CM),
      (MM.x *= s.x ** 2),
      (MM.y *= s.y ** 2),
      (MM.z *= s.z ** 2);
    const r = Math.sqrt(CM.dot(MM));
    return MM.divideScalar(r), n.copy(MM).addScaledVector(CM, i);
  }
  getCartographicToNormal(e, t, i) {
    return (
      SM.set(1, -e + Math.PI / 2, t),
      i.setFromSpherical(SM).normalize(),
      EM(i),
      i
    );
  }
  getPositionToNormal(e, t) {
    const i = this.radius;
    return (
      t.copy(e),
      (t.x /= i.x ** 2),
      (t.y /= i.y ** 2),
      (t.z /= i.z ** 2),
      t.normalize(),
      t
    );
  }
}
const TM = Math.PI,
  IM = TM / 2,
  RM = new Vector3(),
  PM = new Vector3(),
  DM = new Vector3(),
  LM = new Matrix4();
let FM = 0;
const NM = [];
function BM(e = !1) {
  return e
    ? (NM[FM] || (NM[FM] = new Vector3()), FM++, NM[FM - 1])
    : new Vector3();
}
function kM() {
  FM = 0;
}
class OM extends wM {
  constructor(e, t, i, n = -IM, s = IM, r = 0, a = 2 * TM, o = 0, l = 0) {
    super(e, t, i),
      (this.latStart = n),
      (this.latEnd = s),
      (this.lonStart = r),
      (this.lonEnd = a),
      (this.heightStart = o),
      (this.heightEnd = l);
  }
  _getPoints(e = !1) {
    const {
        latStart: t,
        latEnd: i,
        lonStart: n,
        lonEnd: s,
        heightStart: r,
        heightEnd: a,
      } = this,
      o = ze.mapLinear(0.5, 0, 1, t, i),
      l = ze.mapLinear(0.5, 0, 1, n, s),
      h = Math.floor(n / IM) * IM,
      c = [
        [-TM / 2, 0],
        [TM / 2, 0],
        [0, h],
        [0, h + TM / 2],
        [0, h + TM],
        [0, h + (3 * TM) / 2],
        [t, s],
        [i, s],
        [t, n],
        [i, n],
        [0, n],
        [0, s],
        [o, l],
        [t, l],
        [i, l],
        [o, n],
        [o, s],
      ],
      u = [],
      d = c.length;
    for (let p = 0; p <= 1; p++) {
      const o = ze.mapLinear(p, 0, 1, r, a);
      for (let r = 0, a = d; r < a; r++) {
        const [a, l] = c[r];
        if (a >= t && a <= i && l >= n && l <= s) {
          const t = BM(e);
          u.push(t), this.getCartographicToPosition(a, l, o, t);
        }
      }
    }
    return u;
  }
  getBoundingBox(e, t) {
    kM();
    const { latStart: i, latEnd: n, lonStart: s, lonEnd: r } = this;
    if (n - i < TM / 2) {
      const e = ze.mapLinear(0.5, 0, 1, i, n),
        a = ze.mapLinear(0.5, 0, 1, s, r);
      this.getCartographicToNormal(e, a, DM),
        PM.set(0, 0, 1),
        RM.crossVectors(PM, DM),
        PM.crossVectors(RM, DM),
        t.makeBasis(RM, PM, DM);
    } else
      RM.set(1, 0, 0),
        PM.set(0, 1, 0),
        DM.set(0, 0, 1),
        t.makeBasis(RM, PM, DM);
    LM.copy(t).invert();
    const a = this._getPoints(!0);
    for (let o = 0, l = a.length; o < l; o++) a[o].applyMatrix4(LM);
    e.makeEmpty(), e.setFromPoints(a);
  }
  getBoundingSphere(e, t) {
    kM();
    const i = this._getPoints(!0);
    e.makeEmpty(), e.setFromPoints(i, t);
  }
}
const UM = new kt(),
  zM = new Matrix4(),
  GM = new Vector3(),
  VM = new Vector3(),
  QM = new jt(),
  HM = [];
function jM(e, t) {
  return e.distance - t.distance;
}
function WM(e, t, i) {
  e.traverse((e) => {
    Object.getPrototypeOf(e).raycast.call(e, t, i);
  });
}
function qM(e, t, i, n) {
  if (i.has(e)) {
    if ((WM(e.cached.scene, n, HM), HM.length > 0)) {
      HM.length > 1 && HM.sort(jM);
      const e = HM[0];
      return (HM.length = 0), e;
    }
    return null;
  }
  const s = [],
    r = e.children;
  for (let l = 0, h = r.length; l < h; l++) {
    const e = r[l],
      i = e.cached,
      a = t.matrixWorld;
    zM.copy(a);
    const o = i.sphere;
    if (o && (UM.copy(o), UM.applyMatrix4(zM), !n.ray.intersectsSphere(UM)))
      continue;
    const h = i.box,
      c = i.boxTransform;
    if (h) {
      if (
        (zM.multiply(c).invert(),
        QM.copy(n.ray),
        QM.applyMatrix4(zM),
        !QM.intersectBox(h, GM))
      )
        continue;
      {
        VM.setFromMatrixScale(zM);
        const t = VM.x;
        Math.abs(Math.max(VM.x - VM.y, VM.x - VM.z)) > 1e-6 &&
          console.warn(
            "ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when raycasting."
          );
        const i = { distance: 1 / 0, tile: null };
        s.push(i),
          h.containsPoint(QM.origin)
            ? (i.distance = 0)
            : (i.distance = GM.distanceToSquared(QM.origin) * t * t),
          (i.tile = e);
      }
    }
  }
  s.sort(jM);
  let a = 1 / 0,
    o = null;
  for (let l = 0, h = s.length; l < h; l++) {
    const e = s[l];
    if (e.distance > a) break;
    {
      const s = e.tile,
        r = s.cached.scene;
      let l = null;
      if (
        (i.has(s)
          ? (WM(r, n, HM),
            HM.length > 0 && (HM.length > 1 && HM.sort(jM), (l = HM[0])))
          : (l = qM(s, t, i, n)),
        l)
      ) {
        const e = l.distance * l.distance;
        e < a && ((a = e), (o = l)), (HM.length = 0);
      }
    }
  }
  return o;
}
function XM(e, t, i, n, s) {
  const r = e.cached,
    a = t.matrixWorld;
  zM.copy(a);
  const o = r.sphere;
  if (o && (UM.copy(o), UM.applyMatrix4(zM), !n.ray.intersectsSphere(UM)))
    return;
  const l = r.box,
    h = r.boxTransform;
  if (
    l &&
    (zM.multiply(h).invert(),
    QM.copy(n.ray).applyMatrix4(zM),
    !QM.intersectsBox(l))
  )
    return;
  const c = r.scene;
  if (i.has(e)) return void WM(c, n, s);
  const u = e.children;
  for (let d = 0, p = u.length; d < p; d++) XM(u[d], t, i, n, s);
}
const YM = Symbol("INITIAL_FRUSTUM_CULLED"),
  KM = new Matrix4(),
  ZM = new Matrix4(),
  JM = new Vector3(),
  $M = new Vector3(),
  ew = new Vector3(),
  tw = new Vector3(),
  iw = new Vector3(1, 0, 0),
  nw = new Vector3(0, 1, 0);
function sw(e, t) {
  e.traverse((e) => {
    e.frustumCulled = e[YM] && t;
  });
}
class rw extends iC {
  get autoDisableRendererCulling() {
    return this._autoDisableRendererCulling;
  }
  set autoDisableRendererCulling(e) {
    this._autoDisableRendererCulling !== e &&
      ((super._autoDisableRendererCulling = e),
      this.forEachLoadedModel((t) => {
        sw(t, !e);
      }));
  }
  constructor(...e) {
    super(...e),
      (this.group = new bM(this)),
      (this.cameras = []),
      (this.cameraMap = new Map()),
      (this.cameraInfo = []),
      (this.activeTiles = new Set()),
      (this.visibleTiles = new Set()),
      (this._autoDisableRendererCulling = !0),
      (this.optimizeRaycast = !0),
      (this.onLoadTileSet = null),
      (this.onLoadModel = null),
      (this.onDisposeModel = null),
      (this.onTileVisibilityChange = null);
    const t = new ul();
    t.setURLModifier((e) => (this.preprocessURL ? this.preprocessURL(e) : e)),
      (this.manager = t);
    const i = this;
    this._overridenRaycast = function (e, t) {
      i.optimizeRaycast || Object.getPrototypeOf(this).raycast.call(this, e, t);
    };
  }
  getBounds(e) {
    if (!this.root) return !1;
    const t = this.root.cached,
      i = t.box,
      n = t.boxTransform;
    return !!i && (e.copy(i), e.applyMatrix4(n), !0);
  }
  getOrientedBounds(e, t) {
    if (!this.root) return !1;
    const i = this.root.cached,
      n = i.box,
      s = i.boxTransform;
    return !!n && (e.copy(n), t.copy(s), !0);
  }
  getBoundingSphere(e) {
    if (!this.root) return !1;
    const t = this.root.cached.sphere;
    return !!t && (e.copy(t), !0);
  }
  forEachLoadedModel(e) {
    this.traverse((t) => {
      const i = t.cached.scene;
      i && e(i, t);
    });
  }
  raycast(e, t) {
    if (this.root)
      if (e.firstHitOnly) {
        const i = qM(this.root, this.group, this.activeTiles, e);
        i && t.push(i);
      } else XM(this.root, this.group, this.activeTiles, e, t);
  }
  hasCamera(e) {
    return this.cameraMap.has(e);
  }
  setCamera(e) {
    const t = this.cameras,
      i = this.cameraMap;
    return !i.has(e) && (i.set(e, new Vector2()), t.push(e), !0);
  }
  setResolution(e, t, i) {
    const n = this.cameraMap;
    return (
      !!n.has(e) &&
      (t instanceof Vector2 ? n.get(e).copy(t) : n.get(e).set(t, i), !0)
    );
  }
  setResolutionFromRenderer(e, t) {
    const i = this.cameraMap;
    if (!i.has(e)) return !1;
    const n = i.get(e);
    return t.getSize(n), n.multiplyScalar(t.getPixelRatio()), !0;
  }
  deleteCamera(e) {
    const t = this.cameras,
      i = this.cameraMap;
    if (i.has(e)) {
      const n = t.indexOf(e);
      return t.splice(n, 1), i.delete(e), !0;
    }
    return !1;
  }
  fetchTileSet(e, ...t) {
    const i = super.fetchTileSet(e, ...t);
    return (
      i.then((t) => {
        this.onLoadTileSet &&
          Promise.resolve().then(() => {
            this.onLoadTileSet(t, e);
          });
      }),
      i
    );
  }
  update() {
    const e = this.group,
      t = this.cameras,
      i = this.cameraMap,
      n = this.cameraInfo;
    if (0 === t.length)
      return void console.warn(
        "TilesRenderer: no cameras defined. Cannot update 3d tiles."
      );
    for (; n.length > t.length; ) n.pop();
    for (; n.length < t.length; )
      n.push({
        frustum: new Frustum(),
        isOrthographic: !1,
        sseDenominator: -1,
        position: new Vector3(),
        invScale: -1,
        pixelSize: 0,
      });
    ZM.copy(e.matrixWorld).invert(), JM.setFromMatrixScale(ZM);
    const s = JM.x;
    Math.abs(Math.max(JM.x - JM.y, JM.x - JM.z)) > 1e-6 &&
      console.warn(
        "ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error."
      );
    for (let r = 0, a = n.length; r < a; r++) {
      const a = t[r],
        o = n[r],
        l = o.frustum,
        h = o.position,
        c = i.get(a);
      (0 !== c.width && 0 !== c.height) ||
        console.warn(
          "TilesRenderer: resolution for camera error calculation is not set."
        );
      const u = a.projectionMatrix.elements;
      if (((o.isOrthographic = 1 === u[15]), o.isOrthographic)) {
        const e = 2 / u[0],
          t = 2 / u[5];
        o.pixelSize = Math.max(t / c.height, e / c.width);
      } else o.sseDenominator = 2 / u[5] / c.height;
      (o.invScale = s),
        KM.copy(e.matrixWorld),
        KM.premultiply(a.matrixWorldInverse),
        KM.premultiply(a.projectionMatrix),
        l.setFromProjectionMatrix(KM),
        h.set(0, 0, 0),
        h.applyMatrix4(a.matrixWorld),
        h.applyMatrix4(ZM);
    }
    super.update();
  }
  preprocessNode(e, t, i) {
    super.preprocessNode(e, t, i);
    const n = new Matrix4();
    if (e.transform) {
      const t = e.transform;
      for (let e = 0; e < 16; e++) n.elements[e] = t[e];
    } else n.identity();
    t && n.premultiply(t.cached.transform);
    const s = new Matrix4().copy(n).invert();
    let r = null,
      a = null,
      o = null;
    if ("box" in e.boundingVolume) {
      const t = e.boundingVolume.box;
      (r = new Box3()),
        (a = new Matrix4()),
        (o = new Matrix4()),
        $M.set(t[3], t[4], t[5]),
        ew.set(t[6], t[7], t[8]),
        tw.set(t[9], t[10], t[11]);
      const i = $M.length(),
        s = ew.length(),
        l = tw.length();
      $M.normalize(),
        ew.normalize(),
        tw.normalize(),
        0 === i && $M.crossVectors(ew, tw),
        0 === s && ew.crossVectors($M, tw),
        0 === l && tw.crossVectors($M, ew),
        a.set(
          $M.x,
          ew.x,
          tw.x,
          t[0],
          $M.y,
          ew.y,
          tw.y,
          t[1],
          $M.z,
          ew.z,
          tw.z,
          t[2],
          0,
          0,
          0,
          1
        ),
        a.premultiply(n),
        o.copy(a).invert(),
        r.min.set(-i, -s, -l),
        r.max.set(i, s, l);
    }
    let l = null;
    if ("sphere" in e.boundingVolume) {
      const t = e.boundingVolume.sphere;
      (l = new kt()),
        l.center.set(t[0], t[1], t[2]),
        (l.radius = t[3]),
        l.applyMatrix4(n);
    } else if ("box" in e.boundingVolume) {
      const t = e.boundingVolume.box;
      (l = new kt()),
        r.getBoundingSphere(l),
        l.center.set(t[0], t[1], t[2]),
        l.applyMatrix4(n);
    }
    let h = null;
    if ("region" in e.boundingVolume) {
      const t = e.boundingVolume.region,
        [i, n, s, c, u, d] = t;
      (h = new OM(QS, QS, 6356752.314245179, n, c, i, s, u, d)),
        null === l && ((l = new kt()), h.getBoundingSphere(l)),
        null === r &&
          ((r = new Box3()),
          (a = new Matrix4()),
          (o = new Matrix4()),
          h.getBoundingBox(r, a),
          o.copy(a).invert());
    }
    e.cached = {
      loadIndex: 0,
      transform: n,
      transformInverse: s,
      active: !1,
      inFrustum: [],
      box: r,
      boxTransform: a,
      boxTransformInverse: o,
      sphere: l,
      region: h,
      scene: null,
      geometry: null,
      material: null,
    };
  }
  parseTile(e, t, i) {
    (t._loadIndex = t._loadIndex || 0), t._loadIndex++;
    const n = t.content.uri.split(/[\\\/]/g);
    n.pop();
    const s = n.join("/"),
      r = this.fetchOptions,
      a = this.manager,
      o = t._loadIndex;
    let l = null;
    const h =
        (this.rootTileSet.asset && this.rootTileSet.asset.gltfUpAxis) || "y",
      c = t.cached,
      u = c.transform;
    switch (h.toLowerCase()) {
      case "x":
        KM.makeRotationAxis(nw, -Math.PI / 2);
        break;
      case "y":
        KM.makeRotationAxis(iw, Math.PI / 2);
        break;
      case "z":
        KM.identity();
    }
    const d = oC(e) || i;
    switch (d) {
      case "b3dm": {
        const t = new sM(a);
        (t.workingPath = s),
          (t.fetchOptions = r),
          t.adjustmentTransform.copy(KM),
          (l = t.parse(e).then((e) => e.scene));
        break;
      }
      case "pnts": {
        const t = new oM(a);
        (t.workingPath = s),
          (t.fetchOptions = r),
          (l = t.parse(e).then((e) => e.scene));
        break;
      }
      case "i3dm": {
        const t = new gM(a);
        (t.workingPath = s),
          (t.fetchOptions = r),
          t.adjustmentTransform.copy(KM),
          (l = t.parse(e).then((e) => e.scene));
        break;
      }
      case "cmpt": {
        const t = new vM(a);
        (t.workingPath = s),
          (t.fetchOptions = r),
          t.adjustmentTransform.copy(KM),
          (l = t.parse(e).then((e) => e.scene));
        break;
      }
      case "gltf":
      case "glb":
        const t = new yM(a);
        (t.workingPath = s),
          (t.fetchOptions = r),
          (l = t.parse(e).then((e) => e.scene));
        break;
      default:
        console.warn(`TilesRenderer: Content type "${d}" not supported.`),
          (l = Promise.resolve(null));
    }
    return l.then((e) => {
      if (t._loadIndex !== o) return;
      e.updateMatrix(),
        ("glb" !== d && "gltf" !== d) || e.matrix.multiply(KM),
        e.matrix.premultiply(u),
        e.matrix.decompose(e.position, e.quaternion, e.scale),
        e.traverse((e) => {
          e[YM] = e.frustumCulled;
        }),
        sw(e, !this.autoDisableRendererCulling),
        (c.scene = e),
        e.traverse((e) => {
          e.raycast = this._overridenRaycast;
        });
      const i = [],
        n = [],
        s = [];
      e.traverse((e) => {
        if ((e.geometry && n.push(e.geometry), e.material)) {
          const t = e.material;
          i.push(e.material);
          for (const e in t) {
            const i = t[e];
            i && i.isTexture && s.push(i);
          }
        }
      }),
        (c.materials = i),
        (c.geometry = n),
        (c.textures = s),
        this.onLoadModel && this.onLoadModel(e, t);
    });
  }
  disposeTile(e) {
    const t = e.cached;
    if (t.scene) {
      const i = t.materials,
        n = t.geometry,
        s = t.textures,
        r = t.scene.parent;
      for (let e = 0, t = n.length; e < t; e++) n[e].dispose();
      for (let e = 0, t = i.length; e < t; e++) i[e].dispose();
      for (let e = 0, t = s.length; e < t; e++) {
        s[e].dispose();
      }
      r && r.remove(t.scene),
        this.onDisposeModel && this.onDisposeModel(t.scene, e),
        (t.scene = null),
        (t.materials = null),
        (t.textures = null),
        (t.geometry = null);
    }
    this.activeTiles.delete(e), this.visibleTiles.delete(e), e._loadIndex++;
  }
  setTileVisible(e, t) {
    const i = e.cached.scene,
      n = this.visibleTiles,
      s = this.group;
    t
      ? (s.add(i), n.add(e), i.updateMatrixWorld(!0))
      : (s.remove(i), n.delete(e)),
      this.onTileVisibilityChange && this.onTileVisibilityChange(i, e, t);
  }
  setTileActive(e, t) {
    const i = this.activeTiles;
    t ? i.add(e) : i.delete(e);
  }
  calculateError(e) {
    const t = e.cached,
      i = t.inFrustum,
      n = this.cameras,
      s = this.cameraInfo,
      r = t.sphere,
      a = t.box,
      o = t.boxTransformInverse,
      l = t.transformInverse,
      h = a && o;
    let c = -1 / 0,
      u = 1 / 0;
    for (let d = 0, p = n.length; d < p; d++) {
      if (!i[d]) continue;
      const t = s[d],
        n = t.invScale;
      let p;
      if (t.isOrthographic) {
        const i = t.pixelSize;
        p = e.geometricError / (i * n);
      } else {
        let i;
        JM.copy(t.position),
          h
            ? (JM.applyMatrix4(o), (i = a.distanceToPoint(JM)))
            : (JM.applyMatrix4(l), (i = Math.max(r.distanceToPoint(JM), 0)));
        const s = i * n,
          c = t.sseDenominator;
        (p = e.geometricError / (s * c)), (u = Math.min(u, s));
      }
      c = Math.max(c, p);
    }
    (e.__distanceFromCamera = u), (e.__error = c);
  }
  tileInView(e) {
    const t = e.cached,
      i = t.sphere,
      n = t.inFrustum;
    if (i) {
      const e = this.cameraInfo;
      let t = !1;
      for (let s = 0, r = e.length; s < r; s++) {
        e[s].frustum.intersectsSphere(i)
          ? ((t = !0), (n[s] = !0))
          : (n[s] = !1);
      }
      return t;
    }
    return !0;
  }
}
const aw = new Vector3(),
  ow = ["x", "y", "z"];
class lw extends co {
  constructor(e, t = 16776960, i = 40) {
    const n = new rn(),
      s = [];
    for (let r = 0; r < 3; r++) {
      const e = ow[r],
        t = ow[(r + 1) % 3];
      aw.set(0, 0, 0);
      for (let n = 0; n < i; n++) {
        let r;
        (r = (2 * Math.PI * n) / (i - 1)),
          (aw[e] = Math.sin(r)),
          (aw[t] = Math.cos(r)),
          s.push(aw.x, aw.y, aw.z),
          (r = (2 * Math.PI * (n + 1)) / (i - 1)),
          (aw[e] = Math.sin(r)),
          (aw[t] = Math.cos(r)),
          s.push(aw.x, aw.y, aw.z);
      }
    }
    n.setAttribute("position", new Wi(new Float32Array(s), 3)),
      n.computeBoundingSphere(),
      super(n, new to({ color: t, toneMapped: !1 })),
      (this.sphere = e),
      (this.type = "SphereHelper");
  }
  updateMatrixWorld(e) {
    const t = this.sphere;
    this.position.copy(t.center),
      this.scale.setScalar(t.radius),
      super.updateMatrixWorld(e);
  }
}
const hw = new Vector3(),
  cw = new Vector3(),
  uw = new Vector3();
new Vector3(), new Vector3();
class dw extends co {
  constructor(e = new OM(), t = 16776960) {
    super(),
      (this.ellipsoidRegion = e),
      this.material.color.set(t),
      this.update();
  }
  update() {
    const e = (function (e) {
      const {
          latStart: t = -Math.PI / 2,
          latEnd: i = Math.PI / 2,
          lonStart: n = 0,
          lonEnd: s = 2 * Math.PI,
          heightStart: r = 0,
          heightEnd: a = 0,
        } = e,
        o = new Cn(1, 1, 1, 32, 32),
        { normal: l, position: h } = o.attributes,
        c = h.clone();
      for (let u = 0, d = h.count; u < d; u++) {
        uw.fromBufferAttribute(h, u);
        const o = ze.mapLinear(uw.x, -0.5, 0.5, t, i),
          l = ze.mapLinear(uw.y, -0.5, 0.5, n, s);
        let c = r;
        e.getCartographicToNormal(o, l, hw),
          uw.z < 0 && (c = a),
          e.getCartographicToPosition(o, l, c, uw),
          h.setXYZ(u, ...uw);
      }
      o.computeVertexNormals();
      for (let u = 0, d = c.count; u < d; u++) {
        uw.fromBufferAttribute(c, u);
        const r = ze.mapLinear(uw.x, -0.5, 0.5, t, i),
          a = ze.mapLinear(uw.y, -0.5, 0.5, n, s);
        hw.fromBufferAttribute(l, u),
          e.getCartographicToNormal(r, a, cw),
          Math.abs(hw.dot(cw)) > 0.1 &&
            (uw.z > 0 && cw.multiplyScalar(-1), l.setXYZ(u, ...cw));
      }
      return o;
    })(this.ellipsoidRegion);
    this.geometry.dispose(), (this.geometry = new ko(e, 80));
  }
  dispose() {
    this.geometry.dispose(), this.material.dispose();
  }
}
const pw = Symbol("ORIGINAL_MATERIAL"),
  fw = Symbol("HAS_RANDOM_COLOR"),
  mw = Symbol("HAS_RANDOM_NODE_COLOR");
function gw() {}
class _w extends rw {
  constructor(...e) {
    super(...e);
    const t = this.group,
      i = new va();
    (i.name = "DebugTilesRenderer.boxGroup"), t.add(i);
    const n = new va();
    (n.name = "DebugTilesRenderer.sphereGroup"), t.add(n);
    const s = new va();
    (s.name = "DebugTilesRenderer.regionGroup"),
      t.add(s),
      (this.displayBoxBounds = !1),
      (this.displaySphereBounds = !1),
      (this.displayRegionBounds = !1),
      (this.colorMode = 0),
      (this.customColorCallback = null),
      (this.boxGroup = i),
      (this.sphereGroup = n),
      (this.regionGroup = s),
      (this.maxDebugDepth = -1),
      (this.maxDebugDistance = -1),
      (this.maxDebugError = -1),
      (this.getDebugColor = (e, t) => {
        t.setRGB(e, e, e);
      }),
      (this.extremeDebugDepth = -1),
      (this.extremeDebugError = -1);
  }
  initExtremes() {
    let e = -1;
    this.traverse((t) => {
      e = Math.max(e, t.__depth);
    });
    let t = -1;
    this.traverse((e) => {
      t = Math.max(t, e.geometricError);
    }),
      (this.extremeDebugDepth = e),
      (this.extremeDebugError = t);
  }
  fetchTileSet(...e) {
    const t = super.fetchTileSet(...e);
    return (
      t
        .then(() => {
          Promise.resolve().then(() => {
            this.initExtremes();
          });
        })
        .catch(() => {}),
      t
    );
  }
  getTileInformationFromActiveObject(e) {
    let t = null;
    return (
      this.activeTiles.forEach((i) => {
        if (t) return !0;
        const n = i.cached.scene;
        n &&
          n.traverse((n) => {
            n === e && (t = i);
          });
      }),
      t
        ? {
            distanceToCamera: t.__distanceFromCamera,
            geometricError: t.geometricError,
            screenSpaceError: t.__error,
            depth: t.__depth,
            isLeaf: t.__isLeaf,
          }
        : null
    );
  }
  update() {
    if ((super.update(), !this.root)) return;
    (this.boxGroup.visible = this.displayBoxBounds),
      (this.sphereGroup.visible = this.displaySphereBounds),
      (this.regionGroup.visible = this.displayRegionBounds);
    let e = -1;
    e = -1 === this.maxDebugDepth ? this.extremeDebugDepth : this.maxDebugDepth;
    let t = -1;
    t = -1 === this.maxDebugError ? this.extremeDebugError : this.maxDebugError;
    let i = -1;
    i =
      -1 === this.maxDebugDistance
        ? this.root.cached.sphere.radius
        : this.maxDebugDistance;
    const n = this.errorTarget,
      s = this.colorMode;
    this.visibleTiles.forEach((r) => {
      const a = r.cached.scene;
      let o, l, h;
      7 === s &&
        ((o = Math.random()),
        (l = 0.5 + 0.5 * Math.random()),
        (h = 0.375 + 0.25 * Math.random())),
        a.traverse((a) => {
          8 === s &&
            ((o = Math.random()),
            (l = 0.5 + 0.5 * Math.random()),
            (h = 0.375 + 0.25 * Math.random()));
          const c = a.material;
          if (c) {
            const u = a[pw];
            if (0 === s && c !== u) a.material.dispose(), (a.material = a[pw]);
            else if (0 !== s && c === u)
              if (a.isPoints) {
                const e = new po();
                (e.size = u.size),
                  (e.sizeAttenuation = u.sizeAttenuation),
                  (a.material = e);
              } else (a.material = new Vo()), (a.material.flatShading = !0);
            switch (
              (7 !== s && delete a.material[fw],
              8 !== s && delete a.material[mw],
              s)
            ) {
              case 4: {
                const t = r.__depth / e;
                this.getDebugColor(t, a.material.color);
                break;
              }
              case 5: {
                const t = r.__depthFromRenderedParent / e;
                this.getDebugColor(t, a.material.color);
                break;
              }
              case 1: {
                const e = r.__error / n;
                e > 1
                  ? a.material.color.setRGB(1, 0, 0)
                  : this.getDebugColor(e, a.material.color);
                break;
              }
              case 2: {
                const e = Math.min(r.geometricError / t, 1);
                this.getDebugColor(e, a.material.color);
                break;
              }
              case 3: {
                const e = Math.min(r.__distanceFromCamera / i, 1);
                this.getDebugColor(e, a.material.color);
                break;
              }
              case 6:
                r.children && 0 !== r.children.length
                  ? this.getDebugColor(0, a.material.color)
                  : this.getDebugColor(1, a.material.color);
                break;
              case 8:
                a.material[mw] ||
                  (a.material.color.setHSL(o, l, h), (a.material[mw] = !0));
                break;
              case 7:
                a.material[fw] ||
                  (a.material.color.setHSL(o, l, h), (a.material[fw] = !0));
                break;
              case 9:
                this.customColorCallback
                  ? this.customColorCallback(r, a)
                  : console.warn(
                      "DebugTilesRenderer: customColorCallback not defined"
                    );
            }
          }
        });
    });
  }
  setTileVisible(e, t) {
    super.setTileVisible(e, t);
    const i = e.cached,
      n = this.sphereGroup,
      s = this.boxGroup,
      r = this.regionGroup,
      a = i.boxHelperGroup,
      o = i.sphereHelper,
      l = i.regionHelper;
    t
      ? (a && (s.add(a), a.updateMatrixWorld(!0)),
        o && (n.add(o), o.updateMatrixWorld(!0)),
        l && (r.add(l), l.updateMatrixWorld(!0)))
      : (a && s.remove(a), o && n.remove(o), l && r.remove(l));
  }
  parseTile(e, t, i) {
    return super.parseTile(e, t, i).then(() => {
      const e = t.cached,
        i = e.scene;
      if (i) {
        if (e.box && e.boxTransform) {
          const i = e.box,
            n = e.boxTransform,
            s = new va();
          (s.name = "DebugTilesRenderer.boxHelperGroup"),
            s.matrix.copy(n),
            (s.matrixAutoUpdate = !1);
          const r = new lh(i, kS(t.__depth));
          (r.raycast = gw),
            s.add(r),
            (e.boxHelperGroup = s),
            this.visibleTiles.has(t) &&
              this.displayBoxBounds &&
              (this.boxGroup.add(s), s.updateMatrixWorld(!0));
        }
        if (e.sphere) {
          const i = e.sphere,
            n = new lw(i, kS(t.__depth));
          (n.raycast = gw),
            (e.sphereHelper = n),
            this.visibleTiles.has(t) &&
              this.displaySphereBounds &&
              (this.sphereGroup.add(n), n.updateMatrixWorld(!0));
        }
        if (e.region) {
          const i = e.region,
            n = new dw(i, kS(t.__depth));
          n.raycast = gw;
          const s = new kt();
          i.getBoundingSphere(s),
            n.position.copy(s.center),
            s.center.multiplyScalar(-1),
            n.geometry.translate(...s.center),
            (e.regionHelper = n),
            this.visibleTiles.has(t) &&
              this.displayRegionBounds &&
              (this.regionGroup.add(n), n.updateMatrixWorld(!0));
        }
        i.traverse((e) => {
          const t = e.material;
          t && (e[pw] = t);
        });
      }
    });
  }
  disposeTile(e) {
    super.disposeTile(e);
    const t = e.cached;
    t.boxHelperGroup &&
      (t.boxHelperGroup.children[0].geometry.dispose(),
      delete t.boxHelperGroup),
      t.sphereHelper &&
        (t.sphereHelper.geometry.dispose(), delete t.sphereHelper);
  }
}
class vw {
  constructor(e) {
    publicField(this, "_tileMaxLevel", 19),
      publicField(this, "_subscribedMaxLodLevel", 1),
      publicField(this, "_elementHandlers", []),
      publicField(this, "_objectParent", null),
      publicField(this, "subscribedDataTypeMap", {}),
      publicField(this, "_active", !1),
      publicField(this, "_configVersion", 0),
      publicField(
        this,
        "shouldIgnoreTile",
        (e) => e.__lodLevel > this._subscribedMaxLodLevel
      ),
      publicField(this, "parseElements", (e) => {
        const t = e.cached.scene,
          i = t.batchTable && t.batchTable.header;
        if (!i) return;
        if (!i.id || !i.dataType) return;
        const n = i.id,
          s = i.dataType,
          r = {},
          a = new Map();
        let o = null,
          l = null,
          h = null;
        for (let c = 0, u = s.length; c < u; c++) {
          if (!this.subscribedDataTypeMap[s[c]]) continue;
          (o = s[c]), (l = this.subscribedDataTypeMap[o]), (h = n[c]);
          const e = {
            id: h,
            dataType: o,
            position: [],
            uv: [],
            normal: [],
            index: [],
          };
          r[c] = e;
          const t = a.get(l);
          t ? t.push(e) : a.set(l, [e]);
        }
        for (const c of t.children) this.findElementInMesh(c, r, a);
        for (const c of a.keys()) {
          const t = a.get(c);
          c.addTileElementObjects(e, t);
        }
      }),
      publicField(this, "getInterleavedBufferValue2", (e, t) => {
        const i = e.data.array,
          n = e.data.stride * t + e.offset;
        return [i[n], i[n + 1]];
      }),
      publicField(this, "getInterleavedBufferValue3", (e, t) => {
        const i = e.data.array,
          n = e.data.stride * t + e.offset;
        return [i[n], i[n + 1], i[n + 2]];
      }),
      publicField(this, "findElementInMesh", (e, t, i) => {
        if (!e || !e.geometry) return;
        const n = e.geometry.getAttribute("_batchid");
        if (!n) return;
        const s = e.geometry.getAttribute("normal");
        if (!s) return;
        const r = e.geometry.getAttribute("position"),
          a = e.geometry.getAttribute("uv"),
          o = n.data.count,
          l = {};
        let h = null;
        for (let u = 0; u < o; u++) {
          if (((h = n.getX(u)), !t[h])) continue;
          let e = t[h],
            i = this.getInterleavedBufferValue3(r, u),
            o = this.getInterleavedBufferValue3(s, u),
            c = this.getInterleavedBufferValue2(a, u);
          e.position.push(i[0], i[1], i[2]),
            e.normal.push(o[0], o[1], o[2]),
            e.uv.push(c[0], c[1]),
            (l[u] = { batchId: h, index: e.position.length / 3 - 1 });
        }
        const c = e.geometry.index.array;
        for (let u = 0, d = c.length - 2; u < d; u += 3) {
          let e = c[u];
          if (void 0 === l[e]) continue;
          let i = c[u + 1],
            n = c[u + 2],
            s = l[e],
            r = s.batchId,
            a = s.index,
            o = l[i] && l[i].index,
            h = l[n] && l[n].index;
          if (void 0 === o || void 0 === h) {
            console.warn("one face includes more than one object");
            continue;
          }
          t[r].index.push(a, o, h);
        }
        for (const u of Object.keys(t)) {
          const e = t[u],
            i = new rn();
          i.setAttribute("position", new Wi(new Float32Array(e.position), 3)),
            i.setAttribute("normal", new Wi(new Float32Array(e.normal), 3)),
            i.setAttribute("uv", new Wi(new Float32Array(e.uv), 2)),
            i.setIndex(e.index),
            (e.geometry = i);
        }
      }),
      publicField(this, "onTileLoad", (e, t) => {
        this.parseTileInfo(e), this.shouldIgnoreTile(e);
      }),
      publicField(this, "onTileDispose", (e, t) => {
        if (!this.shouldIgnoreTile(e))
          for (const i of this._elementHandlers) i.disposeTileElementObjects(e);
      }),
      publicField(this, "onTileShow", (e) => {
        this._active && !this.shouldIgnoreTile(e) && this.refreshTile(e);
      }),
      publicField(this, "onTileHide", (e) => {
        if (this._active && !this.shouldIgnoreTile(e))
          for (const t of this._elementHandlers) t.hideTileElementObjects(e);
      }),
      publicField(this, "parseTileInfo", (e) => {
        const t = e.content.uri,
          i = t.substring(t.lastIndexOf("/") + 1).split(".")[0],
          n = i.split("-");
        (e.__id = i),
          (e.__level = parseInt(n[0], 10)),
          (e.__lodLevel = this._tileMaxLevel - e.__level);
      }),
      publicField(this, "refreshTile", (e) => {
        if (e.__elementsConfigVersion !== this._configVersion) {
          for (const t of this._elementHandlers) t.disposeTileElementObjects(e);
          this.parseElements(e),
            (e.__elementsConfigVersion = this._configVersion);
        }
        for (const t of this._elementHandlers) t.showTileElementObjects(e);
      }),
      publicField(this, "refreshTiles", () => {
        this.tilesRenderer.forEachLoadedModel((e, t) => {
          t.__visible && !this.shouldIgnoreTile(t) && this.refreshTile(t);
        }),
          this.engine.requestRender();
      }),
      (this._objectParent = e);
  }
  registerElement(e) {
    (e.parent = this._objectParent), (e.engine = this.engine);
    for (const t of e.subscribedDataTypeIds) this.subscribedDataTypeMap[t] = e;
    return (
      this._elementHandlers.push(e),
      this._configVersion++,
      (this._active = !0),
      this.refreshTiles(),
      e
    );
  }
  unregisterElement(e) {
    for (let i of Object.keys(this.subscribedDataTypeMap))
      this.subscribedDataTypeMap[i] === e &&
        delete this.subscribedDataTypeMap[i];
    let t = this._elementHandlers.indexOf(e);
    t > -1 && (e.dispose(), this._elementHandlers.splice(t, 1)),
      this._configVersion++,
      (this._active = this._elementHandlers.length > 0),
      this.refreshTiles();
  }
  tick(e) {
    if (this._active) for (const t of this._elementHandlers) t.tick(e);
  }
  get subscribedMaxLodLevel() {
    return this._subscribedMaxLodLevel;
  }
  set subscribedMaxLodLevel(e) {
    this._subscribedMaxLodLevel = e;
  }
}
class Aw extends Object3D {
  constructor(e, t) {
    if (
      (super(),
      publicField(this, "isEventEntitySupported", !0),
      publicField(this, "_meshes", []),
      publicField(this, "_idIndexMap", {}),
      publicField(this, "_indexIdMap", {}),
      publicField(this, "_matrixAttribute", null),
      publicField(this, "_count", 0),
      publicField(this, "_rtc", null),
      publicField(this, "updateRenderingMesh", () => {
        this._cleanOldMesh();
        const e = this._meshes,
          t = e.length;
        for (let i = 0; i < t; ++i) {
          const t = e[i],
            n = new eo(t.geometry, t.material);
          (n.__eventProxyByParent = !0),
            (n.castShadow = t.castShadow),
            (n.receiveShadow = t.receiveShadow),
            (n.parent = this),
            (n.name = t.name),
            this.add(n);
        }
      }),
      publicField(this, "_cleanOldMesh", () => {
        const e = this.children;
        for (const t of e)
          this.remove(t),
            t.geometry && t.geometry.dispose(),
            t.material &&
              (t.material.map && t.material.map.dispose(),
              t.material.dispose());
      }),
      e)
    )
      this.meshes = e;
    else {
      const e = (this._defaultMesh = new En(
        new Cn(1, 1, 1),
        new Oi({ color: 16777215 })
      ));
      this._meshes = [e];
    }
    this.updateRenderingMesh(),
      (this._matrixAttribute = new Wa(new Float32Array(16 * t), 16)),
      (this._initialized = !0);
  }
  getEntityByIndex(e) {
    const t = this._indexIdMap[e];
    if (void 0 === t) return null;
    const i = { id: t, index: e };
    return (
      (i.matrix = this._matrixAttribute.array.slice(16 * e, 16 * (e + 1))), i
    );
  }
  has(e) {
    return void 0 !== this._idIndexMap[e];
  }
  clear() {
    (this._idIndexMap = {}), (this._indexIdMap = {}), (this._rtc = null);
  }
  setBufferData(e) {
    if ((this.clear(), !e)) return;
    const t = e.id.length;
    0 !== t &&
      ((this.count = t),
      e.instanceMatrix
        ? this._matrixAttribute.array.set(e.instanceMatrix, 16 * this._count)
        : this.computeTempMatrix(e));
  }
  computeTempMatrix(e) {
    const t = e.id,
      i = e.translation,
      n = e.scale,
      s = e.rotation,
      r = this._matrixAttribute.array;
    let a = new Matrix4(),
      o = new Vector3(),
      l = new Vector3(),
      h = new ii(),
      c = new Quaternion(),
      u = null,
      d = null,
      p = this._rtc;
    p ||
      (i
        ? ((p = [i[0], i[1], i[2]]),
          (this._rtc = p),
          this.position.set(p[0], p[1], p[2]))
        : (p = [0, 0, 0]));
    for (let f = 0; f < this._count; f++) {
      let e = 3 * f;
      n ? l.set(n[e], n[e + 1], n[e + 2]) : l.set(1, 1, 1),
        i
          ? o.set(i[e] - p[0], i[e + 1] - p[1], i[e + 2] - p[2])
          : o.set(0, 0, 0),
        s ? h.set(s[e], s[e + 1], s[e + 2], "XYZ") : h.set(0, 0, 0, "XYZ"),
        c.setFromEuler(h),
        a.compose(o, c, l),
        (e = 16 * f);
      const m = a.elements;
      for (let t = 0; t < 16; t++) r[e + t] = m[t];
      (u = t[f]), (d = f), (this._idIndexMap[u] = d), (this._indexIdMap[d] = u);
    }
  }
  update() {
    if (!this._initialized) return;
    const e = this.children;
    this._matrixAttribute.needsUpdate = !0;
    for (const t of e)
      (t.instanceMatrix = this._matrixAttribute),
        (t.count = this._count),
        t.computeBoundingSphere(),
        (t.instanceMatrix.needsUpdate = !0);
  }
  dispose() {
    this._cleanOldMesh(),
      this._defaultMesh &&
        (this._defaultMesh.geometry.dispose(),
        this._defaultMesh.material.dispose());
  }
  raycast(e, t) {
    this.receiveRaycast &&
      this.visible &&
      this.children.forEach((i) => {
        i.raycast(e, t);
      });
  }
  set needsUpdate(e) {
    e && this.update();
  }
  set count(e) {
    e !== this._count &&
      ((this._count = e),
      (this._matrixAttribute = new Wa(new Float32Array(16 * e), 16)));
  }
  get count() {
    return this._count;
  }
  set meshes(e) {
    e &&
      (Array.isArray(e)
        ? (this._meshes = e)
        : e.isMesh
        ? (this._meshes = [e])
        : e.isGroup && (this._meshes = e.children),
      this.updateRenderingMesh(),
      this.update());
  }
  get meshes() {
    return this._meshes;
  }
}
const yw = (e) => {
    if (e.isMesh) e.geometry.applyMatrix4(e.matrixWorld);
    else if (e.children.length > 0) for (const t of e.children) yw(t);
    e.position.set(0, 0, 0), e.scale.set(1, 1, 1), e.quaternion.set(0, 0, 0, 1);
  },
  xw = (e, t) => {
    if (e.isMesh) t.push(e);
    else if (e.children.length > 0) for (const i of e.children) xw(i, t);
  },
  bw = (e, t, i) => {
    t &&
      ((e) => {
        const t = new Box3();
        t.setFromObject(e);
        const i = Math.max(
          t.max.x - t.min.x,
          t.max.y - t.min.y,
          t.max.z - t.min.z
        );
        e.scale.multiplyScalar(1 / i);
      })(e),
      i && (e.rotation.x = Math.PI / 2),
      e.updateMatrixWorld(),
      yw(e),
      e.updateMatrixWorld();
    const n = [];
    return xw(e, n), n;
  },
  Ew = Object.freeze(
    Object.defineProperty(
      {
        __proto__: null,
        parseLODModel: (e, t, i) => {
          const n = [];
          for (const s of e) {
            const e = s.name;
            if (!e.startsWith("lod")) continue;
            const r = parseInt(e.substring(3), 10);
            if (isNaN(r)) continue;
            const a = bw(s, t, i);
            n[r] = a;
          }
          return n;
        },
        parseScene: bw,
      },
      Symbol.toStringTag,
      { value: "Module" }
    )
  );
class Sw {
  constructor() {
    publicField(this, "_lastUpdateTime", 0),
      publicField(this, "_updateDelayTimerHander", null),
      publicField(this, "_configVersion", 0),
      publicField(this, "_config", {
        tree: {
          enabled: !1,
          isFoliage: !0,
          isBox: !1,
          scaleByZ: !1,
          instances: [
            {
              subtype: 1,
              modelPath: Hm("assets/models/tree/planar/tree20.glb"),
              itemScale: 1,
              zOffset: 0,
            },
            {
              subtype: 0,
              modelPath: Hm("assets/models/tree/planar/tree19.glb"),
              itemScale: 1,
              zOffset: 0,
            },
          ],
        },
      }),
      publicField(this, "_idEnabled", !1),
      publicField(this, "_dataTypeEnabled", !1),
      publicField(
        this,
        "_generateModelMesh",
        async (e) =>
          new Promise((t, i) => {
            DS.load(
              e,
              (e) => {
                const i = bw(e.scene, !0, !0);
                t(i);
              },
              null,
              i
            );
          })
      ),
      publicField(this, "markNeedsUpdate", () => {
        this._updateDelayTimerHander ||
          (this._updateDelayTimerHander = setTimeout(() => {
            this.engine.requestRender(), (this._updateDelayTimerHander = null);
          }, 100));
      }),
      publicField(this, "remapBatchValueToNumber", (e) =>
        e
          ? isFinite(e)
            ? (e = Math.round(e % 100))
            : "string" == typeof e
            ? (e = e.charCodeAt(3) || 0) % 100
            : 0
          : 0
      ),
      publicField(this, "parseBatchTableAttribute", (e, t, i) => {
        const n = e.cached.scene,
          s = n.children,
          r = n.batchTable && n.batchTable.header;
        if (!r) return;
        const a = r[t];
        if (a)
          for (const o of s) {
            if (
              "type" in o.geometry.userData &&
              "subtype" in o.geometry.userData
            )
              continue;
            const e = o.geometry,
              t = e.getAttribute("_batchid");
            if (!t) continue;
            const n = t.data.count;
            let s = -1,
              r = 0;
            const l = [];
            for (let i = 0; i < n; i++)
              (s = t.getX(i)),
                (r = this.remapBatchValueToNumber(a[s])),
                l.push(r);
            e.attributes[i] = new Wi(new Float32Array(l), 1);
          }
      }),
      publicField(this, "onTileLoad", (e, t) => {
        this.refreshTile(e);
      }),
      publicField(this, "onTileDispose", (e, t) => {
        this.resetTile(e);
      }),
      publicField(this, "onTileShow", (e) => {
        const t = e.__instancedModel;
        e.__instanceEnabled && t && ((t.visible = !0), this.markNeedsUpdate());
      }),
      publicField(this, "onTileHide", (e) => {
        const t = e.__instancedModel;
        e.__instanceEnabled && t && ((t.visible = !1), this.markNeedsUpdate());
      }),
      publicField(this, "resetTile", (e) => {
        e.__instancedModel && this.group.remove(e.__instancedModel),
          delete e.__instancedModel,
          delete e.__instanceData,
          delete e.__instanceEnabled;
      }),
      publicField(this, "refreshTile", (e) => {
        const t = e.cached.scene.children;
        if (e.__instanceConfigVersion !== this._configVersion) {
          for (const i of t)
            if (
              "type" in i.geometry.userData &&
              "subtype" in i.geometry.userData
            ) {
              i.visible = !1;
              const { type: t, subtype: n } = i.geometry.userData,
                s = this.getInstanceCollectioConfig(t),
                r = this.getInstanceConfig(t, n);
              (e.__instanceEnabled = s.enabled),
                s.enabled && this.createInstanceComponent(i, e, s, r);
            }
          e.__instanceConfigVersion = this._configVersion;
        }
      }),
      publicField(this, "refreshTiles", () => {
        this.tilesRenderer.forEachLoadedModel((e, t) => {
          t.__visible && (this.resetTile(t), this.refreshTile(t));
        }),
          this.engine.requestRender();
      }),
      (this.group = new va()),
      (this._modelMeshSingleton = new lE()),
      (this._modelMeshSingleton.generate = this._generateModelMesh);
  }
  async createInstanceComponent(e, t, i, n) {
    const s = e.geometry,
      r = t.__id,
      a = s.attributes.position,
      o = a.count;
    if (0 === o) return;
    const l = n.itemScale,
      h = n.zOffset,
      c = await this._modelMeshSingleton.get(n.modelPath),
      u = new Aw(c, o),
      d = [],
      p = s.attributes.scale,
      f = s.attributes.rotation,
      m = new Float32Array(3 * o),
      g = new Float32Array(3 * o),
      _ = new Float32Array(3 * o),
      v = t.cached.scene.matrix,
      A = new Vector3();
    for (let x = 0; x < o; x++)
      A.set(a.getX(x), a.getY(x), a.getZ(x)),
        A.applyMatrix4(v),
        (m[3 * x] = A.x),
        (m[3 * x + 1] = A.y),
        (m[3 * x + 2] = A.z + h),
        (g[3 * x] = p.getX(x) * l),
        (g[3 * x + 1] = p.getY(x) * l),
        (g[3 * x + 2] = p.getZ(x) * l),
        (_[3 * x] = f.getX(x)),
        (_[3 * x + 1] = f.getY(x)),
        (_[3 * x + 2] = f.getZ(x)),
        d.push(r + "-" + x);
    const y = { translation: m, scale: g, rotation: _, id: d };
    u.setBufferData(y),
      (u.needsUpdate = !0),
      (t.__instancedModel = u),
      (t.__instanceData = y),
      this.group.add(u);
  }
  getInstanceCollectioConfig(e) {
    return { type: e, ...this._config[e] };
  }
  setInstanceCollectionConfig(e, t) {
    return (
      this._config[e]
        ? (this._config[e] = { ...this._config[e], ...t })
        : (this._config[e] = t),
      this._configVersion++,
      this.refreshTiles(),
      this
    );
  }
  getInstanceConfig(e, t) {
    if (this._config[e]) {
      let i = this._config[e].instances;
      for (let e = 0; e < i.length; e++) {
        const n = i[e];
        if (String(n.subtype) === String(t)) return n;
      }
    }
  }
  setInstanceConfig(e, t, i) {
    if (this._config[e]) {
      let n = this._config[e].instances,
        s = !0;
      for (let e = 0; e < n.length; e++) {
        const r = n[e];
        if (String(r.subtype) === String(t)) {
          (n[e] = { ...r, ...i }), (s = !1);
          break;
        }
      }
      s && this._config[e].instances.push({ ...i, subtype: t }),
        this._configVersion++,
        this.refreshTiles();
    }
    return this;
  }
  set config(e) {
    (this._config = e), this._configVersion++, this.refreshTiles();
  }
  get config() {
    return this._config;
  }
}
new En(), new kt(), new Matrix4(), new Matrix4();
class Cw extends Object3D {
  constructor(e) {
    if (
      (super(),
      publicField(this, "isEventEntitySupported", !0),
      publicField(this, "_initialSize", 100),
      publicField(this, "_expandStepSize", 20),
      publicField(this, "_meshes", []),
      publicField(this, "_attributes", []),
      publicField(this, "_idIndexMap", {}),
      publicField(this, "_indexIdMap", {}),
      publicField(this, "_instanceMatrixArraySize", 100),
      publicField(this, "_matrixAttribute", null),
      publicField(this, "_colorAttribute", null),
      publicField(this, "_currentCount", 0),
      publicField(this, "_enableColor", !1),
      publicField(this, "_enableColorList", []),
      publicField(this, "_rtc", null),
      publicField(this, "updateRenderingMesh", () => {
        const e = this._meshes,
          t = e.length,
          i = this.children;
        for (let n = 0; n < t; ++n) {
          const t = e[n],
            s = new eo(t.geometry, t.material);
          (s.__eventProxyByParent = !0),
            (s.frustumCulled = !1),
            (s.castShadow = t.castShadow),
            (s.receiveShadow = t.receiveShadow),
            (s.parent = this),
            (s.name = t.name),
            (i[n] = s);
        }
        if (i.length > t) {
          for (let e = i.length - 1; e >= t; --e) this.remove(this.children[e]);
        }
      }),
      publicField(this, "expandInstanceArray", (e, t = !0) => {
        const i =
            this._instanceMatrixArraySize +
            this._expandStepSize * Math.ceil(e / this._expandStepSize),
          n = new Float32Array(16 * i);
        if (
          (t && n.set(this._matrixAttribute.array),
          (this._matrixAttribute = new Wa(n, 16)),
          this._enableColor)
        ) {
          const e = new Float32Array(3 * i).fill(1);
          t && e.set(this._colorAttribute.array),
            (this._colorAttribute = new Wa(e, 3));
        } else this._colorAttribute = new Wa(new Float32Array(), 3);
        (this._instanceMatrixArraySize = i),
          this._matrixAttribute.setUsage(xe),
          this._colorAttribute.setUsage(xe);
      }),
      publicField(this, "copyArrayData", (e, t, i, n, s) => {
        for (let r = 0; r < s; r++) e[t + r] = i[n + r];
      }),
      e)
    )
      this.meshes = e;
    else {
      const e = (this._defaultMesh = new En(
        new Cn(1, 1, 1),
        new Oi({ color: 16777215 })
      ));
      this._meshes = [e];
    }
    this.updateRenderingMesh(),
      (this._matrixAttribute = new Wa(
        new Float32Array(16 * this._initialSize),
        16
      )),
      (this._colorAttribute = new Wa(new Float32Array(), 3)),
      this._matrixAttribute.setUsage(xe),
      this._colorAttribute.setUsage(xe),
      (this._initialized = !0);
  }
  getEntityByIndex(e) {
    const t = this._indexIdMap[e];
    if (void 0 === t) return null;
    const i = { id: t, index: e };
    return (
      (i.matrix = this._matrixAttribute.array.slice(16 * e, 16 * (e + 1))), i
    );
  }
  has(e) {
    return void 0 !== this._idIndexMap[e];
  }
  resetBufferAttribute(e) {
    const t = new Float32Array(16 * e);
    if (((this._matrixAttribute = new Wa(t, 16)), this._enableColor)) {
      const t = new Float32Array(3 * e).fill(1);
      this._colorAttribute = new Wa(t, 3);
    } else this._colorAttribute = new Wa(new Float32Array(), 3);
  }
  clear() {
    (this._idIndexMap = {}),
      (this._indexIdMap = {}),
      this.resetBufferAttribute(this._initialSize),
      (this._instanceMatrixArraySize = this._initialSize),
      (this._currentCount = 0),
      (this._rtc = null),
      this._matrixAttribute.setUsage(xe),
      this._colorAttribute.setUsage(xe);
  }
  setBufferData(e) {
    if (!e)
      return void this.resetBufferAttribute(this._instanceMatrixArraySize);
    const t = e.id.length;
    0 !== t
      ? ((this._idIndexMap = {}),
        (this._indexIdMap = {}),
        t > this._instanceMatrixArraySize
          ? this.expandInstanceArray(t - this._instanceMatrixArraySize, !1)
          : this.resetBufferAttribute(this._instanceMatrixArraySize),
        e.instanceMatrix
          ? this._matrixAttribute.array.set(e.instanceMatrix, 16 * t)
          : (this._currentCount = this.computeTempMatrix(e, 0, t)))
      : this.resetBufferAttribute(this._instanceMatrixArraySize);
  }
  setColor(e, t) {
    const i = this._idIndexMap[e];
    void 0 !== i && this._colorAttribute.array.set(t, 3 * i);
  }
  addInstances(e) {
    if (!e) return;
    const t = e.id.length;
    0 !== t &&
      (this._currentCount + t > this._instanceMatrixArraySize &&
        this.expandInstanceArray(t),
      e.instanceMatrix
        ? (this._matrixAttribute.array.set(
            e.instanceMatrix,
            16 * this._currentCount
          ),
          (this._currentCount += t))
        : (this._currentCount = this.computeTempMatrix(
            e,
            this._currentCount,
            t
          )));
  }
  computeTempMatrix(e, t, i) {
    const n = e.id,
      s = e.translation,
      r = e.scale,
      a = e.rotation,
      o = e.color,
      l = this._matrixAttribute.array,
      h = this._colorAttribute.array;
    let c = new Matrix4(),
      u = new Vector3(),
      d = new Vector3(),
      p = new ii(),
      f = new Quaternion(),
      m = null,
      g = null,
      _ = this._rtc;
    _ ||
      (s
        ? ((_ = [s[0], s[1], s[2]]),
          (this._rtc = _),
          this.position.set(_[0], _[1], _[2]))
        : (_ = [0, 0, 0]));
    for (let v = 0; v < i; v++) {
      let e = 3 * v;
      if (
        (r ? d.set(r[e], r[e + 1], r[e + 2]) : d.set(1, 1, 1),
        s
          ? u.set(s[e] - _[0], s[e + 1] - _[1], s[e + 2] - _[2])
          : u.set(0, 0, 0),
        a ? p.set(a[e], a[e + 1], a[e + 2], "XYZ") : p.set(0, 0, 0, "XYZ"),
        (e = 3 * (t + v)),
        this._enableColor && o)
      ) {
        const { r: t, g: i, b: n } = new Color(o[v] || "#fff"),
          s = [t, i, n];
        for (let r = 0; r < 3; r++) h[e + r] = s[r];
      }
      f.setFromEuler(p), c.compose(u, f, d), (e = 16 * (t + v));
      const i = c.elements;
      for (let t = 0; t < 16; t++) l[e + t] = i[t];
      (m = n[v]),
        (g = t + v),
        (this._idIndexMap[m] = g),
        (this._indexIdMap[g] = m);
    }
    return t + i;
  }
  removeInstance(e) {
    this.removeInstances({ id: [e] });
  }
  removeInstances(e) {
    const t = e.id,
      i = t.length;
    if (0 === i) return;
    const n = this._matrixAttribute.array,
      s = this._colorAttribute.array;
    for (let r = 0; r < i; ++r) {
      const e = t[r],
        i = this._idIndexMap[e];
      if (void 0 === i) {
        console.warn(`remove an item ${e} not exist`);
        continue;
      }
      const a = this._currentCount - 1;
      if (!(i > a)) {
        if (i < a) {
          this.copyArrayData(n, 16 * i, n, 16 * a, 16),
            this._enableColor && this.copyArrayData(s, 3 * i, s, 3 * a, 3);
          const t = this._indexIdMap[a];
          (this._indexIdMap[i] = t),
            (this._idIndexMap[t] = i),
            delete this._idIndexMap[e];
        }
        this._currentCount--;
      }
    }
  }
  update() {
    if (!this._initialized) return;
    const e = this.children;
    (this._matrixAttribute.needsUpdate = !0),
      (this._colorAttribute.needsUpdate = !0);
    const t = this._enableColorList.every((t) => e.every((e) => e.name !== t));
    for (const i of e) {
      i.instanceMatrix = this._matrixAttribute;
      const e =
        !this._enableColorList.length ||
        t ||
        this._enableColorList.includes(i.name);
      this._enableColor && e && (i.instanceColor = this._colorAttribute),
        (i.count = this._currentCount),
        i.computeBoundingSphere(),
        (i.instanceMatrix.needsUpdate = !0);
    }
  }
  set meshes(e) {
    e &&
      (Array.isArray(e)
        ? (this._meshes = e)
        : e.isMesh
        ? (this._meshes = [e])
        : e.isGroup && (this._meshes = e.children),
      this.updateRenderingMesh(),
      this.update());
  }
  dispose() {
    this._defaultMesh &&
      (this._defaultMesh.geometry.dispose(),
      this._defaultMesh.material.dispose());
  }
  raycast(e, t) {
    this.children.forEach((i) => {
      i.raycast(e, t);
    });
  }
  set needsUpdate(e) {
    e && this.update();
  }
  get meshes() {
    return this._meshes;
  }
  get enableColor() {
    return this._enableColor;
  }
  set enableColor(e) {
    e &&
      ((this._colorAttribute = new Wa(
        new Float32Array(3 * this._instanceMatrixArraySize).fill(1),
        3
      )),
      this._colorAttribute.setUsage(xe)),
      (this._enableColor = e);
  }
  set enableColorList(e) {
    this._enableColorList = e;
  }
}
const Mw = {
    pars: "",
    main_before: "",
    main_after: "",
    project_after: "",
    worldpos_after: "",
  },
  ww = { pars: "", main_before: "", color_after: "", custom_map: "" };
class Tw extends ShaderMaterial {
  constructor(e) {
    super(),
      publicField(this, "getShaderSource", (e, t, i, n) => {
        const s = Object.assign({}, t, i);
        for (const r of Object.keys(s)) {
          const t = s[r];
          e = e.replace("#chunk <" + n + "_" + r + ">", t);
        }
        return e;
      }),
      publicField(this, "setCommonUniforms", (e) => {
        for (const t of Object.keys(e)) this.uniforms[t] = e[t];
      }),
      (this.lights = !0),
      (this.fog = !0),
      (this.type = "ExtendMeshStandardMaterial"),
      (this.isMeshStandardMaterial = !0),
      (this.defines = { STANDARD: "" }),
      (this.defineMaterialNormalProperties = N_),
      (this.defineMaterialAliasProperties = k_),
      N_(this, [
        "roughness",
        "metalness",
        "map",
        "lightMap",
        "aoMap",
        "emissive",
        "emissiveMap",
        "bumpMap",
        "normalMap",
        "displacementMap",
        "roughnessMap",
        "metalnessMap",
        "alphaMap",
        "envMap",
      ]),
      k_(this, [["color", "diffuse"]]),
      (this.uniforms = In.clone(In.merge([Yn.standard.uniforms, e.uniforms]))),
      (this.color = new Color(16777215)),
      (this.roughness = 1),
      (this.metalness = 0),
      (this.map = null),
      (this.lightMap = null),
      (this.lightMapIntensity = 1),
      (this.aoMap = null),
      (this.aoMapIntensity = 1),
      (this.emissive = new Color(0)),
      (this.emissiveIntensity = 1),
      (this.emissiveMap = null),
      (this.bumpMap = null),
      (this.bumpScale = 1),
      (this.normalMap = null),
      (this.normalMapType = 0),
      (this.normalScale = new Vector2(1, 1)),
      (this.displacementMap = null),
      (this.displacementScale = 1),
      (this.displacementBias = 0),
      (this.roughnessMap = null),
      (this.metalnessMap = null),
      (this.alphaMap = null),
      (this.envMap = null),
      (this.envMapIntensity = 1),
      (this.refractionRatio = 0.98),
      (this.wireframe = !1),
      (this.wireframeLinewidth = 1),
      (this.wireframeLinecap = "round"),
      (this.wireframeLinejoin = "round"),
      (this.flatShading = !1);
    const {
      vertexShaderChunks: t,
      fragmentShaderChunks: i,
      uniforms: n,
      ...s
    } = e;
    this.setValues(s),
      (this.vertexShaderChunks = t),
      (this.fragmentShaderChunks = i);
  }
  set vertexShaderChunks(e) {
    (this.vertexShader = this.getShaderSource(
      "#define GLSLIFY 1\n#define STANDARD\n\nvarying vec3 vViewPosition;\n\n#ifdef USE_TRANSMISSION\n\n\tvarying vec3 vWorldPosition;\n\n#endif\n\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <normal_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\n#chunk <vertex_pars>\n\nvoid main() {\n\n    #chunk <vertex_main_before>\n\n\t#include <uv_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <normal_vertex>\n\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#chunk <vertex_project_after>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#chunk <vertex_worldpos_after>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n\n#ifdef USE_TRANSMISSION\n\n\tvWorldPosition = worldPosition.xyz;\n\n#endif\n    #chunk <vertex_main_after>\n}",
      Mw,
      e,
      "vertex"
    )),
      (this.needsUpdate = !0);
  }
  set fragmentShaderChunks(e) {
    (this.fragmentShader = this.getShaderSource(
      "#define GLSLIFY 1\n#define STANDARD\n\n#ifdef PHYSICAL\n\t#define IOR\n\t#define SPECULAR\n#endif\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n\n#ifdef IOR\n\tuniform float ior;\n#endif\n\n#ifdef SPECULAR\n\tuniform float specularIntensity;\n\tuniform vec3 specularColor;\n\n\t#ifdef USE_SPECULARINTENSITYMAP\n\t\tuniform sampler2D specularIntensityMap;\n\t#endif\n\n\t#ifdef USE_SPECULARCOLORMAP\n\t\tuniform sampler2D specularColorMap;\n\t#endif\n#endif\n\n#ifdef USE_CLEARCOAT\n\tuniform float clearcoat;\n\tuniform float clearcoatRoughness;\n#endif\n\n#ifdef USE_SHEEN\n\tuniform vec3 sheenColor;\n\tuniform float sheenRoughness;\n\n\t#ifdef USE_SHEENCOLORMAP\n\t\tuniform sampler2D sheenColorMap;\n\t#endif\n\n\t#ifdef USE_SHEENROUGHNESSMAP\n\t\tuniform sampler2D sheenRoughnessMap;\n\t#endif\n#endif\n\nvarying vec3 vViewPosition;\n\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <alphatest_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_common_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <lights_physical_pars_fragment>\n#include <transmission_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <clearcoat_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\n#chunk <fragment_pars>\n\nvoid main() {\n\n\t#ifdef USE_MAP\n\t\tvec2 vUv = vMapUv;\n    \tvec2 uv = vec2(vMapUv);\n\t#endif\n    #chunk <fragment_main_before>\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#ifdef USE_MAP\n\n\t\t#ifdef USE_CUSTOM_MAP\n\t\t\t #chunk <fragment_custom_map>\n\t\t#else\n\t\t\tvec4 sampledDiffuseColor = texture2D( map, uv );\n\t\t#endif\n\n        #ifdef DECODE_VIDEO_TEXTURE\n\n            // inline sRGB decode (TODO: Remove this code when https://crbug.com/1256340 is solved)\n\n            sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );\n\n        #endif\n\n        diffuseColor *= sampledDiffuseColor;\n\n    #endif\n\t#include <color_fragment>\n    #chunk <fragment_color_after>\n\t#ifdef USE_ALPHAMAP\n\n        diffuseColor.a *= texture2D( alphaMap, uv ).g;\n\n    #endif\n\t#include <alphatest_fragment>\n\tfloat roughnessFactor = roughness;\n\n    #ifdef USE_ROUGHNESSMAP\n\n        vec4 texelRoughness = texture2D( roughnessMap, uv );\n\n        // reads channel G, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n        roughnessFactor *= texelRoughness.g;\n\n    #endif\n\tfloat metalnessFactor = metalness;\n\n    #ifdef USE_METALNESSMAP\n\n        vec4 texelMetalness = texture2D( metalnessMap, uv );\n\n        // reads channel B, compatible with a combined OcclusionRoughnessMetallic (RGB) texture\n        metalnessFactor *= texelMetalness.b;\n\n    #endif\n\t#include <normal_fragment_begin>\n\t#ifdef OBJECTSPACE_NORMALMAP\n\n\tnormal = texture2D( normalMap, uv ).xyz * 2.0 - 1.0; // overrides both flatShading and attribute normals\n\n\t#ifdef FLIP_SIDED\n\n\t\tnormal = - normal;\n\n\t#endif\n\n\t#ifdef DOUBLE_SIDED\n\n\t\tnormal = normal * faceDirection;\n\n\t#endif\n\n\tnormal = normalize( normalMatrix * normal );\n\n    #elif defined( TANGENTSPACE_NORMALMAP )\n\n        vec3 mapN = texture2D( normalMap, uv ).xyz * 2.0 - 1.0;\n        mapN.xy *= normalScale;\n\n        #ifdef USE_TANGENT\n\n            normal = normalize( vTBN * mapN );\n\n        #else\n\n            normal = perturbNormal2Arb( - vViewPosition, normal, mapN, faceDirection );\n\n        #endif\n\n    #elif defined( USE_BUMPMAP )\n\n        normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );\n\n    #endif\n\t#include <clearcoat_normal_fragment_begin>\n\t#include <clearcoat_normal_fragment_maps>\n\t#ifdef USE_EMISSIVEMAP\n\n        vec4 emissiveColor = texture2D( emissiveMap, uv );\n\n        totalEmissiveRadiance *= emissiveColor.rgb;\n\n    #endif\n\n\t// accumulation\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\n\t// modulation\n\t#include <aomap_fragment>\n\n\tvec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;\n\tvec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;\n\n\t#include <transmission_fragment>\n\n\tvec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;\n\n\t#ifdef USE_SHEEN\n\n\t\t// Sheen energy compensation approximation calculation can be found at the end of\n\t\t// https://drive.google.com/file/d/1T0D1VSyR4AllqIJTQAraEIzjlb5h4FKH/view?usp=sharing\n\t\tfloat sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );\n\n\t\toutgoingLight = outgoingLight * sheenEnergyComp + sheenSpecular;\n\n\t#endif\n\n\t#ifdef USE_CLEARCOAT\n\n\t\tfloat dotNVcc = saturate( dot( geometry.clearcoatNormal, geometry.viewDir ) );\n\n\t\tvec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );\n\n\t\toutgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + clearcoatSpecular * material.clearcoat;\n\n\t#endif\n\n\t#include <opaque_fragment>\n\t#include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n\n}",
      ww,
      e,
      "fragment"
    )),
      (this.needsUpdate = !0);
  }
  dispose() {
    let e = [
      "map",
      "lightMap",
      "aoMap",
      "emissiveMap",
      "bumpMap",
      "normalMap",
      "displacementMap",
      "roughnessMap",
      "metalnessMap",
      "alphaMap",
      "envMap",
      "specularIntensityMap",
      "specularColorMap",
      "sheenColorMap",
      "sheenRoughnessMap",
    ];
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      this[i] && this[i].dispose();
    }
    super.dispose();
  }
}
const Iw = {
    pars: "\n        uniform float elapsedTime;\n        uniform vec3 windDirection;\n        uniform float windStrength;\n    ",
    main_after: "\n        \n    ",
    project_after:
      "\n    vec4 modelPosition = vec4( transformed, 1.0 );\n    #ifdef USE_INSTANCING\n        modelPosition = instanceMatrix * modelPosition;\n    #endif\n    modelPosition = modelMatrix * modelPosition;\n\n    float dirDot = abs(dot(windDirection, normal));\n    float period = 1500.0 * dirDot + 500.0;\n    period = sin(mod(elapsedTime, period) / period * PI * 2.0);\n    period = (period + 1.0) / 2.0;\n    vec3 worldPositionOffset = windDirection * windStrength * period * dirDot;\n    modelPosition.xyz += worldPositionOffset;\n\n    mvPosition = viewMatrix * modelPosition;\n    gl_Position = projectionMatrix * mvPosition;\n    ",
    worldpos_after:
      "\n    #if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION )\n        worldPosition.xyz += worldPositionOffset;\n    #endif\n    ",
  },
  Rw = { pars: "\n    ", main_before: "\n    ", color_after: "\n    " };
class Pw extends Tw {
  constructor(e = {}) {
    super({
      uniforms: {
        windDirection: { value: [1, 0, 0] },
        windStrength: { value: 0.5 },
      },
    }),
      (this.vertexShaderChunks = Iw),
      (this.fragmentShaderChunks = Rw),
      this.setValues(e);
  }
  get windDirection() {
    return this.uniforms.windDirection.value;
  }
  set windDirection(e) {
    this.uniforms.windDirection.value = e;
  }
  get windStrength() {
    return this.uniforms.windStrength.value;
  }
  set windStrength(e) {
    this.uniforms.windStrength.value = e;
  }
  static fromMaterial(e, t) {
    const i = new Pw(t);
    return (
      (i.map = e.map),
      (i.alphaTest = e.alphaTest),
      (i.metalness = e.metalness),
      (i.roughness = e.roughness),
      (i.side = e.side),
      (i.vertexColors = e.vertexColors),
      i
    );
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(),
      super.dispose();
  }
}
class Dw {
  constructor() {
    publicField(this, "_configVersion", 0),
      publicField(this, "_deletedIds", new Set()),
      publicField(this, "_needsRefreshAll", !1),
      publicField(this, "updateEditableAttribute", (e) => {
        const t = e.cached.scene,
          i = t.children,
          n = t.batchTable && t.batchTable.header;
        if (!n) return;
        const s = n.id;
        if (!s) return;
        const r = this._deletedIds;
        for (const a of i) {
          const e = a.geometry,
            t = e.getAttribute("_batchid");
          if (!t) continue;
          const i = t.data.count;
          let o = -1,
            l = 0;
          const h = [];
          for (let a = 0; a < i; a++)
            (o = t.getX(a)),
              (l = s[o] + ""),
              r.has(l) || this.shouldBeHidden(n, o) ? h.push(1) : h.push(0);
          e.attributes._tileEditableValue = new Wi(new Float32Array(h), 1);
        }
      }),
      publicField(this, "shouldBeHidden", (e, t) => !1),
      publicField(this, "onTileLoad", (e, t) => {
        e.__editableConfigVersion = 0;
      }),
      publicField(this, "onTileDispose", (e, t) => {}),
      publicField(this, "onTileShow", (e) => {
        this.refreshTile(e);
      }),
      publicField(this, "onTileHide", (e) => {}),
      publicField(this, "refreshTile", (e) => {
        e.cached.scene.children,
          e.__editableConfigVersion !== this._configVersion &&
            (this.updateEditableAttribute(e),
            (e.__editableConfigVersion = this._configVersion));
      }),
      publicField(this, "refreshTiles", () => {
        this._needsRefreshAll &&
          this.tilesRenderer.forEachLoadedModel((e, t) => {
            t.__visible && this.refreshTile(t);
          });
      });
  }
  addDeletedId(e) {
    (e += ""),
      this._deletedIds.add(e),
      this._configVersion++,
      (this._needsRefreshAll = !0),
      this.engine.requestRender();
  }
  addDeletedIds(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t] + "";
      this._deletedIds.add(i);
    }
    this._configVersion++,
      (this._needsRefreshAll = !0),
      this.engine.requestRender();
  }
  removeDeletedId(e) {
    (e += ""),
      this._deletedIds.delete(e),
      this._configVersion++,
      (this._needsRefreshAll = !0),
      this.engine.requestRender();
  }
  removeDeletedIds(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t] + "";
      this._deletedIds.delete(i);
    }
    this._configVersion++,
      (this._needsRefreshAll = !0),
      this.engine.requestRender();
  }
  hasDeletedId(e) {
    return this._deletedIds.has(e);
  }
  requestUpdate() {
    this._configVersion++,
      (this._needsRefreshAll = !0),
      this.engine.requestRender();
  }
}
const Lw = {},
  Fw = {
    up: { south: "east", north: "west", west: "south", east: "north" },
    down: { south: "west", north: "east", west: "north", east: "south" },
    south: { up: "west", down: "east", west: "down", east: "up" },
    north: { up: "east", down: "west", west: "up", east: "down" },
    west: { up: "north", down: "south", north: "down", south: "up" },
    east: { up: "south", down: "north", north: "up", south: "down" },
  };
let Nw = {
    north: [-1, 0, 0],
    east: [0, 1, 0],
    up: [0, 0, 1],
    south: [1, 0, 0],
    west: [0, -1, 0],
    down: [0, 0, -1],
  },
  Bw = {},
  kw = {
    east: new Vector3(),
    north: new Vector3(),
    up: new Vector3(),
    west: new Vector3(),
    south: new Vector3(),
    down: new Vector3(),
  },
  Ow = new Vector3(),
  Uw = new Vector3(),
  zw = new Vector3();
const Gw = (e) => void 0 !== e,
  Vw = new Vector3(),
  Qw = new Vector3(
    1 / 40680631590769,
    1 / 40680631590769,
    1 / 40408299984661.445
  ),
  Hw = new Vector3(),
  jw = new Vector3(),
  Ww = function (e, t, i = 0, n) {
    const s = new Vector3(40680631590769, 40680631590769, 40408299984661.445),
      r = Math.cos(t);
    (Hw.x = r * Math.cos(e)),
      (Hw.y = r * Math.sin(e)),
      (Hw.z = Math.sin(t)),
      Hw.normalize(),
      jw.multiplyVectors(s, Hw);
    const a = Math.sqrt(Hw.dot(jw));
    return (
      jw.divideScalar(a),
      Hw.multiplyScalar(i),
      Gw(n) || (n = new Vector3()),
      n.addVectors(jw, Hw)
    );
  },
  qw = (e, t, i = 0, n) => Ww((e * Math.PI) / 180, (t * Math.PI) / 180, i, n);
(Lw.lnglatToEcef = qw),
  (Lw.radianToEcef = Ww),
  (Lw.localFrameToFixedFrameGenerator = function (e, t) {
    if (!Fw.hasOwnProperty(e) || !Fw[e].hasOwnProperty(t))
      throw new Error(
        "firstAxis and secondAxis must be east, north, up, west, south or down."
      );
    let i,
      n = Fw[e][t],
      s = e + t;
    return (
      Gw(Bw[s])
        ? (i = Bw[s])
        : ((i = function (i, s) {
            if (!Gw(i)) throw new Error("origin is required.");
            if ((Gw(s) || (s = new Matrix4()), i.equals(Vw)))
              Ow.fromArray(Nw[e]), Uw.fromArray(Nw[t]), zw.fromArray(Nw[n]);
            else if (Math.abs(i.x) < 1e-14 && Math.abs(i.y) < 1e-14) {
              let s = 0 == (r = +(r = i.z)) ? r : r > 0 ? 1 : -1;
              Ow.fromArray(Nw[e]),
                "east" !== e && "west" !== e && Ow.multiplyScalar(s),
                Uw.fromArray(Nw[t]),
                "east" !== t && "west" !== t && Uw.multiplyScalar(s),
                zw.fromArray(Nw[n]),
                "east" !== n && "west" !== n && zw.multiplyScalar(s);
            } else {
              ((e, t) => {
                t.multiplyVectors(e, Qw).normalize();
              })(i, kw.up);
              let s = kw.up,
                r = kw.east;
              (r.x = -i.y),
                (r.y = i.x),
                (r.z = 0),
                kw.east.copy(r).normalize(),
                kw.north.crossVectors(s, r),
                kw.down.copy(kw.up).multiplyScalar(-1),
                kw.west.copy(kw.east).multiplyScalar(-1),
                kw.south.copy(kw.north).multiplyScalar(-1),
                (Ow = kw[e]),
                (Uw = kw[t]),
                (zw = kw[n]);
            }
            var r;
            const a = s.elements;
            return (
              (a[0] = Ow.x),
              (a[1] = Ow.y),
              (a[2] = Ow.z),
              (a[3] = 0),
              (a[4] = Uw.x),
              (a[5] = Uw.y),
              (a[6] = Uw.z),
              (a[7] = 0),
              (a[8] = zw.x),
              (a[9] = zw.y),
              (a[10] = zw.z),
              (a[11] = 0),
              (a[12] = i.x),
              (a[13] = i.y),
              (a[14] = i.z),
              (a[15] = 1),
              s
            );
          }),
          (Bw[s] = i)),
      i
    );
  }),
  (Lw.eastNorthUpToFixedFrame = Lw.localFrameToFixedFrameGenerator(
    "east",
    "north"
  )),
  (Lw.northEastDownToFixedFrame = Lw.localFrameToFixedFrameGenerator(
    "north",
    "east"
  )),
  (Lw.northUpEastToFixedFrame = Lw.localFrameToFixedFrameGenerator(
    "north",
    "up"
  )),
  (Lw.northWestUpToFixedFrame = Lw.localFrameToFixedFrameGenerator(
    "north",
    "west"
  ));
const Xw = 6378137,
  Yw = new Matrix4(),
  Kw = new Matrix4(),
  Zw = new Vector3(),
  Jw = new Vector3(),
  $w = new Vector3(),
  eT = new Vector3(),
  tT = 3,
  iT = 4;
function nT(e, t) {
  const i = t.stats,
    n = t.frameCount,
    s = t.errorTarget,
    r = t.maxDepth,
    a = t.loadSiblings,
    o = t.lruCache,
    l = t.stopAtEmptyTiles,
    h = t.enabledSchedule,
    c = t.cullWithChildrenBounds;
  lT(e, n);
  if (!1 === t.tileInView(e)) return !1;
  if (
    ((e.__used = !0),
    o.markUsed(e),
    (e.__inFrustum = !0),
    i.inFrustum++,
    (l || !e.__contentEmpty) && !e.__externalTileSet)
  ) {
    t.calculateError(e);
    if (e.__error <= s) return !0;
    if (t.maxDepth > 0 && e.__depth + 1 >= r) return !0;
  }
  e.__externalTileSet && !hT(e.__loadingState) && h && t.requestTileContents(e);
  let u = !1;
  const d = e.children;
  for (let p = 0; p < d.length; p++) {
    const i = d[p];
    e.__externalTileSet &&
      !hT(e.__loadingState) &&
      h &&
      t.requestTileContents(e);
    const n = nT(i, t);
    u = u || n;
  }
  if (u && a)
    for (let p = 0; p < d.length; p++) {
      const e = d[p];
      if ((cT(e, n, o), !e.__inFrustum && h)) {
        e.__externalTileSet && t.requestTileContents(e);
      }
    }
  return (
    !(c && !u && d.length > 0 && "REPLACE" === e.refine && e.__inFrustum) ||
    ((e.__inFrustum = !1), i.inFrustum++, !1)
  );
}
function sT(e, t) {
  if (!uT(e, t.frameCount)) return;
  e.parent || (e.contentChildren = dT(e));
  const i = e.children;
  for (let n = 0; n < i.length; n++) {
    const e = i[n];
    (e.contentChildren = dT(e)), sT(e, t);
  }
}
function rT(e, t) {
  const i = t.frameCount,
    n = t.stats,
    s = t.deferOutSideFrustum,
    r = t.deferLoadDepth,
    a = t.downloadQueue.maxJobs;
  if (!uT(e, i)) return;
  const o = [],
    l = [];
  l.push(e);
  let h = 0;
  for (; l.length > 0; ) {
    const e = l.pop();
    if (!uT(e, i)) continue;
    let c = e.contentChildren || [];
    c.sort(pT);
    let u = c.filter((e) => uT(e, i));
    if (s) {
      const e = u.filter((e) => e.__inFrustum),
        t = u
          .filter((e) => !e.__inFrustum)
          .filter((e) => !hT(e.__loadingState));
      t.length > 0 && h++, (u = e), o.push(...t);
    }
    const d = u.filter((e) => !hT(e.__loadingState));
    if (
      d.length > 0 &&
      (d.forEach((e) => {
        t.requestTileContents(e);
      }),
      n.downloading >= (3 * a) / 4)
    )
      break;
    if (h > r && s) break;
    const p = e.children;
    p.sort(pT), l.push(...p.reverse());
  }
  for (; n.downloading < (3 * a) / 4 && o.length > 0; ) {
    const e = o.shift();
    t.requestTileContents(e);
  }
  n.downloading < (1 * a) / 2 && fT(e, t);
}
function aT(e, t) {
  const i = t.stats,
    n = t.frameCount,
    s = t.enabledSchedule,
    r = t.deferOutSideFrustum;
  if (!uT(e, n)) return;
  i.used++;
  const a = e.children;
  let o = !1;
  for (let l = 0, h = a.length; l < h; l++) {
    const e = a[l];
    o = o || uT(e, n);
  }
  if (o) {
    let i = !1,
      o = !0;
    for (let e = 0, l = a.length; e < l; e++) {
      const l = a[e];
      if (
        (aT(l, t),
        (i = i || l.__wasSetVisible || l.__childrenWereVisible),
        s && r)
      ) {
        if (l.__inFrustum) {
          const e =
            l.__allChildrenLoaded ||
            (!l.__contentEmpty && hT(l.__loadingState)) ||
            (l.__externalTileSet && l.__loadingState === iT);
          o = o && e;
        }
      } else if (uT(l, n)) {
        const e =
          l.__allChildrenLoaded ||
          (!l.__contentEmpty && hT(l.__loadingState)) ||
          (l.__externalTileSet && l.__loadingState === iT);
        o = o && e;
      }
    }
    (e.__childrenWereVisible = i), (e.__allChildrenLoaded = o);
  } else e.__isLeaf = !0;
}
function oT(e, t) {
  const i = t.stats,
    n = t.frameCount,
    s = t.enabledSchedule;
  if (!uT(e, n)) return;
  const r = e.parent,
    a = r ? r.__depthFromRenderedParent : -1;
  e.__depthFromRenderedParent = a;
  const o = t.lruCache;
  if (e.__isLeaf)
    return (
      e.__depthFromRenderedParent++,
      void (e.__loadingState === tT
        ? (e.__inFrustum && ((e.__visible = !0), i.visible++),
          (e.__active = !0),
          i.active++)
        : s ||
          o.isFull() ||
          (e.__contentEmpty && !e.__externalTileSet) ||
          t.requestTileContents(e))
    );
  const l = (t.errorTarget + 1) * t.errorThreshold,
    h = e.__error <= l,
    c = h || "ADD" === e.refine,
    u = !e.__contentEmpty,
    d = u || e.__externalTileSet,
    p = hT(e.__loadingState) && d,
    f = e.__childrenWereVisible,
    m = e.children,
    g = e.__allChildrenLoaded;
  if (
    (c && u && e.__depthFromRenderedParent++,
    s || !c || p || o.isFull() || !d || t.requestTileContents(e),
    ((s && h && !g && p) ||
      (!s && h && !g && !f && p) ||
      ("ADD" === e.refine && p)) &&
      (e.__inFrustum && ((e.__visible = !0), i.visible++),
      (e.__active = !0),
      i.active++),
    "ADD" !== e.refine && h && !g && p)
  )
    for (let _ = 0, v = m.length; _ < v && !s; _++) {
      const i = m[_];
      uT(i, n) &&
        !o.isFull() &&
        ((i.__depthFromRenderedParent = e.__depthFromRenderedParent + 1),
        mT(i, i.__depthFromRenderedParent, t));
    }
  else
    for (let _ = 0, v = m.length; _ < v; _++) {
      oT(m[_], t);
    }
}
function lT(e, t) {
  e.__lastFrameVisited !== t &&
    ((e.__lastFrameVisited = t),
    (e.__used = !1),
    (e.__inFrustum = !1),
    (e.__isLeaf = !1),
    (e.__visible = !1),
    (e.__active = !1),
    (e.__error = 1 / 0),
    (e.__distanceFromCamera = 1 / 0),
    (e.__childrenWereVisible = !1),
    (e.__allChildrenLoaded = !1));
}
function hT(e) {
  return e === tT || e === iT;
}
function cT(e, t, i) {
  if ((lT(e, t), (e.__used = !0), i.markUsed(e), e.__contentEmpty)) {
    const n = e.children;
    for (let e = 0, s = n.length; e < s; e++) cT(n[e], t, i);
  }
}
function uT(e, t) {
  return e.__lastFrameVisited === t && e.__used;
}
function dT(e, t = e, i = !0, n = 0, s = {}) {
  const r = !e.__contentEmpty,
    a = e.__externalTileSet;
  if (r && !i) s[n] ? s[n].push(e) : (s[n] = [e]);
  else {
    n++;
    const i = e.children;
    for (let r = 0, o = i.length; r < o; r++) {
      const o = dT(i[r], t, !1, n, s);
      if (a)
        for (let t = 0; t < o.length; t++) {
          const i = o[t];
          e.__distanceFromCamera = Math.min(
            e.__distanceFromCamera,
            i.__distanceFromCamera
          );
        }
    }
  }
  const o = Object.keys(s),
    l = o[0];
  let h = [];
  return o[0] && (h = s[l]), h;
}
function pT(e, t) {
  return e.__inFrustum !== t.__inFrustum
    ? e.__inFrustum
      ? -1
      : 1
    : e.__distanceFromCamera !== t.__distanceFromCamera
    ? e.__distanceFromCamera - t.__distanceFromCamera
    : e._foveatedFactor !== t._foveatedFactor
    ? e._foveatedFactor - t._foveatedFactor
    : 0;
}
function fT(e, t) {
  const i = t.downloadQueue.maxJobs,
    n = t.stats,
    s = t.cacheDepth,
    r = t.lruCache,
    a = t.maxCacheChildren;
  if (!r.cacheList || r.cacheList.length >= a) return;
  if ((r.markCache(e), e.__depth >= s)) return;
  const o = e.children || [];
  for (let l = 0; l < o.length; l++) {
    const e = o[l];
    (!e.__contentEmpty || e.__externalTileSet) &&
      !hT(e.__loadingState) &&
      n.downloading < (3 * i) / 4 &&
      t.requestTileContents(e),
      fT(e, t);
  }
}
function mT(e, t, i) {
  if (e.__contentEmpty && (!e.__externalTileSet || hT(e.__loadingState))) {
    const n = e.children;
    for (let e = 0, s = n.length; e < s; e++) {
      const s = n[e];
      (s.__depthFromRenderedParent = t), mT(s, t, i);
    }
  } else i.requestTileContents(e);
}
function gT(e, t) {
  const i = uT(e, t.frameCount);
  if (i || e.__usedLastFrame) {
    let n = !1,
      s = !1;
    i &&
      ((n = e.__active),
      (s = (t.displayActiveTiles && e.__active) || e.__visible)),
      e.__contentEmpty ||
        e.__loadingState !== tT ||
        (e.__wasSetActive !== n && t.setTileActive(e, n),
        e.__wasSetVisible !== s && t.setTileVisible(e, s)),
      (e.__wasSetActive = n),
      (e.__wasSetVisible = s),
      (e.__usedLastFrame = i);
    const r = e.children;
    for (let e = 0, i = r.length; e < i; e++) {
      gT(r[e], t);
    }
  }
}
(US.prototype.markCache = function (e) {
  const t = this.cacheList;
  t.includes(e) || t.push(e);
}),
  (US.prototype.markAllUnCached = function () {
    this.cacheList = [];
  }),
  (US.prototype.unloadUnusedContent = function () {
    const e = this.unloadPercent,
      t = this.minSize,
      i = this.itemList,
      n = this.itemSet,
      s = this.usedSet,
      r = this.callbacks,
      a = i.length - s.size,
      o = i.length - t,
      l = this.unloadPriorityCallback || this.defaultPriorityCallback;
    if (o > 0 && a > 0) {
      i.sort((e, t) => {
        const i = s.has(e),
          n = s.has(t);
        return i && n ? 0 : i || n ? (i ? 1 : -1) : l(t) - l(e);
      });
      const h = Math.min(o, a),
        c = Math.max(t * e, h * e);
      let u = Math.min(c, a);
      u = Math.ceil(u);
      const d = i.splice(0, u);
      for (let e = 0, t = d.length; e < t; e++) {
        const t = d[e];
        this.cacheList.includes(t) || (r.get(t)(t), n.delete(t), r.delete(t));
      }
    }
  });
const _T = (e, t) =>
  e.__inFrustum !== t.__inFrustum
    ? e.__inFrustum
      ? 1
      : -1
    : e.__depth !== t.__depth
    ? e.__depth > t.__depth
      ? -1
      : 1
    : e.__error !== t.__error
    ? e.__error > t.__error
      ? 1
      : -1
    : e.__used !== t.__used
    ? e.__used
      ? 1
      : -1
    : e.__distanceFromCamera !== t.__distanceFromCamera
    ? e.__distanceFromCamera > t.__distanceFromCamera
      ? -1
      : 1
    : 0;
var vT, AT;
((vT = rw).prototype.preprocessNode = function (e, t, i) {
  iC.prototype.preprocessNode.call(this, e, t, i);
  const n = new Matrix4();
  if (e.transform) {
    const t = e.transform;
    for (let e = 0; e < 16; e++) n.elements[e] = t[e];
  } else n.identity();
  t && n.premultiply(t.cached.transform);
  const s = new Matrix4().copy(n).invert();
  let r = null,
    a = null,
    o = null;
  if ("box" in e.boundingVolume) {
    const t = e.boundingVolume.box;
    (r = new Box3()),
      (a = new Matrix4()),
      (o = new Matrix4()),
      Jw.set(t[3], t[4], t[5]),
      $w.set(t[6], t[7], t[8]),
      eT.set(t[9], t[10], t[11]);
    const i = Jw.length(),
      s = $w.length(),
      l = eT.length();
    Jw.normalize(),
      $w.normalize(),
      eT.normalize(),
      0 === i && Jw.crossVectors($w, eT),
      0 === s && $w.crossVectors(Jw, eT),
      0 === l && eT.crossVectors(Jw, $w),
      a.set(
        Jw.x,
        $w.x,
        eT.x,
        t[0],
        Jw.y,
        $w.y,
        eT.y,
        t[1],
        Jw.z,
        $w.z,
        eT.z,
        t[2],
        0,
        0,
        0,
        1
      ),
      a.premultiply(n),
      o.copy(a).invert(),
      r.min.set(-i, -s, -l),
      r.max.set(i, s, l);
  }
  let l = null;
  if ("sphere" in e.boundingVolume) {
    const t = e.boundingVolume.sphere;
    (l = new kt()),
      l.center.set(t[0], t[1], t[2]),
      (l.radius = t[3]),
      l.applyMatrix4(n);
  } else if ("box" in e.boundingVolume) {
    const t = e.boundingVolume.box;
    (l = new kt()),
      r.getBoundingSphere(l),
      l.center.set(t[0], t[1], t[2]),
      l.applyMatrix4(n);
  }
  let h = null;
  if ("region" in e.boundingVolume) {
    const t = e.boundingVolume.region,
      [i, s, c, u, d, p] = t;
    if (
      ((h = new OM(Xw, Xw, 6356752.314245179, s, u, i, c, d, p)),
      null === l && ((l = new kt()), h.getBoundingSphere(l)),
      null === r &&
        ((r = new Box3()),
        (a = new Matrix4()),
        (o = new Matrix4()),
        h.getBoundingBox(r, a),
        o.copy(a).invert()),
      this._engine)
    ) {
      let e = this._engine.map.projectPointArr([
          (i / Math.PI) * 180,
          (s / Math.PI) * 180,
          d,
        ]),
        t = this._engine.map.projectPointArr([
          (c / Math.PI) * 180,
          (u / Math.PI) * 180,
          p,
        ]),
        h = new Box3();
      h.set(new Vector3(...e), new Vector3(...t)),
        h.getBoundingSphere(l),
        h.getCenter(l.center),
        a.set(
          1,
          0,
          0,
          l.center.x,
          0,
          1,
          0,
          l.center.y,
          0,
          0,
          1,
          l.center.z,
          0,
          0,
          0,
          1
        ),
        a.premultiply(n),
        o.copy(a).invert(),
        h.applyMatrix4(o),
        (r = h);
    }
  }
  const c = r.clone();
  c.applyMatrix4(a),
    (e.cached = {
      loadIndex: 0,
      transform: n,
      transformInverse: s,
      active: !1,
      inFrustum: [],
      absoluteBox: c,
      box: r,
      boxTransform: a,
      boxTransformInverse: o,
      sphere: l,
      region: h,
      scene: null,
      geometry: null,
      material: null,
    });
}),
  (vT.prototype.tileInView = function (e) {
    const t = e.cached,
      i = t.sphere,
      n = t.inFrustum;
    if (i) {
      const e = this.cameraInfo;
      let s = !1;
      for (let r = 0, a = e.length; r < a; r++) {
        const a = e[r].frustum;
        let o = !1;
        (o = this.checkIntersectByBox
          ? a.intersectsBox(t.absoluteBox)
          : a.intersectsSphere(i)),
          o ? ((s = !0), (n[r] = !0)) : (n[r] = !1);
      }
      return s;
    }
    return !0;
  }),
  (vT.prototype.isOnScreenLongEnough = function (e) {
    let t = 0;
    if (!this.cullRequestsWhileMoving) return !0;
    const i = this.cameraInfo[0],
      { positionWCDeltaMagnitude: n, positionWCDeltaMagnitudeLastFrame: s } = i,
      r = 0 !== n ? n : s,
      a = e.cached.sphere,
      o = Math.max(2 * a.radius, 1);
    return (
      (t = Math.max(t, (this.cullRequestsWhileMovingMultiplier * r) / o)), t < 1
    );
  }),
  (vT.prototype.update = function () {
    const e = this.group,
      t = this.cameras,
      i = this.cameraMap,
      n = this.cameraInfo;
    if (0 === t.length)
      return void console.warn(
        "TilesRenderer: no cameras defined. Cannot update 3d tiles."
      );
    for (; n.length > t.length; ) n.pop();
    for (; n.length < t.length; )
      n.push({
        frustum: new Frustum(),
        isOrthographic: !1,
        sseDenominator: -1,
        position: new Vector3(),
        invScale: -1,
        pixelSize: 0,
        oldPosition: null,
        positionWCDeltaMagnitude: 0,
        lastMovedTimestamp: Date.now(),
        positionWCDeltaMagnitudeLastFrame: 0,
        timeSinceMoved: 0,
        directionWC: new Vector3(),
      });
    Kw.copy(e.matrixWorld).invert(), Zw.setFromMatrixScale(Kw);
    const s = Zw.x;
    Math.abs(Math.max(Zw.x - Zw.y, Zw.x - Zw.z)) > 1e-6 &&
      console.warn(
        "ThreeTilesRenderer : Non uniform scale used for tile which may cause issues when calculating screen space error."
      );
    for (let r = 0, a = n.length; r < a; r++) {
      const a = t[r],
        o = n[r],
        l = o.frustum,
        h = o.position,
        c = i.get(a);
      o.oldPosition
        ? o.oldPosition.copy(o.position)
        : (o.oldPosition = h.clone()),
        (0 !== c.width && 0 !== c.height) ||
          console.warn(
            "TilesRenderer: resolution for camera error calculation is not set."
          );
      const u = a.projectionMatrix.elements;
      if (((o.isOrthographic = 1 === u[15]), o.isOrthographic)) {
        const e = 2 / u[0],
          t = 2 / u[5];
        o.pixelSize = Math.max(t / c.height, e / c.width);
      } else o.sseDenominator = 2 / u[5] / c.height;
      (o.invScale = s),
        Yw.copy(e.matrixWorld),
        Yw.premultiply(a.matrixWorldInverse),
        Yw.premultiply(a.projectionMatrix),
        l.setFromProjectionMatrix(Yw),
        h.set(0, 0, 0),
        h.applyMatrix4(a.matrixWorld),
        h.applyMatrix4(Kw),
        (o.positionWCDeltaMagnitudeLastFrame = o.positionWCDeltaMagnitude);
      const d = new Vector3().subVectors(h, o.oldPosition);
      (o.positionWCDeltaMagnitude = d.length()),
        o.positionWCDeltaMagnitude > 0
          ? ((o.timeSinceMoved = 0), (o.lastMovedTimestamp = Date.now()))
          : (o.timeSinceMoved =
              Math.max(Date.now() - o.lastMovedTimestamp, 0) / 1e3),
        a.getWorldDirection(o.directionWC);
    }
    iC.prototype.update.call(this);
  }),
  (vT.prototype.updateDynamicScreenSpaceError = function (e) {
    if (!this.dynamicScreenSpaceError) return;
    let t, i;
    if (0 === this.cameraInfo.length) return;
    const n = this.cameraInfo[0],
      { absoluteBox: s, sphere: r } = e.cached;
    s ? ((t = s.min.z), (i = s.max.z)) : ((t = 0), (i = 2 * r.center.z));
    const a = n.position.z,
      o = n.directionWC.z;
    let l = 1 - Math.abs(o);
    const h = t + (i - t) * this.dynamicScreenSpaceErrorHeightFalloff,
      c = i * this.dynamicScreenHeightScale;
    (l *= 1 - ze.clamp((a - h) / (c - h), 0, 1)),
      (this._dynamicScreenSpaceErrorComputedDensity =
        this.dynamicScreenSpaceErrorDensity * l);
  }),
  (vT.prototype.calculateError = function (e) {
    this.updateFoveatedFactor(e);
    const t = e.cached,
      i = t.inFrustum,
      n = this.cameras,
      s = this.cameraInfo,
      r = t.sphere,
      a = t.box,
      o = t.boxTransformInverse,
      l = t.transformInverse,
      h = a && o;
    let c = -1 / 0,
      u = 1 / 0;
    for (let d = 0, p = n.length; d < p; d++) {
      if (!i[d]) continue;
      const t = s[d],
        n = t.invScale;
      let p;
      if (t.isOrthographic) {
        const i = t.pixelSize;
        p = e.geometricError / (i * n);
      } else {
        let i;
        Zw.copy(t.position),
          h
            ? (Zw.applyMatrix4(o), (i = a.distanceToPoint(Zw)))
            : (Zw.applyMatrix4(l), (i = Math.max(r.distanceToPoint(Zw), 0)));
        const s = i * n,
          c = t.sseDenominator;
        if (
          ((p = e.geometricError / (s * c)),
          (u = Math.min(u, s)),
          this.dynamicScreenSpaceError)
        ) {
          const e = this._dynamicScreenSpaceErrorComputedDensity,
            t = this.dynamicScreenSpaceErrorFactor;
          p -= this.fogDensity(i, e) * t;
        }
      }
      c = Math.max(c, p);
    }
    (e.__distanceFromCamera = u), (e.__error = c);
  }),
  (vT.prototype.updateFoveatedFactor = function (e) {
    const t = this.distanceToTileCenter(e),
      i = this.isPriorityDeferred(e, t);
    e.priorityDeferred = i;
  }),
  (vT.prototype.isPriorityDeferred = function (e, t) {
    if (!this.foveatedScreenSpaceError || 1 === this.foveatedConeSize)
      return !1;
    const { radius: i, center: n } = e.cached.sphere,
      s = this.cameraInfo[0],
      { directionWC: r, position: a } = s,
      o = r.clone().multiplyScalar(t),
      l = a.clone().add(o).sub(n);
    if (l.length() > i) {
      const t = l.normalize().multiplyScalar(i).add(n).sub(a).normalize();
      e._foveatedFactor = 1 - Math.abs(r.dot(t));
    } else e._foveatedFactor = 0;
    const h = 1 - Math.cos(0.5 * this.cameras[0].fov),
      c = this.foveatedConeSize * h;
    if (e._foveatedFactor <= c) return !1;
    const u = h - c,
      d = ze.clamp((e._foveatedFactor - c) / u, 0, 1),
      p = ze.lerp(0, this.errorTarget, d);
    return this.errorTarget - p <= e.__error;
  }),
  (vT.prototype.fogDensity = function (e, t) {
    const i = e * t;
    return 1 - Math.exp(-i * i);
  }),
  (vT.prototype.distanceToTileCenter = function (e) {
    const { sphere: t } = e.cached;
    let i = Math.min();
    const n = this.cameras[0],
      s = new Vector3().subVectors(t.center, n.position),
      r = new Vector3();
    n.getWorldDirection(r);
    const a = s.dot(r);
    return a < i && (i = a), i;
  }),
  (vT.prototype.setPreloadCamera = function (e) {
    this.setCamera(e) && (this.preloadCamera = e);
  }),
  (vT.prototype.removePreloadCamera = function () {
    this.preloadCamera &&
      (this.deleteCamera(this.preloadCamera), (this.preloadCamera = null));
  }),
  ((AT = iC).prototype.isOnScreenLongEnough = function () {
    return !0;
  }),
  (AT.prototype.updateDynamicScreenSpaceError = function () {}),
  (AT.prototype.requestTileContents = function (e) {
    if (0 !== e.__loadingState) return;
    if (!this.isOnScreenLongEnough(e)) return;
    const t = this.stats,
      i = this.lruCache,
      n = this.downloadQueue,
      s = this.parseQueue,
      r = e.__externalTileSet;
    i.add(e, (e) => {
      1 === e.__loadingState
        ? (e.__loadAbort.abort(), (e.__loadAbort = null))
        : r
        ? (e.children.length = 0)
        : this.disposeTile(e),
        1 === e.__loadingState
          ? t.downloading--
          : 2 === e.__loadingState && t.parsing--,
        (e.__loadingState = 0),
        e.__loadIndex++,
        s.remove(e),
        n.remove(e);
    }),
      e.__loadIndex++;
    const a = e.__loadIndex,
      o = new AbortController(),
      l = o.signal;
    t.downloading++, (e.__loadAbort = o), (e.__loadingState = 1);
    const h = (r) => {
      e.__loadIndex === a &&
        ("AbortError" !== r.name
          ? (s.remove(e),
            n.remove(e),
            2 === e.__loadingState
              ? t.parsing--
              : 1 === e.__loadingState && t.downloading--,
            t.failed++,
            console.error(
              `TilesRenderer : Failed to load tile at url "${e.content.uri}".`
            ),
            console.error(r),
            (e.__loadingState = iT))
          : i.remove(e));
    };
    r
      ? n
          .add(e, (e) => {
            if (e.__loadIndex !== a) return Promise.resolve();
            const t = this.preprocessURL
              ? this.preprocessURL(e.content.uri)
              : e.content.uri;
            return this.fetchTileSet(
              t,
              Object.assign({ signal: l }, this.fetchOptions),
              e
            );
          })
          .then((i) => {
            e.__loadIndex === a &&
              (t.downloading--,
              (e.__loadAbort = null),
              (e.__loadingState = tT),
              e.children.push(i.root));
          })
          .catch(h)
      : n
          .add(e, (e) => {
            if (e.__loadIndex !== a) return Promise.resolve();
            const t = this.preprocessURL
              ? this.preprocessURL(e.content.uri)
              : e.content.uri;
            return fetch(t, Object.assign({ signal: l }, this.fetchOptions));
          })
          .then((t) => {
            if (e.__loadIndex === a) {
              if (t.ok) return t.arrayBuffer();
              throw new Error(
                `Failed to load model with error code ${t.status}`
              );
            }
          })
          .then((i) => {
            if (e.__loadIndex === a)
              return (
                t.downloading--,
                t.parsing++,
                (e.__loadAbort = null),
                (e.__loadingState = 2),
                s.add(e, (e) => {
                  if (e.__loadIndex !== a) return Promise.resolve();
                  const t = (function (e) {
                    let t;
                    try {
                      t = new URL(e, "http://fakehost.com/");
                    } catch (s) {
                      return null;
                    }
                    const i = t.pathname.split("/").pop(),
                      n = i.lastIndexOf(".");
                    return -1 === n || n === i.length - 1
                      ? null
                      : i.substring(n + 1);
                  })(e.content.uri);
                  return this.parseTile(i, e, t);
                })
              );
          })
          .then(() => {
            e.__loadIndex === a &&
              (t.parsing--,
              (e.__loadingState = tT),
              e.__wasSetVisible && this.setTileVisible(e, !0),
              e.__wasSetActive && this.setTileActive(e, !0));
          })
          .catch(h);
  }),
  (AT.prototype.update = function () {
    const e = this.stats,
      t = this.lruCache,
      i = this.tileSets,
      n = this.enabledSchedule,
      s = i[this.rootURL];
    if (!(this.rootURL in i)) return void this.loadRootTileSet(this.rootURL);
    if (!s || !s.root) return;
    const r = s.root;
    this.updateDynamicScreenSpaceError(r),
      (e.inFrustum = 0),
      (e.used = 0),
      (e.active = 0),
      (e.visible = 0),
      this.frameCount++,
      nT(r, this),
      n && (sT(r, this), rT(r, this)),
      aT(r, this),
      oT(r, this),
      gT(r, this),
      t.scheduleUnload();
  });
class yT {
  constructor() {
    publicField(this, "_materrialMap", new Map()),
      publicField(this, "_inited", !1),
      publicField(this, "is3DTilesMaterialManager", !0);
  }
  init() {
    this._inited || (this.onInit(), (this._inited = !0));
  }
  onInit() {}
  getMaterialByKey(e) {
    return this._materrialMap.get(e) || this._materrialMap.get("*");
  }
  addMaterialByKey(e, t) {
    this._materrialMap.set(e, t);
  }
  removeMaterialByKey(e) {
    this._materrialMap.delete(e);
  }
  dispose() {
    this.beforeDispose();
    for (const e of Object.keys(this._materrialMap)) {
      this._materrialMap[e].dispose();
    }
  }
  beforeDispose() {}
}
const xT = new yl();
let bT = {},
  ET = {};
const ST = In.merge([
  Xn.fog,
  Xn.lights,
  {
    envMap: { value: null },
    alpha: { value: 1 },
    time: { value: 0 },
    autoScale: { value: !1 },
    size: { value: 1 },
    distortionScale: { value: 5 },
    textureMatrix: { value: new Matrix4() },
    sunColor: { value: new Color(16777215) },
    sunDirection: { value: new Vector3(0.70707, 0.70707, 0) },
    eye: { value: new Vector3() },
    waterColor: { value: new Color(7695) },
    reflectionColor: { value: new Color(7695) },
    normalMap: { value: null },
    waterBedMap: { value: null },
    mvt_normalMatrix: { value: new Matrix3() },
    isEmissive: { value: !1 },
  },
]);
class CT extends CommonShaderMaterial {
  constructor(e = {}) {
    super(),
      publicField(this, "_timeScaleFactor", 0.001),
      publicField(this, "_style", ""),
      (this.type = "WaterMaterial"),
      (this.vertexShader =
        "#define GLSLIFY 1\nuniform mat4 textureMatrix;\nuniform float time;\n\nvarying vec2 vUv;\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\n#include <common>\n#include <normal_pars_vertex>\n#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n    vUv = uv;\n    mirrorCoord = modelMatrix * vec4(position, 1.0);\n    worldPosition = mirrorCoord.xyzw;\n    mirrorCoord = textureMatrix * mirrorCoord;\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    gl_Position = projectionMatrix * mvPosition;\n\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <normal_vertex>\n    #include <logdepthbuf_vertex>\n    #include <fog_vertex>\n    #include <shadowmap_vertex>\n}"),
      (this.fragmentShader =
        "// http://29a.ch/slides/2012/webglwater/ : Water shader explanations in WebGL\n\nprecision highp float;\nprecision highp int;\n#define GLSLIFY 1\n\n// uniform sampler2D mirrorSampler;\nuniform bool autoScale;\nuniform float alpha;\nuniform float time;\nuniform float size;\nuniform float distortionScale;\nuniform sampler2D normalMap;\nuniform sampler2D waterBedMap;\nuniform vec3 sunColor;\nuniform vec3 sunDirection;\nuniform vec3 eye;\nuniform vec3 waterColor;\n#ifdef USE_ENVMAP\n    uniform sampler2D envMap;\n#else\n    uniform vec3 reflectionColor;\n#endif\nuniform mat3 mvt_normalMatrix;\n\nvarying vec2 vUv;\nvarying vec4 mirrorCoord;\nvarying vec4 worldPosition;\n\nvec4 getNoise(vec2 uv) {\n    vec2 uv0 = (uv / 103.0) + vec2(time / 17.0, time / 29.0);\n    vec2 uv1 = uv / 107.0 - vec2(time / -19.0, time / 31.0);\n    vec2 uv2 = uv / vec2(8907.0, 9803.0) + vec2(time / 101.0, time / 97.0);\n    vec2 uv3 = uv / vec2(1091.0, 1027.0) - vec2(time / 109.0, time / -113.0);\n    vec4 noise = texture2D(normalMap, uv0) +\n        texture2D(normalMap, uv1) +\n        texture2D(normalMap, uv2) +\n        texture2D(normalMap, uv3);\n    return noise * 0.5 - 1.0;\n}\n\nvoid sunLight(const vec3 surfaceNormal, const vec3 eyeDirection, float shiny, float spec, float diffuse, inout vec3 diffuseColor, inout vec3 specularColor) {\n    vec3 reflection = normalize(reflect(-sunDirection, surfaceNormal));\n    float direction = max(0.0, dot(eyeDirection, reflection));\n    specularColor += pow(direction, shiny) * sunColor * spec;\n    diffuseColor += max(dot(sunDirection, surfaceNormal), 0.0) * sunColor * diffuse;\n}\n\n#define ENVMAP_TYPE_CUBE_UV\n\n#include <common>\n#include <packing>\n\n#include <bsdfs>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n\n#include <cube_uv_reflection_fragment>\n\n#define MVT_FRAG_REFLECTION_FACTOR\n#define MVT_FRAG_NORMAL\n\n/* texture tiling */\n#define HASHSCALE1 443.8975\n//----------------------------------------------------------------------------------------\n//  1 out, 2 in...\n\nfloat hash12(vec2 p) {\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\nfloat noise(vec2 p){\n\tvec2 ip = floor(p);\n\tvec2 u = fract(p);\n\tu = u*u*(3.0-2.0*u);\n\t\n\tfloat res = mix(\n\t\tmix(hash12(ip),hash12(ip+vec2(1.0,0.0)),u.x),\n\t\tmix(hash12(ip+vec2(0.0,1.0)),hash12(ip+vec2(1.0,1.0)),u.x),u.y);\n\t//return res*res;\n    return res;\n}\n\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n//----------------------------------------------------------------------------------------\n//  3 out, 1 in...\nvec3 hash31(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx+19.19);\n\treturn fract((p3.xxy+p3.yzz)*p3.zyx); \n}\n\nstruct InterpNodes2 {\n    vec2 seeds;\n    vec2 weights;\n};\nInterpNodes2 GetNoiseInterpNodes(float smoothNoise) {\n    vec2 globalPhases = vec2(smoothNoise * 0.5) + vec2(0.5, 0.0);\n    vec2 phases = fract(globalPhases);\n    vec2 seeds = floor(globalPhases) * 2.0 + vec2(0.0, 1.0);\n    vec2 weights = min(phases, vec2(1.0f) - phases) * 2.0;\n    return InterpNodes2(seeds, weights);\n}\n\nvec4 PreserveVariance(vec4 linearColor, vec4 meanColor, float moment2) {\n    return (linearColor - meanColor) / sqrt(moment2) + meanColor;\n}\n\nvec4 GetTextureSample(sampler2D tex, vec2 uvIn, float seed) {\n    vec3 hash = hash31(seed);\n    float ang = hash.x * 2.0 * PI;\n    mat2 rotation = mat2(cos(ang), sin(ang), -sin(ang), cos(ang));\n    \n    vec2 uv = rotation * uvIn + hash.yz;\n    return texture(tex, uv);\n}\n\nconst float layersCount = 5.0;\nvec4 texture2D_NoTiling(sampler2D tex, vec2 uv) {\n    InterpNodes2 interpNodes = GetNoiseInterpNodes(noise(uv) * layersCount);\n    \n    vec4 col;\n    \n    float moment2 = 0.0;\n    for(int i = 0; i < 2; i++) {\n        float weight = interpNodes.weights[i];\n        moment2 += weight * weight;\n        col += GetTextureSample(tex, uv, interpNodes.seeds[i]) * weight;\n    }\n    col = PreserveVariance(col, textureLod(tex, vec2(0.5), 10000.0), moment2);\n    return col;\n}\n\nfloat step_distance(float value) {\n    float n = 100.;\n    if (value > 1000.) {\n        n = 1000.;\n    }\n    if (value > 10000.) {\n        n = 10000.;\n    }\n    if (value > 100000.) {\n        n = 100000.;\n    }\n    return value - value / n;\n}\n\nvoid main() {\n\n\t#include <logdepthbuf_fragment>\n    vec4 noise = getNoise(worldPosition.xy * size);\n    vec3 surfaceNormal = normalize(noise.xyz * vec3(1.5, 1.5, 1.0));\n\n    vec3 diffuseLight = vec3(0.0);\n    vec3 specularLight = vec3(0.0);\n\n    vec3 worldToEye = cameraPosition - worldPosition.xyz;\n    vec3 eyeDirection = normalize(worldToEye);\n    sunLight(surfaceNormal, eyeDirection, 100.0, 2.0, 0.5, diffuseLight, specularLight);\n\n    float dist = length(worldToEye);\n\n    vec2 distortion = surfaceNormal.xy * (0.001 + 1.0 / dist) * distortionScale;\n    // vec3 reflectionSample = vec3(texture2D(mirrorSampler, mirrorCoord.xy / mirrorCoord.w + distortion));\n    vec3 reflectDir = reflect(vec3(-worldToEye.x, -worldToEye.y, -worldToEye.z), vec3(0.0, 0.0, 1.0));\n    reflectDir.xy += distortion;\n\n    #ifdef USE_ENVMAP\n        vec3 reflectionSample = textureCubeUV(envMap, reflectDir, 0.0).xyz;\n    #else\n        vec3 reflectionSample = reflectionColor;\n    #endif\n\n    float theta = max(dot(eyeDirection, surfaceNormal), 0.0);\n    float rf0 = 0.3;\n    float reflectance = rf0 + (1.0 - rf0) * pow((1.0 - theta), 5.0);\n    vec3 scatter = max(0.0, dot(surfaceNormal, eyeDirection)) * waterColor;\n\n    // vec2 uv = vUv * 5.;\n    vec2 uv = mirrorCoord.xy / mirrorCoord.w * 0.01;\n    if(autoScale) {\n        float scat = step_distance(cameraPosition.z) * 0.01;\n        uv /= scat;\n    }\n    uv = uv * size + distortion;\n\n    vec3 bedSample = texture2D_NoTiling(waterBedMap, uv).rgb;\n    scatter = mix(scatter, bedSample, 0.2);\n\n    vec3 albedo = mix((sunColor * diffuseLight * 0.3 + scatter) * getShadowMask(), (vec3(0.1) + reflectionSample * 0.9 + reflectionSample * specularLight), reflectance);\n    vec3 outgoingLight = albedo;\n    gl_FragColor = vec4(outgoingLight, alpha);\n    float mvt_frag_reflectionFactor = 1.0;\n    // vec3 mvt_frag_normal = vec3(0., 0., 1.0) * mvt_normalMatrix;\n    vec3 mvt_frag_normal = normalize(noise.xyz * vec3(0.2, 0.2, 1.0)) * mvt_normalMatrix;\n    // gl_FragColor = worldPosition;\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    #include <fog_fragment>\n}"),
      (this.isWaterMaterial = !0),
      (this.lights = !0),
      (this.fog = !0),
      Object.assign(this.uniforms, In.clone(ST)),
      (this.defines = {
        CUBEUV_TEXEL_WIDTH: 0.0003255208333333333,
        CUBEUV_TEXEL_HEIGHT: 0.000244140625,
        CUBEUV_MAX_MIP: "10.0",
      }),
      N_(this, [
        "sunColor",
        "waterColor",
        "reflectionColor",
        "autoScale",
        "size",
        "alpha",
        "distortionScale",
        "isEmissive",
      ]),
      Object.defineProperties(this, {
        waterBedMap: {
          get: function () {
            return this.uniforms.waterBedMap.value;
          },
          set: function (e) {
            (e.wrapS = e.wrapT = w),
              this.uniforms.waterBedMap.value &&
                this.uniforms.waterBedMap.value.dispose(),
              (this.uniforms.waterBedMap.value = e),
              (this.needsUpdate = !0);
          },
        },
        normalMap: {
          get: function () {
            return this.uniforms.normalMap.value;
          },
          set: function (e) {
            (e.wrapS = e.wrapT = w),
              this.uniforms.normalMap.value &&
                this.uniforms.normalMap.value.dispose(),
              (this.uniforms.normalMap.value = e),
              (this.needsUpdate = !0);
          },
        },
      }),
      (this.style = "lake"),
      this.setValues(e);
  }
  onBeforeSceneRender(e, t, i, n) {
    if (
      (this.uniforms.eye.value.copy(i.position),
      (this.uniforms.time.value =
        e.rendering.uniforms.elapsedTime.value * this._timeScaleFactor),
      this.uniforms.envMap.value !== t.environment)
    ) {
      this.uniforms.envMap.value = t.environment;
      const e = V_(t.environment);
      e &&
        ((this.defines.CUBEUV_TEXEL_WIDTH = e.texelWidth),
        (this.defines.CUBEUV_TEXEL_HEIGHT = e.texelHeight),
        (this.defines.CUBEUV_MAX_MIP = e.maxMip + ".0")),
        t.environment
          ? (this.defines.USE_ENVMAP = !0)
          : delete this.defines.USE_ENVMAP;
    }
    this.uniforms.mvt_normalMatrix.value.getNormalMatrix(i.matrixWorld);
    const s = e.rendering.sky;
    s && this.uniforms.sunDirection.value.copy(s.sunDirection);
  }
  get timeScaleFactor() {
    return this._timeScaleFactor;
  }
  set timeScaleFactor(e) {
    this._timeScaleFactor = e;
  }
  get style() {
    return this._style;
  }
  set style(e) {
    e !== this._style &&
      (bT[e] && ET[e]
        ? ((this.normalMap = bT[e]),
          (this.waterBedMap = ET[e]),
          (this._style = e))
        : ("river" !== e && "lake" !== e && "ocean" !== e) ||
          (xT.load(Hm(`assets/textures/water/${e}_normal.webp`), (t) => {
            (this.normalMap = t), (bT[e] = t);
          }),
          xT.load(Hm(`assets/textures/water/${e}_bed.webp`), (t) => {
            (this.waterBedMap = t), (ET[e] = t);
          }),
          (this._style = e)));
  }
  dispose() {
    let e = ["envMap", "normalMap", "waterBedMap"];
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      this.uniforms[i] &&
        this.uniforms[i].value &&
        this.uniforms[i].value.dispose();
    }
    (bT = {}), (ET = {}), super.dispose();
  }
}
const MT = new yl(),
  wT = new Color(16777215);
class TT extends ShaderMaterial {
  constructor(e) {
    super(),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\nvarying vec3 vIdColor;\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n    gl_FragColor = vec4(vIdColor.xyz, 1.0);\n\n}"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n#ifdef MVT_TYPE_DATATYPE\nattribute float _dataType;\n#else \nattribute float _id;\n#endif\n\nvarying vec3 vIdColor;\n#include <logdepthbuf_pars_vertex>\nvoid main() { \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    #ifdef MVT_TYPE_DATATYPE\n         float value = _dataType * 0.2536789535;\n         vIdColor = vec3(mod(value, 0.1) * 9.0, mod(value, 0.01) * 90.0, mod(value, 0.001) * 900.0);\n        // vIdColor = vec3(mod(_dataType * 0.2, 0.7), mod(1.0 - mod(_dataType * 0.835, 1.0), 0.4) + 0.4, mod(_dataType * 0.57245, 0.2) + 0.2);\n    #else \n        float value = (_id + 9.3234242) * 0.2536789535;\n         vIdColor = vec3(mod(value, 0.1) * 10.0, mod(value, 0.01) * 100.0, mod(value, 0.001) * 1000.0);\n        // vIdColor = vec3(mod(_id * 0.2, 0.7), mod(1.0 - mod(_id * 0.835, 1.0), 0.7), mod(_id * 0.57245, 0.5));\n    #endif\n    \n    #include <logdepthbuf_vertex>\n}"),
      (this.defines = { MVT_TYPE_ID: !0 }),
      (this.type = 1),
      this.setValues(e);
  }
  set type(e) {
    1 === e
      ? ((this.defines.MVT_TYPE_ID = !0), delete this.defines.MVT_TYPE_DATATYPE)
      : 2 === e &&
        ((this.defines.MVT_TYPE_DATATYPE = !0),
        delete this.defines.MVT_TYPE_ID),
      (this.needsUpdate = !0);
  }
  get type() {
    return this.defines.MVT_TYPE_DATATYPE ? 2 : 1;
  }
}
class IT {
  constructor(e) {
    publicField(this, "_parent", null),
      publicField(this, "_material", null),
      publicField(this, "subscribedDataTypeIds", []),
      publicField(this, "_positionScaleFactor", 1.3),
      publicField(this, "_tileObjectMap", new Map()),
      publicField(this, "_idObjectMap", new Map()),
      publicField(this, "_objectDataMap", new Map()),
      publicField(this, "_visibleIdMap", new Map()),
      publicField(this, "_scaleSize", 0.05),
      publicField(this, "_tickInterval", 500),
      publicField(this, "_lastTickTime", 0),
      (this._parent = e);
  }
  set parent(e) {
    this._parent = e;
  }
  createMeshFromGeometry(e) {
    return (
      this._material ||
        ((this._material = new Oi({ color: 16777130 })),
        (this._material.emissive = new Color(16777130))),
      new En(e, this._material)
    );
  }
  addTileElementObjects(e, t) {
    const i = e.cached.scene,
      n = [];
    for (const s of t) {
      const t = this.createMeshFromGeometry(s.geometry, s);
      t.userData.id = s.id;
      const r = s.geometry.getAttribute("position").array,
        a = s.geometry.getAttribute("normal").array;
      for (let e = 0, i = r.length - 2; e < i; e += 3)
        (r[e] = r[e] + this._scaleSize * a[e]),
          (r[e + 1] = r[e + 1] + this._scaleSize * a[e + 1]),
          (r[e + 2] = r[e + 2] + this._scaleSize * a[e + 2]);
      t.position.copy(i.position),
        t.rotation.copy(i.rotation),
        t.scale.copy(i.scale),
        (t.__tile = e),
        n.push(t),
        this._objectDataMap.set(t, s);
    }
    this._tileObjectMap.set(e, n);
  }
  onEntityShow(e, t) {}
  showTileElementObjects(e) {
    const t = this._tileObjectMap.get(e);
    if (t)
      for (const i of t) {
        const e = i.userData.id;
        this._visibleIdMap.set(e, i),
          this.onEntityShow(e, i),
          this._parent.add(i);
      }
  }
  hideTileElementObjects(e) {
    const t = this._tileObjectMap.get(e);
    if (t)
      for (const i of t) {
        const e = i.userData.id;
        this._visibleIdMap.get(e) === i && this._visibleIdMap.delete(e),
          this._parent.remove(i);
      }
  }
  disposeTileElementObjects(e) {
    const t = this._tileObjectMap.get(e);
    if (t) {
      for (const e of t)
        e.parent && e.parent.remove(e),
          this._objectDataMap.delete(e),
          e.geometry.dispose();
      this._tileObjectMap.delete(e);
    }
  }
  doTick(e) {
    for (const t of this._visibleIdMap.keys()) {
      const i = this._visibleIdMap.get(t);
      this.tickObject(i, e);
    }
  }
  tickObject(e, t) {}
  tick(e) {
    this._tickInterval <= 0 ||
      (e - this._lastTickTime > this._tickInterval &&
        ((this._lastTickTime = e), this.doTick(e)));
  }
  dispose() {
    this._material && this._material.dispose(),
      this._tileObjectMap.forEach((e, t) => {
        for (const i of e) this._parent.remove(i);
      });
  }
}
class RT extends Object3D {
  constructor(e) {
    super(), (this.geometry = e);
    const t = (this.material = new Oi({ color: 16777130 }));
    t.emissive = new Color(16777130);
    const i = (this.mesh = new En(e, t));
    this.add(i);
  }
  set color(e) {
    e.isColor || (e = new Color(e)),
      (this.material.color = e),
      (this.material.emissive = e);
  }
  get color() {
    return this.material.color;
  }
}
const PT = new yl();
let DT = null,
  LT = null;
const FT = In.merge([
  Xn.fog,
  D_,
  {
    spriteCount: { value: 16 },
    slotCount: { value: 3 },
    slotSpriteOffset0: { value: 0 },
    slotSpriteOffset1: { value: 0 },
    slotSpriteOffset2: { value: 0 },
    slotSpriteOffset3: { value: 0 },
    slotState0: { value: 0 },
    slotState1: { value: 0 },
    slotState2: { value: 0 },
    slotState3: { value: 0 },
    maskMap: { value: null },
    numberMaskMap: { value: null },
    number: 0,
    redColor: { value: [1, 0.1, 0.1] },
    greenColor: { value: [0.1, 1, 0.1] },
    yellowColor: { value: [1, 0.6, 0.1] },
  },
]);
class NT extends CommonShaderMaterial {
  constructor(e = {}) {
    super(),
      (this.type = "TrafficLightMaterial"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\n#include <logdepthbuf_pars_vertex>\n\nvarying vec2 vUv;\nvoid main() { \n    vUv = uv;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    #include <logdepthbuf_vertex>\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\n#include <logdepthbuf_pars_fragment>\nuniform sampler2D maskMap;\nuniform sampler2D numberMaskMap;\nuniform float spriteCount;\n\n// 最多4个槽位，\nuniform float slotCount;\n// 每个槽位图标的偏移位置， -1代表当前槽位是倒数读秒数\nuniform float slotSpriteOffset0;\nuniform float slotSpriteOffset1;\nuniform float slotSpriteOffset2;\nuniform float slotSpriteOffset3;\n\n// 每个slot的状态，0，1，2，3 分别代表关、红、黄、绿，后续考虑合并到一个变量中\nuniform float slotState0;\nuniform float slotState1;\nuniform float slotState2;\nuniform float slotState3;\n\nuniform float number;\nvarying vec2 vUv;\n\nuniform vec3 redColor;\nuniform vec3 greenColor;\nuniform vec3 yellowColor;\n\n//#include <mvt_mrt_output_pars_fragment>\n\nvoid main() {\n\n    // 当前像素落在哪个槽位\n    float slotIndex = floor(vUv.y * slotCount);\n    float currentSlotState = 0.0;\n    float spriteIndex = 0.0;\n    if (slotIndex == 0.0) {\n        currentSlotState = slotState0;\n        spriteIndex = slotSpriteOffset0;\n    }\n    else if (slotIndex == 1.0) {\n        currentSlotState = slotState1;\n        spriteIndex = slotSpriteOffset1;\n    }\n    else if (slotIndex == 2.0) {\n        currentSlotState = slotState2;\n        spriteIndex = slotSpriteOffset2;\n    }\n    else if (slotIndex == 3.0) {\n        currentSlotState = slotState3;\n        spriteIndex = slotSpriteOffset3;\n    }\n    if (currentSlotState == 0.0) {\n        discard;\n    }\n    vec3 outColor;\n    if (currentSlotState == 1.0) {\n        outColor = redColor;\n    }\n    else if (currentSlotState == 2.0) {\n        outColor = yellowColor;\n    }\n    else if (currentSlotState == 3.0) {\n        outColor = greenColor;\n    }\n    //float slotRatio = 1.0 / spriteCount;\n    // 将高亮区域的v缩放到0-1\n    float v = (vUv.y - float(slotIndex) / slotCount) * slotCount;\n    // v = v * 0.98 + 0.01;\n\n    float u = 0.0;\n    float spriteUnit = 1.0 / spriteCount;\n\n    // 数字\n    if (spriteIndex == -1.0) {\n        // gl_FragColor = vec4(1.0, 0, 0, 1.0);\n        float i1 = floor((number + 0.001) / 10.0);\n        float i2 = floor(mod(number, 10.0));\n        if (vUv.x < 0.5) {\n            u = mix(i1 * 0.1, i1 * 0.1 + 0.1, vUv.x * 2.0);\n        }\n        else {\n            u = mix(i2 * 0.1, i2 * 0.1 + 0.1, (vUv.x - 0.5) * 2.0);\n        }\n        float r = texture2D(numberMaskMap, vec2(u, v)).r;\n        if (r < 0.05) {\n            discard;\n        }\n    }\n    else {\n        u = mix(spriteIndex * spriteUnit, (spriteIndex + 1.0) * spriteUnit, vUv.x);\n        float r = texture2D(maskMap, vec2(u, v)).r;\n        if (r < 0.05) {\n            discard;\n        }\n    }\n    \n    // gl_FragColor = vec4(texture2D(maskMap, vec2(u, v)).xyz, 1.0);\n    gl_FragColor = vec4(outColor, 1.0);\n    #include <logdepthbuf_fragment> \n\t//#include <mvt_mrt_output_fragment>\n}"),
      (this.isTrafficLightMaterial = !0),
      (this.transparent = !0),
      Object.assign(this.uniforms, In.clone(FT)),
      N_(this, [
        "slotState0",
        "slotState1",
        "slotState2",
        "slotState3",
        "number",
        "redColor",
        "greenColor",
        "yellowColor",
      ]),
      G_(this),
      Object.defineProperties(this, {
        slotConfig: {
          get: function () {
            return this._slotConfig;
          },
          set: function (e) {
            (this._slotConfig = e),
              (this.uniforms.slotCount.value = e.length),
              (this.uniforms.slotSpriteOffset0.value = e[0]),
              (this.uniforms.slotSpriteOffset1.value = e[1] || 0),
              (this.uniforms.slotSpriteOffset2.value = e[2] || 0),
              (this.uniforms.slotSpriteOffset3.value = e[3] || 0);
          },
        },
      }),
      (DT && LT) ||
        ((DT = PT.load(Hm("assets/textures/element/traffic_light_mask.jpg"))),
        (DT.flipY = !1),
        (DT.magFilter = DT.minFilter = R),
        (LT = PT.load(
          Hm("assets/textures/element/traffic_light_number_mask.jpg")
        )),
        (LT.flipY = !1),
        (LT.magFilter = LT.minFilter = R)),
      (this.uniforms.maskMap.value = DT),
      (this.uniforms.numberMaskMap.value = LT),
      (this.emissiveEnabled = !0),
      (this.emissiveIntensity = 0.8),
      this.setValues(e);
  }
  dispose() {
    this.uniforms.maskMap &&
      this.uniforms.maskMap.value &&
      (this.uniforms.maskMap.value.dispose(), (DT = null)),
      this.uniforms.numberMaskMap &&
        this.uniforms.numberMaskMap.value &&
        (this.uniforms.numberMaskMap.value.dispose(), (LT = null)),
      super.dispose();
  }
}
class BT extends Object3D {
  constructor(e) {
    super(),
      publicField(this, "isMesh", !0),
      publicField(this, "_slots", []),
      publicField(this, "_slotCount", 3),
      publicField(this, "_numberSlot", -1),
      publicField(this, "_timeTable", null),
      publicField(this, "_channelCount", 3),
      (this.geometry = e),
      (this.material = new NT()),
      (this.number = 0);
  }
  set slots(e) {
    (this._slots = e), (this._slotCount = e.length);
    let t = -1,
      i = 0;
    for (let n = 0, s = e.length; n < s; n++) -1 === e[n] ? (t = n) : i++;
    (this._numberSlot = t),
      (this._channelCount = i),
      (this.material.slotConfig = e);
  }
  get slots() {
    return this._slots;
  }
  get slotCount() {
    return this._slotCount;
  }
  get numberSlot() {
    return this._numberSlot;
  }
  get number() {
    return this._number;
  }
  set number(e) {
    (this._number = e), (this.material.number = e);
  }
  set timeTable(e) {
    (this._number = 0), (this._lightState = 0), (this._timeTable = e);
  }
  get timeTable() {
    return this.timeTable;
  }
  set lightState(e) {
    this._lightState = e;
  }
  get lightState() {
    return this._lightState;
  }
  updateState(e) {
    if (this._timeTable) {
      const t = this._timeTable,
        i = (e / 1e3 - t.startTime) % t.period;
      for (let e = t.states.length - 1, n = e; n >= 0; --n)
        if (t.states[n][0] <= i) {
          (this._lightState = t.states[n][1]),
            (this._number = (n === e ? t.period : t.states[n + 1][0]) - i + 1);
          break;
        }
      (this._active = !0), this.updateMaterial();
    } else
      void 0 !== this._lightState && null !== this._lightState
        ? ((this._active = !0), this.updateMaterial())
        : this._active && (this.updateMaterial(), (this._active = !1));
  }
  updateMaterial() {
    const e = this.material;
    3 === this._channelCount
      ? ((e.slotState0 = 1 === this._lightState ? 1 : 0),
        (e.slotState1 = 2 === this._lightState ? 2 : 0),
        (e.slotState2 = 3 === this._lightState ? 3 : 0),
        -1 !== this._numberSlot &&
          ((e.number = this._number), (e.slotState3 = this._lightState)))
      : 2 === this._channelCount
      ? ((e.slotState0 = 1 === this._lightState ? 1 : 0),
        (e.slotState1 = 3 === this._lightState ? 3 : 0),
        -1 !== this._numberSlot &&
          ((e.number = this._number), (e.slotState2 = this._lightState)))
      : 1 === this._channelCount
      ? ((e.slotState0 = this._lightState),
        -1 !== this._numberSlot &&
          ((e.number = this._number), (e.slotState1 = this._lightState)))
      : 0 === this._channelCount
      ? -1 !== this._numberSlot &&
        ((e.number = this._number), (e.slotState0 = this._lightState))
      : console.warn("invalid channel count:", this._channelCount);
  }
}
let kT;
const OT = class extends fA {
  constructor(e) {
    super(e),
      publicField(this, "_geoDataType"),
      publicField(this, "_geoFeatures", []),
      publicField(this, "_geoIndexMap", []),
      (this.type = "GeoJSONDataSource");
  }
  getOriginDataIndex(e) {
    return e < this._templateDataLength
      ? this._geoIndexMap[e]
      : [e - this._templateDataLength + this._geoFeatures.length, 0];
  }
  getOriginData(e) {
    if (e < this._templateDataLength) {
      const t = this._geoIndexMap[e];
      return this._geoFeatures[t[0]];
    }
    return this._addCache[e - this._templateDataLength];
  }
  async _getFetchData(e) {
    return await e.json();
  }
  onClear() {
    (this._geoDataType = void 0),
      (this._geoFeatures = []),
      (this._geoIndexMap = []);
  }
  _onProcessTemplateData(e, t) {
    return this._prepareFeatures(), this._parseFeatures(e, t), e;
  }
  originToFeatures(e) {
    for (let t = 0; t < this._geoFeatures.length; t++) {
      const i = this._geoFeatures[t];
      e.push({
        type: "Feature",
        geometry: {
          type: i.geometry.type,
          coordinates: i.geometry.coordinates,
        },
        properties: i.properties,
      });
    }
    return e;
  }
  _parseFeatures(e, t) {
    let i = 0;
    for (let n = 0; n < this._geoFeatures.length; n++) {
      const s = this._geoFeatures[n],
        r = this._onDecomposeFeature(this._geoDataType, s);
      for (let a = 0; a < r.length; a++) {
        const s = r[a];
        e.position.push(s.geometry[this.projectionName]),
          a > 0 && i++,
          e.index.push(n + i),
          (this._geoIndexMap[n + i] = [n, a]);
        let o = { position: s.geometry[this.projectionName], index: n + i };
        for (const t of this._attributeMap.keys()) {
          let i;
          s.properties &&
          void 0 !== s.properties[this._attributeMap.get(t)] &&
          null !== s.properties[this._attributeMap.get(t)]
            ? (i = s.properties[this._attributeMap.get(t)])
            : this._attributeMap.get(t) instanceof Function &&
              (i = this._attributeMap.get(t)(s.properties)),
            e[t].push(i),
            (o[t] = i);
        }
        t.push(o);
      }
    }
  }
  _prepareFeatures() {
    var e, t;
    (this._geoFeatures = Lv(this._origin, this.projectionName)),
      (this._geoDataType = super._getDataType(
        null == (t = null == (e = this._geoFeatures[0]) ? void 0 : e.geometry)
          ? void 0
          : t.type
      ));
  }
  get geoDataType() {
    return this._geoDataType;
  }
};
let UT = OT;
publicField(UT, "fromGeoJSON", async function (e) {
  let t = new OT();
  return await t.load(e), t;
}),
  publicField(UT, "fromUrl", async function (e) {
    let t = new OT();
    return await t.load(e), t;
  }),
  publicField(UT, "fromGeoJSONObject", function (e) {
    let t = new OT();
    return t.setData(e), t;
  }),
  publicField(UT, "fromObject", function (e) {
    let t = new OT();
    return t.setData(e), t;
  });
var zT =
    "undefined" != typeof global
      ? global
      : "undefined" != typeof self
      ? self
      : "undefined" != typeof window
      ? window
      : {},
  GT = [],
  VT = [],
  QT = "undefined" != typeof Uint8Array ? Uint8Array : Array,
  HT = !1;
function jT() {
  HT = !0;
  for (
    var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",
      t = 0;
    t < 64;
    ++t
  )
    (GT[t] = e[t]), (VT[e.charCodeAt(t)] = t);
  (VT["-".charCodeAt(0)] = 62), (VT["_".charCodeAt(0)] = 63);
}
function WT(e, t, i) {
  for (var n, s, r = [], a = t; a < i; a += 3)
    (n = (e[a] << 16) + (e[a + 1] << 8) + e[a + 2]),
      r.push(
        GT[((s = n) >> 18) & 63] +
          GT[(s >> 12) & 63] +
          GT[(s >> 6) & 63] +
          GT[63 & s]
      );
  return r.join("");
}
function qT(e) {
  var t;
  HT || jT();
  for (
    var i = e.length, n = i % 3, s = "", r = [], a = 16383, o = 0, l = i - n;
    o < l;
    o += a
  )
    r.push(WT(e, o, o + a > l ? l : o + a));
  return (
    1 === n
      ? ((t = e[i - 1]),
        (s += GT[t >> 2]),
        (s += GT[(t << 4) & 63]),
        (s += "=="))
      : 2 === n &&
        ((t = (e[i - 2] << 8) + e[i - 1]),
        (s += GT[t >> 10]),
        (s += GT[(t >> 4) & 63]),
        (s += GT[(t << 2) & 63]),
        (s += "=")),
    r.push(s),
    r.join("")
  );
}
function XT(e, t, i, n, s) {
  var r,
    a,
    o = 8 * s - n - 1,
    l = (1 << o) - 1,
    h = l >> 1,
    c = -7,
    u = i ? s - 1 : 0,
    d = i ? -1 : 1,
    p = e[t + u];
  for (
    u += d, r = p & ((1 << -c) - 1), p >>= -c, c += o;
    c > 0;
    r = 256 * r + e[t + u], u += d, c -= 8
  );
  for (
    a = r & ((1 << -c) - 1), r >>= -c, c += n;
    c > 0;
    a = 256 * a + e[t + u], u += d, c -= 8
  );
  if (0 === r) r = 1 - h;
  else {
    if (r === l) return a ? NaN : (1 / 0) * (p ? -1 : 1);
    (a += Math.pow(2, n)), (r -= h);
  }
  return (p ? -1 : 1) * a * Math.pow(2, r - n);
}
function YT(e, t, i, n, s, r) {
  var a,
    o,
    l,
    h = 8 * r - s - 1,
    c = (1 << h) - 1,
    u = c >> 1,
    d = 23 === s ? Math.pow(2, -24) - Math.pow(2, -77) : 0,
    p = n ? 0 : r - 1,
    f = n ? 1 : -1,
    m = t < 0 || (0 === t && 1 / t < 0) ? 1 : 0;
  for (
    t = Math.abs(t),
      isNaN(t) || t === 1 / 0
        ? ((o = isNaN(t) ? 1 : 0), (a = c))
        : ((a = Math.floor(Math.log(t) / Math.LN2)),
          t * (l = Math.pow(2, -a)) < 1 && (a--, (l *= 2)),
          (t += a + u >= 1 ? d / l : d * Math.pow(2, 1 - u)) * l >= 2 &&
            (a++, (l /= 2)),
          a + u >= c
            ? ((o = 0), (a = c))
            : a + u >= 1
            ? ((o = (t * l - 1) * Math.pow(2, s)), (a += u))
            : ((o = t * Math.pow(2, u - 1) * Math.pow(2, s)), (a = 0)));
    s >= 8;
    e[i + p] = 255 & o, p += f, o /= 256, s -= 8
  );
  for (
    a = (a << s) | o, h += s;
    h > 0;
    e[i + p] = 255 & a, p += f, a /= 256, h -= 8
  );
  e[i + p - f] |= 128 * m;
}
var KT = {}.toString,
  ZT =
    Array.isArray ||
    function (e) {
      return "[object Array]" == KT.call(e);
    };
function JT() {
  return eI.TYPED_ARRAY_SUPPORT ? 2147483647 : 1073741823;
}
function $T(e, t) {
  if (JT() < t) throw new RangeError("Invalid typed array length");
  return (
    eI.TYPED_ARRAY_SUPPORT
      ? ((e = new Uint8Array(t)).__proto__ = eI.prototype)
      : (null === e && (e = new eI(t)), (e.length = t)),
    e
  );
}
function eI(e, t, i) {
  if (!(eI.TYPED_ARRAY_SUPPORT || this instanceof eI)) return new eI(e, t, i);
  if ("number" == typeof e) {
    if ("string" == typeof t)
      throw new Error(
        "If encoding is specified then the first argument must be a string"
      );
    return nI(this, e);
  }
  return tI(this, e, t, i);
}
function tI(e, t, i, n) {
  if ("number" == typeof t)
    throw new TypeError('"value" argument must not be a number');
  return "undefined" != typeof ArrayBuffer && t instanceof ArrayBuffer
    ? (function (e, t, i, n) {
        if ((t.byteLength, i < 0 || t.byteLength < i))
          throw new RangeError("'offset' is out of bounds");
        if (t.byteLength < i + (n || 0))
          throw new RangeError("'length' is out of bounds");
        t =
          void 0 === i && void 0 === n
            ? new Uint8Array(t)
            : void 0 === n
            ? new Uint8Array(t, i)
            : new Uint8Array(t, i, n);
        eI.TYPED_ARRAY_SUPPORT
          ? ((e = t).__proto__ = eI.prototype)
          : (e = sI(e, t));
        return e;
      })(e, t, i, n)
    : "string" == typeof t
    ? (function (e, t, i) {
        ("string" == typeof i && "" !== i) || (i = "utf8");
        if (!eI.isEncoding(i))
          throw new TypeError('"encoding" must be a valid string encoding');
        var n = 0 | oI(t, i);
        e = $T(e, n);
        var s = e.write(t, i);
        s !== n && (e = e.slice(0, s));
        return e;
      })(e, t, i)
    : (function (e, t) {
        if (aI(t)) {
          var i = 0 | rI(t.length);
          return 0 === (e = $T(e, i)).length || t.copy(e, 0, 0, i), e;
        }
        if (t) {
          if (
            ("undefined" != typeof ArrayBuffer &&
              t.buffer instanceof ArrayBuffer) ||
            "length" in t
          )
            return "number" != typeof t.length || (n = t.length) != n
              ? $T(e, 0)
              : sI(e, t);
          if ("Buffer" === t.type && ZT(t.data)) return sI(e, t.data);
        }
        var n;
        throw new TypeError(
          "First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object."
        );
      })(e, t);
}
function iI(e) {
  if ("number" != typeof e)
    throw new TypeError('"size" argument must be a number');
  if (e < 0) throw new RangeError('"size" argument must not be negative');
}
function nI(e, t) {
  if ((iI(t), (e = $T(e, t < 0 ? 0 : 0 | rI(t))), !eI.TYPED_ARRAY_SUPPORT))
    for (var i = 0; i < t; ++i) e[i] = 0;
  return e;
}
function sI(e, t) {
  var i = t.length < 0 ? 0 : 0 | rI(t.length);
  e = $T(e, i);
  for (var n = 0; n < i; n += 1) e[n] = 255 & t[n];
  return e;
}
function rI(e) {
  if (e >= JT())
    throw new RangeError(
      "Attempt to allocate Buffer larger than maximum size: 0x" +
        JT().toString(16) +
        " bytes"
    );
  return 0 | e;
}
function aI(e) {
  return !(null == e || !e._isBuffer);
}
function oI(e, t) {
  if (aI(e)) return e.length;
  if (
    "undefined" != typeof ArrayBuffer &&
    "function" == typeof ArrayBuffer.isView &&
    (ArrayBuffer.isView(e) || e instanceof ArrayBuffer)
  )
    return e.byteLength;
  "string" != typeof e && (e = "" + e);
  var i = e.length;
  if (0 === i) return 0;
  for (var n = !1; ; )
    switch (t) {
      case "ascii":
      case "latin1":
      case "binary":
        return i;
      case "utf8":
      case "utf-8":
      case void 0:
        return FI(e).length;
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return 2 * i;
      case "hex":
        return i >>> 1;
      case "base64":
        return NI(e).length;
      default:
        if (n) return FI(e).length;
        (t = ("" + t).toLowerCase()), (n = !0);
    }
}
function lI(e, t, i) {
  var n = !1;
  if (((void 0 === t || t < 0) && (t = 0), t > this.length)) return "";
  if (((void 0 === i || i > this.length) && (i = this.length), i <= 0))
    return "";
  if ((i >>>= 0) <= (t >>>= 0)) return "";
  for (e || (e = "utf8"); ; )
    switch (e) {
      case "hex":
        return EI(this, t, i);
      case "utf8":
      case "utf-8":
        return AI(this, t, i);
      case "ascii":
        return xI(this, t, i);
      case "latin1":
      case "binary":
        return bI(this, t, i);
      case "base64":
        return vI(this, t, i);
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return SI(this, t, i);
      default:
        if (n) throw new TypeError("Unknown encoding: " + e);
        (e = (e + "").toLowerCase()), (n = !0);
    }
}
function hI(e, t, i) {
  var n = e[t];
  (e[t] = e[i]), (e[i] = n);
}
function cI(e, t, i, n, s) {
  if (0 === e.length) return -1;
  if (
    ("string" == typeof i
      ? ((n = i), (i = 0))
      : i > 2147483647
      ? (i = 2147483647)
      : i < -2147483648 && (i = -2147483648),
    (i = +i),
    isNaN(i) && (i = s ? 0 : e.length - 1),
    i < 0 && (i = e.length + i),
    i >= e.length)
  ) {
    if (s) return -1;
    i = e.length - 1;
  } else if (i < 0) {
    if (!s) return -1;
    i = 0;
  }
  if (("string" == typeof t && (t = eI.from(t, n)), aI(t)))
    return 0 === t.length ? -1 : uI(e, t, i, n, s);
  if ("number" == typeof t)
    return (
      (t &= 255),
      eI.TYPED_ARRAY_SUPPORT &&
      "function" == typeof Uint8Array.prototype.indexOf
        ? s
          ? Uint8Array.prototype.indexOf.call(e, t, i)
          : Uint8Array.prototype.lastIndexOf.call(e, t, i)
        : uI(e, [t], i, n, s)
    );
  throw new TypeError("val must be string, number or Buffer");
}
function uI(e, t, i, n, s) {
  var r,
    a = 1,
    o = e.length,
    l = t.length;
  if (
    void 0 !== n &&
    ("ucs2" === (n = String(n).toLowerCase()) ||
      "ucs-2" === n ||
      "utf16le" === n ||
      "utf-16le" === n)
  ) {
    if (e.length < 2 || t.length < 2) return -1;
    (a = 2), (o /= 2), (l /= 2), (i /= 2);
  }
  function h(e, t) {
    return 1 === a ? e[t] : e.readUInt16BE(t * a);
  }
  if (s) {
    var c = -1;
    for (r = i; r < o; r++)
      if (h(e, r) === h(t, -1 === c ? 0 : r - c)) {
        if ((-1 === c && (c = r), r - c + 1 === l)) return c * a;
      } else -1 !== c && (r -= r - c), (c = -1);
  } else
    for (i + l > o && (i = o - l), r = i; r >= 0; r--) {
      for (var u = !0, d = 0; d < l; d++)
        if (h(e, r + d) !== h(t, d)) {
          u = !1;
          break;
        }
      if (u) return r;
    }
  return -1;
}
function dI(e, t, i, n) {
  i = Number(i) || 0;
  var s = e.length - i;
  n ? (n = Number(n)) > s && (n = s) : (n = s);
  var r = t.length;
  if (r % 2 != 0) throw new TypeError("Invalid hex string");
  n > r / 2 && (n = r / 2);
  for (var a = 0; a < n; ++a) {
    var o = parseInt(t.substr(2 * a, 2), 16);
    if (isNaN(o)) return a;
    e[i + a] = o;
  }
  return a;
}
function pI(e, t, i, n) {
  return BI(FI(t, e.length - i), e, i, n);
}
function fI(e, t, i, n) {
  return BI(
    (function (e) {
      for (var t = [], i = 0; i < e.length; ++i) t.push(255 & e.charCodeAt(i));
      return t;
    })(t),
    e,
    i,
    n
  );
}
function mI(e, t, i, n) {
  return fI(e, t, i, n);
}
function gI(e, t, i, n) {
  return BI(NI(t), e, i, n);
}
function _I(e, t, i, n) {
  return BI(
    (function (e, t) {
      for (var i, n, s, r = [], a = 0; a < e.length && !((t -= 2) < 0); ++a)
        (n = (i = e.charCodeAt(a)) >> 8), (s = i % 256), r.push(s), r.push(n);
      return r;
    })(t, e.length - i),
    e,
    i,
    n
  );
}
function vI(e, t, i) {
  return 0 === t && i === e.length ? qT(e) : qT(e.slice(t, i));
}
function AI(e, t, i) {
  i = Math.min(e.length, i);
  for (var n = [], s = t; s < i; ) {
    var r,
      a,
      o,
      l,
      h = e[s],
      c = null,
      u = h > 239 ? 4 : h > 223 ? 3 : h > 191 ? 2 : 1;
    if (s + u <= i)
      switch (u) {
        case 1:
          h < 128 && (c = h);
          break;
        case 2:
          128 == (192 & (r = e[s + 1])) &&
            (l = ((31 & h) << 6) | (63 & r)) > 127 &&
            (c = l);
          break;
        case 3:
          (r = e[s + 1]),
            (a = e[s + 2]),
            128 == (192 & r) &&
              128 == (192 & a) &&
              (l = ((15 & h) << 12) | ((63 & r) << 6) | (63 & a)) > 2047 &&
              (l < 55296 || l > 57343) &&
              (c = l);
          break;
        case 4:
          (r = e[s + 1]),
            (a = e[s + 2]),
            (o = e[s + 3]),
            128 == (192 & r) &&
              128 == (192 & a) &&
              128 == (192 & o) &&
              (l =
                ((15 & h) << 18) |
                ((63 & r) << 12) |
                ((63 & a) << 6) |
                (63 & o)) > 65535 &&
              l < 1114112 &&
              (c = l);
      }
    null === c
      ? ((c = 65533), (u = 1))
      : c > 65535 &&
        ((c -= 65536),
        n.push(((c >>> 10) & 1023) | 55296),
        (c = 56320 | (1023 & c))),
      n.push(c),
      (s += u);
  }
  return (function (e) {
    var t = e.length;
    if (t <= yI) return String.fromCharCode.apply(String, e);
    var i = "",
      n = 0;
    for (; n < t; )
      i += String.fromCharCode.apply(String, e.slice(n, (n += yI)));
    return i;
  })(n);
}
(eI.TYPED_ARRAY_SUPPORT =
  void 0 === zT.TYPED_ARRAY_SUPPORT || zT.TYPED_ARRAY_SUPPORT),
  JT(),
  (eI.poolSize = 8192),
  (eI._augment = function (e) {
    return (e.__proto__ = eI.prototype), e;
  }),
  (eI.from = function (e, t, i) {
    return tI(null, e, t, i);
  }),
  eI.TYPED_ARRAY_SUPPORT &&
    ((eI.prototype.__proto__ = Uint8Array.prototype),
    (eI.__proto__ = Uint8Array),
    "undefined" != typeof Symbol && Symbol.species && eI[Symbol.species]),
  (eI.alloc = function (e, t, i) {
    return (function (e, t, i, n) {
      return (
        iI(t),
        t <= 0
          ? $T(e, t)
          : void 0 !== i
          ? "string" == typeof n
            ? $T(e, t).fill(i, n)
            : $T(e, t).fill(i)
          : $T(e, t)
      );
    })(null, e, t, i);
  }),
  (eI.allocUnsafe = function (e) {
    return nI(null, e);
  }),
  (eI.allocUnsafeSlow = function (e) {
    return nI(null, e);
  }),
  (eI.isBuffer = kI),
  (eI.compare = function (e, t) {
    if (!aI(e) || !aI(t)) throw new TypeError("Arguments must be Buffers");
    if (e === t) return 0;
    for (var i = e.length, n = t.length, s = 0, r = Math.min(i, n); s < r; ++s)
      if (e[s] !== t[s]) {
        (i = e[s]), (n = t[s]);
        break;
      }
    return i < n ? -1 : n < i ? 1 : 0;
  }),
  (eI.isEncoding = function (e) {
    switch (String(e).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return !0;
      default:
        return !1;
    }
  }),
  (eI.concat = function (e, t) {
    if (!ZT(e))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (0 === e.length) return eI.alloc(0);
    var i;
    if (void 0 === t) for (t = 0, i = 0; i < e.length; ++i) t += e[i].length;
    var n = eI.allocUnsafe(t),
      s = 0;
    for (i = 0; i < e.length; ++i) {
      var r = e[i];
      if (!aI(r))
        throw new TypeError('"list" argument must be an Array of Buffers');
      r.copy(n, s), (s += r.length);
    }
    return n;
  }),
  (eI.byteLength = oI),
  (eI.prototype._isBuffer = !0),
  (eI.prototype.swap16 = function () {
    var e = this.length;
    if (e % 2 != 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (var t = 0; t < e; t += 2) hI(this, t, t + 1);
    return this;
  }),
  (eI.prototype.swap32 = function () {
    var e = this.length;
    if (e % 4 != 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (var t = 0; t < e; t += 4) hI(this, t, t + 3), hI(this, t + 1, t + 2);
    return this;
  }),
  (eI.prototype.swap64 = function () {
    var e = this.length;
    if (e % 8 != 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (var t = 0; t < e; t += 8)
      hI(this, t, t + 7),
        hI(this, t + 1, t + 6),
        hI(this, t + 2, t + 5),
        hI(this, t + 3, t + 4);
    return this;
  }),
  (eI.prototype.toString = function () {
    var e = 0 | this.length;
    return 0 === e
      ? ""
      : 0 === arguments.length
      ? AI(this, 0, e)
      : lI.apply(this, arguments);
  }),
  (eI.prototype.equals = function (e) {
    if (!aI(e)) throw new TypeError("Argument must be a Buffer");
    return this === e || 0 === eI.compare(this, e);
  }),
  (eI.prototype.inspect = function () {
    var e = "";
    return (
      this.length > 0 &&
        ((e = this.toString("hex", 0, 50).match(/.{2}/g).join(" ")),
        this.length > 50 && (e += " ... ")),
      "<Buffer " + e + ">"
    );
  }),
  (eI.prototype.compare = function (e, t, i, n, s) {
    if (!aI(e)) throw new TypeError("Argument must be a Buffer");
    if (
      (void 0 === t && (t = 0),
      void 0 === i && (i = e ? e.length : 0),
      void 0 === n && (n = 0),
      void 0 === s && (s = this.length),
      t < 0 || i > e.length || n < 0 || s > this.length)
    )
      throw new RangeError("out of range index");
    if (n >= s && t >= i) return 0;
    if (n >= s) return -1;
    if (t >= i) return 1;
    if (this === e) return 0;
    for (
      var r = (s >>>= 0) - (n >>>= 0),
        a = (i >>>= 0) - (t >>>= 0),
        o = Math.min(r, a),
        l = this.slice(n, s),
        h = e.slice(t, i),
        c = 0;
      c < o;
      ++c
    )
      if (l[c] !== h[c]) {
        (r = l[c]), (a = h[c]);
        break;
      }
    return r < a ? -1 : a < r ? 1 : 0;
  }),
  (eI.prototype.includes = function (e, t, i) {
    return -1 !== this.indexOf(e, t, i);
  }),
  (eI.prototype.indexOf = function (e, t, i) {
    return cI(this, e, t, i, !0);
  }),
  (eI.prototype.lastIndexOf = function (e, t, i) {
    return cI(this, e, t, i, !1);
  }),
  (eI.prototype.write = function (e, t, i, n) {
    if (void 0 === t) (n = "utf8"), (i = this.length), (t = 0);
    else if (void 0 === i && "string" == typeof t)
      (n = t), (i = this.length), (t = 0);
    else {
      if (!isFinite(t))
        throw new Error(
          "Buffer.write(string, encoding, offset[, length]) is no longer supported"
        );
      (t |= 0),
        isFinite(i)
          ? ((i |= 0), void 0 === n && (n = "utf8"))
          : ((n = i), (i = void 0));
    }
    var s = this.length - t;
    if (
      ((void 0 === i || i > s) && (i = s),
      (e.length > 0 && (i < 0 || t < 0)) || t > this.length)
    )
      throw new RangeError("Attempt to write outside buffer bounds");
    n || (n = "utf8");
    for (var r = !1; ; )
      switch (n) {
        case "hex":
          return dI(this, e, t, i);
        case "utf8":
        case "utf-8":
          return pI(this, e, t, i);
        case "ascii":
          return fI(this, e, t, i);
        case "latin1":
        case "binary":
          return mI(this, e, t, i);
        case "base64":
          return gI(this, e, t, i);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return _I(this, e, t, i);
        default:
          if (r) throw new TypeError("Unknown encoding: " + n);
          (n = ("" + n).toLowerCase()), (r = !0);
      }
  }),
  (eI.prototype.toJSON = function () {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0),
    };
  });
var yI = 4096;
function xI(e, t, i) {
  var n = "";
  i = Math.min(e.length, i);
  for (var s = t; s < i; ++s) n += String.fromCharCode(127 & e[s]);
  return n;
}
function bI(e, t, i) {
  var n = "";
  i = Math.min(e.length, i);
  for (var s = t; s < i; ++s) n += String.fromCharCode(e[s]);
  return n;
}
function EI(e, t, i) {
  var n = e.length;
  (!t || t < 0) && (t = 0), (!i || i < 0 || i > n) && (i = n);
  for (var s = "", r = t; r < i; ++r) s += LI(e[r]);
  return s;
}
function SI(e, t, i) {
  for (var n = e.slice(t, i), s = "", r = 0; r < n.length; r += 2)
    s += String.fromCharCode(n[r] + 256 * n[r + 1]);
  return s;
}
function CI(e, t, i) {
  if (e % 1 != 0 || e < 0) throw new RangeError("offset is not uint");
  if (e + t > i) throw new RangeError("Trying to access beyond buffer length");
}
function MI(e, t, i, n, s, r) {
  if (!aI(e))
    throw new TypeError('"buffer" argument must be a Buffer instance');
  if (t > s || t < r) throw new RangeError('"value" argument is out of bounds');
  if (i + n > e.length) throw new RangeError("Index out of range");
}
function wI(e, t, i, n) {
  t < 0 && (t = 65535 + t + 1);
  for (var s = 0, r = Math.min(e.length - i, 2); s < r; ++s)
    e[i + s] = (t & (255 << (8 * (n ? s : 1 - s)))) >>> (8 * (n ? s : 1 - s));
}
function TI(e, t, i, n) {
  t < 0 && (t = 4294967295 + t + 1);
  for (var s = 0, r = Math.min(e.length - i, 4); s < r; ++s)
    e[i + s] = (t >>> (8 * (n ? s : 3 - s))) & 255;
}
function II(e, t, i, n, s, r) {
  if (i + n > e.length) throw new RangeError("Index out of range");
  if (i < 0) throw new RangeError("Index out of range");
}
function RI(e, t, i, n, s) {
  return s || II(e, 0, i, 4), YT(e, t, i, n, 23, 4), i + 4;
}
function PI(e, t, i, n, s) {
  return s || II(e, 0, i, 8), YT(e, t, i, n, 52, 8), i + 8;
}
(eI.prototype.slice = function (e, t) {
  var i,
    n = this.length;
  if (
    ((e = ~~e) < 0 ? (e += n) < 0 && (e = 0) : e > n && (e = n),
    (t = void 0 === t ? n : ~~t) < 0
      ? (t += n) < 0 && (t = 0)
      : t > n && (t = n),
    t < e && (t = e),
    eI.TYPED_ARRAY_SUPPORT)
  )
    (i = this.subarray(e, t)).__proto__ = eI.prototype;
  else {
    var s = t - e;
    i = new eI(s, void 0);
    for (var r = 0; r < s; ++r) i[r] = this[r + e];
  }
  return i;
}),
  (eI.prototype.readUIntLE = function (e, t, i) {
    (e |= 0), (t |= 0), i || CI(e, t, this.length);
    for (var n = this[e], s = 1, r = 0; ++r < t && (s *= 256); )
      n += this[e + r] * s;
    return n;
  }),
  (eI.prototype.readUIntBE = function (e, t, i) {
    (e |= 0), (t |= 0), i || CI(e, t, this.length);
    for (var n = this[e + --t], s = 1; t > 0 && (s *= 256); )
      n += this[e + --t] * s;
    return n;
  }),
  (eI.prototype.readUInt8 = function (e, t) {
    return t || CI(e, 1, this.length), this[e];
  }),
  (eI.prototype.readUInt16LE = function (e, t) {
    return t || CI(e, 2, this.length), this[e] | (this[e + 1] << 8);
  }),
  (eI.prototype.readUInt16BE = function (e, t) {
    return t || CI(e, 2, this.length), (this[e] << 8) | this[e + 1];
  }),
  (eI.prototype.readUInt32LE = function (e, t) {
    return (
      t || CI(e, 4, this.length),
      (this[e] | (this[e + 1] << 8) | (this[e + 2] << 16)) +
        16777216 * this[e + 3]
    );
  }),
  (eI.prototype.readUInt32BE = function (e, t) {
    return (
      t || CI(e, 4, this.length),
      16777216 * this[e] +
        ((this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3])
    );
  }),
  (eI.prototype.readIntLE = function (e, t, i) {
    (e |= 0), (t |= 0), i || CI(e, t, this.length);
    for (var n = this[e], s = 1, r = 0; ++r < t && (s *= 256); )
      n += this[e + r] * s;
    return n >= (s *= 128) && (n -= Math.pow(2, 8 * t)), n;
  }),
  (eI.prototype.readIntBE = function (e, t, i) {
    (e |= 0), (t |= 0), i || CI(e, t, this.length);
    for (var n = t, s = 1, r = this[e + --n]; n > 0 && (s *= 256); )
      r += this[e + --n] * s;
    return r >= (s *= 128) && (r -= Math.pow(2, 8 * t)), r;
  }),
  (eI.prototype.readInt8 = function (e, t) {
    return (
      t || CI(e, 1, this.length),
      128 & this[e] ? -1 * (255 - this[e] + 1) : this[e]
    );
  }),
  (eI.prototype.readInt16LE = function (e, t) {
    t || CI(e, 2, this.length);
    var i = this[e] | (this[e + 1] << 8);
    return 32768 & i ? 4294901760 | i : i;
  }),
  (eI.prototype.readInt16BE = function (e, t) {
    t || CI(e, 2, this.length);
    var i = this[e + 1] | (this[e] << 8);
    return 32768 & i ? 4294901760 | i : i;
  }),
  (eI.prototype.readInt32LE = function (e, t) {
    return (
      t || CI(e, 4, this.length),
      this[e] | (this[e + 1] << 8) | (this[e + 2] << 16) | (this[e + 3] << 24)
    );
  }),
  (eI.prototype.readInt32BE = function (e, t) {
    return (
      t || CI(e, 4, this.length),
      (this[e] << 24) | (this[e + 1] << 16) | (this[e + 2] << 8) | this[e + 3]
    );
  }),
  (eI.prototype.readFloatLE = function (e, t) {
    return t || CI(e, 4, this.length), XT(this, e, !0, 23, 4);
  }),
  (eI.prototype.readFloatBE = function (e, t) {
    return t || CI(e, 4, this.length), XT(this, e, !1, 23, 4);
  }),
  (eI.prototype.readDoubleLE = function (e, t) {
    return t || CI(e, 8, this.length), XT(this, e, !0, 52, 8);
  }),
  (eI.prototype.readDoubleBE = function (e, t) {
    return t || CI(e, 8, this.length), XT(this, e, !1, 52, 8);
  }),
  (eI.prototype.writeUIntLE = function (e, t, i, n) {
    ((e = +e), (t |= 0), (i |= 0), n) ||
      MI(this, e, t, i, Math.pow(2, 8 * i) - 1, 0);
    var s = 1,
      r = 0;
    for (this[t] = 255 & e; ++r < i && (s *= 256); )
      this[t + r] = (e / s) & 255;
    return t + i;
  }),
  (eI.prototype.writeUIntBE = function (e, t, i, n) {
    ((e = +e), (t |= 0), (i |= 0), n) ||
      MI(this, e, t, i, Math.pow(2, 8 * i) - 1, 0);
    var s = i - 1,
      r = 1;
    for (this[t + s] = 255 & e; --s >= 0 && (r *= 256); )
      this[t + s] = (e / r) & 255;
    return t + i;
  }),
  (eI.prototype.writeUInt8 = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 1, 255, 0),
      eI.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
      (this[t] = 255 & e),
      t + 1
    );
  }),
  (eI.prototype.writeUInt16LE = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 2, 65535, 0),
      eI.TYPED_ARRAY_SUPPORT
        ? ((this[t] = 255 & e), (this[t + 1] = e >>> 8))
        : wI(this, e, t, !0),
      t + 2
    );
  }),
  (eI.prototype.writeUInt16BE = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 2, 65535, 0),
      eI.TYPED_ARRAY_SUPPORT
        ? ((this[t] = e >>> 8), (this[t + 1] = 255 & e))
        : wI(this, e, t, !1),
      t + 2
    );
  }),
  (eI.prototype.writeUInt32LE = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 4, 4294967295, 0),
      eI.TYPED_ARRAY_SUPPORT
        ? ((this[t + 3] = e >>> 24),
          (this[t + 2] = e >>> 16),
          (this[t + 1] = e >>> 8),
          (this[t] = 255 & e))
        : TI(this, e, t, !0),
      t + 4
    );
  }),
  (eI.prototype.writeUInt32BE = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 4, 4294967295, 0),
      eI.TYPED_ARRAY_SUPPORT
        ? ((this[t] = e >>> 24),
          (this[t + 1] = e >>> 16),
          (this[t + 2] = e >>> 8),
          (this[t + 3] = 255 & e))
        : TI(this, e, t, !1),
      t + 4
    );
  }),
  (eI.prototype.writeIntLE = function (e, t, i, n) {
    if (((e = +e), (t |= 0), !n)) {
      var s = Math.pow(2, 8 * i - 1);
      MI(this, e, t, i, s - 1, -s);
    }
    var r = 0,
      a = 1,
      o = 0;
    for (this[t] = 255 & e; ++r < i && (a *= 256); )
      e < 0 && 0 === o && 0 !== this[t + r - 1] && (o = 1),
        (this[t + r] = (((e / a) >> 0) - o) & 255);
    return t + i;
  }),
  (eI.prototype.writeIntBE = function (e, t, i, n) {
    if (((e = +e), (t |= 0), !n)) {
      var s = Math.pow(2, 8 * i - 1);
      MI(this, e, t, i, s - 1, -s);
    }
    var r = i - 1,
      a = 1,
      o = 0;
    for (this[t + r] = 255 & e; --r >= 0 && (a *= 256); )
      e < 0 && 0 === o && 0 !== this[t + r + 1] && (o = 1),
        (this[t + r] = (((e / a) >> 0) - o) & 255);
    return t + i;
  }),
  (eI.prototype.writeInt8 = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 1, 127, -128),
      eI.TYPED_ARRAY_SUPPORT || (e = Math.floor(e)),
      e < 0 && (e = 255 + e + 1),
      (this[t] = 255 & e),
      t + 1
    );
  }),
  (eI.prototype.writeInt16LE = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 2, 32767, -32768),
      eI.TYPED_ARRAY_SUPPORT
        ? ((this[t] = 255 & e), (this[t + 1] = e >>> 8))
        : wI(this, e, t, !0),
      t + 2
    );
  }),
  (eI.prototype.writeInt16BE = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 2, 32767, -32768),
      eI.TYPED_ARRAY_SUPPORT
        ? ((this[t] = e >>> 8), (this[t + 1] = 255 & e))
        : wI(this, e, t, !1),
      t + 2
    );
  }),
  (eI.prototype.writeInt32LE = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 4, 2147483647, -2147483648),
      eI.TYPED_ARRAY_SUPPORT
        ? ((this[t] = 255 & e),
          (this[t + 1] = e >>> 8),
          (this[t + 2] = e >>> 16),
          (this[t + 3] = e >>> 24))
        : TI(this, e, t, !0),
      t + 4
    );
  }),
  (eI.prototype.writeInt32BE = function (e, t, i) {
    return (
      (e = +e),
      (t |= 0),
      i || MI(this, e, t, 4, 2147483647, -2147483648),
      e < 0 && (e = 4294967295 + e + 1),
      eI.TYPED_ARRAY_SUPPORT
        ? ((this[t] = e >>> 24),
          (this[t + 1] = e >>> 16),
          (this[t + 2] = e >>> 8),
          (this[t + 3] = 255 & e))
        : TI(this, e, t, !1),
      t + 4
    );
  }),
  (eI.prototype.writeFloatLE = function (e, t, i) {
    return RI(this, e, t, !0, i);
  }),
  (eI.prototype.writeFloatBE = function (e, t, i) {
    return RI(this, e, t, !1, i);
  }),
  (eI.prototype.writeDoubleLE = function (e, t, i) {
    return PI(this, e, t, !0, i);
  }),
  (eI.prototype.writeDoubleBE = function (e, t, i) {
    return PI(this, e, t, !1, i);
  }),
  (eI.prototype.copy = function (e, t, i, n) {
    if (
      (i || (i = 0),
      n || 0 === n || (n = this.length),
      t >= e.length && (t = e.length),
      t || (t = 0),
      n > 0 && n < i && (n = i),
      n === i)
    )
      return 0;
    if (0 === e.length || 0 === this.length) return 0;
    if (t < 0) throw new RangeError("targetStart out of bounds");
    if (i < 0 || i >= this.length)
      throw new RangeError("sourceStart out of bounds");
    if (n < 0) throw new RangeError("sourceEnd out of bounds");
    n > this.length && (n = this.length),
      e.length - t < n - i && (n = e.length - t + i);
    var s,
      r = n - i;
    if (this === e && i < t && t < n)
      for (s = r - 1; s >= 0; --s) e[s + t] = this[s + i];
    else if (r < 1e3 || !eI.TYPED_ARRAY_SUPPORT)
      for (s = 0; s < r; ++s) e[s + t] = this[s + i];
    else Uint8Array.prototype.set.call(e, this.subarray(i, i + r), t);
    return r;
  }),
  (eI.prototype.fill = function (e, t, i, n) {
    if ("string" == typeof e) {
      if (
        ("string" == typeof t
          ? ((n = t), (t = 0), (i = this.length))
          : "string" == typeof i && ((n = i), (i = this.length)),
        1 === e.length)
      ) {
        var s = e.charCodeAt(0);
        s < 256 && (e = s);
      }
      if (void 0 !== n && "string" != typeof n)
        throw new TypeError("encoding must be a string");
      if ("string" == typeof n && !eI.isEncoding(n))
        throw new TypeError("Unknown encoding: " + n);
    } else "number" == typeof e && (e &= 255);
    if (t < 0 || this.length < t || this.length < i)
      throw new RangeError("Out of range index");
    if (i <= t) return this;
    var r;
    if (
      ((t >>>= 0),
      (i = void 0 === i ? this.length : i >>> 0),
      e || (e = 0),
      "number" == typeof e)
    )
      for (r = t; r < i; ++r) this[r] = e;
    else {
      var a = aI(e) ? e : FI(new eI(e, n).toString()),
        o = a.length;
      for (r = 0; r < i - t; ++r) this[r + t] = a[r % o];
    }
    return this;
  });
var DI = /[^+\/0-9A-Za-z-_]/g;
function LI(e) {
  return e < 16 ? "0" + e.toString(16) : e.toString(16);
}
function FI(e, t) {
  var i;
  t = t || 1 / 0;
  for (var n = e.length, s = null, r = [], a = 0; a < n; ++a) {
    if ((i = e.charCodeAt(a)) > 55295 && i < 57344) {
      if (!s) {
        if (i > 56319) {
          (t -= 3) > -1 && r.push(239, 191, 189);
          continue;
        }
        if (a + 1 === n) {
          (t -= 3) > -1 && r.push(239, 191, 189);
          continue;
        }
        s = i;
        continue;
      }
      if (i < 56320) {
        (t -= 3) > -1 && r.push(239, 191, 189), (s = i);
        continue;
      }
      i = 65536 + (((s - 55296) << 10) | (i - 56320));
    } else s && (t -= 3) > -1 && r.push(239, 191, 189);
    if (((s = null), i < 128)) {
      if ((t -= 1) < 0) break;
      r.push(i);
    } else if (i < 2048) {
      if ((t -= 2) < 0) break;
      r.push((i >> 6) | 192, (63 & i) | 128);
    } else if (i < 65536) {
      if ((t -= 3) < 0) break;
      r.push((i >> 12) | 224, ((i >> 6) & 63) | 128, (63 & i) | 128);
    } else {
      if (!(i < 1114112)) throw new Error("Invalid code point");
      if ((t -= 4) < 0) break;
      r.push(
        (i >> 18) | 240,
        ((i >> 12) & 63) | 128,
        ((i >> 6) & 63) | 128,
        (63 & i) | 128
      );
    }
  }
  return r;
}
function NI(e) {
  return (function (e) {
    var t, i, n, s, r, a;
    HT || jT();
    var o = e.length;
    if (o % 4 > 0)
      throw new Error("Invalid string. Length must be a multiple of 4");
    (r = "=" === e[o - 2] ? 2 : "=" === e[o - 1] ? 1 : 0),
      (a = new QT((3 * o) / 4 - r)),
      (n = r > 0 ? o - 4 : o);
    var l = 0;
    for (t = 0, i = 0; t < n; t += 4, i += 3)
      (s =
        (VT[e.charCodeAt(t)] << 18) |
        (VT[e.charCodeAt(t + 1)] << 12) |
        (VT[e.charCodeAt(t + 2)] << 6) |
        VT[e.charCodeAt(t + 3)]),
        (a[l++] = (s >> 16) & 255),
        (a[l++] = (s >> 8) & 255),
        (a[l++] = 255 & s);
    return (
      2 === r
        ? ((s = (VT[e.charCodeAt(t)] << 2) | (VT[e.charCodeAt(t + 1)] >> 4)),
          (a[l++] = 255 & s))
        : 1 === r &&
          ((s =
            (VT[e.charCodeAt(t)] << 10) |
            (VT[e.charCodeAt(t + 1)] << 4) |
            (VT[e.charCodeAt(t + 2)] >> 2)),
          (a[l++] = (s >> 8) & 255),
          (a[l++] = 255 & s)),
      a
    );
  })(
    (function (e) {
      if (
        (e = (function (e) {
          return e.trim ? e.trim() : e.replace(/^\s+|\s+$/g, "");
        })(e).replace(DI, "")).length < 2
      )
        return "";
      for (; e.length % 4 != 0; ) e += "=";
      return e;
    })(e)
  );
}
function BI(e, t, i, n) {
  for (var s = 0; s < n && !(s + i >= t.length || s >= e.length); ++s)
    t[s + i] = e[s];
  return s;
}
function kI(e) {
  return (
    null != e &&
    (!!e._isBuffer ||
      OI(e) ||
      (function (e) {
        return (
          "function" == typeof e.readFloatLE &&
          "function" == typeof e.slice &&
          OI(e.slice(0, 0))
        );
      })(e))
  );
}
function OI(e) {
  return (
    !!e.constructor &&
    "function" == typeof e.constructor.isBuffer &&
    e.constructor.isBuffer(e)
  );
}
class UI extends Error {
  constructor(e, t, i, ...n) {
    Array.isArray(t) && (t = t.join(" ")),
      super(t),
      void 0 !== Error.captureStackTrace && Error.captureStackTrace(this, UI),
      (this.code = e);
    for (const s of n)
      for (const e in s) {
        const t = s[e];
        this[e] = kI(t)
          ? t.toString(i.encoding)
          : null == t
          ? t
          : JSON.parse(JSON.stringify(t));
      }
  }
}
const zI = function (e) {
    return "object" == typeof e && null !== e && !Array.isArray(e);
  },
  GI = function (e) {
    const t = [];
    for (let i = 0, n = e.length; i < n; i++) {
      const n = e[i];
      if (null == n || !1 === n) t[i] = { disabled: !0 };
      else if ("string" == typeof n) t[i] = { name: n };
      else {
        if (!zI(n))
          throw new UI("CSV_INVALID_COLUMN_DEFINITION", [
            "Invalid column definition:",
            "expect a string or a literal object,",
            `got ${JSON.stringify(n)} at position ${i}`,
          ]);
        if ("string" != typeof n.name)
          throw new UI("CSV_OPTION_COLUMNS_MISSING_NAME", [
            "Option columns missing name:",
            `property "name" is required at position ${i}`,
            "when column is an object literal",
          ]);
        t[i] = n;
      }
    }
    return t;
  };
class VI {
  constructor(e = 100) {
    (this.size = e), (this.length = 0), (this.buf = eI.allocUnsafe(e));
  }
  prepend(e) {
    if (kI(e)) {
      const t = this.length + e.length;
      if (t >= this.size && (this.resize(), t >= this.size))
        throw Error("INVALID_BUFFER_STATE");
      const i = this.buf;
      (this.buf = eI.allocUnsafe(this.size)),
        e.copy(this.buf, 0),
        i.copy(this.buf, e.length),
        (this.length += e.length);
    } else {
      const t = this.length++;
      t === this.size && this.resize();
      const i = this.clone();
      (this.buf[0] = e), i.copy(this.buf, 1, 0, t);
    }
  }
  append(e) {
    const t = this.length++;
    t === this.size && this.resize(), (this.buf[t] = e);
  }
  clone() {
    return eI.from(this.buf.slice(0, this.length));
  }
  resize() {
    const e = this.length;
    this.size = 2 * this.size;
    const t = eI.allocUnsafe(this.size);
    this.buf.copy(t, 0, 0, e), (this.buf = t);
  }
  toString(e) {
    return e
      ? this.buf.slice(0, this.length).toString(e)
      : Uint8Array.prototype.slice.call(this.buf.slice(0, this.length));
  }
  toJSON() {
    return this.toString("utf8");
  }
  reset() {
    this.length = 0;
  }
}
const QI = function (e) {
    return {
      bomSkipped: !1,
      bufBytesStart: 0,
      castField: e.cast_function,
      commenting: !1,
      error: void 0,
      enabled: 1 === e.from_line,
      escaping: !1,
      escapeIsQuote:
        kI(e.escape) && kI(e.quote) && 0 === eI.compare(e.escape, e.quote),
      expectedRecordLength: Array.isArray(e.columns)
        ? e.columns.length
        : void 0,
      field: new VI(20),
      firstLineToHeaders: e.cast_first_line_to_header,
      needMoreDataSize: Math.max(
        null !== e.comment ? e.comment.length : 0,
        ...e.delimiter.map((e) => e.length),
        null !== e.quote ? e.quote.length : 0
      ),
      previousBuf: void 0,
      quoting: !1,
      stop: !1,
      rawBuffer: new VI(100),
      record: [],
      recordHasError: !1,
      record_length: 0,
      recordDelimiterMaxLength:
        0 === e.record_delimiter.length
          ? 2
          : Math.max(...e.record_delimiter.map((e) => e.length)),
      trimChars: [eI.from(" ", e.encoding)[0], eI.from("\t", e.encoding)[0]],
      wasQuoting: !1,
      wasRowDelimiter: !1,
      timchars: [
        eI.from(eI.from([13], "utf8").toString(), e.encoding),
        eI.from(eI.from([10], "utf8").toString(), e.encoding),
        eI.from(eI.from([12], "utf8").toString(), e.encoding),
        eI.from(eI.from([32], "utf8").toString(), e.encoding),
        eI.from(eI.from([9], "utf8").toString(), e.encoding),
      ],
    };
  },
  HI = function (e) {
    const t = {};
    for (const s in e)
      t[
        ((i = s),
        i.replace(/([A-Z])/g, function (e, t) {
          return "_" + t.toLowerCase();
        }))
      ] = e[s];
    var i;
    if (void 0 === t.encoding || !0 === t.encoding) t.encoding = "utf8";
    else if (null === t.encoding || !1 === t.encoding) t.encoding = null;
    else if ("string" != typeof t.encoding && null !== t.encoding)
      throw new UI(
        "CSV_INVALID_OPTION_ENCODING",
        [
          "Invalid option encoding:",
          "encoding must be a string or null to return a buffer,",
          `got ${JSON.stringify(t.encoding)}`,
        ],
        t
      );
    if (void 0 === t.bom || null === t.bom || !1 === t.bom) t.bom = !1;
    else if (!0 !== t.bom)
      throw new UI(
        "CSV_INVALID_OPTION_BOM",
        [
          "Invalid option bom:",
          "bom must be true,",
          `got ${JSON.stringify(t.bom)}`,
        ],
        t
      );
    if (
      ((t.cast_function = null),
      void 0 === t.cast || null === t.cast || !1 === t.cast || "" === t.cast)
    )
      t.cast = void 0;
    else if ("function" == typeof t.cast)
      (t.cast_function = t.cast), (t.cast = !0);
    else if (!0 !== t.cast)
      throw new UI(
        "CSV_INVALID_OPTION_CAST",
        [
          "Invalid option cast:",
          "cast must be true or a function,",
          `got ${JSON.stringify(t.cast)}`,
        ],
        t
      );
    if (
      void 0 === t.cast_date ||
      null === t.cast_date ||
      !1 === t.cast_date ||
      "" === t.cast_date
    )
      t.cast_date = !1;
    else if (!0 === t.cast_date)
      t.cast_date = function (e) {
        const t = Date.parse(e);
        return isNaN(t) ? e : new Date(t);
      };
    else if ("function" != typeof t.cast_date)
      throw new UI(
        "CSV_INVALID_OPTION_CAST_DATE",
        [
          "Invalid option cast_date:",
          "cast_date must be true or a function,",
          `got ${JSON.stringify(t.cast_date)}`,
        ],
        t
      );
    if (((t.cast_first_line_to_header = null), !0 === t.columns))
      t.cast_first_line_to_header = void 0;
    else if ("function" == typeof t.columns)
      (t.cast_first_line_to_header = t.columns), (t.columns = !0);
    else if (Array.isArray(t.columns)) t.columns = GI(t.columns);
    else {
      if (void 0 !== t.columns && null !== t.columns && !1 !== t.columns)
        throw new UI(
          "CSV_INVALID_OPTION_COLUMNS",
          [
            "Invalid option columns:",
            "expect an array, a function or true,",
            `got ${JSON.stringify(t.columns)}`,
          ],
          t
        );
      t.columns = !1;
    }
    if (
      void 0 === t.group_columns_by_name ||
      null === t.group_columns_by_name ||
      !1 === t.group_columns_by_name
    )
      t.group_columns_by_name = !1;
    else {
      if (!0 !== t.group_columns_by_name)
        throw new UI(
          "CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",
          [
            "Invalid option group_columns_by_name:",
            "expect an boolean,",
            `got ${JSON.stringify(t.group_columns_by_name)}`,
          ],
          t
        );
      if (!1 === t.columns)
        throw new UI(
          "CSV_INVALID_OPTION_GROUP_COLUMNS_BY_NAME",
          [
            "Invalid option group_columns_by_name:",
            "the `columns` mode must be activated.",
          ],
          t
        );
    }
    if (
      void 0 === t.comment ||
      null === t.comment ||
      !1 === t.comment ||
      "" === t.comment
    )
      t.comment = null;
    else if (
      ("string" == typeof t.comment &&
        (t.comment = eI.from(t.comment, t.encoding)),
      !kI(t.comment))
    )
      throw new UI(
        "CSV_INVALID_OPTION_COMMENT",
        [
          "Invalid option comment:",
          "comment must be a buffer or a string,",
          `got ${JSON.stringify(t.comment)}`,
        ],
        t
      );
    const n = JSON.stringify(t.delimiter);
    if (
      (Array.isArray(t.delimiter) || (t.delimiter = [t.delimiter]),
      0 === t.delimiter.length)
    )
      throw new UI(
        "CSV_INVALID_OPTION_DELIMITER",
        [
          "Invalid option delimiter:",
          "delimiter must be a non empty string or buffer or array of string|buffer,",
          `got ${n}`,
        ],
        t
      );
    if (
      ((t.delimiter = t.delimiter.map(function (e) {
        if (null == e || !1 === e) return eI.from(",", t.encoding);
        if (
          ("string" == typeof e && (e = eI.from(e, t.encoding)),
          !kI(e) || 0 === e.length)
        )
          throw new UI(
            "CSV_INVALID_OPTION_DELIMITER",
            [
              "Invalid option delimiter:",
              "delimiter must be a non empty string or buffer or array of string|buffer,",
              `got ${n}`,
            ],
            t
          );
        return e;
      })),
      void 0 === t.escape || !0 === t.escape
        ? (t.escape = eI.from('"', t.encoding))
        : "string" == typeof t.escape
        ? (t.escape = eI.from(t.escape, t.encoding))
        : (null !== t.escape && !1 !== t.escape) || (t.escape = null),
      null !== t.escape && !kI(t.escape))
    )
      throw new Error(
        `Invalid Option: escape must be a buffer, a string or a boolean, got ${JSON.stringify(
          t.escape
        )}`
      );
    if (void 0 === t.from || null === t.from) t.from = 1;
    else {
      if (
        ("string" == typeof t.from &&
          /\d+/.test(t.from) &&
          (t.from = parseInt(t.from)),
        !Number.isInteger(t.from))
      )
        throw new Error(
          `Invalid Option: from must be an integer, got ${JSON.stringify(
            t.from
          )}`
        );
      if (t.from < 0)
        throw new Error(
          `Invalid Option: from must be a positive integer, got ${JSON.stringify(
            e.from
          )}`
        );
    }
    if (void 0 === t.from_line || null === t.from_line) t.from_line = 1;
    else {
      if (
        ("string" == typeof t.from_line &&
          /\d+/.test(t.from_line) &&
          (t.from_line = parseInt(t.from_line)),
        !Number.isInteger(t.from_line))
      )
        throw new Error(
          `Invalid Option: from_line must be an integer, got ${JSON.stringify(
            e.from_line
          )}`
        );
      if (t.from_line <= 0)
        throw new Error(
          `Invalid Option: from_line must be a positive integer greater than 0, got ${JSON.stringify(
            e.from_line
          )}`
        );
    }
    if (
      void 0 === t.ignore_last_delimiters ||
      null === t.ignore_last_delimiters
    )
      t.ignore_last_delimiters = !1;
    else if ("number" == typeof t.ignore_last_delimiters)
      (t.ignore_last_delimiters = Math.floor(t.ignore_last_delimiters)),
        0 === t.ignore_last_delimiters && (t.ignore_last_delimiters = !1);
    else if ("boolean" != typeof t.ignore_last_delimiters)
      throw new UI(
        "CSV_INVALID_OPTION_IGNORE_LAST_DELIMITERS",
        [
          "Invalid option `ignore_last_delimiters`:",
          "the value must be a boolean value or an integer,",
          `got ${JSON.stringify(t.ignore_last_delimiters)}`,
        ],
        t
      );
    if (!0 === t.ignore_last_delimiters && !1 === t.columns)
      throw new UI(
        "CSV_IGNORE_LAST_DELIMITERS_REQUIRES_COLUMNS",
        [
          "The option `ignore_last_delimiters`",
          "requires the activation of the `columns` option",
        ],
        t
      );
    if (void 0 === t.info || null === t.info || !1 === t.info) t.info = !1;
    else if (!0 !== t.info)
      throw new Error(
        `Invalid Option: info must be true, got ${JSON.stringify(t.info)}`
      );
    if (
      void 0 === t.max_record_size ||
      null === t.max_record_size ||
      !1 === t.max_record_size
    )
      t.max_record_size = 0;
    else if (Number.isInteger(t.max_record_size) && t.max_record_size >= 0);
    else {
      if (
        "string" != typeof t.max_record_size ||
        !/\d+/.test(t.max_record_size)
      )
        throw new Error(
          `Invalid Option: max_record_size must be a positive integer, got ${JSON.stringify(
            t.max_record_size
          )}`
        );
      t.max_record_size = parseInt(t.max_record_size);
    }
    if (void 0 === t.objname || null === t.objname || !1 === t.objname)
      t.objname = void 0;
    else if (kI(t.objname)) {
      if (0 === t.objname.length)
        throw new Error("Invalid Option: objname must be a non empty buffer");
      null === t.encoding || (t.objname = t.objname.toString(t.encoding));
    } else if ("string" == typeof t.objname) {
      if (0 === t.objname.length)
        throw new Error("Invalid Option: objname must be a non empty string");
    } else if ("number" != typeof t.objname)
      throw new Error(
        `Invalid Option: objname must be a string or a buffer, got ${t.objname}`
      );
    if (void 0 !== t.objname)
      if ("number" == typeof t.objname) {
        if (!1 !== t.columns)
          throw Error(
            "Invalid Option: objname index cannot be combined with columns or be defined as a field"
          );
      } else if (!1 === t.columns)
        throw Error(
          "Invalid Option: objname field must be combined with columns or be defined as an index"
        );
    if (void 0 === t.on_record || null === t.on_record) t.on_record = void 0;
    else if ("function" != typeof t.on_record)
      throw new UI(
        "CSV_INVALID_OPTION_ON_RECORD",
        [
          "Invalid option `on_record`:",
          "expect a function,",
          `got ${JSON.stringify(t.on_record)}`,
        ],
        t
      );
    if (null === t.quote || !1 === t.quote || "" === t.quote) t.quote = null;
    else if (
      (void 0 === t.quote || !0 === t.quote
        ? (t.quote = eI.from('"', t.encoding))
        : "string" == typeof t.quote &&
          (t.quote = eI.from(t.quote, t.encoding)),
      !kI(t.quote))
    )
      throw new Error(
        `Invalid Option: quote must be a buffer or a string, got ${JSON.stringify(
          t.quote
        )}`
      );
    if (void 0 === t.raw || null === t.raw || !1 === t.raw) t.raw = !1;
    else if (!0 !== t.raw)
      throw new Error(
        `Invalid Option: raw must be true, got ${JSON.stringify(t.raw)}`
      );
    if (void 0 === t.record_delimiter) t.record_delimiter = [];
    else if ("string" == typeof t.record_delimiter || kI(t.record_delimiter)) {
      if (0 === t.record_delimiter.length)
        throw new UI(
          "CSV_INVALID_OPTION_RECORD_DELIMITER",
          [
            "Invalid option `record_delimiter`:",
            "value must be a non empty string or buffer,",
            `got ${JSON.stringify(t.record_delimiter)}`,
          ],
          t
        );
      t.record_delimiter = [t.record_delimiter];
    } else if (!Array.isArray(t.record_delimiter))
      throw new UI(
        "CSV_INVALID_OPTION_RECORD_DELIMITER",
        [
          "Invalid option `record_delimiter`:",
          "value must be a string, a buffer or array of string|buffer,",
          `got ${JSON.stringify(t.record_delimiter)}`,
        ],
        t
      );
    if (
      ((t.record_delimiter = t.record_delimiter.map(function (e, i) {
        if ("string" != typeof e && !kI(e))
          throw new UI(
            "CSV_INVALID_OPTION_RECORD_DELIMITER",
            [
              "Invalid option `record_delimiter`:",
              "value must be a string, a buffer or array of string|buffer",
              `at index ${i},`,
              `got ${JSON.stringify(e)}`,
            ],
            t
          );
        if (0 === e.length)
          throw new UI(
            "CSV_INVALID_OPTION_RECORD_DELIMITER",
            [
              "Invalid option `record_delimiter`:",
              "value must be a non empty string or buffer",
              `at index ${i},`,
              `got ${JSON.stringify(e)}`,
            ],
            t
          );
        return "string" == typeof e && (e = eI.from(e, t.encoding)), e;
      })),
      "boolean" == typeof t.relax_column_count)
    );
    else {
      if (void 0 !== t.relax_column_count && null !== t.relax_column_count)
        throw new Error(
          `Invalid Option: relax_column_count must be a boolean, got ${JSON.stringify(
            t.relax_column_count
          )}`
        );
      t.relax_column_count = !1;
    }
    if ("boolean" == typeof t.relax_column_count_less);
    else {
      if (
        void 0 !== t.relax_column_count_less &&
        null !== t.relax_column_count_less
      )
        throw new Error(
          `Invalid Option: relax_column_count_less must be a boolean, got ${JSON.stringify(
            t.relax_column_count_less
          )}`
        );
      t.relax_column_count_less = !1;
    }
    if ("boolean" == typeof t.relax_column_count_more);
    else {
      if (
        void 0 !== t.relax_column_count_more &&
        null !== t.relax_column_count_more
      )
        throw new Error(
          `Invalid Option: relax_column_count_more must be a boolean, got ${JSON.stringify(
            t.relax_column_count_more
          )}`
        );
      t.relax_column_count_more = !1;
    }
    if ("boolean" == typeof t.relax_quotes);
    else {
      if (void 0 !== t.relax_quotes && null !== t.relax_quotes)
        throw new Error(
          `Invalid Option: relax_quotes must be a boolean, got ${JSON.stringify(
            t.relax_quotes
          )}`
        );
      t.relax_quotes = !1;
    }
    if ("boolean" == typeof t.skip_empty_lines);
    else {
      if (void 0 !== t.skip_empty_lines && null !== t.skip_empty_lines)
        throw new Error(
          `Invalid Option: skip_empty_lines must be a boolean, got ${JSON.stringify(
            t.skip_empty_lines
          )}`
        );
      t.skip_empty_lines = !1;
    }
    if ("boolean" == typeof t.skip_records_with_empty_values);
    else {
      if (
        void 0 !== t.skip_records_with_empty_values &&
        null !== t.skip_records_with_empty_values
      )
        throw new Error(
          `Invalid Option: skip_records_with_empty_values must be a boolean, got ${JSON.stringify(
            t.skip_records_with_empty_values
          )}`
        );
      t.skip_records_with_empty_values = !1;
    }
    if ("boolean" == typeof t.skip_records_with_error);
    else {
      if (
        void 0 !== t.skip_records_with_error &&
        null !== t.skip_records_with_error
      )
        throw new Error(
          `Invalid Option: skip_records_with_error must be a boolean, got ${JSON.stringify(
            t.skip_records_with_error
          )}`
        );
      t.skip_records_with_error = !1;
    }
    if (void 0 === t.rtrim || null === t.rtrim || !1 === t.rtrim) t.rtrim = !1;
    else if (!0 !== t.rtrim)
      throw new Error(
        `Invalid Option: rtrim must be a boolean, got ${JSON.stringify(
          t.rtrim
        )}`
      );
    if (void 0 === t.ltrim || null === t.ltrim || !1 === t.ltrim) t.ltrim = !1;
    else if (!0 !== t.ltrim)
      throw new Error(
        `Invalid Option: ltrim must be a boolean, got ${JSON.stringify(
          t.ltrim
        )}`
      );
    if (void 0 === t.trim || null === t.trim || !1 === t.trim) t.trim = !1;
    else if (!0 !== t.trim)
      throw new Error(
        `Invalid Option: trim must be a boolean, got ${JSON.stringify(t.trim)}`
      );
    if (
      (!0 === t.trim && !1 !== e.ltrim
        ? (t.ltrim = !0)
        : !0 !== t.ltrim && (t.ltrim = !1),
      !0 === t.trim && !1 !== e.rtrim
        ? (t.rtrim = !0)
        : !0 !== t.rtrim && (t.rtrim = !1),
      void 0 === t.to || null === t.to)
    )
      t.to = -1;
    else {
      if (
        ("string" == typeof t.to && /\d+/.test(t.to) && (t.to = parseInt(t.to)),
        !Number.isInteger(t.to))
      )
        throw new Error(
          `Invalid Option: to must be an integer, got ${JSON.stringify(e.to)}`
        );
      if (t.to <= 0)
        throw new Error(
          `Invalid Option: to must be a positive integer greater than 0, got ${JSON.stringify(
            e.to
          )}`
        );
    }
    if (void 0 === t.to_line || null === t.to_line) t.to_line = -1;
    else {
      if (
        ("string" == typeof t.to_line &&
          /\d+/.test(t.to_line) &&
          (t.to_line = parseInt(t.to_line)),
        !Number.isInteger(t.to_line))
      )
        throw new Error(
          `Invalid Option: to_line must be an integer, got ${JSON.stringify(
            e.to_line
          )}`
        );
      if (t.to_line <= 0)
        throw new Error(
          `Invalid Option: to_line must be a positive integer greater than 0, got ${JSON.stringify(
            e.to_line
          )}`
        );
    }
    return t;
  },
  jI = function (e) {
    return e.every(
      (e) => null == e || (e.toString && "" === e.toString().trim())
    );
  },
  WI = { utf8: eI.from([239, 187, 191]), utf16le: eI.from([255, 254]) },
  qI = function (e, t = {}) {
    "string" == typeof e && (e = eI.from(e));
    const i = t && t.objname ? {} : [],
      n = (function (e = {}) {
        const t = HI(e);
        return {
          info: {
            bytes: 0,
            comment_lines: 0,
            empty_lines: 0,
            invalid_field_length: 0,
            lines: 1,
            records: 0,
          },
          original_options: e,
          options: t,
          state: QI(t),
          __needMoreData: function (e, t, i) {
            if (i) return !1;
            const { quote: n } = this.options,
              {
                quoting: s,
                needMoreDataSize: r,
                recordDelimiterMaxLength: a,
              } = this.state;
            return t - e - 1 < Math.max(r, a, s ? n.length + a : 0);
          },
          parse: function (e, t, i, n) {
            const {
              bom: s,
              from_line: r,
              ltrim: a,
              max_record_size: o,
              raw: l,
              relax_quotes: h,
              rtrim: c,
              skip_empty_lines: u,
              to: d,
              to_line: p,
            } = this.options;
            let {
              comment: f,
              escape: m,
              quote: g,
              record_delimiter: _,
            } = this.options;
            const {
              bomSkipped: v,
              previousBuf: A,
              rawBuffer: y,
              escapeIsQuote: x,
            } = this.state;
            let b;
            if (void 0 === A) {
              if (void 0 === e) return void n();
              b = e;
            } else b = void 0 !== A && void 0 === e ? A : eI.concat([A, e]);
            if (!1 === v)
              if (!1 === s) this.state.bomSkipped = !0;
              else if (b.length < 3) {
                if (!1 === t) return void (this.state.previousBuf = b);
              } else {
                for (const e in WI)
                  if (0 === WI[e].compare(b, 0, WI[e].length)) {
                    const t = WI[e].length;
                    (this.state.bufBytesStart += t),
                      (b = b.slice(t)),
                      (this.options = HI({
                        ...this.original_options,
                        encoding: e,
                      })),
                      ({ comment: f, escape: m, quote: g } = this.options);
                    break;
                  }
                this.state.bomSkipped = !0;
              }
            const E = b.length;
            let S;
            for (S = 0; S < E && !this.__needMoreData(S, E, t); S++) {
              if (
                (!0 === this.state.wasRowDelimiter &&
                  (this.info.lines++, (this.state.wasRowDelimiter = !1)),
                -1 !== p && this.info.lines > p)
              )
                return (this.state.stop = !0), void n();
              !1 === this.state.quoting &&
                0 === _.length &&
                this.__autoDiscoverRecordDelimiter(b, S) &&
                (_ = this.options.record_delimiter);
              const e = b[S];
              if (
                (!0 === l && y.append(e),
                (13 !== e && 10 !== e) ||
                  !1 !== this.state.wasRowDelimiter ||
                  (this.state.wasRowDelimiter = !0),
                !0 === this.state.escaping)
              )
                this.state.escaping = !1;
              else {
                if (
                  null !== m &&
                  !0 === this.state.quoting &&
                  this.__isEscape(b, S, e) &&
                  S + m.length < E
                ) {
                  if (!x) {
                    (this.state.escaping = !0), (S += m.length - 1);
                    continue;
                  }
                  if (this.__isQuote(b, S + m.length)) {
                    (this.state.escaping = !0), (S += m.length - 1);
                    continue;
                  }
                }
                if (!1 === this.state.commenting && this.__isQuote(b, S))
                  if (!0 === this.state.quoting) {
                    const t = b[S + g.length],
                      i = c && this.__isCharTrimable(b, S + g.length),
                      n =
                        null !== f &&
                        this.__compareBytes(f, b, S + g.length, t),
                      s = this.__isDelimiter(b, S + g.length, t),
                      r =
                        0 === _.length
                          ? this.__autoDiscoverRecordDelimiter(b, S + g.length)
                          : this.__isRecordDelimiter(t, b, S + g.length);
                    if (
                      null !== m &&
                      this.__isEscape(b, S, e) &&
                      this.__isQuote(b, S + m.length)
                    )
                      S += m.length - 1;
                    else {
                      if (!t || s || r || n || i) {
                        (this.state.quoting = !1),
                          (this.state.wasQuoting = !0),
                          (S += g.length - 1);
                        continue;
                      }
                      if (!1 === h) {
                        const e = this.__error(
                          new UI(
                            "CSV_INVALID_CLOSING_QUOTE",
                            [
                              "Invalid Closing Quote:",
                              `got "${String.fromCharCode(t)}"`,
                              `at line ${this.info.lines}`,
                              "instead of delimiter, record delimiter, trimable character",
                              "(if activated) or comment",
                            ],
                            this.options,
                            this.__infoField()
                          )
                        );
                        if (void 0 !== e) return e;
                      } else
                        (this.state.quoting = !1),
                          (this.state.wasQuoting = !0),
                          this.state.field.prepend(g),
                          (S += g.length - 1);
                    }
                  } else {
                    if (0 === this.state.field.length) {
                      (this.state.quoting = !0), (S += g.length - 1);
                      continue;
                    }
                    if (!1 === h) {
                      const e = this.__error(
                        new UI(
                          "INVALID_OPENING_QUOTE",
                          [
                            "Invalid Opening Quote:",
                            `a quote is found inside a field at line ${this.info.lines}`,
                          ],
                          this.options,
                          this.__infoField(),
                          { field: this.state.field }
                        )
                      );
                      if (void 0 !== e) return e;
                    }
                  }
                if (!1 === this.state.quoting) {
                  const t = this.__isRecordDelimiter(e, b, S);
                  if (0 !== t) {
                    if (
                      this.state.commenting &&
                      !1 === this.state.wasQuoting &&
                      0 === this.state.record.length &&
                      0 === this.state.field.length
                    )
                      this.info.comment_lines++;
                    else {
                      if (
                        !1 === this.state.enabled &&
                        this.info.lines +
                          (!0 === this.state.wasRowDelimiter ? 1 : 0) >=
                          r
                      ) {
                        (this.state.enabled = !0),
                          this.__resetField(),
                          this.__resetRecord(),
                          (S += t - 1);
                        continue;
                      }
                      if (
                        !0 === u &&
                        !1 === this.state.wasQuoting &&
                        0 === this.state.record.length &&
                        0 === this.state.field.length
                      ) {
                        this.info.empty_lines++, (S += t - 1);
                        continue;
                      }
                      this.info.bytes = this.state.bufBytesStart + S;
                      const e = this.__onField();
                      if (void 0 !== e) return e;
                      this.info.bytes = this.state.bufBytesStart + S + t;
                      const s = this.__onRecord(i);
                      if (void 0 !== s) return s;
                      if (-1 !== d && this.info.records >= d)
                        return (this.state.stop = !0), void n();
                    }
                    (this.state.commenting = !1), (S += t - 1);
                    continue;
                  }
                  if (this.state.commenting) continue;
                  if (
                    0 !== (null === f ? 0 : this.__compareBytes(f, b, S, e))
                  ) {
                    this.state.commenting = !0;
                    continue;
                  }
                  const s = this.__isDelimiter(b, S, e);
                  if (0 !== s) {
                    this.info.bytes = this.state.bufBytesStart + S;
                    const e = this.__onField();
                    if (void 0 !== e) return e;
                    S += s - 1;
                    continue;
                  }
                }
              }
              if (
                !1 === this.state.commenting &&
                0 !== o &&
                this.state.record_length + this.state.field.length > o
              )
                return this.__error(
                  new UI(
                    "CSV_MAX_RECORD_SIZE",
                    [
                      "Max Record Size:",
                      "record exceed the maximum number of tolerated bytes",
                      `of ${o}`,
                      `at line ${this.info.lines}`,
                    ],
                    this.options,
                    this.__infoField()
                  )
                );
              const t =
                  !1 === a ||
                  !0 === this.state.quoting ||
                  0 !== this.state.field.length ||
                  !this.__isCharTrimable(b, S),
                s = !1 === c || !1 === this.state.wasQuoting;
              if (!0 !== t || !0 !== s) {
                if (!0 !== c || this.__isCharTrimable(b, S)) {
                  !1 === t && (S += this.__isCharTrimable(b, S) - 1);
                  continue;
                }
                return this.__error(
                  new UI(
                    "CSV_NON_TRIMABLE_CHAR_AFTER_CLOSING_QUOTE",
                    [
                      "Invalid Closing Quote:",
                      "found non trimable byte after quote",
                      `at line ${this.info.lines}`,
                    ],
                    this.options,
                    this.__infoField()
                  )
                );
              }
              this.state.field.append(e);
            }
            if (!0 === t)
              if (!0 === this.state.quoting) {
                const e = this.__error(
                  new UI(
                    "CSV_QUOTE_NOT_CLOSED",
                    [
                      "Quote Not Closed:",
                      `the parsing is finished with an opening quote at line ${this.info.lines}`,
                    ],
                    this.options,
                    this.__infoField()
                  )
                );
                if (void 0 !== e) return e;
              } else if (
                !0 === this.state.wasQuoting ||
                0 !== this.state.record.length ||
                0 !== this.state.field.length
              ) {
                this.info.bytes = this.state.bufBytesStart + S;
                const e = this.__onField();
                if (void 0 !== e) return e;
                const t = this.__onRecord(i);
                if (void 0 !== t) return t;
              } else
                !0 === this.state.wasRowDelimiter
                  ? this.info.empty_lines++
                  : !0 === this.state.commenting && this.info.comment_lines++;
            else
              (this.state.bufBytesStart += S),
                (this.state.previousBuf = b.slice(S));
            !0 === this.state.wasRowDelimiter &&
              (this.info.lines++, (this.state.wasRowDelimiter = !1));
          },
          __onRecord: function (e) {
            const {
                columns: t,
                group_columns_by_name: i,
                encoding: n,
                info: s,
                from: r,
                relax_column_count: a,
                relax_column_count_less: o,
                relax_column_count_more: l,
                raw: h,
                skip_records_with_empty_values: c,
              } = this.options,
              { enabled: u, record: d } = this.state;
            if (!1 === u) return this.__resetRecord();
            const p = d.length;
            if (!0 === t)
              return !0 === c && jI(d)
                ? void this.__resetRecord()
                : this.__firstLineToColumns(d);
            if (
              (!1 === t &&
                0 === this.info.records &&
                (this.state.expectedRecordLength = p),
              p !== this.state.expectedRecordLength)
            ) {
              const e =
                !1 === t
                  ? new UI(
                      "CSV_RECORD_INCONSISTENT_FIELDS_LENGTH",
                      [
                        "Invalid Record Length:",
                        `expect ${this.state.expectedRecordLength},`,
                        `got ${p} on line ${this.info.lines}`,
                      ],
                      this.options,
                      this.__infoField(),
                      { record: d }
                    )
                  : new UI(
                      "CSV_RECORD_INCONSISTENT_COLUMNS",
                      [
                        "Invalid Record Length:",
                        `columns length is ${t.length},`,
                        `got ${p} on line ${this.info.lines}`,
                      ],
                      this.options,
                      this.__infoField(),
                      { record: d }
                    );
              if (
                !0 === a ||
                (!0 === o && p < this.state.expectedRecordLength) ||
                (!0 === l && p > this.state.expectedRecordLength)
              )
                this.info.invalid_field_length++, (this.state.error = e);
              else {
                const t = this.__error(e);
                if (t) return t;
              }
            }
            if (!0 === c && jI(d)) this.__resetRecord();
            else {
              if (!0 === this.state.recordHasError)
                return (
                  this.__resetRecord(), void (this.state.recordHasError = !1)
                );
              if ((this.info.records++, 1 === r || this.info.records >= r)) {
                const { objname: r } = this.options;
                if (!1 !== t) {
                  const a = {};
                  for (let e = 0, n = d.length; e < n; e++)
                    void 0 === t[e] ||
                      t[e].disabled ||
                      (!0 === i && void 0 !== a[t[e].name]
                        ? Array.isArray(a[t[e].name])
                          ? (a[t[e].name] = a[t[e].name].concat(d[e]))
                          : (a[t[e].name] = [a[t[e].name], d[e]])
                        : (a[t[e].name] = d[e]));
                  if (!0 === h || !0 === s) {
                    const t = Object.assign(
                        { record: a },
                        !0 === h
                          ? { raw: this.state.rawBuffer.toString(n) }
                          : {},
                        !0 === s ? { info: this.__infoRecord() } : {}
                      ),
                      i = this.__push(void 0 === r ? t : [a[r], t], e);
                    if (i) return i;
                  } else {
                    const t = this.__push(void 0 === r ? a : [a[r], a], e);
                    if (t) return t;
                  }
                } else if (!0 === h || !0 === s) {
                  const t = Object.assign(
                      { record: d },
                      !0 === h ? { raw: this.state.rawBuffer.toString(n) } : {},
                      !0 === s ? { info: this.__infoRecord() } : {}
                    ),
                    i = this.__push(void 0 === r ? t : [d[r], t], e);
                  if (i) return i;
                } else {
                  const t = this.__push(void 0 === r ? d : [d[r], d], e);
                  if (t) return t;
                }
              }
              this.__resetRecord();
            }
          },
          __firstLineToColumns: function (e) {
            const { firstLineToHeaders: t } = this.state;
            try {
              const i = void 0 === t ? e : t.call(null, e);
              if (!Array.isArray(i))
                return this.__error(
                  new UI(
                    "CSV_INVALID_COLUMN_MAPPING",
                    [
                      "Invalid Column Mapping:",
                      "expect an array from column function,",
                      `got ${JSON.stringify(i)}`,
                    ],
                    this.options,
                    this.__infoField(),
                    { headers: i }
                  )
                );
              const n = GI(i);
              return (
                (this.state.expectedRecordLength = n.length),
                (this.options.columns = n),
                void this.__resetRecord()
              );
            } catch (i) {
              return i;
            }
          },
          __resetRecord: function () {
            !0 === this.options.raw && this.state.rawBuffer.reset(),
              (this.state.error = void 0),
              (this.state.record = []),
              (this.state.record_length = 0);
          },
          __onField: function () {
            const {
                cast: e,
                encoding: t,
                rtrim: i,
                max_record_size: n,
              } = this.options,
              { enabled: s, wasQuoting: r } = this.state;
            if (!1 === s) return this.__resetField();
            let a = this.state.field.toString(t);
            if ((!0 === i && !1 === r && (a = a.trimRight()), !0 === e)) {
              const [e, t] = this.__cast(a);
              if (void 0 !== e) return e;
              a = t;
            }
            this.state.record.push(a),
              0 !== n &&
                "string" == typeof a &&
                (this.state.record_length += a.length),
              this.__resetField();
          },
          __resetField: function () {
            this.state.field.reset(), (this.state.wasQuoting = !1);
          },
          __push: function (e, t) {
            const { on_record: i } = this.options;
            if (void 0 !== i) {
              const t = this.__infoRecord();
              try {
                e = i.call(null, e, t);
              } catch (n) {
                return n;
              }
              if (null == e) return;
            }
            t(e);
          },
          __cast: function (e) {
            const { columns: t, relax_column_count: i } = this.options;
            if (
              !0 === Array.isArray(t) &&
              i &&
              this.options.columns.length <= this.state.record.length
            )
              return [void 0, void 0];
            if (null !== this.state.castField)
              try {
                const t = this.__infoField();
                return [void 0, this.state.castField.call(null, e, t)];
              } catch (n) {
                return [n];
              }
            if (this.__isFloat(e)) return [void 0, parseFloat(e)];
            if (!1 !== this.options.cast_date) {
              const t = this.__infoField();
              return [void 0, this.options.cast_date.call(null, e, t)];
            }
            return [void 0, e];
          },
          __isCharTrimable: function (e, t) {
            return ((e, t) => {
              const { timchars: i } = this.state;
              e: for (let n = 0; n < i.length; n++) {
                const s = i[n];
                for (let i = 0; i < s.length; i++)
                  if (s[i] !== e[t + i]) continue e;
                return s.length;
              }
              return 0;
            })(e, t);
          },
          __isFloat: function (e) {
            return e - parseFloat(e) + 1 >= 0;
          },
          __compareBytes: function (e, t, i, n) {
            if (e[0] !== n) return 0;
            const s = e.length;
            for (let r = 1; r < s; r++) if (e[r] !== t[i + r]) return 0;
            return s;
          },
          __isDelimiter: function (e, t, i) {
            const { delimiter: n, ignore_last_delimiters: s } = this.options;
            if (
              !0 === s &&
              this.state.record.length === this.options.columns.length - 1
            )
              return 0;
            if (
              !1 !== s &&
              "number" == typeof s &&
              this.state.record.length === s - 1
            )
              return 0;
            e: for (let r = 0; r < n.length; r++) {
              const s = n[r];
              if (s[0] === i) {
                for (let i = 1; i < s.length; i++)
                  if (s[i] !== e[t + i]) continue e;
                return s.length;
              }
            }
            return 0;
          },
          __isRecordDelimiter: function (e, t, i) {
            const { record_delimiter: n } = this.options,
              s = n.length;
            e: for (let r = 0; r < s; r++) {
              const s = n[r],
                a = s.length;
              if (s[0] === e) {
                for (let e = 1; e < a; e++) if (s[e] !== t[i + e]) continue e;
                return s.length;
              }
            }
            return 0;
          },
          __isEscape: function (e, t, i) {
            const { escape: n } = this.options;
            if (null === n) return !1;
            const s = n.length;
            if (n[0] === i) {
              for (let i = 0; i < s; i++) if (n[i] !== e[t + i]) return !1;
              return !0;
            }
            return !1;
          },
          __isQuote: function (e, t) {
            const { quote: i } = this.options;
            if (null === i) return !1;
            const n = i.length;
            for (let s = 0; s < n; s++) if (i[s] !== e[t + s]) return !1;
            return !0;
          },
          __autoDiscoverRecordDelimiter: function (e, t) {
            const { encoding: i } = this.options,
              n = e[t];
            return 13 === n
              ? 10 === e[t + 1]
                ? (this.options.record_delimiter.push(eI.from("\r\n", i)),
                  (this.state.recordDelimiterMaxLength = 2),
                  2)
                : (this.options.record_delimiter.push(eI.from("\r", i)),
                  (this.state.recordDelimiterMaxLength = 1),
                  1)
              : 10 === n
              ? (this.options.record_delimiter.push(eI.from("\n", i)),
                (this.state.recordDelimiterMaxLength = 1),
                1)
              : 0;
          },
          __error: function (e) {
            const {
                encoding: t,
                raw: i,
                skip_records_with_error: n,
              } = this.options,
              s = "string" == typeof e ? new Error(e) : e;
            return n
              ? ((this.state.recordHasError = !0),
                void (
                  void 0 !== this.options.on_skip &&
                  this.options.on_skip(
                    s,
                    i ? this.state.rawBuffer.toString(t) : void 0
                  )
                ))
              : s;
          },
          __infoDataSet: function () {
            return { ...this.info, columns: this.options.columns };
          },
          __infoRecord: function () {
            const { columns: e, raw: t, encoding: i } = this.options;
            return {
              ...this.__infoDataSet(),
              error: this.state.error,
              header: !0 === e,
              index: this.state.record.length,
              raw: t ? this.state.rawBuffer.toString(i) : void 0,
            };
          },
          __infoField: function () {
            const { columns: e } = this.options,
              t = Array.isArray(e);
            return {
              ...this.__infoRecord(),
              column:
                !0 === t
                  ? e.length > this.state.record.length
                    ? e[this.state.record.length].name
                    : null
                  : this.state.record.length,
              quoting: this.state.wasQuoting,
            };
          },
        };
      })(t),
      s = (e) => {
        void 0 === n.options.objname ? i.push(e) : (i[e[0]] = e[1]);
      },
      r = () => {},
      a = n.parse(e, !1, s, r);
    if (void 0 !== a) throw a;
    const o = n.parse(void 0, !0, s, r);
    if (void 0 !== o) throw o;
    return i;
  };
var XI = { exports: {} };
(XI.exports = ZI),
  (XI.exports.parse = ZI),
  (XI.exports.stringify = function e(t) {
    "Feature" === t.type && (t = t.geometry);
    function i(e) {
      return e.join(" ");
    }
    function n(e) {
      return e.map(i).join(", ");
    }
    function s(e) {
      return e.map(n).map(r).join(", ");
    }
    function r(e) {
      return "(" + e + ")";
    }
    switch (t.type) {
      case "Point":
        return "POINT (" + i(t.coordinates) + ")";
      case "LineString":
        return "LINESTRING (" + n(t.coordinates) + ")";
      case "Polygon":
        return "POLYGON (" + s(t.coordinates) + ")";
      case "MultiPoint":
        return "MULTIPOINT (" + n(t.coordinates) + ")";
      case "MultiPolygon":
        return (
          "MULTIPOLYGON (" + (t.coordinates.map(s).map(r).join(", ") + ")")
        );
      case "MultiLineString":
        return "MULTILINESTRING (" + s(t.coordinates) + ")";
      case "GeometryCollection":
        return "GEOMETRYCOLLECTION (" + t.geometries.map(e).join(", ") + ")";
      default:
        throw new Error(
          "stringify requires a valid GeoJSON Feature or geometry object as input"
        );
    }
  });
var YI = /[-+]?([0-9]*\.[0-9]+|[0-9]+)([eE][-+]?[0-9]+)?/,
  KI = new RegExp("^" + YI.source + "(\\s" + YI.source + "){1,}");
function ZI(e) {
  var t = e.split(";"),
    i = t.pop(),
    n = (t.shift() || "").split("=").pop(),
    s = 0;
  function r(e) {
    var t = i.substring(s).match(e);
    return t ? ((s += t[0].length), t[0]) : null;
  }
  function a() {
    r(/^\s*/);
  }
  function o() {
    a();
    for (
      var e, t = 0, i = [], n = [i], s = i;
      (e = r(/^(\()/) || r(/^(\))/) || r(/^(,)/) || r(KI));

    ) {
      if ("(" === e) n.push(s), (s = []), n[n.length - 1].push(s), t++;
      else if (")" === e) {
        if (0 === s.length) return null;
        if (!(s = n.pop())) return null;
        if (0 === --t) break;
      } else if ("," === e) (s = []), n[n.length - 1].push(s);
      else {
        if (e.split(/\s/g).some(isNaN)) return null;
        Array.prototype.push.apply(s, e.split(/\s/g).map(parseFloat));
      }
      a();
    }
    return 0 !== t ? null : i;
  }
  function l() {
    for (var e, t, i = []; (t = r(KI) || r(/^(,)/)); )
      "," === t
        ? (i.push(e), (e = []))
        : t.split(/\s/g).some(isNaN) ||
          (e || (e = []),
          Array.prototype.push.apply(e, t.split(/\s/g).map(parseFloat))),
        a();
    return e ? (i.push(e), i.length ? i : null) : null;
  }
  function h() {
    return (
      (function () {
        if (!r(/^(point(\sz)?)/i)) return null;
        if ((a(), !r(/^(\()/))) return null;
        var e = l();
        return e
          ? (a(), r(/^(\))/) ? { type: "Point", coordinates: e[0] } : null)
          : null;
      })() ||
      (function () {
        if (!r(/^(linestring(\sz)?)/i)) return null;
        if ((a(), !r(/^(\()/))) return null;
        var e = l();
        return e && r(/^(\))/) ? { type: "LineString", coordinates: e } : null;
      })() ||
      (function () {
        if (!r(/^(polygon(\sz)?)/i)) return null;
        a();
        var e = o();
        return e ? { type: "Polygon", coordinates: e } : null;
      })() ||
      (function () {
        if (!r(/^(multipoint)/i)) return null;
        a();
        var e = i
          .substring(i.indexOf("(") + 1, i.length - 1)
          .replace(/\(/g, "")
          .replace(/\)/g, "");
        i = "MULTIPOINT (" + e + ")";
        var t = o();
        return t ? (a(), { type: "MultiPoint", coordinates: t }) : null;
      })() ||
      (function () {
        if (!r(/^(multilinestring)/i)) return null;
        a();
        var e = o();
        return e ? (a(), { type: "MultiLineString", coordinates: e }) : null;
      })() ||
      (function () {
        if (!r(/^(multipolygon)/i)) return null;
        a();
        var e = o();
        return e ? { type: "MultiPolygon", coordinates: e } : null;
      })() ||
      (function () {
        var e,
          t = [];
        if (!r(/^(geometrycollection)/i)) return null;
        if ((a(), !r(/^(\()/))) return null;
        for (; (e = h()); ) t.push(e), a(), r(/^(,)/), a();
        return r(/^(\))/)
          ? { type: "GeometryCollection", geometries: t }
          : null;
      })()
    );
  }
  return (function (e) {
    return (
      e &&
        n.match(/\d+/) &&
        (e.crs = {
          type: "name",
          properties: { name: "urn:ogc:def:crs:EPSG::" + n },
        }),
      e
    );
  })(h());
}
const JI = class extends fA {
  constructor(e) {
    super(e),
      publicField(this, "_coordinatesKey", "coordinates"),
      publicField(this, "_csvDataType"),
      publicField(this, "_csvFeatures", []),
      publicField(this, "_csvIndexMap", []),
      (this.type = "CSVDataSource");
  }
  async _getFetchData(e) {
    return await e.text();
  }
  getOriginDataIndex(e) {
    return e < this._templateDataLength
      ? this._csvIndexMap[e]
      : [e - this._templateDataLength + this._csvFeatures.length, 0];
  }
  getOriginData(e) {
    if (e < this._templateDataLength) {
      const t = this._csvIndexMap[e];
      return this._csvFeatures[t[0]];
    }
    return this._addCache[e - this._templateDataLength];
  }
  onClear() {
    (this._csvDataType = void 0), (this._csvFeatures = []);
  }
  originToFeatures(e) {
    for (let t = 0; t < this._csvFeatures.length; t++) {
      const i = this._csvFeatures[t];
      e.push({
        type: "Feature",
        geometry: {
          type: i.geometry.type,
          coordinates: i.geometry.coordinates,
        },
        properties: i.properties,
      });
    }
    return e;
  }
  _onProcessTemplateData(e, t) {
    return this._prepareFeatures(), this._parseFeature(e, t), e;
  }
  _parseFeature(e, t) {
    let i = 0;
    for (let n = 0; n < this._csvFeatures.length; n++) {
      const s = this._csvFeatures[n],
        r = this._onDecomposeFeature(this._csvDataType, s);
      for (let a = 0; a < r.length; a++) {
        const s = r[a];
        e.position.push(s.geometry[this.projectionName]),
          a > 0 && i++,
          e.index.push(n + i),
          (this._csvIndexMap[n + i] = [n, a]);
        let o = { position: s.geometry[this.projectionName], index: n + i };
        for (const t of this._attributeMap.keys()) {
          let i;
          s.properties &&
          void 0 !== s.properties[this._attributeMap.get(t)] &&
          null !== s.properties[this._attributeMap.get(t)]
            ? (i = s.properties[this._attributeMap.get(t)])
            : this._attributeMap.get(t) instanceof Function &&
              (i = this._attributeMap.get(t)(s.properties)),
            e[t].push(i),
            (o[t] = i);
        }
        t.push(o);
      }
    }
  }
  _prepareFeatures() {
    (this._csvFeatures = this.csvToFeatures()), this._getDataType();
  }
  csvToFeatures() {
    if (!this.origin) return [];
    let e = qI(this.origin, { columns: !0, skip_empty_lines: !0 });
    const t = [];
    for (let i = 0; i < e.length; i++) {
      const n = e[i],
        s = {};
      let r;
      Object.keys(n).forEach((e) => {
        e === this._coordinatesKey
          ? (r = { geometry: XI.exports(n[e]), properties: s })
          : (s[e] = n[e]);
      }),
        Array.isArray(r) ? t.push(...r) : t.push(r);
    }
    return Lv(t, this.projectionName);
  }
  _getDataType() {
    var e, t;
    this._csvDataType = super._getDataType(
      null == (t = null == (e = this._csvFeatures[0]) ? void 0 : e.geometry)
        ? void 0
        : t.type
    );
  }
  get csvDataType() {
    return this._csvDataType;
  }
};
let $I = JI;
publicField($I, "fromUrl", async function (e) {
  let t = new JI();
  return await t.load(e), t;
});
const eR = class extends fA {
  constructor(e) {
    super(e),
      publicField(this, "_coordinatesKey", "coordinates"),
      publicField(this, "_jsonFeatures", []),
      publicField(this, "_jsonIndexMap", []),
      publicField(this, "_jsonDataType"),
      (this.type = "JSONDataSource");
  }
  getOriginDataIndex(e) {
    return e < this._templateDataLength
      ? this._jsonIndexMap[e]
      : [e - this._templateDataLength + this._jsonFeatures.length, 0];
  }
  async _getFetchData(e) {
    return await e.json();
  }
  getOriginData(e) {
    if (e < this._templateDataLength) {
      const t = this._jsonIndexMap[e];
      return this._jsonFeatures[t[0]];
    }
    return this._addCache[e - this._templateDataLength];
  }
  originToFeatures(e) {
    for (let t = 0; t < this._jsonFeatures.length; t++) {
      const i = this._jsonFeatures[t];
      e.push({
        type: "Feature",
        geometry: {
          type: i.geometry.type,
          coordinates: i.geometry.coordinates,
        },
        properties: i.properties,
      });
    }
    return e;
  }
  _onProcessTemplateData(e, t) {
    return this._prepareFeatures(), this._parseFeature(e, t), e;
  }
  _prepareFeatures() {
    (this._jsonFeatures = this._parseJson(this.origin)), this._getDataType();
  }
  _parseJson(e) {
    let t = [];
    if (Array.isArray(e))
      for (let i = 0; i < e.length; i++) {
        const n = this._parseJson(e[i]);
        t.push(...n);
      }
    else {
      let i = {},
        n = {};
      for (let t in e)
        Object.hasOwnProperty.call(e, t) &&
          (t === this.coordinatesKey
            ? ((n.geometry = XI.exports(e[t])), (n.properties = i))
            : (i[t] = e[t]));
      t.push(n);
    }
    return Lv(t, this.projectionName);
  }
  _parseFeature(e, t) {
    let i = 0;
    for (let n = 0; n < this._jsonFeatures.length; n++) {
      const s = this._jsonFeatures[n],
        r = this._onDecomposeFeature(this._jsonDataType, s);
      for (let a = 0; a < r.length; a++) {
        const s = r[a];
        e.position.push(s.geometry[this.projectionName]),
          a > 0 && i++,
          e.index.push(n + i),
          (this._jsonIndexMap[n + i] = [n, a]);
        let o = { position: s.geometry[this.projectionName], index: n + i };
        for (const t of this._attributeMap.keys()) {
          let i;
          s.properties &&
          void 0 !== s.properties[this._attributeMap.get(t)] &&
          null !== s.properties[this._attributeMap.get(t)]
            ? (i = s.properties[this._attributeMap.get(t)])
            : this._attributeMap.get(t) instanceof Function &&
              (i = this._attributeMap.get(t)(s.properties)),
            e[t].push(i),
            (o[t] = i);
        }
        t.push(o);
      }
    }
  }
  _getDataType() {
    var e, t;
    this._jsonDataType = super._getDataType(
      null == (t = null == (e = this._jsonFeatures[0]) ? void 0 : e.geometry)
        ? void 0
        : t.type
    );
  }
  onClear() {
    (this._jsonDataType = void 0), (this._jsonFeatures = []);
  }
  get jsonDataType() {
    return this._jsonDataType;
  }
  get coordinatesKey() {
    return this._coordinatesKey;
  }
  set coordinatesKey(e) {
    this._coordinatesKey = e;
  }
};
let tR = eR;
publicField(tR, "fromUrl", async function (e) {
  let t = new eR();
  return await t.load(e), t;
}),
  publicField(tR, "fromJSON", function (e) {
    let t = new eR();
    return t.setData(e), t;
  });
class iR {
  constructor() {
    publicField(this, "_process", []), publicField(this, "_hasTime", !1);
  }
  provide(e) {
    let t = 0;
    this._hasTime || (t = new Date().valueOf());
    for (let i = 0; i < e.length; i++) {
      const n = e[i];
      for (let e = 0; e < this._process.length; e++) {
        const t = this._process[e];
        "string" == typeof t[1] && n[t[1]]
          ? (n[t[0]] = n[t[1]])
          : t[1] instanceof Function
          ? (n[t[0]] = t[1](n))
          : (n[t[0]] = void 0);
      }
      this._hasTime || (n.time = t);
    }
    return e;
  }
  process(e, t) {
    return (
      "time" === e && (this._hasTime = !0), this._process.push([e, t]), this
    );
  }
}
class nR {
  constructor(e) {
    publicField(this, "id", null),
      publicField(this, "data", []),
      publicField(this, "interpolateDirectThreshold", 10),
      e && "number" == typeof e && (this.data = new Array(e));
  }
  tick(e, t) {
    let i = this.data[0],
      n = this.data[1];
    if (!i || !n) return null;
    const s = (t - i.time) / (n.time - i.time),
      r = bv(i.point, n.point, s),
      a = e.map.projectPointArr(r);
    let o = null,
      l = null,
      h = null,
      c = i.dir;
    !c &&
      i.point &&
      n.point &&
      ((o = e.map.projectPointArr(i.point)),
      (l = e.map.projectPointArr(n.point)),
      (c = new Vector2(l[0] - o[0], l[1] - o[1]).angle()));
    let u = yv(a, e.map.projectPointArr(n.point));
    if (u < this.interpolateDirectThreshold)
      if (!n.dir && this.data[2] && this.data[2].point) {
        h = e.map.projectPointArr(this.data[2].point);
        const t = new Vector2(h[0] - l[0], h[1] - l[1]).angle();
        Math.abs(t - c) < Math.PI / 2 &&
          (c = xv(c, t, 1 - u / this.interpolateDirectThreshold));
      } else
        n.dir &&
          Math.abs(n.dir - c) < Math.PI / 2 &&
          (c = xv(c, n.dir, 1 - u / this.interpolateDirectThreshold));
    return {
      ...i,
      id: this.id,
      modelType: i.modelType,
      ratio: s,
      point: r,
      position: a,
      dir: c,
    };
  }
  push(e) {
    if (
      (!this.id && e && ((this.id = e.id), (this.modelType = e.modelType)),
      this.id)
    )
      return this.data.push(e);
  }
  shift() {
    return this.data.shift();
  }
  splice(e, t, ...i) {
    return this.data.splice(e, t, ...i);
  }
  get length() {
    return this.data.length;
  }
  get empty() {
    return !("" !== this.data.join(""));
  }
}
class sR {
  constructor(e) {
    publicField(this, "_entities", new Map()),
      publicField(this, "_entityCacheTimes", []),
      publicField(this, "_startTime", 1 / 0),
      publicField(this, "_timeOffset", 0),
      (this.delay = e.delay),
      (this.twin = e.twin);
  }
  push(e) {
    const t = e[0].time,
      i = this._entities;
    for (let n = 0; n < e.length; n++) {
      const t = e[n];
      i.get(t.id) || i.set(t.id, new nR(this._entityCacheTimes.length)),
        i.get(t.id).push(t);
    }
    Array.from(i.entries()).forEach(([e, t]) => {
      t.length === this._entityCacheTimes.length && t.push(void 0);
    }),
      this._entityCacheTimes.push(t);
  }
  shift(e) {
    const t = this._entities,
      i = this._entityCacheTimes;
    let n = 0,
      s = [];
    for (let r = 1; r < i.length; r++) {
      const t = i[r];
      if (e - this.delay - this.timeOffset < t) break;
      n += 1;
    }
    return (
      i.splice(0, n),
      Array.from(t.entries()).forEach(([e, i]) => {
        i.splice(0, n), i.empty && (t.delete(e), s.push(e));
      }),
      1 === i.length && this.reset(),
      s
    );
  }
  tick(e, t) {
    if (t - this.delay < this._startTime) return {};
    this.shift(t);
    const i = Array.from(this._entities.values()),
      n = [],
      s = [],
      r = [],
      a = [],
      o = [],
      l = [],
      h = [],
      c = [],
      u = [],
      d = {};
    for (let p = 0; p < i.length; p++) {
      let f = i[p].tick(e, t - this.delay - this.timeOffset);
      if (f) {
        const { scale: e = [1, 1, 1] } = f;
        n.push(f.id),
          s.push(n.length - 1),
          r.push(f.position),
          a.push(...f.position),
          o.push(0, 0, f.dir + (this.twin._extraDir / 180) * Math.PI),
          l.push(...e),
          h.push(f.modelType),
          c.push(f),
          u.push(f.color),
          d[f.modelType]
            ? d[f.modelType].push(n.length - 1)
            : (d[f.modelType] = [n.length - 1]);
      }
    }
    return {
      buffers: {
        id: n,
        index: s,
        position: r,
        translation: a,
        rotation: o,
        scale: l,
        modelType: h,
        payload: c,
        color: u,
      },
      modelIndexMap: d,
    };
  }
  reset() {
    (this._startTime = 1 / 0),
      (this._timeOffset = 0),
      (this._entityCacheTimes = []),
      (this._entities = new Map()),
      this.twin.reset();
  }
  get startTime() {
    return this._startTime;
  }
  set startTime(e) {
    this._startTime = e;
  }
  get timeOffset() {
    return this._timeOffset;
  }
  set timeOffset(e) {
    this._timeOffset = e;
  }
}
class rR extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_trackObject", null),
      publicField(this, "_trackStatus", !1),
      publicField(this, "_trackConfig", {}),
      publicField(this, "_trackParams", {});
  }
  track(e, t) {
    (this._trackObject = e), (this._trackConfig = { ...t });
  }
  stop() {
    const e = this._engine.map.map;
    if ("blank" === this._engine.map.mapType) {
      e.cameraDistance = this._trackConfig.radius;
      let t =
          (100 / (this._engine._container.clientHeight / 2)) *
          Math.tan(((this._engine.map.fov / 2) * Math.PI) / 180),
        i = this._engine.map.getZoomByZoomUnits(t);
      (e.zoom = i), (e.zoomUnits = t);
      const { heading: n, pitch: s, center: r } = this._trackParams;
      n && (e.heading = n), s && (e.pitch = s), r && (e.center = r);
    }
    const t = document.getElementById("inside-mask");
    t && this._engine.container.removeChild(t),
      (this._trackObject = null),
      (this._trackStatus = !1),
      (this._trackConfig = {}),
      (this._trackParams = {});
  }
  afterAddToEngine(e) {
    (this._engine = e),
      "blank" !== e.map.mapType &&
        "blank_3dcontrol" !== e.map.mapType &&
        console.error(
          "PathTracker is not compatible with current type of Map."
        );
  }
  onBeforeScenePrepareRender(e, t, i, n) {
    this._trackObject &&
      (this._trackParams = this.getCameraByTargetAndView(
        e,
        this._trackObject,
        this._trackConfig
      )),
      this._engine.requestRender();
  }
  getCameraByTargetAndView(e, t, i = {}) {
    let n, s;
    if (
      (Object.keys(i).forEach((e) => {
        null === i[e] && delete i[e];
      }),
      i.inside)
    ) {
      if (!document.getElementById("inside-mask")) {
        const t = document.createElement("div");
        (t.id = "inside-mask"),
          (t.style.width = "100%"),
          (t.style.height = "100%"),
          (t.style.position = "absolute"),
          (t.style.backgroundImage = `url(${i.insideMask})`),
          (t.style.backgroundSize = "cover"),
          (t.style.top = 0),
          (t.style.right = 0),
          (t.style.zIndex = 5),
          e.container.appendChild(t);
      }
      i = { radius: -10, pitch: 88.8, height: 3.5, ...i };
    }
    if (t.instance && void 0 !== t.instanceIndex) {
      const e = new Vector3(),
        i = new Quaternion(),
        r = new ii(),
        a = new Vector3(),
        o = new Matrix4(),
        l = t.instance.getEntityByIndex(t.instanceIndex);
      if (!l) return;
      {
        (o.elements = l.matrix),
          o.decompose(e, i, a),
          r.setFromQuaternion(i),
          (r.y = r.z),
          (s = r);
        const [h, c, u] = t.instance._rtc;
        n = new Vector3(h + e.x, c + e.y, u + e.z);
      }
    } else if (t instanceof Object3D) {
      let e;
      (n = t.getWorldPosition(new Vector3())),
        (s = t.rotation),
        t.updateMatrix(),
        t.updateMatrixWorld(),
        (t.boundingBox = null),
        t.traverse((e) => {
          if (e.geometry) {
            e.geometry.boundingBox || e.geometry.computeBoundingBox(),
              e.updateMatrixWorld();
            const i = rR.computeTransformedBoundingBox(
              e.geometry.boundingBox,
              e.matrixWorld
            );
            t.boundingBox
              ? (t.boundingBox = t.boundingBox.union(i))
              : (t.boundingBox = i);
          }
        }),
        (e = t.boundingSphere
          ? t.boundingSphere
          : t.geometry && t.geometry.boundingSphere
          ? t.geometry.boundingSphere
          : t.boundingBox.getBoundingSphere(new kt())),
        (n = e.center);
    } else if (t instanceof Vector3) n = t.clone();
    else {
      if (!(t instanceof Array)) return null;
      n = new Vector3(t[0], t[1], t[2] || 0);
    }
    i.extraDir && (s.y = s.y - (i.extraDir / 180) * Math.PI);
    const { lock: r = !0 } = i;
    if (!this._trackStatus && !r) {
      const { x: e, y: t, z: r } = n;
      this._engine.map.lookAt(this._engine.map.projectCoordinates([e, t, r]), {
        range: i.radius,
        pitch: i.pitch,
        heading: ((s.y - Math.PI / 2) / Math.PI) * 180,
      });
    }
    const a = e.camera,
      o = a.clone();
    r &&
      (o.rotation.copy(a.rotation),
      (o.rotation.order = "ZXY"),
      (o.rotation.z = s.y - Math.PI / 2),
      (o.rotation.x = (i.pitch * Math.PI) / 180),
      (o.rotation.y = 0),
      o.updateMatrix(),
      o.updateMatrixWorld());
    const l = o.getWorldDirection(new Vector3()).multiplyScalar(-i.radius);
    return (
      o.position.copy(n.add(l)),
      a.position.copy(o.position),
      (a.position.z += i.height || 0),
      a.rotation.copy(o.rotation),
      a.updateMatrix(),
      a.updateMatrixWorld(),
      a.updateProjectionMatrix(),
      (this._trackStatus = !0),
      {
        heading: ((s.y - Math.PI / 2) / Math.PI) * 180,
        pitch: i.pitch,
        center: [a.position.x, a.position.y],
      }
    );
  }
  static computeTransformedBoundingBox(e, t) {
    const i = [
        new Vector3(e.min.x, e.min.y, e.min.z).applyMatrix4(t),
        new Vector3(e.min.x, e.min.y, e.min.z).applyMatrix4(t),
        new Vector3(e.max.x, e.min.y, e.min.z).applyMatrix4(t),
        new Vector3(e.min.x, e.max.y, e.min.z).applyMatrix4(t),
        new Vector3(e.min.x, e.min.y, e.max.z).applyMatrix4(t),
        new Vector3(e.min.x, e.max.y, e.max.z).applyMatrix4(t),
        new Vector3(e.max.x, e.max.y, e.min.z).applyMatrix4(t),
        new Vector3(e.max.x, e.min.y, e.max.z).applyMatrix4(t),
        new Vector3(e.max.x, e.max.y, e.max.z).applyMatrix4(t),
      ],
      n = new Box3();
    return n.setFromPoints(i), n;
  }
}
class aR extends Object3D {
  constructor(e = {}) {
    super(),
      publicField(this, "engine", null),
      publicField(this, "_dataProvider", null),
      publicField(this, "_extraDir"),
      publicField(this, "_modelConfig", {}),
      publicField(this, "_modelLoaded", !0),
      publicField(this, "_buffers", {}),
      publicField(this, "_instances", {}),
      publicField(this, "_objects", []),
      publicField(this, "_objectAttributes", {}),
      publicField(this, "handleBeforeRender", (e, t) => {
        if (!this._entityManager || this._isPause) return;
        let { buffers: i, modelIndexMap: n } = this._entityManager.tick(
          e,
          t.time
        );
        if (((this._buffers = i), this._modelLoaded)) {
          Object.keys(this._instances).forEach((e) => {
            let t = this._instances[e],
              i = this._filterBuffer(n, e);
            t && (t.setBufferData(i), t.update());
          });
          for (let e = 0; e < this._objects.length; e++) {
            this._objects[e].dataSource.setData(i);
          }
          this.onTicking && this.onTicking(i),
            this._trackInfo
              ? this._track()
              : this._objectTracker._trackObject && this.clearTrack();
        }
      }),
      (this.options = e),
      e.modelConfig && (this.modelConfig = e.modelConfig),
      (this._delay = e.delay || 2e3),
      (this._objectAttributes = e.objectAttributes || {}),
      (this._extraDir = e.extraDir || 0),
      (this._dataProvider = new iR()),
      (this._entityManager = new sR({ delay: this._delay, twin: this })),
      (this._objectTracker = new rR());
  }
  afterAddToEngine(e) {
    (this.engine = e),
      (this.objects = this.options.objects || []),
      this.engine.add(this._objectTracker),
      e.addPrepareRenderListener(this.handleBeforeRender);
  }
  push(e) {
    if (!e || 0 === e.length || !this._entityManager) return;
    let t = this._dataProvider.provide(e);
    if (!this._isStarted) {
      this._isStarted = !0;
      const e = new Date().valueOf();
      (this._entityManager.startTime = e),
        (this._entityManager.timeOffset = e - t[0].time);
    }
    this._entityManager.push(t);
  }
  pause() {
    (this._isPause = !0), (this._pauseTime = new Date().valueOf());
  }
  start() {
    this._isPause = !1;
    const e = new Date().valueOf();
    (this._entityManager.startTime = e - this._entityManager.delay),
      (this._entityManager.timeOffset += e - this._pauseTime),
      (this._pauseTime = null);
  }
  reset() {
    console.warn("twin: reset"),
      Object.values(this._instances).forEach((e) => {
        e.clear();
      });
    const { autoClearTrack: e = !0 } = this.options;
    e && (this._trackInfo = null), (this._isStarted = !1);
  }
  _filterBuffer(e, t) {
    if (!e || !e[t]) return null;
    const i = e[t],
      n = [],
      s = [],
      r = [],
      a = [],
      o = [],
      l = [];
    for (let h = 0; h < i.length; h++) {
      const e = i[h];
      n.push(this._buffers.id[e]),
        s.push(
          this._buffers.translation[3 * e],
          this._buffers.translation[3 * e + 1],
          this._buffers.translation[3 * e + 2]
        ),
        r.push(
          this._buffers.rotation[3 * e],
          this._buffers.rotation[3 * e + 1],
          this._buffers.rotation[3 * e + 2]
        ),
        a.push(
          this._buffers.scale[3 * e],
          this._buffers.scale[3 * e + 1],
          this._buffers.scale[3 * e + 2]
        ),
        l.push(this._buffers.color[e]),
        o.push(this._buffers.modelType[e]);
    }
    return {
      id: n,
      translation: s,
      rotation: r,
      scale: a,
      modelType: o,
      color: l,
    };
  }
  loadModelAsync(e) {
    return new Promise((t, i) => {
      PS.load(e, (e) => {
        let i = bw(e.scene, !1, !0);
        t(i);
      });
    });
  }
  modelClear() {
    (this._modelConfig = {}),
      Object.values(this._instances).forEach((e) => {
        this.engine.remove(e);
      }),
      (this._instances = {});
  }
  getCurrentBuffers() {
    return this._buffers;
  }
  setColorById(e, t) {
    this._modelLoaded &&
      Object.keys(this._instances).forEach((i) => {
        this._instances[i].setColor(e, new Color(t));
      });
  }
  _track() {
    if (this._modelLoaded) {
      const { id: e, option: t } = this._trackInfo;
      let i, n;
      Object.keys(this._instances).forEach((t) => {
        const s = this._instances[t],
          r = s._idIndexMap[e];
        void 0 !== r && ((n = s), (i = r));
      });
      const { autoClearTrack: s = !0 } = this.options;
      void 0 === i && s
        ? this._objectTracker._trackObject && this.clearTrack()
        : this._objectTracker.track({ instance: n, instanceIndex: i }, t);
    }
  }
  trackById(e, t = {}) {
    t.inside
      ? (this._trackInfo = {
          id: e,
          option: {
            extraDir: this._extraDir,
            inside: !0,
            insideMask: Hm("assets/images/carInside.png"),
            ...t,
          },
        })
      : (this._trackInfo = {
          id: e,
          option: { extraDir: this._extraDir, radius: 100, pitch: 1.2, ...t },
        });
  }
  clearTrack() {
    (this._trackInfo = null), this._objectTracker.stop();
  }
  dispose() {
    this.modelClear();
    for (let e = 0; e < this._objects.length; e++) {
      const t = this._objects[e];
      this.engine.remove(t);
    }
    this.entityManager.reset(), (this._entityManager = null);
  }
  get dataProvider() {
    return this._dataProvider;
  }
  get entityManager() {
    return this._entityManager;
  }
  get objectAttributes() {
    return this._objectAttributes;
  }
  set objectAttributes(e) {
    this._objectAttributes = e;
  }
  get objects() {
    return this._objects;
  }
  set objects(e) {
    for (let t = 0; t < this._objects.length; t++) {
      const e = this._objects[t];
      this.engine.remove(e);
    }
    this._objects = e;
    for (let t = 0; t < this._objects.length; t++) {
      const e = this._objects[t];
      e.__initInEngine || this.engine.add(e);
      const i = new mA();
      i.setAttributes(this._objectAttributes), (e.dataSource = i);
    }
  }
  get modelConfig() {
    return this._modelConfig;
  }
  set modelConfig(e) {
    this._modelLoaded = !1;
    let t = Object.keys(e),
      i = Object.values(e).map((e) => this.loadModelAsync(e));
    Promise.all(i).then((e) => {
      this.modelClear();
      for (let i = 0; i < t.length; i++) {
        const n = t[i],
          s = e[i];
        (this._modelConfig[n] = s),
          (this._instances[n] = this.engine.add(new Cw(s))),
          this.engine.event.bind(this._instances[n], "click", (e) => {
            this.dispatchEvent({ type: "click", clickInfo: e.entity });
          }),
          (this._instances[n].enableColor = !0),
          (this._instances[n].enableColorList = this.options
            .enableColorList || ["body"]);
      }
      (this._modelLoaded = !0),
        this.dispatchEvent({ type: "modelLoaded", modelMap: this._instances });
    });
  }
}
publicField(aR, "TWIN_REALISTIC_TEMPLATE_COLOR", {
  white: "#BFC4CC",
  black: "#25272F",
  gray: "#6F7580",
  blue: "#284CC7",
  red: "#D11800",
  green: "#3FA765",
  brown: "#CC7C42",
  yellow: "#DBA100",
  orange: "#D14D00",
  purple: "#8100D1",
  cyanl: "#00BEA5",
  pink: "#D37AD0",
});
let oR = new Box3();
new Matrix4(), new jt();
let lR = new kt(),
  hR = new Matrix4(),
  cR = new Matrix4(),
  uR = new Matrix4(),
  dR = new Matrix4(),
  pR = new En(),
  fR = [],
  mR = new Vector3(),
  gR = new Vector4();

class InstancedMesh extends GeoObject {
  constructor(e, t) {
    super(),
      publicField(this, "type", "InstancedMesh"),
      publicField(this, "isMesh", !0),
      publicField(this, "isInstancedMesh", !0),
      publicField(this, "frustumCulled", !1),
      publicField(this, "instanceColor", null),
      publicField(this, "count", 0),
      publicField(this, "instanceMatrix"),
      publicField(this, "_enableInstanceColor", !1),
      publicField(this, "instanceMorphMatrix", new Matrix4()),
      publicField(this, "isEventEntitySupported", !0),
      publicField(this, "boundingBox", null),
      publicField(this, "boundingSphere", null),
      publicField(this, "getInstanceLocalMatrix", (e, t, i) => null),
      publicField(this, "addCustomAttributes", () => {}),
      (this.geometry = e),
      (this.material = t),
      (this.instanceMatrix = new Wa(new Float32Array(0), 16));
  }
  set enableInstanceColor(e) {
    e !== this._enableInstanceColor &&
      ((this._enableInstanceColor = e), (this.needsUpdate = !0));
  }
  get enableInstanceColor() {
    return this._enableInstanceColor;
  }
  collisionTest(e) {
    let t = this.material.keepSize ? this.size : 0;
    return { width: t, height: t };
  }
  setData() {
    let e = [];
    e =
      this._enableCollision && this._collisionData
        ? this._collisionData
        : this.dataSource.userData;
    const t = [],
      i = [],
      n = [];
    let s = 1 / 0,
      r = 1 / 0,
      a = 1 / 0,
      o = -1 / 0,
      l = -1 / 0,
      h = -1 / 0;
    for (let u = 0; u < e.length; u++) {
      const t = e[u].position,
        [i, n, c = 0] = t;
      i < s && (s = i),
        i > o && (o = i),
        n < r && (r = n),
        n > l && (l = n),
        c < a && (a = c),
        c > h && (h = c);
    }
    let c = [(s + o) / 2, (r + l) / 2, (a + h) / 2 || 0];
    for (let u = 0; u < e.length; u++) {
      const s = e[u].position;
      e[u].index;
      const r = this.getInstanceLocalMatrix(
          s,
          this.dataSource.getOriginData(u),
          u
        ),
        a = new Matrix4();
      a.makeTranslation(s[0] - c[0], s[1] - c[1], (s[2] || 0) - c[2]);
      let o = null;
      r ? ((o = new Matrix4()), o.multiplyMatrices(a, r)) : (o = a);
      const l = o.elements;
      if (
        (t.push(
          l[0],
          l[1],
          l[2],
          l[3],
          l[4],
          l[5],
          l[6],
          l[7],
          l[8],
          l[9],
          l[10],
          l[11],
          l[12],
          l[13],
          l[14],
          l[15]
        ),
        i.push(Math.random()),
        this._enableInstanceColor)
      ) {
        let t = colorToArr3(e[u].color);
        n.push(t[0], t[1], t[2]);
      }
    }
    this.geometry.setAttribute(
      "instancedRandomFactor",
      new Wa(new Float32Array(i), 1)
    ),
      this.addCustomAttributes(this.geometry, this.dataSource),
      this.geometry.computeBoundingSphere(),
      (this.geometry.instanceCount = t.length / 16),
      (this.instanceMatrix = new Wa(new Float32Array(t), 16)),
      this._enableInstanceColor &&
        (this.instanceColor = new Wa(new Float32Array(n), 3)),
      (this.count = this.geometry.instanceCount),
      this.makeMeshPositionOffset(c),
      (this.needsUpdate = !1);
  }
  computeBoundingBox() {
    const e = this.geometry,
      t = this.count;
    null === this.boundingBox && (this.boundingBox = new Box3()),
      null === e.boundingBox && e.computeBoundingBox(),
      this.boundingBox.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, hR),
        oR.copy(e.boundingBox).applyMatrix4(hR),
        this.boundingBox.union(oR);
  }
  computeBoundingSphere() {
    const e = this.geometry,
      t = this.count;
    null === this.boundingSphere && (this.boundingSphere = new kt()),
      null === e.boundingSphere && e.computeBoundingSphere(),
      this.boundingSphere.makeEmpty();
    for (let i = 0; i < t; i++)
      this.getMatrixAt(i, hR),
        lR.copy(e.boundingSphere).applyMatrix4(hR),
        this.boundingSphere.union(lR);
  }
  getMatrixAt(e, t) {
    t.fromArray(this.instanceMatrix.array, 16 * e);
  }
  computeInstanceMorphMatrix() {
    const e = this.material;
    let t = e.height || 0,
      i = 1;
    if ((e.keepSize && (i = e.zoomUnits || 1), e.isUseSize3)) {
      const t = e.size3;
      mR.set(t[0] * i, t[1] * i, t[2] * i);
    } else if (e.isUseSize2) {
      const t = e.size2;
      mR.set(t[0] * i, t[1] * i, i);
    } else {
      let t = e.size || 1;
      mR.set(t * i, t * i, t * i);
    }
    this.instanceMorphMatrix
      .identity()
      .scale(mR)
      .premultiply(dR.identity().makeTranslation(0, 0, t * i));
  }
  getEntityByIndex(e) {
    const t = this.dataSource;
    this._enableCollision &&
      this._collisionData &&
      (e = this._collisionData[e].index);
    const i = {
        index: e,
        value: t.getOriginData(e),
        itemIndex: t.getOriginDataIndex(e),
        pairs: {},
      },
      n = t.data;
    for (const s of Object.keys(n)) i.pairs[s] = n[s][e];
    return i;
  }
  raycast(e, t) {
    if (!this.receiveRaycast || !this.visible) return;
    let i = this.geometry,
      n = this.material,
      s = this.matrixWorld;
    if (!n || !i) return;
    const r = this.instanceMatrix;
    if (!r) return;
    const a = r.array;
    this.computeInstanceMorphMatrix();
    const o = this.count;
    if (
      ((pR.geometry = this.geometry.getInstanceGeometry
        ? this.geometry.getInstanceGeometry()
        : this.geometry),
      (pR.material = n),
      n.isInstancedBallonMaterial)
    ) {
      const i = e.camera,
        r = n.resolution,
        l = e.mouse,
        h = n.size / r[0],
        c = n.size / r[1],
        u = (2 * (n.height + n.size / 2)) / r[1],
        d = l.x - h,
        p = l.x + h,
        f = l.y - c - u,
        m = l.y + c - u;
      dR.multiplyMatrices(i.matrixWorldInverse, s),
        dR.multiplyMatrices(i.projectionMatrix, dR);
      for (let n = 0; n < o; ++n)
        if (
          (uR.fromArray(a, 16 * n),
          gR
            .set(0, 0, 0, 1)
            .applyMatrix4(uR)
            .applyMatrix4(dR)
            .divideScalar(gR.w),
          gR.x >= d && gR.y >= f && gR.x <= p && gR.y <= m)
        ) {
          mR.set(uR.elements[12], uR.elements[13], uR.elements[14]);
          const i = e.ray.origin.distanceTo(mR);
          i >= e.near &&
            i <= e.far &&
            ((fR[0] = {
              distance: i,
              point: mR.clone(),
              itemIndex: n,
              object: this,
            }),
            t.push(fR[0]),
            (fR.length = 0));
        }
    } else
      for (let l = 0; l < o; ++l)
        uR.fromArray(a, 16 * l),
          cR.multiplyMatrices(uR, this.instanceMorphMatrix),
          cR.multiplyMatrices(s, cR),
          (pR.matrixWorld = cR),
          pR.raycast(e, fR),
          fR.length > 0 &&
            ((fR[0].instanceId = l),
            (fR[0].object = this),
            t.push(fR[0]),
            (fR.length = 0));
  }
}
class Points extends GeoObject {
  constructor() {
    super(...arguments),
      publicField(this, "isPoints", !0),
      publicField(this, "isEventEntitySupported", !0);
  }
  get size() {
    return this.material.size;
  }
  set size(e) {
    this.material.size = e;
  }
  raycast(e, t) {
    if (!this.receiveRaycast || !this.visible) return;
    const i = e.params.Points.threshold;
    let n = i * this.size;
    this.material.uniforms.zoomUnits &&
      (n *= this.material.uniforms.zoomUnits.value),
      (e.params.Points.threshold = n),
      vo.prototype.raycast.call(this, e, t),
      (e.params.Points.threshold = i);
  }
  getEntityByIndex(e) {
    const t = this.dataSource.data,
      i = {};
    for (const n of Object.keys(t)) i[n] = t[n][e];
    return i;
  }
}

const SimplePoint = makeSimplePoint(CommonShaderMaterial,
  U_,
  N_,
  k_,
  B_,
  O_,
  G_,
  yl,
  Xn,
  L_,
  D_,
  rn,
  Ki,
  colorToVec4,
  Points
);

let SR = new Box3(),
  CR = new Vector3();
class MR extends kl {
  constructor() {
    super(...arguments),
      publicField(this, "isCustomInstancedBufferGeometry", !0),
      publicField(this, "instanceGeometry", null);
  }
  computeBoundingBox() {
    null === this.boundingBox && (this.boundingBox = new Box3());
    const e = this.attributes.instancedPosition;
    void 0 !== e
      ? this.boundingBox.setFromBufferAttribute(e)
      : this.boundingBox.makeEmpty(),
      (isNaN(this.boundingBox.min.x) ||
        isNaN(this.boundingBox.min.y) ||
        isNaN(this.boundingBox.min.z)) &&
        console.error(
          'CustomInstancedBufferGeometry.computeBoundingBox: Computed min/max have NaN values.The "position" attribute is likely to have NaN values.',
          this
        );
  }
  computeBoundingSphere() {
    null === this.boundingSphere && (this.boundingSphere = new kt());
    let e = this.attributes.instancedPosition;
    if (e) {
      let t = this.boundingSphere.center;
      SR.setFromBufferAttribute(e), SR.getCenter(t);
      let i = 0;
      for (let n = 0, s = e.count; n < s; n++)
        CR.fromBufferAttribute(e, n),
          (i = Math.max(i, t.distanceToSquared(CR)));
      (this.boundingSphere.radius = Math.sqrt(i)),
        1 === e.count && (this.boundingSphere.radius = 1e5),
        isNaN(this.boundingSphere.radius) &&
          console.error(
            'CustomInstancedBufferGeometry.computeBoundingSphere(): Computed radius is NaN.The "position" attribute is likely to have NaN values.',
            this
          );
    }
  }
  getInstanceGeometry() {
    return (
      this.instanceGeometry ||
        ((this.instanceGeometry = new rn()),
        (this.instanceGeometry.attributes = this.attributes),
        (this.instanceGeometry.index = this.index)),
      this.instanceGeometry
    );
  }
}
class wR extends MR {
  constructor() {
    super(),
      publicField(this, "setModelData", () => {
        this.setAttribute(
          "position",
          new Ki([-0.5, -0.5, 0, -0.5, 0.5, 0, 0.5, 0.5, 0, 0.5, -0.5, 0], 3)
        ),
          this.setAttribute("uv", new Ki([0, 0, 0, 1, 1, 1, 1, 0], 2)),
          this.setIndex([0, 2, 1, 0, 3, 2]);
      }),
      this.setModelData();
  }
}
const TR = (e) => {
    Object.defineProperties(e, {
      color: {
        get: function () {
          return this.uniforms.color.value;
        },
        set: function (e) {
          this.uniforms.color.value = colorToVec4(e);
        },
      },
      height: {
        get: function () {
          return this.uniforms.height.value;
        },
        set: function (e) {
          this.uniforms.height.value = e;
        },
      },
      size: {
        get: function () {
          return this.uniforms.size.value;
        },
        set: function (e) {
          this.uniforms.size.value = e;
        },
      },
      size3: {
        get: function () {
          return this.uniforms.size3.value;
        },
        set: function (e) {
          Array.isArray(e) && 3 === e.length && (this.uniforms.size3.value = e);
        },
      },
      useSize3: {
        get: function () {
          return this.defines.USE_SIZE3;
        },
        set: function (e) {
          e === this.defines.USE_SIZE3 && (this.defines.USE_SIZE3 = !!e),
            (this.needsUpdate = !0);
        },
      },
      opacity: {
        get: function () {
          return this.uniforms.opacity.value;
        },
        set: function (e) {
          this.uniforms.opacity.value = e;
        },
      },
    });
  },
  IR = (e) => {
    Object.defineProperties(e, {
      animationRotate: {
        get: function () {
          return !!this.defines.ENABLE_ANIMATION_ROTATE;
        },
        set: function (e) {
          e !== this.animationRotate &&
            (e
              ? (this.defines.ENABLE_ANIMATION_ROTATE = !0)
              : delete this.defines.ENABLE_ANIMATION_ROTATE,
            (this.needsUpdate = !0));
        },
      },
      animationRotatePeriod: {
        get: function () {
          return this.uniforms.animationRotatePeriod.value;
        },
        set: function (e) {
          this.uniforms.animationRotatePeriod.value = e;
        },
      },
      animationJump: {
        get: function () {
          return !!this.defines.ENABLE_ANIMATION_JUMP;
        },
        set: function (e) {
          e !== this.animationJump &&
            (e
              ? (this.defines.ENABLE_ANIMATION_JUMP = !0)
              : delete this.defines.ENABLE_ANIMATION_JUMP,
            (this.needsUpdate = !0));
        },
      },
      animationJumpPeriod: {
        get: function () {
          return this.uniforms.animationJumpPeriod.value;
        },
        set: function (e) {
          this.uniforms.animationJumpPeriod.value = e;
        },
      },
      animationJumpHeight: {
        get: function () {
          return this.uniforms.animationJumpHeight.value;
        },
        set: function (e) {
          this.uniforms.animationJumpHeight.value = e;
        },
      },
      animationPeriodOffset: {
        get: function () {
          return this.uniforms.animationPeriodOffset.value;
        },
        set: function (e) {
          this.uniforms.animationPeriodOffset.value = e;
        },
      },
      animationEffect: {
        get: function () {
          return this.uniforms.animationEffect.value;
        },
        set: function (e) {
          this.uniforms.animationEffect.value = e;
        },
      },
      animationEffectPeriod: {
        get: function () {
          return this.uniforms.animationEffectPeriod.value;
        },
        set: function (e) {
          this.uniforms.animationEffectPeriod.value = e;
        },
      },
      animationScale: {
        get: function () {
          return !!this.defines.ENABLE_ANIMATION_SCALE;
        },
        set: function (e) {
          e !== this.animationScale &&
            (e
              ? (this.defines.ENABLE_ANIMATION_SCALE = !0)
              : delete this.defines.ENABLE_ANIMATION_SCALE,
            (this.needsUpdate = !0));
        },
      },
      animationBreath: {
        get: function () {
          return !!this.defines.ENABLE_ANIMATION_BREATH;
        },
        set: function (e) {
          e !== this.animationBreath &&
            (e
              ? (this.defines.ENABLE_ANIMATION_BREATH = !0)
              : delete this.defines.ENABLE_ANIMATION_BREATH,
            (this.needsUpdate = !0));
        },
      },
      animationPeriod: {
        get: function () {
          return this.uniforms.animationPeriod.value;
        },
        set: function (e) {
          this.uniforms.animationPeriod.value = e;
        },
      },
    });
  },
  RR = In.merge([
    Xn.fog,
    {
      height: { value: 0 },
      size: { value: 1 },
      size3: { value: [1, 1, 1] },
      resolution: { value: [1, 1] },
      zoomUnits: { value: 1 },
      color: { value: [1, 0, 0, 1] },
      opacity: { value: 1 },
    },
    {
      animationRotatePeriod: { value: 4e3 },
      animationJumpPeriod: { value: 4e3 },
      animationJumpHeight: { value: 30 },
      animationPeriodOffset: { value: !1 },
      animationEffect: { value: !0 },
      animationEffectPeriod: { value: 4e3 },
      animationPeriod: { value: 4e3 },
    },
    L_,
    F_,
    { isCesium: { value: !1 } },
  ]);
class PR extends CommonShaderMaterial {
  constructor(e) {
    super(),
      (this.type = "InstancedEffectPointMaterial"),
      (this.isInstancedEffectPointMaterial = !0),
      (this.lights = !1),
      (this.transparent = !0),
      Object.assign(this.uniforms, In.clone(RR)),
      TR(this),
      IR(this),
      U_(this),
      z_(this),
      this.setValues(e);
  }
}
const DR = In.merge([
  Xn.fog,
  L_,
  { isEmissive: { value: !1 }, elapsedTime: { value: 0 } },
]);
class LR extends PR {
  constructor(e) {
    super(e),
      publicField(this, "type", "SpecialPointMaterial"),
      publicField(this, "isSpecialPointMaterial", !0),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\n\nuniform float height;\nuniform float size;\nuniform float elapsedTime;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\n\nvarying vec2 vPosition;\nvarying float vEffectRatio;\nvarying vec2 vUV;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n    vUV = uv;\n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    vec3 transformed = vec3(position);\n\n    #include <mvt_animation_vertex>\n\n    transformed *= size;\n\n    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\n    float pixelSize = getPixelSize(vec3(modelViewMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n\n    // gl_Position = projectionMatrix * modelViewMatrix * \n    //     vec4(instancedPosition + transformed, 1.0);\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n#define blue1 vec3(0.74,0.95,1.00)\n#define blue2 vec3(0.87,0.98,1.00)\n#define blue3 vec3(0.35,0.76,0.83)\n#define blue4 vec3(0.953,0.969,0.89)\n#define red   vec3(1.00,0.38,0.227)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n\nuniform float ratio;\n\nfloat PI = 3.1415926;\nuniform float elapsedTime;\nuniform vec2 resolution; \nvarying vec2 vPosition;\nvarying vec2 vUV;\n\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90.0 * elapsedTime / 1000.;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n                            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) );\n        d = normalize(d);\n        //compute gradient based on angle difference to theta0\n        float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.0,1.0);\n        return SMOOTH(l,1.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n\nfloat circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = 180.0*(atan(d.y,d.x)/M_PI);\n    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n\nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n        + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n        + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n        + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n\nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x);\n    int y = int(d.y);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\nfloat dots(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if( r <= 2.5 )\n        return 1.0;\n    if( ( r<= radius) && ( (abs(d.y+0.5)<=1.0) && ( mod(d.x+1.0, 50.0) < 2.0 ) ) )\n        return 1.0;\n    else if ( (abs(d.y+0.5)<=1.0) && ( r >= 50.0 ) && ( r < 115.0 ) )\n        return 0.5;\n    else\n        return 0.0;\n}\nfloat bip1(vec2 uv, vec2 center)\n{\n    return SMOOTH(length(uv - center),3.0);\n}\nfloat bip2(vec2 uv, vec2 center)\n{\n    float r = length(uv - center);\n    float R = 8.0+mod(87.0*elapsedTime / 1000., 80.0);\n    return (0.5-0.5*cos(30.0*elapsedTime / 1000.)) * SMOOTH(r,5.0)\n        + SMOOTH(6.0,r)-SMOOTH(8.0,r)\n        + smoothstep(max(8.0,R-20.0),R,r)-SMOOTH(R,r);\n}\nvoid main() { \n    vec2 _uv = vec2(vPosition.x * resolution.x, vPosition.y * resolution.y);\n    vec3 finalColor;\n    vec2 uv = _uv;\n    //center of the image\n    vec2 c = vec2(vUV.x / 2.0, vUV.y / 2.0);\n    finalColor = vec3( 0.3*_cross(uv, c, 240.0) );\n    finalColor += ( circle(uv, c, 100.0, 1.0)\n                + circle(uv, c, 165.0, 1.0) ) * blue1;\n    finalColor += (circle(uv, c, 240.0, 2.0) );//+ dots(uv,c,240.0)) * blue4;\n    finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n    finalColor += triangles(uv, c, 315.0 + 30.0*sin(elapsedTime / 1000.)) * blue2;\n    finalColor += movingLine(uv, c, 240.0) * blue3;\n    finalColor += circle(uv, c, 10.0, 1.0) * blue3;\n    finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(elapsedTime / 1000.)) * blue3;\n    if( length(uv-c) < 240.0 )\n    {\n        //animate some bips with random movements\n        vec2 p = 130.0*MOV(1.3,1.0,1.0,1.4,3.0+0.1*elapsedTime / 1000.);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 130.0*MOV(0.9,-1.1,1.7,0.8,-2.0+sin(0.1*elapsedTime / 1000.)+0.15*elapsedTime / 1000.);\n        finalColor += bip1(uv, c+p) * vec3(1,1,1);\n        p = 50.0*MOV(1.54,1.7,1.37,1.8,sin(0.1*elapsedTime / 1000.+7.0)+0.2*elapsedTime / 1000.);\n        // finalColor += bip2(uv,c+p) * red;\n    }\n\n    gl_FragColor = vec4( finalColor, 1.0 );\n    // gl_FragColor.a *= finalColor.r;\n    \n}"),
      (this.transparent = !0),
      (this.side = 2),
      (this.depthWrite = !1),
      Object.assign(this.uniforms, In.clone(DR)),
      N_(this, ["isEmissive", "elapsedTime"]),
      this.setValues(e);
  }
}
const FR =
  "#define GLSLIFY 1\n#include <common>\n\nvarying vec2 vUV;\nuniform float size;\nvarying vec2 vPosition;\nuniform float height;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() { \n    vUV = uv;\n    vec3 transformed = vec3(position);\n    vPosition = position.xy;\n\n    transformed *= size;\n\n    vec4 worldPosition = modelMatrix * instanceMatrix * vec4(transformed, 1.0);\n    worldPosition.z += height;\n\n    gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    #include <logdepthbuf_vertex>\n}";
let NR = In.merge([
  {
    speed: { value: 1 },
    color: { value: [1, 0, 0, 1] },
    size: { value: 100 },
    isEmissive: { value: !1 },
  },
]);
class BR extends PR {
  constructor(e) {
    super(e),
      publicField(this, "type", "InstancedFanMaterial"),
      publicField(this, "isInstancedFanMaterial", !0),
      (this.depthWrite = !1),
      N_(this, ["speed", "isEmissive"]),
      "Fan" === e.type
        ? ((this.vertexShader =
            "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\n\nuniform float height;\nuniform float size;\nuniform float elapsedTime;\nuniform float speed;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\n\nvarying vec2 vPosition;\nvarying float vEffectRatio;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n\n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    vec3 transformed = vec3(position);\n\n    float elapsedTime = elapsedTime * speed * .5;\n    #include <mvt_animation_vertex>\n\n    transformed *= size;\n\n    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\n    float pixelSize = getPixelSize(vec3(modelViewMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n\n    vec4 worldPosition = modelMatrix * instanceMatrix * vec4(transformed, 1.0);\n    worldPosition.z += height;\n\n    // gl_Position = projectionMatrix * modelViewMatrix * \n    //     vec4(instancedPosition + transformed, 1.0);\n    gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    #include <logdepthbuf_vertex>\n}"),
          (this.fragmentShader =
            "#define GLSLIFY 1\n// #include <common>\n\nuniform vec4 color;\nuniform float opacity;\nuniform bool animationEffect;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n// #include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n   \n    float bb = atan(vPosition.y, vPosition.x) + 3.15;\n\n    float pi = 3.14 * 1.;\n    // bb = mod(bb, 6.28);\n    if (bb > pi) {\n        discard;\n    } else { \n        float aa = mod(bb / pi, 1.0);\n        float dis = distance(vPosition, vec2(0, 0));\n        if (dis > 0.5) {\n            discard;\n        } else {\n            gl_FragColor = color;\n            gl_FragColor.a *= aa;\n        }\n    }\n\n    gl_FragColor.a *= opacity;\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n    // #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n}"))
        : "Radar" === e.type
        ? ((NR = In.merge([NR, { segmentAngle: { value: 0.25 * Math.PI } }])),
          N_(this, ["segmentAngle"]),
          (this.vertexShader =
            "#include <common>\nprecision mediump float;\nprecision mediump int;\n#define GLSLIFY 1\n#include <mvt_animation_pars_vertex>\nvarying vec2 vPosition;\nuniform float elapsedTime;\nuniform float speed;\nattribute float instancedRandomFactor;\nuniform float size;\nuniform float height;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() {   \n    vec3 transformed = vec3(position);\n    float elapsedTime = elapsedTime * speed * .5;\n    #include <mvt_animation_vertex>\n    transformed *= size;\n    vPosition = position.xy;\n\n    vec4 worldPosition = modelMatrix * instanceMatrix * vec4(transformed, 1.0);\n    worldPosition.z += height;\n    \n    gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    #include <logdepthbuf_vertex>\n}"),
          (this.fragmentShader =
            "#define GLSLIFY 1\nuniform float segmentAngle;\nuniform vec4 color;\nuniform float opacity;\nvarying vec2 vPosition;\n\n#define PI 3.1415926\n#define radius .5\n#include <logdepthbuf_pars_fragment>\n\nfloat cros(vec2 line1, vec2 line2){\n    return line1.x * line2.y - line2.x * line1.y;\n}\n\nvoid main() {\n    bool crossNPI = false;\n    float wholeAng = abs(mod(segmentAngle , PI * 2.));\n    float dis = length(vec2(vPosition.xy - vec2(0.0)));\n\n    // if(wholeAng < -1.0*PI){\n    //     crossNPI = true;\n    //     wholeAng = 2.0*PI + endAng-startAng;\n    // }\n    if (dis<radius) {\n        vec2 nV = normalize(vPosition.xy);\n        float angle = 0.0;\n        if(nV.x > 0.0 && abs(nV.y) < 0.01) {\n            angle = 0.5*PI;\n        }\n        else if (nV.x<0.0 && abs(nV.y) < 0.01) {\n            angle = -0.5*PI;\n        }\n        else {\n            angle = atan(nV.x,nV.y);\n        }\n\n        if (angle<.0) {\n            angle = 2. * PI + angle;\n        }\n\n        float alpha = 0.1;\n\n        if (angle > 0. && angle < wholeAng) {\n            // alpha = 1.1 - (endAng-angle)/wholeAng;\n            alpha = 1.1 - (1. - (wholeAng-angle) / wholeAng);\n        }\n        \n        gl_FragColor = color;\n        gl_FragColor.a = alpha * opacity;\n    }\n    else {\n        discard;\n    }\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    #include <logdepthbuf_fragment>\n}"))
        : "RadarLayered" === e.type
        ? ((NR = In.merge([NR, { sideColor: { value: [0.87, 0.98, 1, 1] } }])),
          B_(this, ["sideColor"]),
          (this.vertexShader = FR),
          (this.fragmentShader =
            "#define GLSLIFY 1\n#define SMOOTH(r,R) (1.0-smoothstep(R-1.0,R+1.0, r))\n#define RANGE(a,b,x) ( step(a,x)*(1.0-step(b,x)) )\n#define RS(a,b,x) ( smoothstep(a-1.0,a+1.0,x)*(1.0-smoothstep(b-1.0,b+1.0,x)) )\n#define M_PI 3.1415926535897932384626433832795\n\n// #define blue1 vec4(0.74,0.95,1.00,1.)\n// #define blue2 vec4(0.87,0.98,1.00,1.)\n// #define blue3 vec4(0.35,0.76,0.83,1.)\n// #define blue4 vec4(0.953,0.969,0.89,1.)\n// #define red   vec4(1.00,0.38,0.227,1.)\n\n#define MOV(a,b,c,d,t) (vec2(a*cos(t)+b*cos(0.1*(t)), c*sin(t)+d*cos(0.1*(t))))\n// #define elapsedTime 0.01\nuniform float elapsedTime;\nuniform float speed;\nvarying vec2 vPosition;\nuniform vec4 color;\nuniform vec4 sideColor;\nuniform float opacity;\n#include <logdepthbuf_pars_fragment>\nfloat movingLine(vec2 uv, vec2 center, float radius)\n{\n    //angle of the line\n    float theta0 = 90.0 * elapsedTime * speed *.0006;\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    if(r<radius)\n    {\n        //compute the distance to the line theta=theta0\n        vec2 p = radius*vec2(cos(theta0*M_PI/180.0),\n            -sin(theta0*M_PI/180.0));\n        float l = length( d - p*clamp( dot(d,p)/dot(p,p), 0.0, 1.0) )* 500.;\n        d = normalize(d);\n        //compute gradient based on angle difference to theta0\n        float theta = mod(180.0*atan(d.y,d.x)/M_PI+theta0,360.0);\n        float gradient = clamp(1.0-theta/90.0,0.3,1.0);\n        return SMOOTH(l,1.0)+0.5*gradient;\n    }\n    else return 0.0;\n}\n    \n    float circle(vec2 uv, vec2 center, float radius, float width)\n{\n    float r = length(uv - center);\n    return smoothstep(radius-width,radius,r)-smoothstep(radius,radius+width,r);\n    // return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n}\n\nfloat circle2(vec2 uv, vec2 center, float radius, float width, float opening)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    if( abs(d.y) > opening )\n        return SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius);\n    else\n        return 0.0;\n}\nfloat circle3(vec2 uv, vec2 center, float radius, float width)\n{\n    vec2 d = uv - center;\n    float r = sqrt( dot( d, d ) );\n    d = normalize(d);\n    float theta = 180.0*(atan(d.y,d.x)/M_PI);\n    return smoothstep(2.0, 2.1, abs(mod(theta+2.0,45.0)-2.0)) *\n        mix( 0.5, 1.0, step(45.0, abs(mod(theta, 180.0)-90.0)) ) *\n        (SMOOTH(r-width/2.0,radius)-SMOOTH(r+width/2.0,radius));\n}\n    \nfloat triangles(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    return RS(-8.0, 0.0, d.x-radius) * (1.0-smoothstep( 7.0+d.x-radius,9.0+d.x-radius, abs(d.y)))\n         + RS( 0.0, 8.0, d.x+radius) * (1.0-smoothstep( 7.0-d.x-radius,9.0-d.x-radius, abs(d.y)))\n         + RS(-8.0, 0.0, d.y-radius) * (1.0-smoothstep( 7.0+d.y-radius,9.0+d.y-radius, abs(d.x)))\n         + RS( 0.0, 8.0, d.y+radius) * (1.0-smoothstep( 7.0-d.y-radius,9.0-d.y-radius, abs(d.x)));\n}\n    \nfloat _cross(vec2 uv, vec2 center, float radius)\n{\n    vec2 d = uv - center;\n    int x = int(d.x * 100.);\n    int y = int(d.y * 100.);\n    float r = sqrt( dot( d, d ) );\n    if( (r<radius) && ( (x==y) || (x==-y) ) )\n        return 1.0;\n    else return 0.0;\n}\n\nvoid main() {\n    vec4 finalColor = vec4(0.0, .0, .0, .0);\n    vec2 uv = vPosition.xy;\n    #include <logdepthbuf_fragment>\n    //center of the image\n    vec2 c = vec2(0.0, 0.0);\n    finalColor += 0.3*_cross( vPosition.xy, c, .5);\n    finalColor += ( circle(uv, c, .3, .01)\n                  + circle(uv, c, .4, .01) ) * color;\n    finalColor += (circle(uv, c, .5, .02) ) * sideColor;//+ dots(uv,c,240.0)) * blue4;\n    // finalColor += circle3(uv, c, 313.0, 4.0) * blue1;\n    // finalColor += triangles(uv, c, 315.0 + 30.0*sin(elapsedTime * speed *.0006)) * blue2;\n    finalColor += movingLine(uv, c, .5) * color;\n    finalColor += circle(uv, c, .05, .01) * color;\n    // finalColor += 0.7 * circle2(uv, c, 262.0, 1.0, 0.5+0.2*cos(elapsedTime * speed *.0006)) * blue3;\n    if( length(uv-c) < .5 ) {\n        if( length(finalColor)<0.2) {\n            discard;\n        }\n    }\n    else{\n        discard;\n    }\n\n    finalColor.a *= opacity;\n    if (finalColor.a <= 0.) {\n        discard;\n    }\n    gl_FragColor = finalColor;\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}"))
        : ((this.vertexShader = FR),
          (this.fragmentShader =
            "#define GLSLIFY 1\n#include <common>\n\nvarying vec2 vUV;\nuniform vec4 color;\nuniform float speed;\nuniform float elapsedTime;\n\nvec3 RadarPing(in vec2 uv, in vec2 center, in float innerTail, \n    in float frontierBorder, in float timeResetSeconds, \n    in float radarPingSpeed, in float fadeDistance, float t) {\n    vec2 diff = center-uv;\n    float r = length(diff);\n    float time = mod(t, timeResetSeconds) * radarPingSpeed;\n    \n    float circle;\n    circle += smoothstep(time - innerTail, time, r) * smoothstep(time + frontierBorder,time, r);\n    circle *= smoothstep(fadeDistance, 0.25, r); // fade to 0 after fadeDistance\n            \n    return vec3(circle);\n}\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    // gl_FragColor = vec4(1.,.0,.0,1.);\n    //normalize coordinates \n    vec2 uv = vUV; //move coordinates to 0..1\n    uv = uv.xy*2.; // translate to the center\n    uv += vec2(-1.0, -1.0);\n    #include <logdepthbuf_fragment>\n    vec3 color1;\n    // generate some radar pings\n    float fadeDistance = 1.3;\n    float resetTimeSec = 5.0;\n    float radarPingSpeed = 0.2;\n    vec2 greenPing = vec2(0.0, 0.0);\n    color1 += RadarPing(uv, greenPing, 0.12, 0.00025, resetTimeSec,\n        radarPingSpeed, fadeDistance, elapsedTime * speed * .0006) * vec3(color.rgb);\n    // color += RadarPing(uv, greenPing, 0.08, 0.00025, resetTimeSec,\n    //    radarPingSpeed, fadeDistance, elapsedTime * speed * .0006 + 1.) * uColor;\n    color1 += RadarPing(uv, greenPing, 0.12, 0.00025, resetTimeSec,\n        radarPingSpeed, fadeDistance, elapsedTime * speed * .0006 + 2.) * vec3(color.rgb);\n    //return the new color\n    if(length(color1)<0.001){\n        discard;\n    }else{\n        gl_FragColor = vec4(color1,clamp(length(color1),0.0,1.0));\n    }\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n}")),
      Object.assign(this.uniforms, In.clone(NR)),
      this.setValues(e);
  }
}
const kR =
    "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\n\nuniform float height;\nuniform float size;\nuniform float elapsedTime;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\n\nvarying vec2 vPosition;\nvarying float vEffectRatio;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\nvoid main() {\n\n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    vec3 transformed = vec3(position);\n\n    #include <mvt_animation_vertex>\n\n    transformed *= size;\n\n    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\n    float pixelSize = getPixelSize(vec3(modelViewMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n\n    vec4 worldPosition = modelMatrix * instanceMatrix * vec4(transformed, 1.0);\n    worldPosition.z += height;\n\n    gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    #include <logdepthbuf_vertex>\n}",
  OR = In.merge([
    {
      color: { value: [1, 1, 0, 1] },
      size: { value: 10 },
      duration: { value: 2e3 },
      trail: { value: 0.5 },
      center: { value: 0.1 },
      radius: { value: 0.5 },
      radiusDiff: { value: 0.08 },
      isEmissive: { value: !1 },
    },
  ]);
class UR extends PR {
  constructor(e) {
    super(e),
      publicField(this, "type", "InstancedBubbleMaterial"),
      publicField(this, "isInstancedBubbleMaterial", !0),
      (this.depthTest = !1),
      (this.depthWrite = !1),
      "Breath" == e.type
        ? ((this.vertexShader =
            "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\n\nuniform float height;\nuniform float size;\nuniform float elapsedTime;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\nuniform float duration;\n\nvarying vec2 vPosition;\nvarying float vEffectRatio;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\nvoid main() {\n\n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n    vec3 transformed = vec3(position);\n\n    #include <mvt_animation_vertex>\n\n    transformed *= size;\n\n    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\n    float pixelSize = getPixelSize(vec3(modelViewMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n\n    if (animationEffect) {\n        vEffectRatio = mod(elapsedTime, duration) / duration;\n        if (animationPeriodOffset) {\n            vEffectRatio += instancedRandomFactor;\n        }\n        vEffectRatio = mod(vEffectRatio, 1.0);\n        transformed *= vEffectRatio;\n    } else {\n        vEffectRatio = 1.0;\n    }\n\n    vec4 worldPosition = modelMatrix * instanceMatrix * vec4(transformed, 1.0);\n    worldPosition.z += height;\n\n    gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    #include <logdepthbuf_vertex>\n}"),
          (this.fragmentShader =
            "#define GLSLIFY 1\n#include <common>\n\nuniform vec4 color;\nuniform float opacity;\nuniform bool animationEffect;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > 0.5) {\n        discard;\n    }\n\n    gl_FragColor = color;\n    \n    gl_FragColor.a *= opacity;\n    if (animationEffect) {\n        if (vEffectRatio > 0.7) {\n            gl_FragColor.a *= (1.0 - vEffectRatio) / 0.3;\n        }\n    }\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n    \n}"))
        : "Wave" == e.type
        ? ((this.vertexShader = kR),
          (this.fragmentShader =
            "#define GLSLIFY 1\n#include <common>\n\nuniform vec4 color;\nuniform float opacity;\nuniform bool animationEffect;\nuniform float elapsedTime;\nuniform float duration;\nuniform float trail;\nuniform float radiusDiff;\nuniform float center;\nuniform float radius;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > radius) {\n        discard;\n    }\n    vec4 vColor = color;\n    \n    float alpha = sin((radiusDiff - d) / radiusDiff * trail * 2.0  * 3.14 + elapsedTime / duration * 10.);\n    // 中心点\n    if (d <= center){\n      if (d > 0.9 * center && d <= center) {\n        if (alpha >= 0.5) {\n          vColor.a = 1.0;\n        } else {\n          vColor.a = 1.0 - smoothstep(center - 0.0001, center, d);\n        }\n      }\n    }\n    else {\n      if (alpha >= 0.6) {\n        vColor.a = 1.0 - d / radius;\n        if (alpha >= 0.5 && alpha <= 0.6) {\n            vColor.a *= smoothstep(0.0, 0.1, alpha - 0.5);\n        }\n        \n        if (d >= 0.8 * radiusDiff && d <= radiusDiff) {\n            vColor.a *= 1.0 - smoothstep(0.9, 1.0, d / radiusDiff);\n        }\n        \n      }\n      else {\n        vColor.a = 0.0;\n      }\n    }\n    vColor.a *= opacity;\n    gl_FragColor = vColor;\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n\t  #include <colorspace_fragment>\n    \n}"))
        : ((this.vertexShader = kR),
          (this.fragmentShader =
            "#define GLSLIFY 1\n#include <common>\n\nuniform vec4 color;\nuniform float opacity;\nuniform bool animationEffect;\nuniform float elapsedTime;\nuniform float duration;\nuniform float trail;\nuniform float center;\nuniform float radius;\n\nvarying float vEffectRatio;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > 0.5) {\n        discard;\n    }\n    vec4 vColor = color;\n    float range = mod(elapsedTime, (duration + trail));\n    float percent = 0.0;\n    if (range <= duration) {\n      percent = range / duration * 2.0;\n    } else {\n      percent = 1.0;\n    }\n    float r = radius * percent;\n    \n    // 中心点\n    if (d <= center){\n      if(d > 0.99 * center && d <= center) {\n        vColor.a = 1.0 - smoothstep(0.99 * center, center, d);\n      }\n    }\n    else {\n      if (d < r) {\n        vColor.a = smoothstep(0.1, 0.9, pow(d / r, 2.0) * 0.9);\n        // 边缘抗锯齿\n        if (d >= 0.99 * r && d <= r) {\n          vColor.a *= 1.0 - smoothstep(0.99, 1.0, d / r);\n        }\n        // 拖尾渐隐\n        if (range > duration) {\n          vColor.a *= 1.0 - (range - duration) / trail;\n        }\n      }\n      else {\n        vColor.a = 0.0;\n      }\n      \n    }\n    vColor.a *= opacity;\n    gl_FragColor = vColor;\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n    #include <tonemapping_fragment>\n\t  #include <colorspace_fragment>\n    \n}")),
      Object.assign(this.uniforms, In.clone(OR)),
      N_(this, ["duration", "trail", "isEmissive"]),
      this.setValues(e);
  }
}
const zR = new Vector3();
new Matrix4();
const GR = new Matrix4();
new Matrix4();
class VR extends MR {
  constructor(e) {
    super(e),
      publicField(this, "_shapeType", "cube"),
      publicField(this, "fillNoLine", (e, t, i, n, s) => {
        for (let r = 0, a = e.length; r < a - 2; r += 3)
          i.push(e[r], e[r + 1], e[r + 2]), t.push(0), n.push(0), s.push(0);
      }),
      publicField(this, "generateLines", (e, t, i, n, s, r, a) => {
        const o = t.length / 3;
        let l, h, c, u, d, p, f, m;
        for (let g = 0, _ = e.length; g < _; ++g) {
          (f = 3 * e[g][0]),
            (m = 3 * e[g][1]),
            (l = t[f]),
            (h = t[f + 1]),
            (c = t[f + 2]),
            (u = t[m]),
            (d = t[m + 1]),
            (p = t[m + 2]),
            t.push(l, h, c, l, h, c, u, d, p, u, d, p),
            i.push(1, 1, 1, 1),
            n.push(u, d, p, u, d, p, l, h, c, l, h, c),
            s.push(1, 1, 0, 0),
            r.push(1, -1, 1, -1);
          const _ = o + 4 * g;
          a.push(_, _ + 1, _ + 2, _ + 2, _ + 1, _ + 3);
        }
      }),
      publicField(this, "applyTransformToPositions", (e, t) => {
        const i = [];
        for (let n = 0, s = e.length; n < s - 2; n += 3)
          zR.set(e[n], e[n + 1], e[n + 2]),
            zR.applyMatrix4(t),
            i.push(zR.x, zR.y, zR.z);
        return i;
      }),
      (this.parameters = e),
      (this.shapeType = this.parameters.shapeType);
  }
  get shapeType() {
    return this._shapeType;
  }
  set shapeType(e) {
    (this._shapeType = e), this.geometry && this.geometry.dispose();
    let t = null,
      i = null,
      n = null,
      s = [],
      r = [],
      a = [],
      o = [];
    if ("cube" === e) {
      (t = new Cn(1, 1, 1)),
        (i = Array.from(t.attributes.position.array)),
        (n = Array.from(t.index.array)),
        GR.identity().makeTranslation(0, 0, 0.5),
        (i = this.applyTransformToPositions(i, GR)),
        this.fillNoLine(i, s, r, a, o);
      const e = [];
      for (let t = 0; t < 24; t += 4)
        e.push([t, t + 1], [t + 3, t + 2], [t + 2, t]);
      this.generateLines(e, i, s, r, a, o, n);
    } else if ("octahedron" === e) {
      (i = [
        0, 0, 1, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, -0.5, 0.5,
        0, 0, 0,
      ]),
        (n = [
          0, 1, 4, 0, 4, 3, 0, 3, 2, 0, 2, 1, 1, 5, 4, 4, 5, 3, 3, 5, 2, 2, 5,
          1,
        ]),
        this.fillNoLine(i, s, r, a, o);
      const e = [
        [0, 1],
        [0, 2],
        [0, 3],
        [0, 4],
        [1, 4],
        [4, 3],
        [3, 2],
        [2, 1],
        [1, 5],
        [2, 5],
        [3, 5],
        [4, 5],
      ];
      this.generateLines(e, i, s, r, a, o, n);
    } else if ("pyramid" === e) {
      (i = [
        -0.5, -0.5, 1, -0.5, 0.5, 1, 0.5, 0.5, 1, 0.5, -0.5, 1, 0, 0, 0, -0.25,
        -0.25, 0.5, -0.25, 0.25, 0.5, 0.25, 0.25, 0.5, 0.25, -0.25, 0.5,
      ]),
        (n = [0, 2, 1, 0, 3, 2, 1, 0, 4, 0, 3, 4, 3, 2, 4, 2, 1, 4]),
        this.fillNoLine(i, s, r, a, o);
      const e = [
        [0, 1],
        [1, 2],
        [2, 3],
        [3, 0],
        [0, 4],
        [1, 4],
        [2, 4],
        [3, 4],
        [6, 5],
        [5, 8],
        [8, 7],
        [7, 6],
      ];
      this.generateLines(e, i, s, r, a, o, n);
    }
    t && t.dispose(),
      i &&
        (this.setAttribute("position", new Ki(new Float32Array(i), 3)),
        this.setAttribute("isLine", new Ki(new Float32Array(s), 1)),
        this.setAttribute("adjacentPoint", new Ki(new Float32Array(r), 3)),
        this.setAttribute("isLineStart", new Ki(new Float32Array(a), 1)),
        this.setAttribute("lineSide", new Ki(new Float32Array(o), 1)),
        this.setIndex(n),
        this.computeBoundingSphere());
  }
  dispose() {}
}
const QR = In.merge([
  {
    lineWidth: { value: 2 },
    lineColor: { value: [1, 1, 0, 1] },
    isCesium: { value: !1 },
    isEmissive: { value: !1 },
  },
]);
class HR extends PR {
  constructor(e) {
    super(),
      (this.type = "InstancedShapeMaterial"),
      (this.isInstancedShapeMaterial = !0),
      (this.isUseSize3 = !0),
      (this.side = 2),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nattribute vec3 instancedPosition;\nattribute float instancedRandomFactor;\nattribute float isLine;\nattribute float isLineStart;\nattribute float lineSide;\nattribute vec3 adjacentPoint;\n// attribute mat4 instanceMatrix;\n\nuniform bool isCesium;\n\nuniform float height;\nuniform vec3 size3;\nuniform float time;\nuniform float lineWidth;\nvarying float vIsLine;\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\n#define MVT_KEEP_PROJECTION_POSITION\n\nvec3 transformPosition(vec3 p) {\n    vec3 transformed = vec3(p);\n\n    #include <mvt_animation_vertex>\n\n    transformed *= size3;\n    transformed.z += height;\n\n    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\n    float pixelSize = getPixelSize(vec3(modelViewMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n\n    return transformed;\n}\n\nvoid main() {\n\n    #include <mvt_selective_vertex>\n    vec4 mvp_projectPosition;\n    if (isLine == 1.0) {\n        vIsLine = 1.0;\n        mat4 m = projectionMatrix * modelViewMatrix * instanceMatrix;\n        vec4 p1 = m * vec4(transformPosition(position), 1.0);\n        vec4 p2 = m * vec4(transformPosition(adjacentPoint), 1.0);\n        mvp_projectPosition = vec4(p1);\n        p1 /= p1.w;\n        p2 /= p2.w;\n        vec2 dir;\n        if (isLineStart == 1.0) {\n            dir = normalize(p2.xy - p1.xy);\n        } else {\n            dir = normalize(p1.xy - p2.xy);\n        }\n        vec2 _normal = vec2(-dir.y, dir.x);\n        // multiply by 2 and then divide by 2\n        vec2 offset = _normal * lineSide / resolution * lineWidth;\n        gl_Position = p1;\n        gl_Position.xy += offset;\n    }\n    else {\n        vIsLine = 0.0;\n        vec3 transformed = transformPosition(position);\n        // mat4 tm = mat4(\n        //     1,0,0,0,\n        //     0,1,0,0,\n        //     0,0,1,0,\n        //     instanceMatrix[3][0],4826138.4,0,1\n        // );\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix *\n            vec4(transformed, 1.0);\n        // gl_Position = projectionMatrix * viewMatrix *\n        //     vec4(transformed.x + 12957564.9, transformed.y + 4826138.4, transformed.z + 0.0, 1.0);\n        // vTest.x = instanceMatrix[1][1];\n        //  gl_Position = projectionMatrix * viewMatrix * \n        //     vec4(instancedPosition + transformed, 1.0);\n        mvp_projectPosition = gl_Position;\n    }\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform vec4 color;\nuniform vec4 lineColor;\nuniform float opacity;\n\nvarying float vIsLine;\n\n#include <mvt_selective_pars_fragment>\n\nvoid main() {\n    if (vIsLine == 1.0) {\n        gl_FragColor = lineColor;\n    }\n    else {\n        gl_FragColor = color;\n        // test\n        // gl_FragColor.r = vTest.x;\n        // gl_FragColor.g = vTest.y;\n        // gl_FragColor.b = vTest.z;\n        // gl_FragColor.a = 1.0;\n        // test end\n    }\n    gl_FragColor.a *= opacity;\n    #include <mvt_selective_fragment>\n}"),
      Object.assign(this.uniforms, In.clone(QR)),
      N_(this, ["isEmissive", "lineWidth"]),
      B_(this, ["lineColor"]),
      this.setValues(e);
  }
}
class jR extends rn {
  constructor(e) {
    super(e), (this.parameters = e);
  }
  setData(e) {
    const {
        vertexSizes: t,
        vertexColors: i,
        vertexOffsets: n,
        vertexIcons: s,
      } = this.parameters,
      {
        aPositions: r,
        aObjectIndices: a,
        aColors: o,
        aSizes: l,
        aOffsets: h,
        aPointUvs: c,
      } = e;
    this.setAttribute("position", new Ki(r, 3)),
      this.setAttribute("objectIndex", new Ki(a, 1)),
      i && this.setAttribute("aColor", new Ki(o, 4)),
      t && this.setAttribute("aSize", new Ki(l, 1)),
      n && this.setAttribute("aOffset", new Ki(h, 2)),
      s && this.setAttribute("aPointUv", new Ki(c, 4));
  }
}
const WR = new yl(),
  qR = In.merge([
    Xn.fog,
    L_,
    {
      emissive: { value: [0, 0, 0] },
      isEmissive: { value: !1 },
      color: { value: [0, 1, 1, 1] },
      size: { value: 30 },
      uOffset: { value: [0, 0] },
      ulength: { value: 0 },
      useCanvasMap: { value: !1 },
      vertexColors: { value: !1 },
      vertexSizes: { value: !1 },
      vertexOffsets: { value: !1 },
      uShapeType: { value: 2 },
      opacity: { value: 1 },
      map: { value: null },
      useMap: { value: !1 },
    },
  ]);
class IconPointMaterial extends CommonShaderMaterial {
  constructor(e) {
    super(),
      (this.type = "IconPointMaterial"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform float size;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\n#ifdef MVT_USE_VERTEX_SIZE\n    attribute float aSize;\n    varying float vSize;\n#endif\n\n#ifdef MVT_USE_VERTEX_OFFSET\n    attribute vec2 aOffset;\n#else\n    uniform vec2 uOffset;\n#endif\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n    varying vec4 vColor;\n#endif\n\n#ifdef MVT_USE_VERTEX_ICON\n    attribute vec4 aPointUv;\n    varying vec4 vPointUv;\n#endif\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n    #include <mvt_selective_vertex>\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n\n    #ifdef MVT_USE_VERTEX_OFFSET\n        vec2 offset = aOffset * 2. * pixelRatio * pixelSize;\n    #else\n        vec2 offset = uOffset * 2. * pixelRatio * pixelSize;\n    #endif\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    gl_Position.xy = gl_Position.xy - offset;\n\n    #ifdef MVT_USE_VERTEX_SIZE\n        vSize = aSize * pixelRatio;\n        gl_PointSize = vSize;\n    #else\n        gl_PointSize = size * pixelRatio;\n    #endif\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #endif\n\n    #ifdef MVT_USE_VERTEX_ICON\n        vPointUv = aPointUv;\n    #endif\n\n    #include <logdepthbuf_vertex>\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#endif\nuniform vec4 color;\nuniform float uShapeType;\nuniform float opacity;\n\n#ifdef MVT_USE_VERTEX_SIZE\n    varying float vSize;\n#else\n    uniform float size;\n#endif\n\n#ifdef MVT_USE_VERTEX_ICON\n    varying vec4 vPointUv;\n#endif\nuniform bool useMap;\nuniform bool useCanvasMap;\nuniform sampler2D map;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_emissive_pars_fragment>\n\nvoid main() {\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        gl_FragColor = vColor;\n    #else\n        gl_FragColor = color;\n    #endif\n\n    if (uShapeType == 2.) {\n        float d = distance(gl_PointCoord, vec2(0.5, 0.5));\n        #ifdef MVT_USE_VERTEX_SIZE\n            float alpha = smoothstep(0.5 + 0.5 / vSize, 0.5 - 1.0 / vSize, d);\n        #else\n            float alpha = smoothstep(0.5 + 0.5 / size, 0.5 - 1.0 / size, d);\n        #endif\n        \n        if (alpha <= 0.) {\n            discard;\n        } else {\n            gl_FragColor.a *= alpha;\n        }\n    }\n \n    if (useMap) {\n        vec4 tColor = texture2D(map, vec2(gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n     //    gl_FragColor.rgb = tColor.rgb * tColor.a + gl_FragColor.rgb * (1.0 - tColor.a);\n     //    gl_FragColor.a += tColor.a;\n        \n        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);\n        // gl_FragColor.rgb = mix(gl_FragColor.rgb, tColor.rgb, tColor.a);\n        // gl_FragColor.a += tColor.a;\n        // gl_FragColor = tColor;\n    }\n\n    #ifdef MVT_USE_VERTEX_ICON\n    if(useCanvasMap) {\n        vec4 tColor = texture2D(map, vec2(vPointUv.x + vPointUv.z * gl_PointCoord.x, (1.0 - vPointUv.y) + vPointUv.w * (1.0 - gl_PointCoord.y)));\n        // vec4 tColor = texture2D(map, vec2(vMapIndex / ulength + 1.0 / ulength * gl_PointCoord.x, 1.0 - gl_PointCoord.y));\n        gl_FragColor = mix(gl_FragColor, tColor, tColor.a);\n    }\n    #endif\n    \n    gl_FragColor.a *= opacity;\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n\n    #include <mvt_selective_fragment> \n    #include <logdepthbuf_fragment> \n    #include <mvt_emissive_fragment>\n}"),
      (this.isIconPointMaterial = !0),
      (this.transparent = !0),
      Object.assign(this.uniforms, In.clone(qR)),
      U_(this),
      N_(this, ["size", "uShapeType", "opacity", "emissive", "isEmissive"]),
      B_(this, ["color"]),
      k_(this, [["offset", "uOffset"]]),
      O_(this, [
        ["vertexColors", "MVT_USE_VERTEX_COLOR"],
        ["vertexSizes", "MVT_USE_VERTEX_SIZE"],
        ["vertexIcons", "MVT_USE_VERTEX_ICON"],
        ["vertexOffsets", "MVT_USE_VERTEX_OFFSET"],
      ]),
      Object.defineProperties(this, {
        mapSrc: {
          get: function () {
            return this.uniforms.map.value;
          },
          set: function (e) {
            const t = this.mapSrc,
              i = this.userData[this.urlCacheKey],
              n = this;
            if (i !== e) {
              if ((t && t.dispose(), !e))
                return (
                  (this.uniforms.map.value = null),
                  (this.uniforms.useMap.value = !1),
                  void delete this.userData[this.urlCacheKey]
                );
              WR.load(e, function (t) {
                (t.wrapS = t.wrapT = T),
                  (n.uniforms.map.value = t),
                  (n.userData[n.urlCacheKey] = e),
                  (n.uniforms.useMap.value = !0),
                  (n.uniforms.useCanvasMap.value = !1);
              });
            }
          },
        },
        mapTexture: {
          get: function () {
            return this.uniforms.map.value;
          },
          set: function (e) {
            if (!e)
              return (
                (this.uniforms.map.value = null),
                void (this.uniforms.useCanvasMap.value = !1)
              );
            (e.wrapS = e.wrapT = T),
              (this.uniforms.map.value = e),
              (this.uniforms.useMap.value = !1),
              (this.uniforms.useCanvasMap.value = !0),
              delete this.userData[this.urlCacheKey];
          },
        },
      }),
      this.setValues(e);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(),
      super.dispose();
  }
}
const YR = (e, t, i, n, s, r = 1) => (
    (e.font = `${r}px Microsoft Yahei`),
    (e.textBaseline = "top"),
    e.measureText(i).width + t[1] + t[3] >= n || r + t[0] + t[2] >= s
      ? r - 1
      : YR(e, t, i, n, s, r + 1)
  ),
  KR = (e, t, i, n = {}) => {
    let s = !1;
    const r = vA(e);
    let { fillStyle: a, fontSize: o, gap: l, padding: h, dpr: c } = n;
    const u = r.w,
      d = r.h;
    (i.width === u && i.height === d) || (s = !0),
      (i.width = u || 1),
      (i.height = d || 1),
      t.save();
    for (let p = 0; p < e.length; p++) {
      const i = e[p],
        n = i.icon,
        s = i.text;
      t.drawImage(n, i.x + l[0] / 2, i.y + l[1] / 2, i.width, i.height),
        s &&
          ("auto" === o && (o = YR(t, h, s, i.width, i.height)),
          (t.font = `${o}px Microsoft Yahei`),
          (t.fillStyle = a),
          (t.textBaseline = "top"),
          t.fillText(s, i.x + l[0] / 2 + h[3], i.y + l[1] / 2 + h[0]));
    }
    return t.restore(), s;
  },
  ZR = (e, t) => {
    if ("object" == typeof e) t(e);
    else {
      let i = new Image();
      (i.crossOrigin = "anonymous"),
        (i.onload = function () {
          let e = i.width,
            n = i.height,
            s = document.createElement("canvas");
          (s.width = e),
            (s.height = n),
            s.getContext("2d").drawImage(i, 0, 0, e, n),
            t(s);
        }),
        (i.onerror = function () {
          let e = document.createElement("canvas");
          (e.width = 20), (e.height = 40);
          let i = e.getContext("2d");
          (i.fillStyle = "red"),
            i.beginPath(),
            i.lineTo(0, 0),
            i.lineTo(20, 0),
            i.lineTo(10, 40),
            i.closePath(),
            i.fill(),
            t(e);
        }),
        (i.src = e);
    }
  };
class JR extends Points {
  constructor(e) {
    super(e),
      publicField(this, "canvas"),
      publicField(this, "ctx"),
      publicField(this, "oldMapTextureRes"),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "iconUrlHash", new Map()),
      publicField(this, "boxHash", new Map()),
      publicField(this, "gap", [0, 0]),
      publicField(this, "color"),
      publicField(this, "vertexColors"),
      publicField(this, "size"),
      publicField(this, "vertexSizes"),
      publicField(this, "mapSrc"),
      publicField(this, "vertexIcons"),
      publicField(this, "opacity"),
      publicField(this, "getTextureAndHash", async (e, t, i, n, s) => {
        const r = this.ctx,
          a = this.iconUrlHash;
        if (!s && this.oldMapTextureRes) return this.oldMapTextureRes;
        if (!e[0] || !e[0][t]) return { texture: this.texture, iconUrlHash: a };
        let o = 0;
        for (let h = 0; h < e.length; h++) {
          const i = e[h][t];
          void 0 === a.get(i) && (a.set(i, o), o++);
        }
        let l = Array.from(a.entries()).map(
          ([e, t]) =>
            new Promise((t, i) => {
              ZR(e, (i) => {
                a.set(e, i), t(e);
              });
            })
        );
        return await Promise.all(l).then((e) => {
          if (!this.canvas) return this.oldMapTextureRes;
          for (let [t, i] of a) {
            const e = t,
              i = a.get(e);
            if ("string" == typeof i) continue;
            const n = this.boxes.findIndex((e) => e.key === t);
            if (n > 0) {
              const e = this.boxes.splice(n, 1);
              this.boxes.unshift(e[0]);
              continue;
            }
            const s = i.width,
              r = i.height,
              o = s + this.gap[0],
              l = r + this.gap[1];
            this.boxes.unshift({
              w: o,
              h: l,
              width: s,
              height: r,
              key: t,
              icon: i,
            }),
              this.boxes.length > this.boxSize &&
                this.boxes.splice(this.boxSize);
          }
          for (let t = 0; t < this.boxes.length; t++) {
            const e = this.boxes[t];
            this.boxHash.set(e.key, e);
          }
          return (
            KR(this.boxes, r, this.canvas, {
              fillStyle: this._fillStyle,
              fontSize: this.parameters.fontSize,
              gap: this.gap,
              padding: this.padding,
              dpr: this.engine.rendering.pixelRatio,
            }),
            this.texture.dispose(),
            (this.texture = new CanvasTexture(this.canvas)),
            (this.oldMapTextureRes = { texture: this.texture, iconUrlHash: a }),
            { texture: this.texture, iconUrlHash: a }
          );
        });
      }),
      (this.parameters = e),
      (this.canvas = document.createElement("canvas")),
      (this.ctx = this.canvas.getContext("2d")),
      (this.texture = new CanvasTexture(this.canvas)),
      this.defineMaterialProxyProperties([
        "color",
        "size",
        "offset",
        "uShapeType",
        "opacity",
        "vertexColors",
        "vertexSizes",
        "vertexOffsets",
        "vertexIcons",
        "mapSrc",
        "mapTexture",
      ]),
      (this.boxes = []),
      (this.boxSize = e.boxSize || 100);
  }
  initObject() {
    (this.geometry = new jR(this.parameters)),
      (this.material = new IconPointMaterial(this.parameters)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  collisionTest(e) {
    let t = 0;
    return (
      (t = this.parameters.vertexSizes && e.size ? e.size : this.size),
      { width: t, height: t }
    );
  }
  async setData() {
    const e = this.dataSource.data,
      {
        vertexIcons: t,
        vertexColors: i,
        vertexSizes: n,
        vertexOffsets: s,
        inconPropName: r = "icon",
        size: a = 30,
      } = this.parameters;
    let o = [];
    o =
      this._enableCollision && this._collisionData
        ? this._collisionData
        : this.dataSource.userData;
    const l = [],
      h = [];
    let c = "",
      u = {};
    const d = [],
      p = [],
      f = [],
      m = [];
    if (t) {
      const e = await this.getTextureAndHash(o, r, a, !0);
      (c = e.texture),
        (u = e.iconUrlHash),
        (this.material.mapTexture = c),
        (this.material.uniforms.ulength.value = u.size);
    }
    for (let g = 0; g < o.length; g++) {
      const a = o[g].position,
        c = o[g].position,
        u = e.color ? o[g].color : this.parameters.color,
        _ = e.size ? o[g].size : this.parameters.size,
        v = e.offset ? o[g].offset : this.parameters.offset;
      if ((l.push(...a), h.push(c), t)) {
        const e = o[g][r],
          t = this.boxHash.get(e);
        if (!t) continue;
        const i = t.x / this.canvas.width,
          n = (t.x + t.w) / this.canvas.width,
          s = (t.y + t.h) / this.canvas.height,
          a = t.y / this.canvas.height;
        m.push(i, s, Math.abs(i - n), Math.abs(s - a));
      }
      if (i) {
        let e = colorToVec4(u);
        d.push(...e.toArray());
      }
      n && p.push(_), s && f.push(v);
    }
    this.geometry.setData({
      aPositions: l,
      aObjectIndices: h,
      aColors: d,
      aSizes: p,
      aOffsets: f,
      aPointUvs: m,
    }),
      this.geometry.computeBoundingSphere(),
      this.makeGeometryOffsetPosition(this.geometry, l),
      (this.needsUpdate = !1);
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
}
const $R = new yl(),
  eP = In.merge([
    Xn.fog,
    L_,
    F_,
    {
      emissive: { value: [0, 0, 0] },
      isEmissive: { value: !1 },
      width: { value: 12 },
      height: { value: 12 },
      offset: { value: [0, 0] },
      ulength: { value: 1 },
      useCanvasMap: { value: !1 },
      vertexIcons: { value: !1 },
      opacity: { value: 1 },
      map: { value: null },
      useMap: { value: !1 },
      uScale: { value: 1 },
      uFlat: { value: !1 },
      keepSize: { value: !0 },
      uColor: { value: [1, 1, 1, 1] },
      vertexColors: { value: !1 },
    },
  ]);
class tP extends CommonShaderMaterial {
  constructor(e) {
    super(),
      (this.type = "IconMaterial"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nattribute float pIndex;\nattribute float aMapIndex;\nattribute vec4 aColor;\n\nuniform float pixelRatio;\nuniform float width;\nuniform float height;\nuniform float uScale;\nuniform float ulength;\nuniform vec2 resolution;\nuniform vec2 offset;\nuniform bool uFlat;\nuniform bool keepSize;\nuniform vec4 uColor;\n\nvarying vec4 vColor;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n    #include <mvt_selective_vertex>\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #else\n        vColor = uColor;\n    #endif\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    pixelSize = pixelSize * 2.0;\n    if (uFlat) {\n        float hw = width * 0.5;\n        float hh = height * 0.5;\n        if (keepSize) {\n            hw *= pixelSize;\n            hh *= pixelSize;\n        }\n        if (pIndex == 1.0) {\n            hw = -hw;\n        } else if (pIndex == 2.0) {\n            \n        } else if (pIndex == 3.0) {\n            hh = -hh;\n        } else {\n            hw = -hw;\n            hh = -hh;\n        }\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);\n    }\n    else {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        float w = gl_Position.w;\n        gl_Position /= w;\n\n        float hw = width / resolution.x * uScale;\n        float hh = height / resolution.y * uScale;\n        vec2 o = offset;\n        if (!keepSize) {\n            hw /= pixelSize;\n            hh /= pixelSize;\n            o /= pixelSize;\n        }\n\n        gl_Position.x += o.x * 2. / resolution.x;\n        gl_Position.y -= o.y * 2. / resolution.y;\n\n        if (pIndex == 1.0) {\n            gl_Position.x -= hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 2.0) {\n            gl_Position.x += hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 3.0) {\n            gl_Position.x += hw;\n            gl_Position.y -= hh;\n        } else {\n            gl_Position.x -= hw;\n            gl_Position.y -= hh;\n        }\n\n        gl_Position *= w;\n    }\n\n    vUv = uv;\n\n    #include <logdepthbuf_vertex>\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform float opacity;\n\nuniform bool useMap;\nuniform bool useCanvasMap;\nuniform sampler2D map;\nuniform float width;\nuniform float height;\n\nvarying vec2 vUv;\nvarying vec4 vColor;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_emissive_pars_fragment>\n\nvoid main() {\n\n    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));\n    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);\n\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n    gl_FragColor.a *= opacity;\n\n    gl_FragColor *= vColor;\n\n    #include <mvt_selective_fragment> \n    #include <logdepthbuf_fragment> \n    #include <mvt_emissive_fragment>\n    #include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}"),
      (this.isIconMaterial = !0),
      (this.transparent = !0),
      Object.assign(this.uniforms, In.clone(eP)),
      z_(this),
      U_(this),
      N_(this, [
        "width",
        "height",
        "offset",
        "opacity",
        "emissive",
        "isEmissive",
      ]),
      k_(this, [
        ["scale", "uScale"],
        ["flat", "uFlat"],
      ]),
      k_(this, [["color", "uColor", colorToVec4]]),
      O_(this, [["vertexColors", "MVT_USE_VERTEX_COLOR"]]),
      Object.defineProperties(this, {
        mapSrc: {
          get: function () {
            return this.uniforms.map.value;
          },
          set: function (e) {
            const t = this.mapSrc,
              i = this.userData[this.urlCacheKey],
              n = this;
            if (i !== e) {
              if ((t && t.dispose(), !e))
                return (
                  (this.uniforms.map.value = null),
                  (this.uniforms.useMap.value = !1),
                  void delete this.userData[this.urlCacheKey]
                );
              $R.load(e, function (t) {
                (t.wrapS = t.wrapT = T),
                  (t.colorSpace = me),
                  (n.uniforms.map.value = t),
                  (n.userData[n.urlCacheKey] = e),
                  (n.uniforms.useMap.value = !0),
                  (n.uniforms.useCanvasMap.value = !1);
              });
            }
          },
        },
        mapTexture: {
          get: function () {
            return this.uniforms.map.value;
          },
          set: function (e) {
            if (!e)
              return (
                (this.uniforms.map.value = null),
                void (this.uniforms.useCanvasMap.value = !1)
              );
            (e.wrapS = e.wrapT = T),
              (e.colorSpace = me),
              (this.uniforms.map.value = e),
              (this.uniforms.useMap.value = !1),
              (this.uniforms.useCanvasMap.value = !0),
              delete this.userData[this.urlCacheKey];
          },
        },
      }),
      this.setValues(e);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(),
      super.dispose();
  }
}
class iP extends rn {
  constructor(e) {
    super(e), (this.parameters = e);
  }
  setData(e) {
    const {
      aPositions: t,
      aObjectIndices: i,
      aUvs: n,
      aColors: s,
      pIndices: r,
      indices: a,
    } = e;
    this.setAttribute("position", new Ki(t, 3)),
      this.setAttribute("pIndex", new Ki(r, 1)),
      this.setAttribute("objectIndex", new Ki(i, 1)),
      this.setAttribute("uv", new Ki(n, 2)),
      this.parameters.vertexColors && this.setAttribute("aColor", new Ki(s, 4)),
      this.setIndex(a),
      (this.cachedObjectIndices = i);
  }
}
const nP = new Vector3(),
  sP = new Vector4(),
  rP = new Matrix4(),
  aP = new Vector3(),
  oP = new Vector3();
class lP extends Mesh {
  constructor(e) {
    super(e),
      publicField(this, "isEventEntitySupported", !0),
      publicField(this, "_padding"),
      publicField(this, "oldMapTextureRes", new Map()),
      publicField(this, "texture"),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "canvas"),
      publicField(this, "ctx"),
      publicField(this, "iconUrlHash", new Map()),
      publicField(this, "boxHash", new Map()),
      publicField(this, "gap", [2, 2]),
      publicField(this, "getTextureAndHash", async (e, t, i, n, s) => {
        const r = this.ctx,
          a = this.iconUrlHash;
        if (!s && this.oldMapTextureRes) return this.oldMapTextureRes;
        if (!e[0] || !e[0][t]) return { texture: this.texture, iconUrlHash: a };
        let o = a.size,
          l = a.size,
          h = new Map();
        for (let u = 0; u < e.length; u++) {
          const i = e[u][t];
          void 0 === a.get(i) && (a.set(i, o), h.set(i, o), o++);
        }
        if (l === a.size) return this.oldMapTextureRes;
        let c = Array.from(a.entries()).map(
          ([e, t]) =>
            new Promise((t, i) => {
              ZR(e, (i) => {
                a.set(e, i), t(e);
              });
            })
        );
        return await Promise.all(c).then((e) => {
          if (!this.canvas) return this.oldMapTextureRes;
          for (let [t, i] of a) {
            const e = t,
              i = a.get(e);
            if ("string" == typeof i) continue;
            const n = this.boxes.findIndex((e) => e.key === t);
            if (n > 0) {
              const e = this.boxes.splice(n, 1);
              this.boxes.unshift(e[0]);
              continue;
            }
            const s = i.width,
              r = i.height,
              o = s + this.gap[0],
              l = r + this.gap[1];
            this.boxes.unshift({
              w: o,
              h: l,
              width: s,
              height: r,
              key: t,
              icon: i,
            });
          }
          for (let t = 0; t < this.boxes.length; t++) {
            const e = this.boxes[t];
            this.boxHash.set(e.key, e);
          }
          return (
            KR(this.boxes, r, this.canvas, {
              fillStyle: this._fillStyle,
              fontSize: this.parameters.fontSize,
              gap: this.gap,
              padding: this.padding,
              dpr: this.engine.rendering.pixelRatio,
            })
              ? (this.texture.dispose(),
                (this.texture = new CanvasTexture(this.canvas)))
              : (this.texture.needsUpdate = !0),
            (this.oldMapTextureRes = { texture: this.texture, iconUrlHash: a }),
            { texture: this.texture, iconUrlHash: a }
          );
        });
      }),
      (this.parameters = e),
      (this._padding =
        void 0 !== this.parameters.padding ? this.parameters.padding : [2, 2]);
    const t = (this.canvas = document.createElement("canvas"));
    (t.width = t.height = 1),
      (this.ctx = t.getContext("2d")),
      (this.texture = new CanvasTexture(t)),
      this.defineMaterialProxyProperties([
        "width",
        "height",
        "offset",
        "map",
        "opacity",
        "flat",
        "keepSize",
        "color",
        "vertexColors",
      ]),
      (this.boxes = []),
      (this.boxSize = e.boxSize || 100);
  }
  initObject() {
    let { vertexIcons: e, ...t } = this.parameters;
    (this.geometry = new iP(this.parameters)),
      (this.material = new tP(t)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  getDefaultParams() {
    return { width: 12, height: 12 };
  }
  collisionTest(e) {
    return { width: this.width, height: this.height };
  }
  async setData() {
    const {
      vertexIcons: e,
      inconPropName: t = "icon",
      width: i,
      height: n,
    } = this.parameters;
    let s = [];
    s =
      this._enableCollision && this._collisionData
        ? this._collisionData
        : this.dataSource.userData;
    const r = [],
      a = [],
      o = [],
      l = [],
      h = [],
      c = [];
    let u = "",
      d = {};
    if (e) {
      const e = await this.getTextureAndHash(s, t, i, n, !0);
      (u = e.texture),
        (d = e.iconUrlHash || {}),
        (this.material.mapTexture = u),
        (this.material.uniforms.ulength.value = d.size);
      for (let i = 0; i < s.length; i++) {
        const e = s[i].position,
          n = s[i].index,
          u = s[i][t],
          d = this.boxHash.get(u);
        if (!d) continue;
        const p = s[i].color;
        let f;
        this.parameters.vertexColors && (f = p ? colorToVec4(p) : [1, 1, 1, 1]);
        for (let t = 0; t < 4; t++)
          r.push(...e), a.push(t), o.push(n), f && c.push(...f);
        const m = d.x / this.canvas.width,
          g = (d.x + d.w) / this.canvas.width,
          _ = (d.y + d.h) / this.canvas.height,
          v = d.y / this.canvas.height;
        l.push(m, _, m, v, g, v, g, _);
        const A = 4 * i;
        h.push(A, A + 2, A + 1, A, A + 3, A + 2);
      }
    } else
      for (let f = 0; f < s.length; f++) {
        const e = s[f].position,
          t = s[f].index,
          i = s[f].color;
        let n;
        this.parameters.vertexColors && (n = i ? colorToVec4(i) : [1, 1, 1, 1]);
        for (let s = 0; s < 4; s++)
          r.push(...e), a.push(s), o.push(t), n && c.push(...n);
        l.push(0, 1, 0, 0, 1, 0, 1, 1);
        const u = 4 * f;
        h.push(u, u + 2, u + 1, u, u + 3, u + 2);
      }
    this.geometry.setData({
      aColors: c,
      aPositions: r,
      pIndices: a,
      aObjectIndices: o,
      aUvs: l,
      indices: h,
    }),
      this.geometry.computeBoundingSphere();
    const p = this.geometry.boundingSphere.center;
    (this.originCenter = new Vector3().copy(p)),
      this.makeGeometryOffsetPosition(this.geometry, r),
      (this.needsUpdate = !1);
  }
  getEntityByIndex(e) {
    const t = this.dataSource;
    this._enableCollision &&
      this._collisionData &&
      (e = this._collisionData[e].index);
    const i = {
        index: e,
        value: t.getOriginData(e),
        itemIndex: t.getOriginDataIndex(e),
        pairs: {},
      },
      n = t.data;
    for (const s of Object.keys(n)) i.pairs[s] = n[s][e];
    return i;
  }
  raycast(e, t) {
    const i = this.flat;
    if (!this.receiveRaycast || !this.visible) return;
    if (i) {
      null === this.geometry.boundingSphere &&
        this.geometry.computeBoundingSphere();
      const { width: i, height: n } = this.parameters;
      let s = Math.max(i, n) / 2;
      return (
        this.keepSize && (s *= this.material.uniforms.zoomUnits.value),
        (this.geometry.boundingSphere.radius += s),
        En.prototype.raycast.call(this, e, t),
        void (this.geometry.boundingSphere.radius -= s)
      );
    }
    const n = this.geometry,
      s = n.getAttribute("position");
    if (!s || !s.array || 0 === !s.array.length) return;
    const r = n.getAttribute("offset");
    let a = [];
    r && (a = r.array);
    const o = e.camera,
      l = e.mouse,
      h = this.material.uniforms.resolution.value,
      c = l.x,
      u = l.y;
    let d = this.width / 2 / h[0],
      p = this.height / 2 / h[1];
    const f = d,
      m = p;
    let g = 0,
      _ = 0,
      v = 0,
      A = 0,
      y = 0,
      x = 0;
    rP.multiplyMatrices(o.projectionMatrix, o.matrixWorldInverse),
      rP.multiplyMatrices(rP, this.matrixWorld);
    const b = s.array;
    let E = 0;
    for (let S = 0, C = b.length - 11; S < C; S += 12) {
      if (
        (sP.set(b[S], b[S + 1], b[S + 2], 1),
        sP.applyMatrix4(rP),
        sP.divideScalar(sP.w),
        this.parameters.vertexOffsets
          ? ((E = (S / 12) * 8), (y = a[E] || 0), (x = a[E + 1] || 0))
          : ((y = (this.parameters.offset && this.parameters.offset[0]) || 0),
            (x = (this.parameters.offset && this.parameters.offset[1]) || 0)),
        (sP.x += (2 * y) / h[0]),
        (sP.y -= (2 * x) / h[1]),
        !this.keepSize)
      ) {
        const { x: e, y: t, z: i } = this.originCenter,
          n = this.getPixelSize(
            new Vector3(b[S] + e, b[S + 1] + t, b[S + 2] + i)
          );
        (d = f / n), (p = m / n), (y /= n), (x /= n);
      }
      if (
        ((g = sP.x - d),
        (v = sP.x + d),
        (_ = sP.y - p),
        (A = sP.y + p),
        g <= c && v >= c && _ <= u && A >= u)
      ) {
        nP.set(b[S], b[S + 1], b[S + 2]), nP.applyMatrix4(this.matrixWorld);
        const e = {
          instanceId: S / 12,
          object: this,
          distance: nP.distanceTo(o.position),
        };
        t.push(e);
      }
    }
  }
  onDispose() {
    this.texture && this.texture.dispose();
  }
  set padding(e) {
    this._padding = e;
  }
  get padding() {
    return this._padding;
  }
  getVertexPosition(e, t) {
    const i = this.geometry,
      n = i.attributes.position,
      s = i.morphAttributes.position,
      r = i.morphTargetsRelative;
    t.fromBufferAttribute(n, e);
    const a = e % 4;
    let o = this.parameters.width / 2,
      l = this.parameters.height / 2;
    if (this.keepSize) {
      const e = this.originCenter,
        i = this.getPixelSize(new Vector3().addVectors(e, t));
      (o *= i), (l *= i);
    }
    1 === a ? (o = -o) : 2 === a || (3 === a ? (l = -l) : ((l = -l), (o = -o))),
      (t.x += o),
      (t.y += l);
    const h = this.morphTargetInfluences;
    if (s && h) {
      oP.set(0, 0, 0);
      for (let i = 0, n = s.length; i < n; i++) {
        const n = h[i],
          a = s[i];
        0 !== n &&
          (aP.fromBufferAttribute(a, e),
          r ? oP.addScaledVector(aP, n) : oP.addScaledVector(aP.sub(t), n));
      }
      t.add(oP);
    }
    return t;
  }
  getPixelSize(e) {
    const { camera: t, rendering: i } = this.engine;
    return (
      ((0.1 * t.projectionMatrix.elements[5]) / i.resolution.y) *
      t.position.distanceTo(e)
    );
  }
  getEntityIndexByFace(e, t) {
    return this.geometry.cachedObjectIndices[t];
  }
}

lP.prototype._computeIntersections = En.prototype._computeIntersections;

const hP = new Vector4();
const cP = new Matrix4();
const uP = new Vector2();

class dP extends GeoObject {
  constructor(e) {
    super(e),
      publicField(this, "isDomPoints", !0),
      publicField(this, "frustumCulled", !1),
      publicField(this, "_visible", !0),
      publicField(this, "onBeforeScenePrepareRenderHook", (e, s, r) => {
        this.container = e.map.container;
        let a = e.renderer;
        const o = this.points,
          l = this.nodes;
        a.getSize(uP),
          cP.multiplyMatrices(r.matrixWorldInverse, this.matrixWorld),
          cP.multiplyMatrices(r.projectionMatrix, cP);
        for (let h = 0; h < o.length; h++) {
          hP.set(o[h][0], o[h][1], o[h][2], 1),
            hP.applyMatrix4(cP),
            hP.divideScalar(hP.w);
          const e = ((hP.x + 1) / 2) * uP.x,
            s = ((1 - hP.y) / 2) * uP.y;
          if (!l[h]) return;
          hP.z > 1 || hP.z < 0
            ? i(l[h], `${t}-hidden`)
            : n(l[h], `${t}-hidden`),
            (l[h].style.left = e + this.offset[0] + "px"),
            (l[h].style.top = s + this.offset[1] + "px");
        }
      }),
      (this.points = []),
      (this.nodes = []),
      (this.offset = [0, 0]),
      (this.parameters = e);
  }
  renderItem(e, t) {
    const i = document.createElement("div");
    return (
      (i.style.position = "absolute"),
      (i.style.width = "60px"),
      (i.style.height = "40px"),
      (i.style.background = "#FFFFFF"),
      i
    );
  }
  setData() {
    const e = this.engine,
      n = e.camera,
      s = e.renderer,
      { offset: r } = this.parameters;
    for (let t = 0; t < this.nodes.length; t++) this.nodes[t].remove();
    (this.nodes = []), (this.points = []);
    const a = this.dataSource;
    if (!a) return;
    a.needsUpdate && a.update(),
      s.getSize(uP),
      cP.multiplyMatrices(n.matrixWorldInverse, this.matrixWorld),
      cP.multiplyMatrices(n.projectionMatrix, cP);
    const o = (a.data && a.data.position) || [];
    for (let l = 0, h = a.size; l < h; l++) {
      const e = o[l];
      this.points.push(e);
      const n = this.renderItem(a.getOriginData(l));
      hP.set(e[0], e[1], e[2], 1), hP.applyMatrix4(cP), hP.divideScalar(hP.w);
      const s = ((hP.x + 1) / 2) * uP.x,
        h = ((1 - hP.y) / 2) * uP.y;
      i(n, `${t}-dom-points`),
        (n.style.left = s + r[0] + "px"),
        (n.style.top = h + r[1] + "px"),
        (n.style.visibility = !0 === this.visible ? "" : "hidden"),
        this.nodes.push(n),
        this.container.appendChild(n);
    }
    (this.offset = r),
      (this.needsUpdate = !1),
      this.engine && this.engine.requestRender();
  }
  onDispose() {
    this.nodes &&
      this.nodes.length &&
      this.nodes.forEach((e) => {
        e.remove();
      }),
      (this.points = []),
      (this.nodes = []);
  }
  set visible(e) {
    if (this._visible === e) return;
    this._visible = e;
    let t = !0 == !!e ? "" : "hidden";
    this.nodes &&
      this.nodes.length &&
      this.nodes.forEach((e) => {
        e.style.visibility = t;
      });
  }
  get visible() {
    return this._visible;
  }
}
const pP = new yl(),
  fP = In.merge([
    Xn.fog,
    L_,
    F_,
    {
      emissive: { value: [0, 0, 0] },
      isEmissive: { value: !1 },
      width: { value: 12 },
      height: { value: 12 },
      offset: { value: [0, 0] },
      ulength: { value: 1 },
      useCanvasMap: { value: !1 },
      vertexIcons: { value: !1 },
      opacity: { value: 1 },
      map: { value: null },
      useMap: { value: !1 },
      uFlat: { value: !1 },
      keepSize: { value: !0 },
    },
  ]);
class mP extends CommonShaderMaterial {
  constructor(e) {
    super(),
      (this.type = "LabelMaterial"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nattribute float pIndex;\nattribute float aMapIndex;\n\nuniform float pixelRatio;\nuniform float width;\nuniform float height;\nuniform float ulength;\nuniform vec2 resolution;\nuniform vec2 offset;\nuniform bool uFlat;\nuniform bool keepSize;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n    #include <mvt_selective_vertex>\n\n    vec4 worldPosition = modelMatrix * vec4(position, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    if (uFlat) {\n        float hw = width * 0.5;\n        float hh = height * 0.5;\n        vec2 o = offset;\n        if (keepSize) {\n            hw *= pixelSize;\n            hh *= pixelSize;\n            o *= pixelSize;\n        }\n        if (pIndex == 1.0) {\n            hw = -hw;\n        } else if (pIndex == 2.0) {\n            \n        } else if (pIndex == 3.0) {\n            hh = -hh;\n        } else {\n            hw = -hw;\n            hh = -hh;\n        }\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + hw, position.y + hh, position.z, 1.0);\n    }\n    else {\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        float w = gl_Position.w;\n        gl_Position /= w;\n\n        float hw = width / resolution.x;\n        float hh = height / resolution.y;\n        vec2 o = offset;\n        if (!keepSize) {\n            hw /= pixelSize;\n            hh /= pixelSize;\n            o /= pixelSize;\n        }\n\n        gl_Position.x += o.x * 2. / resolution.x;\n        gl_Position.y -= o.y * 2. / resolution.y;\n\n        if (pIndex == 1.0) {\n            gl_Position.x -= hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 2.0) {\n            gl_Position.x += hw;\n            gl_Position.y += hh;\n        } else if (pIndex == 3.0) {\n            gl_Position.x += hw;\n            gl_Position.y -= hh;\n        } else {\n            gl_Position.x -= hw;\n            gl_Position.y -= hh;\n        }\n\n        gl_Position *= w;\n    }\n\n    vUv = uv;\n\n    #include <logdepthbuf_vertex>\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform float opacity;\n\nuniform bool useMap;\nuniform bool useCanvasMap;\nuniform sampler2D map;\nuniform float width;\nuniform float height;\n\nvarying vec2 vUv;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_emissive_pars_fragment>\n\nvoid main() {\n\n    gl_FragColor = texture2D(map, vec2(vUv.x, 1. - vUv.y));\n    // gl_FragColor = mix(gl_FragColor, vec4(1., 0., 0., 1.), 0.5);\n\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n    gl_FragColor.a *= opacity;\n\n    #include <mvt_selective_fragment> \n    #include <logdepthbuf_fragment> \n    #include <mvt_emissive_fragment>\n}"),
      (this.isLabelMaterial = !0),
      (this.transparent = !0),
      Object.assign(this.uniforms, In.clone(fP)),
      z_(this),
      U_(this),
      k_(this, [["flat", "uFlat"]]),
      N_(this, [
        "width",
        "height",
        "offset",
        "opacity",
        "emissive",
        "isEmissive",
      ]),
      Object.defineProperties(this, {
        mapSrc: {
          get: function () {
            return this.uniforms.map.value;
          },
          set: function (e) {
            const t = this.mapSrc,
              i = this.userData[this.urlCacheKey],
              n = this;
            if (i !== e) {
              if ((t && t.dispose(), !e))
                return (
                  (this.uniforms.map.value = null),
                  (this.uniforms.useMap.value = !1),
                  void delete this.userData[this.urlCacheKey]
                );
              pP.load(e, function (t) {
                (t.wrapS = t.wrapT = T),
                  (t.colorSpace = me),
                  (n.uniforms.map.value = t),
                  (n.userData[n.urlCacheKey] = e),
                  (n.uniforms.useMap.value = !0),
                  (n.uniforms.useCanvasMap.value = !1);
              });
            }
          },
        },
        mapTexture: {
          get: function () {
            return this.uniforms.map.value;
          },
          set: function (e) {
            if (!e)
              return (
                (this.uniforms.map.value = null),
                void (this.uniforms.useCanvasMap.value = !1)
              );
            (e.wrapS = e.wrapT = T),
              (e.colorSpace = me),
              (this.uniforms.map.value = e),
              (this.uniforms.useMap.value = !1),
              (this.uniforms.useCanvasMap.value = !0),
              delete this.userData[this.urlCacheKey];
          },
        },
      }),
      this.setValues(e);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(),
      super.dispose();
  }
}
class gP extends rn {
  constructor(e) {
    super(e), (this.parameters = e);
  }
  setData(e) {
    const {
      aPositions: t,
      aObjectIndices: i,
      aUvs: n,
      pIndices: s,
      indices: r,
    } = e;
    this.setAttribute("position", new Ki(t, 3)),
      this.setAttribute("pIndex", new Ki(s, 1)),
      this.setAttribute("objectIndex", new Ki(i, 1)),
      this.setAttribute("uv", new Ki(n, 2)),
      this.setIndex(r);
  }
}
const _P = new Vector3();
const vP = new Vector4();
const AP = new Matrix4();

class yP extends Mesh {
  constructor(e) {
    super(e),
      publicField(this, "isEventEntitySupported", !0),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "canvas"),
      publicField(this, "ctx"),
      publicField(this, "texture"),
      publicField(this, "iconUrlHash", new Map()),
      publicField(this, "labelHash", new Map()),
      publicField(this, "boxHash", new Map()),
      publicField(this, "gap", [2, 2]),
      publicField(this, "_padding"),
      publicField(this, "_fillStyle"),
      publicField(this, "oldMapTextureRes", {}),
      publicField(this, "getTextureAndHash", async (e, t, i, n, s) => {
        const r = this.ctx,
          a = this.labelHash,
          o = this.iconUrlHash;
        if (!s && this.oldMapTextureRes) return this.oldMapTextureRes;
        if (!e[0] || !e[0][n]) return { texture: this.texture, labelHash: a };
        let l = a.size,
          h = a.size,
          c = new Map();
        for (let d = 0; d < e.length; d++) {
          const s = this.parameters.vertexBackgrounds ? e[d][i] : t,
            r = e[d][n],
            h = JSON.stringify({ icon: s, text: r });
          void 0 === o.get(s) && (o.set(s, s), c.set(s, s)),
            void 0 === a.get(h) && (a.set(h, l), l++);
        }
        if (h === a.size) return this.oldMapTextureRes;
        let u = Array.from(o.entries())
          .filter((e) => "string" == typeof e[1])
          .map(
            ([e, t]) =>
              new Promise((t, i) => {
                this.url2canvas(e, (i) => {
                  o.set(e, i), t(e);
                });
              })
          );
        return await Promise.all(u).then((e) => {
          if (!this.canvas) return this.oldMapTextureRes;
          for (let [t, i] of a) {
            const e = JSON.parse(t).icon,
              i = JSON.parse(t).text,
              n = o.get(e);
            if ("string" == typeof n) continue;
            const s = this.boxes.findIndex((e) => e.key === t);
            if (s > 0) {
              const e = this.boxes.splice(s, 1);
              this.boxes.unshift(e[0]);
              continue;
            }
            const r = n.width,
              a = n.height,
              l = r + this.gap[0],
              h = a + this.gap[1];
            this.boxes.unshift({
              w: l,
              h: h,
              width: r,
              height: a,
              key: t,
              icon: n,
              text: i,
            });
          }
          for (let t = 0; t < this.boxes.length; t++) {
            const e = this.boxes[t];
            this.boxHash.set(e.key, e);
          }
          return (
            KR(this.boxes, r, this.canvas, {
              fillStyle: this._fillStyle,
              fontSize: this.parameters.fontSize,
              gap: this.gap,
              padding: this.padding,
              dpr: this.engine.rendering.pixelRatio,
            })
              ? (this.texture.dispose(),
                (this.texture = new CanvasTexture(this.canvas)))
              : (this.texture.needsUpdate = !0),
            (this.oldMapTextureRes = { texture: this.texture, labelHash: a }),
            { texture: this.texture, labelHash: a }
          );
        });
      }),
      (this.parameters = e),
      (this._padding = [0, 0, 0, 0]),
      this.parameters.padding && (this.padding = this.parameters.padding),
      (this._fillStyle = this.parameters.fillStyle || "#fff");
    const t = (this.canvas = document.createElement("canvas"));
    t.width = t.height = 1;
    ((this.ctx = t.getContext("2d")).textAlign = "start"),
      (this.texture = new CanvasTexture(t)),
      this.defineMaterialProxyProperties([
        "width",
        "height",
        "offset",
        "opacity",
        "flat",
        "keepSize",
      ]),
      (this.boxes = []),
      (this.boxSize = e.boxSize || 100);
  }
  initObject() {
    const {
      background: e,
      vertexBackgrounds: t,
      fontSize: i,
      padding: n,
      fillStyle: s,
      ...r
    } = this.parameters;
    (this.geometry = new gP(this.parameters)),
      (this.material = new mP(r)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  getDefaultParams() {
    return { width: 12, height: 12, fontSize: 14 };
  }
  collisionTest(e) {
    return { width: this.width, height: this.height };
  }
  async setData() {
    const {
      vertexBackgrounds: e,
      vertexVisible: t = !1,
      background: i,
      bgPropName: n = "background",
      textPropName: s = "text",
      visiblePropName: r = "visible",
    } = this.parameters;
    let a = [];
    a =
      this._enableCollision && this._collisionData
        ? this._collisionData
        : this.dataSource.userData;
    const o = await this.getTextureAndHash(a, i, n, s, !0);
    if (!o || !o.texture || !o.labelHash) return;
    let l = o.texture,
      h = o.labelHash;
    (this.material.mapTexture = l),
      (this.material.uniforms.ulength.value = h.size);
    const c = [],
      u = [],
      d = [],
      p = [],
      f = [];
    for (let m = 0; m < a.length; m++) {
      const o = a[m].position,
        l = a[m].index,
        h = a[m][s],
        g = a[m][r];
      if (t && void 0 !== g && !g) continue;
      const _ = JSON.stringify({ icon: e ? a[m][n] : i, text: h }),
        v = this.boxHash.get(_);
      if (!v) continue;
      for (let e = 0; e < 4; e++) c.push(...o), u.push(e), d.push(l);
      const A = v.x / this.canvas.width,
        y = (v.x + v.w) / this.canvas.width,
        x = (v.y + v.h) / this.canvas.height,
        b = v.y / this.canvas.height;
      p.push(A, x, A, b, y, b, y, x);
      const E = 4 * m;
      f.push(E, E + 2, E + 1, E, E + 3, E + 2);
    }
    this.geometry.setData({
      aPositions: c,
      pIndices: u,
      aObjectIndices: d,
      aUvs: p,
      indices: f,
    }),
      this.geometry.computeBoundingSphere(),
      this.makeGeometryOffsetPosition(this.geometry, c),
      (this.needsUpdate = !1),
      this.engine.requestRender();
  }
  url2canvas(e, t) {
    if ("object" == typeof e) t(e);
    else {
      let i = new Image();
      (i.crossOrigin = "anonymous"),
        (i.onload = function () {
          let e = i.width,
            n = i.height,
            s = document.createElement("canvas");
          (s.width = e),
            (s.height = n),
            s.getContext("2d").drawImage(i, 0, 0, e, n),
            t(s);
        }),
        (i.onerror = function () {
          let e = document.createElement("canvas");
          (e.width = 20), (e.height = 40);
          let i = e.getContext("2d");
          (i.fillStyle = "red"),
            i.beginPath(),
            i.lineTo(0, 0),
            i.lineTo(20, 0),
            i.lineTo(10, 40),
            i.closePath(),
            i.fill(),
            t(e);
        }),
        (i.src = e);
    }
  }
  getEntityByIndex(e) {
    const t = this.dataSource;
    this._enableCollision &&
      this._collisionData &&
      (e = this._collisionData[e].index);
    const i = {
        index: e,
        value: t.getOriginData(e),
        itemIndex: t.getOriginDataIndex(e),
        pairs: {},
      },
      n = t.data;
    for (const s of Object.keys(n)) i.pairs[s] = n[s][e];
    return i;
  }
  raycast(e, t) {
    const i = this.flat;
    if (!this.receiveRaycast || !this.visible) return;
    if (i) return;
    const n = this.geometry,
      s = n.getAttribute("position");
    if (!s || !s.array || 0 === !s.array.length) return;
    const r = n.getAttribute("offset");
    let a = [];
    r && (a = r.array);
    const o = e.camera,
      l = e.mouse,
      h = this.material.uniforms.resolution.value,
      c = l.x,
      u = l.y,
      d = this.width / h[0],
      p = this.height / h[1];
    let f = 0,
      m = 0,
      g = 0,
      _ = 0,
      v = 0,
      A = 0;
    AP.multiplyMatrices(o.projectionMatrix, o.matrixWorldInverse),
      AP.multiplyMatrices(AP, this.matrixWorld);
    const y = s.array;
    let x = 0;
    for (let b = 0, E = y.length - 11; b < E; b += 12)
      if (
        (vP.set(y[b], y[b + 1], y[b + 2], 1),
        vP.applyMatrix4(AP),
        vP.divideScalar(vP.w),
        this.parameters.vertexOffsets
          ? ((x = (b / 12) * 8), (v = a[x] || 0), (A = a[x + 1] || 0))
          : ((v = (this.parameters.offset && this.parameters.offset[0]) || 0),
            (A = (this.parameters.offset && this.parameters.offset[1]) || 0)),
        (vP.x += (2 * v) / h[0]),
        (vP.y -= (2 * A) / h[1]),
        (f = vP.x - d),
        (g = vP.x + d),
        (m = vP.y - p),
        (_ = vP.y + p),
        f <= c && g >= c && m <= u && _ >= u)
      ) {
        _P.set(y[b], y[b + 1], y[b + 2]), _P.applyMatrix4(this.matrixWorld);
        const e = {
          instanceId: b / 12,
          object: this,
          distance: _P.distanceTo(o.position),
        };
        t.push(e);
      }
  }
  set padding(e) {
    2 === e.length
      ? (this._padding = [e[0], e[1], e[0], e[1]])
      : 3 === e.length
      ? (this._padding = [e[0], e[1], e[2], e[1]])
      : e.length >= 4 && (this._padding = [e[0], e[1], e[2], e[3]]);
  }
  get padding() {
    return this._padding;
  }
  onDispose() {
    this.texture && this.texture.dispose(),
      this.canvas && (this.canvas = null),
      this.iconUrlHash.clear(),
      this.labelHash.clear(),
      this.boxHash.clear();
  }
}
function xP(e, t, i, n, s, r) {
  if (s - n <= i) return;
  const a = (n + s) >> 1;
  bP(e, t, a, n, s, r % 2),
    xP(e, t, i, n, a - 1, r + 1),
    xP(e, t, i, a + 1, s, r + 1);
}
function bP(e, t, i, n, s, r) {
  for (; s > n; ) {
    if (s - n > 600) {
      const a = s - n + 1,
        o = i - n + 1,
        l = Math.log(a),
        h = 0.5 * Math.exp((2 * l) / 3),
        c = 0.5 * Math.sqrt((l * h * (a - h)) / a) * (o - a / 2 < 0 ? -1 : 1);
      bP(
        e,
        t,
        i,
        Math.max(n, Math.floor(i - (o * h) / a + c)),
        Math.min(s, Math.floor(i + ((a - o) * h) / a + c)),
        r
      );
    }
    const a = t[2 * i + r];
    let o = n,
      l = s;
    for (EP(e, t, n, i), t[2 * s + r] > a && EP(e, t, n, s); o < l; ) {
      for (EP(e, t, o, l), o++, l--; t[2 * o + r] < a; ) o++;
      for (; t[2 * l + r] > a; ) l--;
    }
    t[2 * n + r] === a ? EP(e, t, n, l) : (l++, EP(e, t, l, s)),
      l <= i && (n = l + 1),
      i <= l && (s = l - 1);
  }
}
function EP(e, t, i, n) {
  SP(e, i, n), SP(t, 2 * i, 2 * n), SP(t, 2 * i + 1, 2 * n + 1);
}
function SP(e, t, i) {
  const n = e[t];
  (e[t] = e[i]), (e[i] = n);
}
function CP(e, t, i, n) {
  const s = e - i,
    r = t - n;
  return s * s + r * r;
}
const MP = (e) => e[0],
  wP = (e) => e[1];
class TP {
  constructor(e, t = MP, i = wP, n = 64, s = Float64Array) {
    (this.nodeSize = n), (this.points = e);
    const r = e.length < 65536 ? Uint16Array : Uint32Array,
      a = (this.ids = new r(e.length)),
      o = (this.coords = new s(2 * e.length));
    for (let l = 0; l < e.length; l++)
      (a[l] = l), (o[2 * l] = t(e[l])), (o[2 * l + 1] = i(e[l]));
    xP(a, o, n, 0, a.length - 1, 0);
  }
  range(e, t, i, n) {
    return (function (e, t, i, n, s, r, a) {
      const o = [0, e.length - 1, 0],
        l = [];
      let h, c;
      for (; o.length; ) {
        const u = o.pop(),
          d = o.pop(),
          p = o.pop();
        if (d - p <= a) {
          for (let a = p; a <= d; a++)
            (h = t[2 * a]),
              (c = t[2 * a + 1]),
              h >= i && h <= s && c >= n && c <= r && l.push(e[a]);
          continue;
        }
        const f = Math.floor((p + d) / 2);
        (h = t[2 * f]),
          (c = t[2 * f + 1]),
          h >= i && h <= s && c >= n && c <= r && l.push(e[f]);
        const m = (u + 1) % 2;
        (0 === u ? i <= h : n <= c) && (o.push(p), o.push(f - 1), o.push(m)),
          (0 === u ? s >= h : r >= c) && (o.push(f + 1), o.push(d), o.push(m));
      }
      return l;
    })(this.ids, this.coords, e, t, i, n, this.nodeSize);
  }
  within(e, t, i) {
    return (function (e, t, i, n, s, r) {
      const a = [0, e.length - 1, 0],
        o = [],
        l = s * s;
      for (; a.length; ) {
        const h = a.pop(),
          c = a.pop(),
          u = a.pop();
        if (c - u <= r) {
          for (let s = u; s <= c; s++)
            CP(t[2 * s], t[2 * s + 1], i, n) <= l && o.push(e[s]);
          continue;
        }
        const d = Math.floor((u + c) / 2),
          p = t[2 * d],
          f = t[2 * d + 1];
        CP(p, f, i, n) <= l && o.push(e[d]);
        const m = (h + 1) % 2;
        (0 === h ? i - s <= p : n - s <= f) &&
          (a.push(u), a.push(d - 1), a.push(m)),
          (0 === h ? i + s >= p : n + s >= f) &&
            (a.push(d + 1), a.push(c), a.push(m));
      }
      return o;
    })(this.ids, this.coords, e, t, i, this.nodeSize);
  }
}
const IP = {
  minZoom: 0,
  maxZoom: 16,
  radius: 40,
  extent: 512,
  nodeSize: 64,
  log: !1,
  generateId: !1,
  reduce: null,
  map: (e) => e,
};
class RP {
  constructor(e) {
    (this.options = OP(Object.create(IP), e)),
      (this.trees = new Array(this.options.maxZoom + 1));
  }
  load(e) {
    const { log: t, minZoom: i, maxZoom: n, nodeSize: s } = this.options;
    t && console.time("total time");
    const r = `prepare ${e.length} points`;
    t && console.time(r), (this.points = e);
    let a = [];
    for (let o = 0; o < e.length; o++) {
      const t = e[o];
      (Array.isArray(t) || t.geometry) && a.push(DP(t, o));
    }
    (this.trees[n + 1] = new TP(a, UP, zP, s, Float32Array)),
      t && console.timeEnd(r);
    for (let o = n; o >= i; o--)
      (a = this._cluster(a, o)),
        (this.trees[o] = new TP(a, UP, zP, s, Float32Array));
    return t && console.timeEnd("total time"), this;
  }
  getClusters(e, t) {
    let i = ((((e[0] + 180) % 360) + 360) % 360) - 180;
    const n = Math.max(-90, Math.min(90, e[1]));
    let s = 180 === e[2] ? 180 : ((((e[2] + 180) % 360) + 360) % 360) - 180;
    const r = Math.max(-90, Math.min(90, e[3]));
    if (e[2] - e[0] >= 360) (i = -180), (s = 180);
    else if (i > s) {
      const e = this.getClusters([i, n, 180, r], t),
        a = this.getClusters([-180, n, s, r], t);
      return e.concat(a);
    }
    const a = this.trees[this._limitZoom(t)],
      o = a.range(NP(i), BP(r), NP(s), BP(n)),
      l = [];
    for (const h of o) {
      const e = a.points[h];
      l.push(e.numPoints ? LP(e) : this.points[e.index]);
    }
    return l;
  }
  getChildren(e) {
    const t = this._getOriginId(e),
      i = this._getOriginZoom(e),
      n = "No cluster with the specified id.",
      s = this.trees[i];
    if (!s) throw new Error(n);
    const r = s.points[t];
    if (!r) throw new Error(n);
    const a = this.options.radius / (this.options.extent * Math.pow(2, i - 1)),
      o = s.within(r.x, r.y, a),
      l = [];
    for (const h of o) {
      const t = s.points[h];
      t.parentId === e && l.push(t.numPoints ? LP(t) : this.points[t.index]);
    }
    if (0 === l.length) throw new Error(n);
    return l;
  }
  getLeaves(e, t, i) {
    (t = t || 10), (i = i || 0);
    const n = [];
    return this._appendLeaves(n, e, t, i, 0), n;
  }
  getTile(e, t, i) {
    const n = this.trees[this._limitZoom(e)],
      s = Math.pow(2, e),
      { extent: r, radius: a } = this.options,
      o = a / r,
      l = (i - o) / s,
      h = (i + 1 + o) / s,
      c = { features: [] };
    return (
      this._addTileFeatures(
        n.range((t - o) / s, l, (t + 1 + o) / s, h),
        n.points,
        t,
        i,
        s,
        c
      ),
      0 === t &&
        this._addTileFeatures(
          n.range(1 - o / s, l, 1, h),
          n.points,
          s,
          i,
          s,
          c
        ),
      t === s - 1 &&
        this._addTileFeatures(n.range(0, l, o / s, h), n.points, -1, i, s, c),
      c.features.length ? c : null
    );
  }
  getClusterExpansionZoom(e) {
    let t = this._getOriginZoom(e) - 1;
    for (; t <= this.options.maxZoom; ) {
      const i = this.getChildren(e);
      if ((t++, 1 !== i.length)) break;
      e = i[0].properties.cluster_id;
    }
    return t;
  }
  _appendLeaves(e, t, i, n, s) {
    const r = this.getChildren(t);
    for (const a of r) {
      const t = a.properties;
      if (
        (t && t.cluster
          ? s + t.point_count <= n
            ? (s += t.point_count)
            : (s = this._appendLeaves(e, t.cluster_id, i, n, s))
          : s < n
          ? s++
          : e.push(a),
        e.length === i)
      )
        break;
    }
    return s;
  }
  _addTileFeatures(e, t, i, n, s, r) {
    for (const a of e) {
      const e = t[a],
        o = e.numPoints,
        l = {
          type: 1,
          geometry: [
            [
              Math.round(this.options.extent * (e.x * s - i)),
              Math.round(this.options.extent * (e.y * s - n)),
            ],
          ],
          tags: o ? FP(e) : this.points[e.index].properties,
        };
      let h;
      o
        ? (h = e.id)
        : this.options.generateId
        ? (h = e.index)
        : this.points[e.index].id && (h = this.points[e.index].id),
        void 0 !== h && (l.id = h),
        r.features.push(l);
    }
  }
  _limitZoom(e) {
    return Math.max(
      this.options.minZoom,
      Math.min(e, this.options.maxZoom + 1)
    );
  }
  _cluster(e, t) {
    const i = [],
      { radius: n, extent: s, reduce: r } = this.options,
      a = n / (s * Math.pow(2, t));
    for (let o = 0; o < e.length; o++) {
      const n = e[o];
      if (n.zoom <= t) continue;
      n.zoom = t;
      const s = this.trees[t + 1],
        l = s.within(n.x, n.y, a);
      let h = n.numPoints || 1,
        c = n.x * h,
        u = n.y * h,
        d = r && h > 1 ? this._map(n, !0) : null;
      const p = (o << 5) + (t + 1) + this.points.length;
      for (const e of l) {
        const i = s.points[e];
        if (i.zoom <= t) continue;
        i.zoom = t;
        const a = i.numPoints || 1;
        (c += i.x * a),
          (u += i.y * a),
          (h += a),
          (i.parentId = p),
          r && (d || (d = this._map(n, !0)), r(d, this._map(i)));
      }
      1 === h
        ? i.push(n)
        : ((n.parentId = p), i.push(PP(c / h, u / h, p, h, d)));
    }
    return i;
  }
  _getOriginId(e) {
    return (e - this.points.length) >> 5;
  }
  _getOriginZoom(e) {
    return (e - this.points.length) % 32;
  }
  _map(e, t) {
    if (e.numPoints) return t ? OP({}, e.properties) : e.properties;
    const i = this.points[e.index].properties,
      n = this.options.map(i);
    return t && n === i ? OP({}, n) : n;
  }
}
function PP(e, t, i, n, s) {
  return {
    x: e,
    y: t,
    zoom: 1 / 0,
    id: i,
    parentId: -1,
    numPoints: n,
    properties: s,
  };
}
function DP(e, t) {
  const [i, n] = Array.isArray(e) ? e : e.geometry.coordinates;
  return { x: NP(i), y: BP(n), zoom: 1 / 0, index: t, parentId: -1 };
}
function LP(e) {
  return {
    type: "Feature",
    id: e.id,
    properties: FP(e),
    geometry: {
      type: "Point",
      coordinates: [((t = e.x), 360 * (t - 0.5)), kP(e.y)],
    },
  };
  var t;
}
function FP(e) {
  const t = e.numPoints,
    i =
      t >= 1e4
        ? `${Math.round(t / 1e3)}k`
        : t >= 1e3
        ? Math.round(t / 100) / 10 + "k"
        : t;
  return OP(OP({}, e.properties), {
    cluster: !0,
    cluster_id: e.id,
    point_count: t,
    point_count_abbreviated: i,
  });
}
function NP(e) {
  return e / 360 + 0.5;
}
function BP(e) {
  const t = Math.sin((e * Math.PI) / 180),
    i = 0.5 - (0.25 * Math.log((1 + t) / (1 - t))) / Math.PI;
  return i < 0 ? 0 : i > 1 ? 1 : i;
}
function kP(e) {
  const t = ((180 - 360 * e) * Math.PI) / 180;
  return (360 * Math.atan(Math.exp(t))) / Math.PI - 90;
}
function OP(e, t) {
  for (const i in t) e[i] = t[i];
  return e;
}
function UP(e) {
  return e.x;
}
function zP(e) {
  return e.y;
}
class GP extends GeoObject {
  constructor() {
    super(...arguments), publicField(this, "isEventEntitySupported", !0);
  }
  addComponent(e) {
    if (!e.isGeoObject) return void console.warn("Only GeoObject can be added");
    (e.__eventProxyByParent = !0), this.add(e), e.afterAddToEngine(this.engine);
    const t = this.getChildDataSource(e);
    return t && (e.dataSource = t), (this.needsUpdate = !0), e;
  }
  removeComponent(e) {
    this.remove(e),
      (e.__eventProxyByParent = !1),
      (e.dataSource = null),
      e.beforeRemoveFromEngine(this.engine),
      (this.needsUpdate = !0);
  }
  getChildDataSource(e) {
    return this.dataSource;
  }
  onBeforeScenePrepareRender(e, t, i, n) {
    super.onBeforeScenePrepareRender &&
      super.onBeforeScenePrepareRender(e, t, i, n);
    for (const s of this.children)
      s.onBeforeScenePrepareRender && s.onBeforeScenePrepareRender(e, t, i, n);
  }
  onBeforeSceneRender(e, t, i, n) {
    super.onBeforeSceneRender && super.onBeforeSceneRender(e, t, i, n);
    for (const s of this.children)
      s.onBeforeSceneRender && s.onBeforeSceneRender(e, t, i, n);
  }
  setDataSource(e) {
    super.setDataSource(e);
    for (const t of this.children) t.setDataSource(this.getChildDataSource(t));
  }
  setData() {
    for (const e of this.children) e.needsUpdate && e.setData();
    this.needsUpdate = !1;
  }
  dispose() {
    for (const e of this.children) e.dispose();
  }
}
const VP = {
  width: 30,
  height: 30,
  mapSrc:
    "https://bj.bcebos.com/v1/yanpan-screen-attachment/resources/image/yinlianPOC/djiudian.png",
};
const QP = { collides: !1, fillStyle: "#ccc", fontSize: 16, flat: !1 };
const HP = { maxZoom: 18, minZoom: 5, radius: 50 };

const jP = In.merge([
  {
    emissive: { value: [0, 0, 0] },
    isEmissive: { value: !1 },
    map: { value: null },
  },
]);
class WP extends PR {
  constructor(e) {
    super(),
      (this.type = "InstancedEffectModelMaterial"),
      (this.isInstancedEffectModelMaterial = !0),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform float height;\n#if defined(USE_SIZE3)\nuniform vec3 size3;\n#else\nuniform float size;\n#endif\n\nuniform float elapsedTime;\nattribute float instancedRandomFactor;\n\n#if defined(VERTEX_COLOR4)\n    attribute vec4 color;\n    varying vec4 vColor;\n#elif defined(VERTEX_COLOR3)\n    attribute vec3 color;\n    varying vec3 vColor;\n#endif\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n#endif\n\n#include <mvt_animation_pars_vertex>\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\n#define MVT_KEEP_PROJECTION_POSITION\n\n#include <logdepthbuf_pars_vertex>\nvec3 transformPosition(vec3 p) {\n    vec3 transformed = vec3(p);\n\n    #include <mvt_animation_vertex>\n\n    #if defined(USE_SIZE3)\n        transformed *= size3;\n    #else\n        transformed *= size;\n    #endif\n    transformed.z += height;\n\n    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\n    float pixelSize = getPixelSize(vec3(modelViewMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n\n    return transformed;\n}\nvoid main() {\n    #ifdef USE_MAP\n        vUv = uv;\n    #endif\n    \n    #if defined(VERTEX_COLOR4)\n        vColor = vec4(color);\n    #elif defined(VERTEX_COLOR3)\n        vColor = vec3(color);\n    #endif\n\n    #include <mvt_selective_vertex>\n    vec4 mvp_projectPosition;\n\n    vec3 transformed = transformPosition(position);\n    \n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);\n    \n    mvp_projectPosition = gl_Position;\n\n    #include <logdepthbuf_vertex>\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n#include <map_pars_fragment>\n\n#if defined(VERTEX_COLOR4)\n    varying vec4 vColor;\n#elif defined(VERTEX_COLOR3)\n    varying vec3 vColor;\n#else\n    uniform vec4 color;\n#endif\n\nuniform float opacity;\nuniform vec3 emissive;\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n#endif\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#define MVT_EMISSIVE_SHADER\nvoid main() {\n\n    #include <logdepthbuf_fragment> \n\n    #if defined(VERTEX_COLOR4)\n        gl_FragColor = vColor;\n    #elif defined(VERTEX_COLOR3)\n        gl_FragColor = vec4(vColor, 1.0);\n    #elif defined(USE_MAP)\n        gl_FragColor = texture2D( map, vUv );\n    #else\n        gl_FragColor = color;\n    #endif\n      \n    gl_FragColor.a *= opacity;\n    vec4 out_emissive = vec4(emissive, 1.0);\n    #include <mvt_selective_fragment>\n\n    #include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n}"),
      Object.assign(this.uniforms, In.clone(jP)),
      (this.defines = {}),
      N_(this, ["emissive", "isEmissive"]),
      Object.defineProperty(this, "map", {
        get: function () {
          return this.uniforms.map.value;
        },
        set: function (e) {
          this.uniforms.map.value = e;
        },
      }),
      this.setValues(e);
  }
  get vertexColors4() {
    return (this.defines.VERTEX_COLOR4 = !0);
  }
  set vertexColors4(e) {
    e !== this.defines.VERTEX_COLOR4 &&
      ((this.defines.VERTEX_COLOR4 = !!e), (this.needsUpdate = !0));
  }
  get vertexColors3() {
    return (this.defines.VERTEX_COLOR3 = !0);
  }
  set vertexColors3(e) {
    e !== this.defines.VERTEX_COLOR3 &&
      ((this.defines.VERTEX_COLOR3 = !!e), (this.needsUpdate = !0));
  }
}
const qP = { normalize: !0, rotateToZUp: !0, keepSize: !0 };
class XP extends GeoObject {
  constructor() {
    super(...arguments),
      publicField(this, "isLine", !0),
      publicField(this, "isLineSegments", !0);
  }
}
class YP extends rn {
  constructor(e) {
    super(e), (this.parameters = e);
  }
  setData(e) {
    const { vertexColors: t, vertexHeights: i } = this.parameters,
      { aPositions: n, indices: s, aColors: r, aHeights: a, aLengths: o } = e;
    this.setAttribute("position", new Ki(n, 3)),
      this.setAttribute("aLength", new Ki(o, 1)),
      t && this.setAttribute("aColor", new Ki(r, 4)),
      i && this.setAttribute("aHeight", new Ki(a, 1)),
      this.setIndex(s);
  }
}
const KP = In.merge([
  Xn.fog,
  L_,
  D_,
  {
    isEmissive: { value: !1 },
    color: { value: [1, 1, 0, 1] },
    height: { value: 100 },
    vertexColors: { value: !1 },
    vertexHeights: { value: !1 },
    tailLength: { value: 50 },
    speed: { value: 1 },
    idle: { value: 2e3 },
  },
]);
class ZP extends CommonShaderMaterial {
  constructor(e) {
    super(),
      (this.type = "SparkMaterial"),
      (this.isSparkMaterial = !0),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nattribute float aLength;\n\nuniform float elapsedTime;\nuniform float tailLength;\nuniform float speed;\nuniform float idle;\n\n#ifdef MVT_USE_VERTEX_COLOR\n    attribute vec4 aColor;\n#else\n    uniform vec4 color;\n#endif\n\n#ifdef MVT_USE_VERTEX_HEIGHT\n    attribute float aHeight;\n#else\n    uniform float height;\n#endif\n\nvarying float vOpacity;\nvarying vec4 vColor;\n\n#include <mvt_selective_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n\nvoid main() {\n    #include <mvt_selective_vertex>\n\n    #ifdef MVT_USE_VERTEX_COLOR\n        vColor = aColor;\n    #else\n        vColor = color;\n    #endif\n\n    #include <begin_vertex>\n    #include <project_vertex>\n\n    #ifdef MVT_USE_VERTEX_HEIGHT\n        float total = aHeight + tailLength;\n    #else\n        float total = height + tailLength;\n    #endif\n    float currentHeight = mod(elapsedTime * speed, total + idle * speed);\n    vOpacity = (aLength - (currentHeight - tailLength)) / tailLength;\n    // vOpacity = 1.;\n\n    #include <logdepthbuf_vertex>\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nvarying vec4 vColor;\nvarying float vOpacity;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n    if (vOpacity > 1.0 || vOpacity < 0.0) {\n        discard;\n    }\n    gl_FragColor = vec4(vColor.rgb, vColor.a * vOpacity);\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n}\n"),
      (this.transparent = !0),
      Object.assign(this.uniforms, In.clone(KP)),
      U_(this),
      N_(this, ["isEmissive", "height", "tailLength", "speed", "idle"]),
      B_(this, ["color"]),
      O_(this, [
        ["vertexColors", "MVT_USE_VERTEX_COLOR"],
        ["vertexHeights", "MVT_USE_VERTEX_HEIGHT"],
      ]),
      G_(this),
      (this.emissiveEnabled = !0),
      (this.emissive = [0, 0, 0]),
      this.setValues(e);
  }
}
let JP = In.merge([
  D_,
  {
    color: { value: [1, 0.5, 0, 1] },
    borderColor: { value: [0, 1, 0, 1] },
    opacity: { value: 1 },
    radius: { value: 0.5 },
    borderWidth: { value: 1 },
    isEmissive: { value: !1 },
  },
]);
class $P extends PR {
  constructor(e) {
    super(),
      publicField(this, "type", "CircleMaterial"),
      publicField(this, "isCircleMaterial", !0),
      (this.depthTest = !1),
      (this.depthWrite = !1),
      e.vertexSizes || (JP = In.merge([JP, { size: { value: 100 } }])),
      Object.assign(this.uniforms, In.clone(JP)),
      N_(this, ["borderWidth", "opacity", "isEmissive"]),
      B_(this, ["borderColor"]),
      O_(this, [
        ["vertexColors", "MVT_USE_VERTEX_COLOR"],
        ["vertexSizes", "MVT_USE_VERTEX_SIZE"],
      ]),
      G_(this),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#endif\n\n#ifndef MVT_USE_VERTEX_SIZE\n    uniform float size;\n#endif\n\nvarying vec2 vPosition;\nvarying float vScale;\n\n#include <mvt_selective_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() {\n\n    #include <mvt_selective_vertex>\n    vPosition = position.xy;\n\n    vec3 transformed = vec3(position);\n    #ifdef MVT_USE_VERTEX_SIZE\n        vScale = instanceMatrix[0][0];\n    #else\n        vScale = size;\n        transformed *= size;\n    #endif\n\n    // vec4 worldPosition = (modelMatrix * vec4(transformed, 1.0));\n    float pixelSize = getPixelSize(vec3(modelViewMatrix * instanceMatrix * vec4(0., 0., 0., 1.)));\n    if (keepSize) {\n        transformed *= pixelSize;\n    }\n\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(transformed, 1.0);\n    #include <logdepthbuf_vertex>\n\n    #if defined(MVT_USE_VERTEX_COLOR) && defined(USE_INSTANCING_COLOR)\n        vColor.xyz = instanceColor.xyz;\n        vColor.a = 1.0;\n    #endif\n}"),
      "Gradient" === e.type
        ? (this.fragmentShader =
            "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec4 color;\n#endif\nuniform float radius;\nuniform float opacity;\nvarying vec2 vPosition;\n\n#include <mvt_selective_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvoid main() {\n    float d = distance(vPosition, vec2(0, 0));\n    if (d > 0.5) {\n        discard;\n    }\n    #ifdef MVT_USE_VERTEX_COLOR\n        vec4 fillColor = vColor;\n    #else\n        vec4 fillColor = color;\n    #endif\n    \n    fillColor.a = smoothstep(0.0, 1.0, pow(d / radius, 2.0));\n    // 边缘抗锯齿\n    if(d >- 0.99 * radius) {\n        fillColor.a *= 1.0 - smoothstep(0.99, 1.0, d / radius); \n    }\n    fillColor.a *= opacity;\n    gl_FragColor = fillColor;\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment>   \n}")
        : (this.fragmentShader =
            "#define GLSLIFY 1\n#include <common>\n\n#ifdef MVT_USE_VERTEX_COLOR\n    varying vec4 vColor;\n#else\n    uniform vec4 color;\n#endif\nuniform vec4 borderColor;\nuniform float opacity;\nuniform float radius;\nuniform float borderWidth;\n\nvarying vec2 vPosition;\nvarying float vScale;\n\n#include <logdepthbuf_pars_fragment>\n#include <mvt_selective_pars_fragment>\n\nvoid main() {\n    float dis = distance(vPosition, vec2(0, 0));\n\n    // 用来保持边框的宽度不会随着缩放而变化\n    float radius2 = radius - (borderWidth / vScale) * radius;\n\n    // 用于抗锯齿\n    float blur = 0.001;\n    float pct = (1.0 - smoothstep(radius - blur, radius + blur, dis));\n    #ifdef MVT_USE_VERTEX_COLOR\n        vec4 currentColor = mix(vColor, borderColor, smoothstep( radius2 - blur,radius2 + blur, dis));\n    #else\n        vec4 currentColor = mix(color, borderColor, smoothstep( radius2 - blur,radius2 + blur, dis));\n    #endif\n    \n    // 设置的自身颜色的透明度优先级高于设置的opacity优先级\n    if(currentColor.a == 1.0) {\n        gl_FragColor = vec4(currentColor.rgb, pct * opacity);\n    } else {\n        gl_FragColor = vec4(currentColor.rgb, pct * currentColor.a);\n    }\n\n    #include <mvt_selective_fragment>\n    #include <logdepthbuf_fragment> \n}"),
      (this.emissiveEnabled = !0),
      (this.emissive = [0, 0, 0]),
      this.setValues(e);
  }
}
class eD extends InstancedMesh {
  constructor(e) {
    super(e),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "color"),
      publicField(this, "size"),
      publicField(this, "opacity"),
      publicField(this, "type"),
      publicField(this, "borderColor"),
      publicField(this, "borderWidth"),
      publicField(this, "getInstanceLocalMatrix", (e, t, i) => {
        const { vertexSizes: n } = this.parameters,
          { size: s } = this.dataSource.data;
        if (n && s) {
          const e = new Matrix4();
          return e.makeScale(s[i], s[i], s[i]), e;
        }
        return null;
      }),
      publicField(this, "addCustomAttributes", () => {
        const { vertexColors: e } = this.parameters,
          { color: t } = this.dataSource.data,
          i = [];
        e &&
          t &&
          t.forEach((e) => {
            const t = colorToVec3(e);
            i.push(...t.toArray());
          }),
          (this.instanceColor = new Wa(new Float32Array(i), 3));
      }),
      (this.parameters = e),
      this.defineMaterialProxyProperties([
        "color",
        "size",
        "size3",
        "opacity",
        "borderWidth",
        "borderColor",
        "radius",
        "keepSize",
      ]);
  }
  initObject() {
    (this.geometry = new wR()),
      (this.material = new $P(this.parameters)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  collisionTest(e) {
    let t = 0;
    return (
      this.material.keepSize &&
        (t = this.parameters.vertexSizes && e.size ? e.size : this.size),
      { width: t, height: t }
    );
  }
}
const tD = In.merge([
  Xn.fog,
  {
    heatmap: { value: null },
    heatmapDepth: { value: null },
    gradientMap: { value: null },
    opacity: { value: 1 },
    isEmissive: { value: !1 },
  },
]);
class iD extends CommonShaderMaterial {
  constructor(e) {
    super(e),
      (this.type = "HeatmapMaterial"),
      (this.isHeatmapMaterial = !0),
      (this.fog = !0),
      (this.lights = !1),
      (this.transparent = !0),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D heatmap;\nuniform sampler2D gradientMap;\nuniform sampler2D heatmapDepth;\nuniform float opacity;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\n\n#include <packing>\n\n#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n#endif\n\nvoid main() {\n    vec4 color = texture2D(heatmap, vUv);\n    \n    if (color.a <= 0.) {\n        discard;\n    }\n    gl_FragColor = texture2D(gradientMap, vec2(color.a, 0.5));\n    float addAlpha = 1.0;\n    if (color.a < 0.3) {\n        addAlpha = color.a * 3.3;\n    }\n    // if (color.a < 0.3) {\n    //     gl_FragColor.a = color.a * 3.3;\n    // } else {\n    //     gl_FragColor.a = 1.0;\n    // }\n    gl_FragColor.a *= color.a;\n    gl_FragColor.a *= opacity;\n\n    vec4 depthColor = texture2D(heatmapDepth, vUv);\n\n    #if defined( USE_LOGDEPTHBUF ) \n        gl_FragDepthEXT = unpackRGBAToDepth(depthColor);\n    #endif\n    // gl_FragColor = depthColor;\n    // #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n    //    int r = int(color.r * 255.0);\n    //    int g = int(color.g * 255.0);\n    //    int b = int(color.b * 255.0);\n    //    int d = r << 16 + g << 8 + b;\n    //    float z = float(d) / 16581375.0;\n    //    gl_FragDepthEXT = z;\n        //gl_FragDepthEXT = color.r;\n       // gl_FragColor = vec4(1.0, 0, 0, color.r);\n       // gl_FragDepthEXT = log2( color.r ) * logDepthBufFC * 0.5;\n       // gl_FragDepthEXT = 1.0;\n\n    //    float depth = dot( vec2(color.r, color.g), 1.0 / vec2(1.0, 256.0) );\n    //    gl_FragDepthEXT = depth * (256.0*256.0) / (256.0*256.0 - 1.0);\n// gl_FragColor = vec4(gl_FragDepthEXT, gl_FragDepthEXT, 0, 1.0);\n    // #endif\n    // gl_FragColor.a = color.a * 0.8;\n    // gl_FragColor = vec4(vUv, 0, 1.0);\n    // gl_FragColor = vec4(1.0, 0,0, 0.8);\n}"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\nuniform sampler2D gradientMap;\n\nvarying vec2 vUv;\n\nvoid main() { \n    \n    gl_Position = vec4(position, 1.0);\n    // vUv = position.xy;\n    vUv = vec2((position.x + 1.0) * 0.5, (position.y + 1.0) * 0.5);\n    // vec4 gray = texture2D(gradientMap, vUv);\n\n    // vec4 m0 = matrixWorldInverse * vec4(gl_Position.xy, 0.0, 1.0);\n    // vec4 m1 = matrixWorldInverse * vec4(gl_Position.xy, 1.0, 1.0);\n    // m0 /= m0.w;\n    // m1 /= m1.w;\n    // vec4 pixel = m0 + (-m0.z / (m1.z - m0.z)) * (m1 - m0);\n    // pixel.z = 100. * gray.a;\n\n    // gl_Position = projectionMatrix * pixelToViewMatrix * vec4(pixel.xyz, 1.0);\n}"),
      Object.assign(this.uniforms, In.clone(tD)),
      N_(this, ["opacity", "resolution", "isEmissive"]),
      k_(this, []),
      O_(this, []),
      (this._cachedGradient = null),
      Object.defineProperties(this, {
        gradient: {
          get: function () {
            return this._cachedGradient;
          },
          set: function (e) {
            (this._cachedGradient = e), this.updateGradientMap();
          },
        },
      }),
      this.createGradientMap(),
      (this.uniforms.gradientMap.value = this._cachedGradientMap),
      this.setValues(e);
  }
  createGradientMap() {
    let e = document.createElement("canvas");
    (e.width = 64), (e.height = 2);
    let t = e.getContext("2d"),
      i = t.createLinearGradient(0, 0, 64, 0);
    i.addColorStop(0, "rgba(0,0,255,1)"),
      i.addColorStop(0.3, "rgba(0,255,0,1)"),
      i.addColorStop(0.6, "rgba(255,255,0,1)"),
      i.addColorStop(1, "rgba(255,0,0,1)"),
      (t.fillStyle = i),
      t.fillRect(0, 0, 64, 2),
      (this._cachedGradientMap = new CanvasTexture(e));
  }
  updateGradientMap() {
    let e = this._cachedGradient;
    if ("[object Object]" !== Object.prototype.toString.call(e)) return;
    let t = this._cachedGradientMap.image.getContext("2d");
    t.clearRect(0, 0, 64, 2);
    let i = t.createLinearGradient(0, 0, 64, 0);
    for (const n in e)
      Object.hasOwnProperty.call(e, n) && i.addColorStop(n, e[n]);
    (t.fillStyle = i),
      t.fillRect(0, 0, 64, 2),
      (this._cachedGradientMap.needsUpdate = !0);
  }
  dispose() {
    this._cachedGradientMap && this._cachedGradientMap.dispose(),
      super.dispose();
  }
}
const nD = In.merge([
  Xn.fog,
  {
    radius: { value: 30 },
    circleMap: { value: null },
    minValue: { value: 0 },
    maxValue: { value: 100 },
    keepSize: { value: !1 },
    attenuateMValueFactor: { value: 0 },
  },
]);
class sD extends CommonShaderMaterial {
  constructor(e) {
    super(e),
      (this.type = "HeatmapTextureMaterial"),
      (this.isHeatmapTextureMaterial = !0),
      (this.fog = !0),
      (this.lights = !1),
      (this.transparent = !0),
      (this.depthTest = !1),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D circleMap;\n\nvarying vec2 vUv;\nvarying float vWeight;\nvarying float vZDepth;\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n    gl_FragColor.a = texture2D(circleMap, vUv).a * vWeight;\n    // gl_FragColor.a = 1.;\n    //#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n        // gl_FragColor = vec4(vec3(gl_FragDepthEXT), 1.0);\n        // int d = int(gl_FragDepthEXT * 16581375.0);\n        // gl_FragColor.r = float((d & 0xff0000) >> 16) / 255.0;\n        // gl_FragColor.g = float((d & 0x00ff00) >> 8) / 255.0;\n        // gl_FragColor.b = float(d & 0x0000ff) / 255.0;\n        // gl_FragColor.r = gl_FragDepthEXT; // a\n        // gl_FragColor.g = mod(gl_FragDepthEXT * 10.0, 1.0);\n        // gl_FragColor.b = mod(gl_FragDepthEXT * 1000.0, 1.0);\n        // int d = int(gl_FragDepthEXT * 10000000.0);\n        // gl_FragColor.r = (d & 0xff000 >> 16) / 255.0; \n        // gl_FragColor.g = (d & 0x00ff00 >> 8) / 255.0; \n        // gl_FragColor.b = (d & 0x0000ff ) / 255.0; \n        // gl_FragColor.r = gl_FragDepthEXT;\n        // gl_FragColor.r = gl_FragCoord.z;\n\n        // float depthVal = gl_FragCoord.z * (256.0*256.0 - 1.0) / (256.0*256.0);\n        // vec3 encode = fract( depthVal * vec3(1.0, 256.0, 256.0*256.0) );\n        // encode.xy = encode.xy - encode.yz / 256.0 + 1.0/512.0;\n        // gl_FragColor.rgb = encode;\n\n    // #else \n    //     gl_FragColor.r = gl_FragCoord.z;\n    // #endif\n    // gl_FragColor.r = 1.0;\n    // gl_FragColor.a = gl_FragCoord.z;\n}"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nattribute float instancedWeight;\n\nuniform float radius;\nuniform float maxValue;\nuniform float minValue;\nuniform bool keepSize;\nuniform float attenuateMValueFactor;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\nvarying vec2 vUv;\nvarying float vWeight;\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n\n    float range = (maxValue - minValue) * attenuateMValueFactor;\n\n    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));\n    float pixelSize = getPixelSize(worldPosition.xyz);\n\n    if (keepSize) {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize, 1.0);\n        range *= pixelSize;\n    } else {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius, 1.0);\n    }\n    \n    // gl_Position = vec4(position, 1.0);\n    // vZDepth = (gl_Position.z / gl_Position.w + 1.0) * 0.5;\n   \n    vUv = vec2(position.x + 0.5, position.y + 0.5);\n    \n    vWeight = (instancedWeight - minValue) / (maxValue + range - minValue);\n\n    #include <logdepthbuf_vertex>\n}"),
      Object.assign(this.uniforms, In.clone(nD)),
      N_(this, [
        "radius",
        "minValue",
        "maxValue",
        "keepSize",
        "attenuateMValueFactor",
      ]),
      k_(this, []),
      O_(this, []);
    const t = this.createCircleMap();
    (this.uniforms.circleMap.value = t),
      this.setValues(e),
      (this.blending = 5),
      (this.blendSrc = p),
      (this.blendDst = d),
      (this.blendSrcAlpha = p),
      (this.blendDstAlpha = p);
  }
  createCircleMap() {
    let e = document.createElement("canvas");
    (e.width = 64), (e.height = 64);
    let t = e.getContext("2d"),
      i = t.createRadialGradient(32, 32, 0, 32, 32, 32);
    return (
      i.addColorStop(0, "rgba(0,0,0,1)"),
      i.addColorStop(1, "rgba(0,0,0,0)"),
      (t.fillStyle = i),
      t.arc(32, 32, 32, 0, 2 * Math.PI, !1),
      t.fill(),
      new CanvasTexture(e)
    );
  }
  dispose() {
    this.uniforms.circleMap.value && this.uniforms.circleMap.value.dispose(),
      super.dispose();
  }
}
const rD = In.merge([
  Xn.fog,
  {
    radius: { value: 30 },
    circleMap: { value: null },
    minValue: { value: 0 },
    maxValue: { value: 100 },
    keepSize: { value: !1 },
    attenuateMValueFactor: { value: 0 },
  },
]);
class aD extends CommonShaderMaterial {
  constructor(e) {
    super(e),
      (this.type = "HeatmapDepthTextureMaterial"),
      (this.isHeatmapDepthTextureMaterial = !0),
      (this.fog = !0),
      (this.lights = !1),
      (this.transparent = !0),
      (this.depthTest = !1),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n#include <packing>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    #include <logdepthbuf_fragment>\n\n    #if defined( USE_LOGDEPTHBUF ) \n    \n        gl_FragColor = packDepthToRGBA(gl_FragDepthEXT);\n    #else\n        gl_FragColor = packDepthToRGBA(gl_FragCoord.z);\n    #endif\n    \n}"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\nattribute vec3 instancedPosition;\n\nuniform float radius;\nuniform bool keepSize;\nuniform float pixelRatio;\nuniform vec2 resolution;\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\nvoid main() { \n\n    vec4 worldPosition = (modelMatrix * vec4(position, 1.0));\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    if (keepSize) {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * pixelSize * 1.1, 1.0);\n    } else {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position * radius * 1.1, 1.0);\n    }\n    #include <logdepthbuf_vertex>\n}"),
      Object.assign(this.uniforms, In.clone(rD)),
      N_(this, [
        "radius",
        "minValue",
        "maxValue",
        "keepSize",
        "attenuateMValueFactor",
      ]),
      k_(this, []),
      O_(this, []),
      this.setValues(e);
  }
}
class oD extends kl {
  constructor() {
    super();
    const e = (this.geometry = new PlaneGeometry());
    this.setAttribute("position", e.attributes.position),
      this.setAttribute("uv", e.attributes.uv),
      this.setIndex(e.index);
  }
  dispose() {
    this.geometry.dispose();
  }
}

class pD extends rn {
  constructor() {
    super(...arguments),
      publicField(
        this,
        "_volumeSegmentLines",
        (e, t, i, n, s, r, a, o, l, h, c) => {
          let u = 0,
            d = new Vector2();
          const p = [a[0], a[1]];
          let f = Ev([r[0], r[1]], p);
          if (
            (c && ((d = Sv(f)), this._volumeExtrusions(e, t, n, i, r, d, l)), o)
          ) {
            let s = Ev(p, [o[0], o[1]]),
              r = new Vector2();
            r.addVectors(f, s), r.normalize();
            const h = Cv(f, s),
              c = Sv(f),
              d = Math.min(l, l / h.dot(c));
            this._volumeExtrusions(e, t, n, i, a, h, d), (u += 2);
          } else
            (d = Sv(f)), this._volumeExtrusions(e, t, n, i, a, d, l), (u += 2);
          return u;
        }
      ),
      publicField(this, "_volumeExtrusions", (e, t, i, n, s, r, a) => {
        i.push(r.x, r.y, 0, -r.x, -r.y, 0),
          e.push(s[0] + (r.x * a) / 2, s[1] + (r.y * a) / 2, s[2]),
          t.push(s[0] - (r.x * a) / 2, s[1] - (r.y * a) / 2, s[2]),
          n.push(a, a);
      });
  }
  createVolumeGeometry(e, t) {
    let i = this.parameters.lineWidth * t,
      n = [];
    for (let s = 0; s < e.length; s++) {
      const { vertices: t } = this.lineToShadowVolumeMesh(e[s], i);
      n.push([t]);
    }
    return n;
  }
  lineToShadowVolumeMesh(e, t) {
    let i = 0,
      n = null,
      s = null,
      r = null,
      a = null;
    const o = [],
      l = [],
      h = [],
      c = [],
      u = [],
      d = [];
    let p = !0;
    for (let g = 1, _ = e.length - 1; g <= _; g++) {
      if (((n = a || e[g - 1]), (s = e[g]), (r = e[g + 1]), r && Av(s, r))) {
        a = n;
        continue;
      }
      const o = this._volumeSegmentLines(u, d, c, l, h, n, s, r, t, i, p);
      -1 !== o && ((i += o), (a = null)), (p = !1);
    }
    const f = this.conversion(u, 3),
      m = this.conversion(d, 3);
    return (
      o.push(...f.concat(m.reverse())),
      o.push(o[0]),
      { vertices: o, indices: h, normals: l, widths: c }
    );
  }
  conversion(e, t) {
    let i = e.length,
      n = i % t == 0 ? i / t : Math.floor(i / t + 1),
      s = [];
    for (let r = 0; r < n; r++) {
      let i = e.slice(r * t, r * t + t);
      s.push(i);
    }
    return s;
  }
}
class fD extends pD {
  constructor(e) {
    super(),
      publicField(this, "isFatLineGeometry", !0),
      publicField(
        this,
        "_segmentLines",
        (e, t, i, n, s, r, aColor, index, point1, point2, c, u, color, p) => {
          let f = 0,
            m = new Vector2(),
            g = new Vector2(),
            _ = new Vector2();
          const isSquareCap = "square" === this.parameters.lineCap,
            isRoundCap = "round" === this.parameters.lineCap,
            isBevelJoin = "bevel" === this.parameters.lineJoin,
            isRoundJoin = "round" === this.parameters.lineJoin,
            pointB = [point2[0], point2[1]],
            pointa = [point1[0], point1[1]];
          let S = Ev(pointa, pointB),
            C = 0;
          if (
            (this._needsCounter &&
              ((C = yv(pointB, pointa)), (this._flags.totalDistance += C)),
            this._flags.normal ||
              ((this._flags.normal = new Vector2()),
              (this._flags.normal = Sv(S))),
            !this._flags.started)
          )
            if (((this._flags.started = !0), isSquareCap)) {
              const o = new Vector2(),
                h = new Vector2();
              o.addVectors(this._flags.normal, S),
                h.subVectors(this._flags.normal, S),
                r.push(h.x, h.y, 0, -o.x, -o.y, 0),
                e.push(
                  point1[0],
                  point1[1],
                  point1[2],
                  point1[0],
                  point1[1],
                  point1[2]
                ),
                t.push(
                  this._flags.totalDistance - C,
                  0,
                  this._flags.totalDistance - C,
                  1
                ),
                i.push(
                  this._flags.totalDistance - C,
                  this._flags.totalDistance - C
                ),
                s.push(u, u),
                n.push(0, 0),
                this.parameters.vertexColors &&
                  aColor.push(
                    color[0],
                    color[1],
                    color[2],
                    color[3],
                    color[0],
                    color[1],
                    color[2],
                    color[3]
                  );
            } else if (isRoundCap) {
              const h = S.clone();
              h.negate();
              const c = new Vector2();
              c.subVectors(this._flags.normal, S), c.normalize();
              const m = new Vector2();
              m.addVectors(this._flags.normal, S), m.normalize();
              const g = this._flags.normal.clone(),
                _ = this._flags.normal.clone();
              _.negate(),
                r.push(h.x, h.y, 0),
                r.push(c.x, c.y, 0),
                r.push(-m.x, -m.y, 0),
                r.push(g.x, g.y, 0),
                r.push(_.x, _.y, 0);
              for (let r = 0; r < 5; r++)
                e.push(point1[0], point1[1], point1[2]),
                  s.push(u),
                  t.push(this._flags.totalDistance - C, 0),
                  i.push(this._flags.totalDistance - C),
                  n.push(0),
                  this.parameters.vertexColors &&
                    aColor.push(color[0], color[1], color[2], color[3]);
              index.push(
                p + 0,
                p + 2,
                p + 1,
                p + 1,
                p + 2,
                p + 3,
                p + 3,
                p + 2,
                p + 4
              ),
                (f += 3),
                (p += 3);
            } else
              this._extrusions(
                e,
                r,
                t,
                i,
                n,
                s,
                aColor,
                point1,
                this._flags.normal,
                this._flags.totalDistance - C,
                u,
                color
              );
          if (
            (index.push(
              ...(-1 === this._flags.lastFlip
                ? [p + 0, p + 1, p + 2]
                : [p + 1, p + 0, p + 2])
            ),
            c)
          ) {
            (g = Ev(pointB, [c[0], c[1]])), _.addVectors(S, g), _.normalize();
            const l = Cv(S, g),
              v = Sv(S),
              A = u / l.dot(v);
            let E = _.dot(this._flags.normal) > 0 ? -1 : 1,
              C = isBevelJoin;
            if (!C && "miter" === this.parameters.lineJoin) {
              Math.abs(A) > (this.parameters.miterLimit || 2 * u) && (C = !0);
            }
            if (C) {
              const c = Math.min(2 * u, Math.abs(A));
              r.push(this._flags.normal.x * E, this._flags.normal.y * E, 0),
                r.push(-l.x * E, -l.y * E, 0),
                e.push(
                  point2[0],
                  point2[1],
                  point2[2],
                  point2[0],
                  point2[1],
                  point2[2]
                ),
                s.push(u, c),
                i.push(this._flags.totalDistance, this._flags.totalDistance),
                n.push(0, 0),
                index.push(
                  ...(this._flags.lastFlip === -E
                    ? -1 === this._flags.lastFlip
                      ? [p + 2, p + 1, p + 3]
                      : [p + 1, p + 2, p + 3]
                    : -1 === this._flags.lastFlip
                    ? [p + 0, p + 2, p + 3]
                    : [p + 2, p + 0, p + 3])
                ),
                (m = Sv(g)),
                this._flags.normal.copy(m),
                r.push(this._flags.normal.x * E, this._flags.normal.y * E, 0),
                e.push(point2[0], point2[1], point2[2]),
                s.push(u),
                i.push(this._flags.totalDistance),
                n.push(0),
                index.push(
                  ...(1 === E ? [p + 2, p + 3, p + 4] : [p + 3, p + 2, p + 4])
                ),
                this._flipedUV(t, this._flags.totalDistance, E, !0),
                this.parameters.vertexColors &&
                  aColor.push(
                    color[0],
                    color[1],
                    color[2],
                    color[3],
                    color[0],
                    color[1],
                    color[2],
                    color[3],
                    color[0],
                    color[1],
                    color[2],
                    color[3]
                  ),
                (f += 3);
            } else if (isRoundJoin) {
              const c = Math.min(2 * u, Math.abs(A));
              r.push(this._flags.normal.x * E, this._flags.normal.y * E, 0),
                e.push(point2[0], point2[1], point2[2]),
                s.push(u),
                i.push(this._flags.totalDistance),
                n.push(0),
                r.push(l.x * E, l.y * E, 0),
                e.push(point2[0], point2[1], point2[2]),
                s.push(u),
                i.push(this._flags.totalDistance),
                n.push(0),
                r.push(-l.x * E, -l.y * E, 0),
                e.push(point2[0], point2[1], point2[2]),
                s.push(c),
                i.push(this._flags.totalDistance),
                n.push(0),
                index.push(
                  ...(this._flags.lastFlip === -E
                    ? -1 === this._flags.lastFlip
                      ? [p + 2, p + 1, p + 4, p + 2, p + 4, p + 3]
                      : [p + 1, p + 2, p + 4, p + 4, p + 2, p + 3]
                    : -1 === this._flags.lastFlip
                    ? [p + 0, p + 2, p + 4, p + 2, p + 3, p + 4]
                    : [p + 2, p + 0, p + 4, p + 3, p + 2, p + 4])
                ),
                (m = Sv(g)),
                this._flags.normal.copy(m),
                r.push(this._flags.normal.x * E, this._flags.normal.y * E, 0),
                e.push(point2[0], point2[1], point2[2]),
                s.push(u),
                i.push(this._flags.totalDistance),
                n.push(0),
                index.push(
                  ...(-1 === E ? [p + 4, p + 3, p + 5] : [p + 3, p + 4, p + 5])
                ),
                this._flipedUV(t, this._flags.totalDistance, E, !1),
                this.parameters.vertexColors &&
                  aColor.push(
                    color[0],
                    color[1],
                    color[2],
                    color[3],
                    color[0],
                    color[1],
                    color[2],
                    color[3],
                    color[0],
                    color[1],
                    color[2],
                    color[3],
                    color[0],
                    color[1],
                    color[2],
                    color[3]
                  ),
                (f += 4);
            } else
              this._extrusions(
                e,
                r,
                t,
                i,
                n,
                s,
                aColor,
                point2,
                l,
                this._flags.totalDistance,
                A,
                color
              ),
                index.push(
                  ...(-1 === this._flags.lastFlip
                    ? [p + 2, p + 1, p + 3]
                    : [p + 2, p + 0, p + 3])
                ),
                (E = -1),
                this._flags.normal.copy(l),
                (f += 2);
            this._flags.lastFlip = E;
          } else {
            if (((this._flags.normal = Sv(S)), isSquareCap)) {
              const o = new Vector2(),
                l = new Vector2();
              o.addVectors(S, this._flags.normal),
                l.subVectors(S, this._flags.normal),
                r.push(o.x, o.y, 0, l.x, l.y, 0),
                e.push(
                  point2[0],
                  point2[1],
                  point2[2],
                  point2[0],
                  point2[1],
                  point2[2]
                ),
                s.push(u, u),
                t.push(
                  this._flags.totalDistance,
                  0,
                  this._flags.totalDistance,
                  1
                ),
                i.push(this._flags.totalDistance, this._flags.totalDistance),
                n.push(0, 0),
                this.parameters.vertexColors &&
                  aColor.push(
                    color[0],
                    color[1],
                    color[2],
                    color[3],
                    color[0],
                    color[1],
                    color[2],
                    color[3]
                  );
            } else
              this._extrusions(
                e,
                r,
                t,
                i,
                n,
                s,
                aColor,
                point2,
                this._flags.normal,
                this._flags.totalDistance,
                u,
                color
              );
            if (
              (index.push(
                ...(-1 === this._flags.lastFlip
                  ? [p + 2, p + 1, p + 3]
                  : [p + 2, p + 0, p + 3])
              ),
              (f += 2),
              isRoundCap)
            ) {
              const l = new Vector2();
              l.addVectors(S, this._flags.normal), l.normalize();
              const c = new Vector2();
              c.subVectors(S, this._flags.normal), c.normalize();
              const m = S.clone();
              r.push(l.x, l.y, 0), r.push(c.x, c.y, 0), r.push(m.x, m.y, 0);
              for (let r = 0; r < 3; r++)
                e.push(point2[0], point2[1], point2[2]),
                  s.push(u),
                  t.push(this._flags.totalDistance, 0),
                  i.push(this._flags.totalDistance),
                  n.push(0),
                  this.parameters.vertexColors &&
                    aColor.push(color[0], color[1], color[2], color[3]);
              index.push(
                p + 2,
                p + 3,
                p + 4,
                p + 4,
                p + 3,
                p + 5,
                p + 4,
                p + 5,
                p + 6
              ),
                (f += 3);
            }
          }
          return f;
        }
      ),
      publicField(this, "_extrusions", (e, t, i, n, s, r, a, o, l, h, c, u) => {
        t.push(l.x, l.y, 0, -l.x, -l.y, 0),
          e.push(o[0], o[1], o[2], o[0], o[1], o[2]),
          r.push(c, c),
          i.push(h, 0, h, 1),
          n.push(h, h),
          s.push(0, 0),
          this.parameters.vertexColors &&
            a.push(u[0], u[1], u[2], u[3], u[0], u[1], u[2], u[3]);
      }),
      (this.parameters = e),
      (this._needsUpdate = !1),
      (this._needsCounter = !1),
      (this._flags = {
        lastFlip: -1,
        started: !1,
        normal: null,
        totalDistance: 0,
      });
  }
  setData(e) {
    (this._needsUpdate = !0),
      (this.parameters.dashed ||
        this.parameters.enableAnimation ||
        this.parameters.mapSrc ||
        this.parameters.map) &&
        (this._needsCounter = !0),
      this.updateGeometry(e);
  }
  updateGeometry(e) {
    const t = [],
      i = [],
      n = [],
      index = [],
      r = [],
      a = [],
      aColor = [],
      l = [],
      h = [],
      c = [],
      u = [];
    let d = 0;
    for (let p = 0; p < e.position.length; p++) {
      const f = e.position[p];
      const m = e.index[p];
      const g = this.parameters.vertexWidths
        ? e.lineWidth[p]
        : this.parameters.lineWidth;
      const _c = this.parameters.vertexColors
        ? e.color[p]
        : colorToArr4(this.parameters.color);

      this._flags = {
        lastFlip: -1,
        started: !1,
        normal: null,
        totalDistance: 0,
      };
      const v = f.length;
      // pos 长度
      let A = t.length / 3,
        y = null,
        x = Math.random();
      c.push(x, x), n.push(0, 0), u.push(m, m);
      for (let e = 1; e < v; e++) {
        const point1 = y || f[e - 1],
          point2 = f[e],
          E = e < v - 1 ? f[e + 1] : null;
        if (E && Av(point2, E)) {
          y = point1;
          continue;
        }

        // 修复使用顶点颜色bug
        let curColor = [];

        if (this.parameters.vertexColors && _c[e]) {
          curColor = colorToArr4(_c[e]);
        } else {
          curColor = colorToArr4(this.parameters.color);
        }

        const S = this._segmentLines(
          t,
          i,
          a,
          h,
          r,
          l,
          aColor,
          index,
          point1,
          point2,
          E,
          g,
          curColor,
          A
        );
        -1 !== S && ((A += S), (y = null));
        for (let t = 0; t < S; t++)
          n.push(e / v),
            this._needsCounter &&
              this.parameters.enableAnimationChaos &&
              c.push(x),
            u.push(m);
        d = Math.max(this._flags.totalDistance, d);
      }
      if (this._needsCounter) for (let e = 0; e < h.length; e++) h[e] = d;
    }
    (this.cachedPositions = t),
      this.setAttribute("position", new Ki(t, 3)),
      this.setAttribute("uv", new Ki(i, 2)),
      this.setAttribute("normal", new Ki(l, 3)),
      this.setAttribute("aWidth", new Ki(r, 1)),
      this.setAttribute("counter", new Ki(n, 1)),
      this.setAttribute("objectIndex", new Ki(u, 1)),
      this._needsCounter &&
        (this.setAttribute("lengths", new Ki(a, 1)),
        this.setAttribute("totalLength", new Ki(h, 1)),
        this.setAttribute("randomFactor", new Ki(c, 1))),
      this.parameters.vertexColors &&
        this.setAttribute("aColor", new Ki(aColor, 4)),
      this.setIndex(index),
      this.computeBoundingSphere(),
      (this._needsUpdate = !1);
  }
  _flipedUV(e, t, i, n) {
    n
      ? -1 === i
        ? e.push(t, 1, t, 0, t, 1)
        : e.push(t, 0, t, 1, t, 0)
      : -1 === i
      ? e.push(t, 1, t, 1, t, 0, t, 1)
      : e.push(t, 0, t, 0, t, 1, t, 0);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
}
const mD = new yl(),
  gD = In.merge([
    Xn.fog,
    L_,
    D_,
    {
      lineWidth: { value: 100 },
      keepSize: { value: !1 },
      map: { value: null },
      useMap: { value: !1 },
      mapGap: { value: 50 },
      uColor: { value: [0, 1, 1, 1] },
      height: { value: 0 },
      opacity: { value: 1 },
      resolution: { value: new Vector2(1, 1) },
      sizeAttenuation: { value: 1 },
      dashArray: { value: 20 },
      dashOffset: { value: 0 },
      dashRatio: { value: 0.5 },
      alphaTest: { value: 0 },
      repeat: { value: new Vector2(1, 1) },
      vertexColors: { value: !1 },
      vertexZIndex: { value: !1 },
      maxLayerIndex: { value: 0 },
      elapsedTime: { value: 0 },
      enableAnimation: { value: !1 },
      enableAnimationChaos: { value: !1 },
      animationInterval: { value: 0 },
      animationSpeed: { value: 1 },
      animationTailType: { value: 1 },
      animationTailRatio: { value: 0.2 },
      animationTailLength: { value: 100 },
      animationIdle: { value: 1e3 },
      isEmissive: { value: !1 },
    },
  ]);
class _D extends CommonShaderMaterial {
  constructor(e) {
    super(),
      (this.type = "FatLineMaterial"),
      (this.isFatLineMaterial = !0),
      (this.fog = !0),
      (this.transparent = !0),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\nuniform sampler2D map;\nuniform bool useMap;\nuniform bool keepSize;\nuniform float lineWidth;\nuniform float mapGap;\nuniform float opacity;\nuniform float alphaTest;\nuniform float elapsedTime;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vLength;\nvarying float vTotalLength;\nvarying float vZoomUnits;\n\n#ifdef USE_ANIMATION\nuniform float animationInterval;\nvarying float vAnimationOpacity;\n#endif\n\n#ifdef USE_DASH\nuniform float dashArray;\nuniform float dashOffset;\nuniform float dashRatio;\nvarying float vDashOpacity;\n#endif\n\nvoid main() {\n\n   vec4 c = vColor;\n\n    if(useMap) {\n        // icon之间的间隔，经验值为间隔50倍宽度，比较稀疏且好看\n        float margin = lineWidth * mapGap;\n        float halfMargin = margin / 2.0;\n        float texWidth = lineWidth;\n        if (keepSize) {\n            margin *= vZoomUnits;\n            texWidth *= vZoomUnits;\n        }\n        float delta = mod(vUV.x, texWidth + margin);\n        if (delta >= halfMargin && delta <= halfMargin + texWidth) {\n            float uvx = (delta - halfMargin) / texWidth;\n            vec4 texture = texture2D(map, vec2(uvx, vUV.y));\n            c = texture.a >= 0.5 ? texture : c;\n        }\n    }\n\n    #ifdef USE_ANIMATION\n        float animationAlpha = vAnimationOpacity;\n        if (animationInterval > 0.0) {\n            animationAlpha = mod(vAnimationOpacity, animationInterval);\n        }\n        if (animationAlpha > 1.0 || animationAlpha < 0.0) {\n            discard;\n        }\n        c.a *= animationAlpha;\n    #endif\n\n    #ifdef USE_DASH\n        float darray = dashArray;\n        if (keepSize) {\n            darray *= vZoomUnits;\n        }\n        c.a *= step(mod(vLength + dashOffset, darray), (darray * dashRatio));\n    #endif\n\n    if (c.a < alphaTest) {\n        discard;\n    }\n\n    gl_FragColor = c;\n\n    gl_FragColor.a *= opacity;\n\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n\t#include <colorspace_fragment>\n    \n}"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\n#ifdef USE_A_COLOR\nattribute vec4 aColor;\n#endif\n\nattribute float totalLength;\nattribute float aWidth;\nattribute float lengths;\nattribute float randomFactor;\n\nuniform float elapsedTime;\nuniform bool vertexColors;\nuniform vec4 uColor;\nuniform float lineWidth;\nuniform float height;\nuniform float opacity;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vLength;\nvarying float vTotalLength;\nvarying float vZoomUnits;\n\n#ifdef USE_ANIMATION\nuniform float animationSpeed;\nuniform float animationTailType;\nuniform float animationTailRatio;\nuniform float animationTailLength;\nuniform float animationIdle;\nvarying float vAnimationOpacity;\n#endif\n\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <mvt_keepsize_pars_vertex>\n#include <mvt_extra_vertex_utils>\n\n#ifdef MVT_USE_VERTEX_ZINDEX\nattribute float layerIndex;\nuniform float maxLayerIndex;\n\n#define WORLD_DISTANCE_NEAR 100000.0\n#define WORLD_DISTANCE_MID 1500000.0\n#define WORLD_DISTANCE_FAR 6000000.0\n#define LAYER_INDEX (maxLayerIndex - layerIndex)\n// 在mid和far交接那块，因为线数据特别碎，导致layerIndex很多，地面会陷很深，还没找到比较好的函数来解决这个case\n\nfloat y1(float x) {\n    return pow(LAYER_INDEX * log2(x * 5.), 1.5);\n}\n\nfloat y2(float x) {\n    float xx = x - WORLD_DISTANCE_NEAR;\n    return LAYER_INDEX * log2(xx) + y1(WORLD_DISTANCE_NEAR);\n}\n\nfloat y3(float x) {\n    float xx = x - WORLD_DISTANCE_MID;\n    return log2(LAYER_INDEX * xx) + y2(WORLD_DISTANCE_MID);\n}\n\nfloat y4(float x) {\n    return 110. * LAYER_INDEX + y3(WORLD_DISTANCE_FAR);\n}\n\n/**\ny1 = pow(x, 2)                  x: (0, near]\ny2 = (x - near) + y1(near)      x: (near, mid]\ny3 = sqrt(x - mid) + y2(mid)    x: (mid, far]\ny4 = n + y3(far)                x: (far, +∞)\n*/\nfloat y(float x) {\n    if (x <= WORLD_DISTANCE_NEAR) {\n        return y1(x);\n    }\n    if (x > WORLD_DISTANCE_NEAR && x <= WORLD_DISTANCE_MID) {\n        return y2(x);\n    }\n    else if (x > WORLD_DISTANCE_MID && x <= WORLD_DISTANCE_FAR) {\n        return y3(x);\n    }\n    else if (x > WORLD_DISTANCE_FAR) {\n        return y4(x);\n    }\n}\n#endif\n\nvoid main() {\n\n    #ifdef USE_A_COLOR\n        vColor = aColor;\n    #else\n        vColor = uColor;\n    #endif\n\n    vUV = uv;\n    // vCounter = counter;\n    vLength = lengths;\n    vTotalLength = totalLength;\n\n    #include <begin_vertex>\n    vec4 worldPosition = modelMatrix * vec4(transformed, 1.0);\n    float pixelSize = getPixelSize(worldPosition.xyz);\n    vZoomUnits = pixelSize;\n\n    vec2 extrude = normal.xy * aWidth / 2.0;\n    if (keepSize) {\n        extrude *= pixelSize;\n    }\n    worldPosition.xy += extrude;\n    worldPosition.z += height;\n\n    #ifdef MVT_USE_VERTEX_ZINDEX\n        vec3 worldToEye = cameraPosition - worldPosition.xyz;\n        float dis = length(worldToEye);\n        float layerGap = maxLayerIndex - layerIndex;\n        // float zOffset = log2(layerGap * dis + 1.0);\n        // float zOffset = exp(layerGap * log2(dis * 10.0));\n        // float zOffset = pow(layerGap * log2(dis * 5.0), 1.5);\n        float zOffset = y(dis);\n        worldPosition.z -= zOffset;\n    #endif\n    \n    #ifdef USE_ANIMATION\n        float tailLength = animationTailType == 1.0 ? vTotalLength * animationTailRatio : animationTailLength;\n\n        #ifdef ANIMATION_CHAOS\n            float currentTime = elapsedTime + randomFactor * 1000.0 * 3600.;\n        #else\n            float currentTime = elapsedTime;\n        #endif\n        float currentLength = mod(currentTime * animationSpeed, vTotalLength + tailLength + animationIdle * animationSpeed);\n        vAnimationOpacity = (vLength - (currentLength - tailLength)) / tailLength;\n    #endif\n\n    vec4 mvPosition = viewMatrix * worldPosition;\n    gl_Position = projectionMatrix * mvPosition;\n\n    // #ifdef MVT_USE_VERTEX_ZINDEX\n    //     float depth = layerGap * 10.0;\n    //     gl_Position.z = gl_Position.z + depth;\n    // #endif\n\n    #include <beginnormal_vertex>\n    #include <fog_vertex>\n    #include <logdepthbuf_vertex>\n}"),
      Object.assign(this.uniforms, In.clone(gD)),
      N_(this, [
        "map",
        "mapGap",
        "lineWidth",
        "keepSize",
        "height",
        "opacity",
        "dashArray",
        "dashOffset",
        "dashRatio",
        "alphaTest",
        "maxLayerIndex",
        "animationInterval",
        "animationSpeed",
        "animationTailType",
        "animationTailRatio",
        "animationTailLength",
        "animationIdle",
        "isEmissive",
      ]),
      k_(this, [["color", "uColor", colorToVec4]]),
      O_(this, [
        ["vertexColors", "USE_A_COLOR"],
        ["vertexZIndex", "MVT_USE_VERTEX_ZINDEX"],
        ["enableAnimation", "USE_ANIMATION"],
        ["enableAnimationChaos", "ANIMATION_CHAOS"],
        ["dashed", "USE_DASH"],
      ]),
      G_(this),
      Object.defineProperties(this, {
        mapSrc: {
          get: function () {
            return this.uniforms.map.value;
          },
          set: function (e) {
            const t = this.mapSrc,
              i = "url_map";
            if (this.userData[i] === e) return;
            if ((t && t.dispose(), !e))
              return (
                (this.uniforms.map.value = null),
                (this.uniforms.useMap.value = !1),
                void delete this.userData[i]
              );
            const n = mD.load(e);
            (n.wrapS = n.wrapT = T),
              (this.uniforms.map.value = n),
              (this.userData[i] = e),
              (this.uniforms.useMap.value = !0);
          },
        },
      }),
      (this.emissiveEnabled = !0),
      (this.emissive = [0, 0, 0]),
      this.setValues(e);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(),
      super.dispose();
  }
}
var vD = { exports: {} };
function AD(e, t, i) {
  i = i || 2;
  var n,
    s,
    r,
    a,
    o,
    l,
    h,
    c = t && t.length,
    u = c ? t[0] * i : e.length,
    d = yD(e, 0, u, i, !0),
    p = [];
  if (!d || d.next === d.prev) return p;
  if (
    (c &&
      (d = (function (e, t, i, n) {
        var s,
          r,
          a,
          o = [];
        for (s = 0, r = t.length; s < r; s++)
          (a = yD(e, t[s] * n, s < r - 1 ? t[s + 1] * n : e.length, n, !1)) ===
            a.next && (a.steiner = !0),
            o.push(PD(a));
        for (o.sort(wD), s = 0; s < o.length; s++) i = TD(o[s], i);
        return i;
      })(e, t, d, i)),
    e.length > 80 * i)
  ) {
    (n = r = e[0]), (s = a = e[1]);
    for (var f = i; f < u; f += i)
      (o = e[f]) < n && (n = o),
        (l = e[f + 1]) < s && (s = l),
        o > r && (r = o),
        l > a && (a = l);
    h = 0 !== (h = Math.max(r - n, a - s)) ? 32767 / h : 0;
  }
  return bD(d, p, i, n, s, h, 0), p;
}
function yD(e, t, i, n, s) {
  var r, a;
  if (s === HD(e, t, i, n) > 0)
    for (r = t; r < i; r += n) a = GD(r, e[r], e[r + 1], a);
  else for (r = i - n; r >= t; r -= n) a = GD(r, e[r], e[r + 1], a);
  return a && ND(a, a.next) && (VD(a), (a = a.next)), a;
}
function xD(e, t) {
  if (!e) return e;
  t || (t = e);
  var i,
    n = e;
  do {
    if (
      ((i = !1), n.steiner || (!ND(n, n.next) && 0 !== FD(n.prev, n, n.next)))
    )
      n = n.next;
    else {
      if ((VD(n), (n = t = n.prev) === n.next)) break;
      i = !0;
    }
  } while (i || n !== t);
  return t;
}
function bD(e, t, i, n, s, r, a) {
  if (e) {
    !a &&
      r &&
      (function (e, t, i, n) {
        var s = e;
        do {
          0 === s.z && (s.z = RD(s.x, s.y, t, i, n)),
            (s.prevZ = s.prev),
            (s.nextZ = s.next),
            (s = s.next);
        } while (s !== e);
        (s.prevZ.nextZ = null),
          (s.prevZ = null),
          (function (e) {
            var t,
              i,
              n,
              s,
              r,
              a,
              o,
              l,
              h = 1;
            do {
              for (i = e, e = null, r = null, a = 0; i; ) {
                for (
                  a++, n = i, o = 0, t = 0;
                  t < h && (o++, (n = n.nextZ));
                  t++
                );
                for (l = h; o > 0 || (l > 0 && n); )
                  0 !== o && (0 === l || !n || i.z <= n.z)
                    ? ((s = i), (i = i.nextZ), o--)
                    : ((s = n), (n = n.nextZ), l--),
                    r ? (r.nextZ = s) : (e = s),
                    (s.prevZ = r),
                    (r = s);
                i = n;
              }
              (r.nextZ = null), (h *= 2);
            } while (a > 1);
          })(s);
      })(e, n, s, r);
    for (var o, l, h = e; e.prev !== e.next; )
      if (((o = e.prev), (l = e.next), r ? SD(e, n, s, r) : ED(e)))
        t.push((o.i / i) | 0),
          t.push((e.i / i) | 0),
          t.push((l.i / i) | 0),
          VD(e),
          (e = l.next),
          (h = l.next);
      else if ((e = l) === h) {
        a
          ? 1 === a
            ? bD((e = CD(xD(e), t, i)), t, i, n, s, r, 2)
            : 2 === a && MD(e, t, i, n, s, r)
          : bD(xD(e), t, i, n, s, r, 1);
        break;
      }
  }
}
function ED(e) {
  var t = e.prev,
    i = e,
    n = e.next;
  if (FD(t, i, n) >= 0) return !1;
  for (
    var s = t.x,
      r = i.x,
      a = n.x,
      o = t.y,
      l = i.y,
      h = n.y,
      c = s < r ? (s < a ? s : a) : r < a ? r : a,
      u = o < l ? (o < h ? o : h) : l < h ? l : h,
      d = s > r ? (s > a ? s : a) : r > a ? r : a,
      p = o > l ? (o > h ? o : h) : l > h ? l : h,
      f = n.next;
    f !== t;

  ) {
    if (
      f.x >= c &&
      f.x <= d &&
      f.y >= u &&
      f.y <= p &&
      DD(s, o, r, l, a, h, f.x, f.y) &&
      FD(f.prev, f, f.next) >= 0
    )
      return !1;
    f = f.next;
  }
  return !0;
}
function SD(e, t, i, n) {
  var s = e.prev,
    r = e,
    a = e.next;
  if (FD(s, r, a) >= 0) return !1;
  for (
    var o = s.x,
      l = r.x,
      h = a.x,
      c = s.y,
      u = r.y,
      d = a.y,
      p = o < l ? (o < h ? o : h) : l < h ? l : h,
      f = c < u ? (c < d ? c : d) : u < d ? u : d,
      m = o > l ? (o > h ? o : h) : l > h ? l : h,
      g = c > u ? (c > d ? c : d) : u > d ? u : d,
      _ = RD(p, f, t, i, n),
      v = RD(m, g, t, i, n),
      A = e.prevZ,
      y = e.nextZ;
    A && A.z >= _ && y && y.z <= v;

  ) {
    if (
      A.x >= p &&
      A.x <= m &&
      A.y >= f &&
      A.y <= g &&
      A !== s &&
      A !== a &&
      DD(o, c, l, u, h, d, A.x, A.y) &&
      FD(A.prev, A, A.next) >= 0
    )
      return !1;
    if (
      ((A = A.prevZ),
      y.x >= p &&
        y.x <= m &&
        y.y >= f &&
        y.y <= g &&
        y !== s &&
        y !== a &&
        DD(o, c, l, u, h, d, y.x, y.y) &&
        FD(y.prev, y, y.next) >= 0)
    )
      return !1;
    y = y.nextZ;
  }
  for (; A && A.z >= _; ) {
    if (
      A.x >= p &&
      A.x <= m &&
      A.y >= f &&
      A.y <= g &&
      A !== s &&
      A !== a &&
      DD(o, c, l, u, h, d, A.x, A.y) &&
      FD(A.prev, A, A.next) >= 0
    )
      return !1;
    A = A.prevZ;
  }
  for (; y && y.z <= v; ) {
    if (
      y.x >= p &&
      y.x <= m &&
      y.y >= f &&
      y.y <= g &&
      y !== s &&
      y !== a &&
      DD(o, c, l, u, h, d, y.x, y.y) &&
      FD(y.prev, y, y.next) >= 0
    )
      return !1;
    y = y.nextZ;
  }
  return !0;
}
function CD(e, t, i) {
  var n = e;
  do {
    var s = n.prev,
      r = n.next.next;
    !ND(s, r) &&
      BD(s, n, n.next, r) &&
      UD(s, r) &&
      UD(r, s) &&
      (t.push((s.i / i) | 0),
      t.push((n.i / i) | 0),
      t.push((r.i / i) | 0),
      VD(n),
      VD(n.next),
      (n = e = r)),
      (n = n.next);
  } while (n !== e);
  return xD(n);
}
function MD(e, t, i, n, s, r) {
  var a = e;
  do {
    for (var o = a.next.next; o !== a.prev; ) {
      if (a.i !== o.i && LD(a, o)) {
        var l = zD(a, o);
        return (
          (a = xD(a, a.next)),
          (l = xD(l, l.next)),
          bD(a, t, i, n, s, r, 0),
          void bD(l, t, i, n, s, r, 0)
        );
      }
      o = o.next;
    }
    a = a.next;
  } while (a !== e);
}
function wD(e, t) {
  return e.x - t.x;
}
function TD(e, t) {
  var i = (function (e, t) {
    var i,
      n = t,
      s = e.x,
      r = e.y,
      a = -1 / 0;
    do {
      if (r <= n.y && r >= n.next.y && n.next.y !== n.y) {
        var o = n.x + ((r - n.y) * (n.next.x - n.x)) / (n.next.y - n.y);
        if (
          o <= s &&
          o > a &&
          ((a = o), (i = n.x < n.next.x ? n : n.next), o === s)
        )
          return i;
      }
      n = n.next;
    } while (n !== t);
    if (!i) return null;
    var l,
      h = i,
      c = i.x,
      u = i.y,
      d = 1 / 0;
    n = i;
    do {
      s >= n.x &&
        n.x >= c &&
        s !== n.x &&
        DD(r < u ? s : a, r, c, u, r < u ? a : s, r, n.x, n.y) &&
        ((l = Math.abs(r - n.y) / (s - n.x)),
        UD(n, e) &&
          (l < d || (l === d && (n.x > i.x || (n.x === i.x && ID(i, n))))) &&
          ((i = n), (d = l))),
        (n = n.next);
    } while (n !== h);
    return i;
  })(e, t);
  if (!i) return t;
  var n = zD(i, e);
  return xD(n, n.next), xD(i, i.next);
}
function ID(e, t) {
  return FD(e.prev, e, t.prev) < 0 && FD(t.next, e, e.next) < 0;
}
function RD(e, t, i, n, s) {
  return (
    (e =
      1431655765 &
      ((e =
        858993459 &
        ((e =
          252645135 &
          ((e = 16711935 & ((e = ((e - i) * s) | 0) | (e << 8))) | (e << 4))) |
          (e << 2))) |
        (e << 1))) |
    ((t =
      1431655765 &
      ((t =
        858993459 &
        ((t =
          252645135 &
          ((t = 16711935 & ((t = ((t - n) * s) | 0) | (t << 8))) | (t << 4))) |
          (t << 2))) |
        (t << 1))) <<
      1)
  );
}
function PD(e) {
  var t = e,
    i = e;
  do {
    (t.x < i.x || (t.x === i.x && t.y < i.y)) && (i = t), (t = t.next);
  } while (t !== e);
  return i;
}
function DD(e, t, i, n, s, r, a, o) {
  return (
    (s - a) * (t - o) >= (e - a) * (r - o) &&
    (e - a) * (n - o) >= (i - a) * (t - o) &&
    (i - a) * (r - o) >= (s - a) * (n - o)
  );
}
function LD(e, t) {
  return (
    e.next.i !== t.i &&
    e.prev.i !== t.i &&
    !(function (e, t) {
      var i = e;
      do {
        if (
          i.i !== e.i &&
          i.next.i !== e.i &&
          i.i !== t.i &&
          i.next.i !== t.i &&
          BD(i, i.next, e, t)
        )
          return !0;
        i = i.next;
      } while (i !== e);
      return !1;
    })(e, t) &&
    ((UD(e, t) &&
      UD(t, e) &&
      (function (e, t) {
        var i = e,
          n = !1,
          s = (e.x + t.x) / 2,
          r = (e.y + t.y) / 2;
        do {
          i.y > r != i.next.y > r &&
            i.next.y !== i.y &&
            s < ((i.next.x - i.x) * (r - i.y)) / (i.next.y - i.y) + i.x &&
            (n = !n),
            (i = i.next);
        } while (i !== e);
        return n;
      })(e, t) &&
      (FD(e.prev, e, t.prev) || FD(e, t.prev, t))) ||
      (ND(e, t) && FD(e.prev, e, e.next) > 0 && FD(t.prev, t, t.next) > 0))
  );
}
function FD(e, t, i) {
  return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y);
}
function ND(e, t) {
  return e.x === t.x && e.y === t.y;
}
function BD(e, t, i, n) {
  var s = OD(FD(e, t, i)),
    r = OD(FD(e, t, n)),
    a = OD(FD(i, n, e)),
    o = OD(FD(i, n, t));
  return (
    (s !== r && a !== o) ||
    !(0 !== s || !kD(e, i, t)) ||
    !(0 !== r || !kD(e, n, t)) ||
    !(0 !== a || !kD(i, e, n)) ||
    !(0 !== o || !kD(i, t, n))
  );
}
function kD(e, t, i) {
  return (
    t.x <= Math.max(e.x, i.x) &&
    t.x >= Math.min(e.x, i.x) &&
    t.y <= Math.max(e.y, i.y) &&
    t.y >= Math.min(e.y, i.y)
  );
}
function OD(e) {
  return e > 0 ? 1 : e < 0 ? -1 : 0;
}
function UD(e, t) {
  return FD(e.prev, e, e.next) < 0
    ? FD(e, t, e.next) >= 0 && FD(e, e.prev, t) >= 0
    : FD(e, t, e.prev) < 0 || FD(e, e.next, t) < 0;
}
function zD(e, t) {
  var i = new QD(e.i, e.x, e.y),
    n = new QD(t.i, t.x, t.y),
    s = e.next,
    r = t.prev;
  return (
    (e.next = t),
    (t.prev = e),
    (i.next = s),
    (s.prev = i),
    (n.next = i),
    (i.prev = n),
    (r.next = n),
    (n.prev = r),
    n
  );
}
function GD(e, t, i, n) {
  var s = new QD(e, t, i);
  return (
    n
      ? ((s.next = n.next), (s.prev = n), (n.next.prev = s), (n.next = s))
      : ((s.prev = s), (s.next = s)),
    s
  );
}
function VD(e) {
  (e.next.prev = e.prev),
    (e.prev.next = e.next),
    e.prevZ && (e.prevZ.nextZ = e.nextZ),
    e.nextZ && (e.nextZ.prevZ = e.prevZ);
}
function QD(e, t, i) {
  (this.i = e),
    (this.x = t),
    (this.y = i),
    (this.prev = null),
    (this.next = null),
    (this.z = 0),
    (this.prevZ = null),
    (this.nextZ = null),
    (this.steiner = !1);
}
function HD(e, t, i, n) {
  for (var s = 0, r = t, a = i - n; r < i; r += n)
    (s += (e[a] - e[r]) * (e[r + 1] + e[a + 1])), (a = r);
  return s;
}
(vD.exports = AD),
  (vD.exports.default = AD),
  (AD.deviation = function (e, t, i, n) {
    var s = t && t.length,
      r = s ? t[0] * i : e.length,
      a = Math.abs(HD(e, 0, r, i));
    if (s)
      for (var o = 0, l = t.length; o < l; o++) {
        var h = t[o] * i,
          c = o < l - 1 ? t[o + 1] * i : e.length;
        a -= Math.abs(HD(e, h, c, i));
      }
    var u = 0;
    for (o = 0; o < n.length; o += 3) {
      var d = n[o] * i,
        p = n[o + 1] * i,
        f = n[o + 2] * i;
      u += Math.abs(
        (e[d] - e[f]) * (e[p + 1] - e[d + 1]) -
          (e[d] - e[p]) * (e[f + 1] - e[d + 1])
      );
    }
    return 0 === a && 0 === u ? 0 : Math.abs((u - a) / a);
  }),
  (AD.flatten = function (e) {
    for (
      var t = e[0][0].length,
        i = { vertices: [], holes: [], dimensions: t },
        n = 0,
        s = 0;
      s < e.length;
      s++
    ) {
      for (var r = 0; r < e[s].length; r++)
        for (var a = 0; a < t; a++) i.vertices.push(e[s][r][a]);
      s > 0 && ((n += e[s - 1].length), i.holes.push(n));
    }
    return i;
  });
const jD = [1, 1, 0, 1];
class WD extends rn {
  constructor(e) {
    super(),
      publicField(this, "isPolygonGeometry", !0),
      publicField(this, "_useUV", !1),
      publicField(this, "_sideUVNormalized", !1),
      publicField(this, "_sideUVReversed", !1),
      publicField(this, "_sideUVUseHeight", !1),
      publicField(
        this,
        "addGeoPolygonToVertices",
        (e, t, i = 0, n = 0, s, r, a, o, l, h, c, u, d = !1) => {
          let p = e.vertices;
          const f = e.dimensions;
          d && (p = p.reverse()), Array.isArray(h) || (h = jD);
          let m = 1 / 0,
            g = 1 / 0;
          for (let A = 0, y = p.length - f + 1; A < y; A += f)
            (m = p[A] < m ? p[A] : m), (g = p[A + 1] < g ? p[A + 1] : g);
          const _ = new Vector3(),
            v = new Vector3();
          for (let A = 0; A <= t.length - f; A += f) {
            let e = [];
            for (let a = 0; a < 3; a++) {
              const d = t[A + a] * f;
              let _;
              (_ = new Vector3(p[d], p[d + 1], 2 === f ? 0 + i : p[d + 2] + i)),
                e.push(_),
                s.push(_.x, _.y, _.z),
                l.push(h[0], h[1], h[2], h[3]),
                o.push(p[d] - m, p[d + 1] - g),
                c.push(u),
                r.push(n + A + a);
            }
            let d = [0, 0, 1];
            2 !== f &&
              (_.subVectors(e[2], e[1]),
              v.subVectors(e[0], e[1]),
              _.cross(v),
              _.normalize(),
              (d = _.toArray())),
              a.push(...d, ...d, ...d);
          }
        }
      ),
      publicField(this, "isClockWise", (e) => {
        let t = e.length,
          i = 0;
        for (let n = t - 1, s = 0; s < t; n = s++)
          i += e[n][0] * e[s][1] - e[s][0] * e[n][1];
        return i < 0;
      }),
      publicField(this, "addSideFace", (e, t, i, n, s, r, a, o, l, h, c) => {
        let u = e[0],
          d = i;
        u.length,
          this.isClockWise(u) && (u = u.reverse()),
          Array.isArray(l) || (l = jD);
        let p = 0;
        let f = 0,
          m = 0;
        for (let g = 0, _ = u.length - 1; g < _; g++) {
          const e = u[g][2] || 0;
          n.push(
            u[g][0],
            u[g][1],
            e + this._zOffset,
            u[g][0],
            u[g][1],
            e + this._zOffset + t,
            u[g + 1][0],
            u[g + 1][1],
            e + this._zOffset + t,
            u[g + 1][0],
            u[g + 1][1],
            e + this._zOffset
          ),
            (d = i + 4 * g),
            s.push(d, d + 2, d + 1, d, d + 3, d + 2);
          let _ = u[g + 1][0] - u[g][0],
            v = u[g + 1][1] - u[g][1];
          const A = Math.sqrt(_ * _ + v * v);
          (_ /= A),
            (v /= A),
            r.push(v, -_, 0, v, -_, 0, v, -_, 0, v, -_, 0),
            this._sideUVUseHeight
              ? ((f = 1 * t), (m = 1 * t))
              : ((f = 0),
                (m = 1 * t),
                this._sideUVNormalized && (m = 1),
                this._sideUVReversed && ((f = m), (m = 0))),
            a.push(1 * p, f, 1 * p, m),
            (p += A),
            a.push(1 * p, m, 1 * p, f),
            o.push(
              l[0],
              l[1],
              l[2],
              l[3],
              l[0],
              l[1],
              l[2],
              l[3],
              l[0],
              l[1],
              l[2],
              l[3],
              l[0],
              l[1],
              l[2],
              l[3]
            ),
            h.push(c, c, c, c);
        }
      }),
      publicField(this, "crossVectors3", (e, t) => {
        const i = [];
        return (
          (i[0] = e[1] * t[2] - e[2] * t[1]),
          (i[1] = e[2] * t[0] - e[0] * t[2]),
          (i[2] = e[0] * t[1] - e[1] * t[0]),
          i
        );
      }),
      (this.parameters = e),
      (this._needsUpdate = !1),
      (this._extrude = e.extrude || !1),
      (this._extrudeValue = e.extrudeValue || 0),
      (this._enableBottomFace = e.enableBottomFace || !1),
      (this._zOffset = e.zOffset || 0),
      (this.cachedPositions = []),
      (this.cachedObjectIndices = []);
  }
  setData(e) {
    (this._needsUpdate = !0), (this.cachedData = e), this.updateGeometry();
  }
  updateGeometry() {
    let e = this.cachedData,
      t = null,
      i = null;
    const n = [],
      s = [],
      r = [],
      a = [];
    let o = [];
    const l = [];
    for (let c = 0; c < e.position.length; c++) {
      const h = e.position[c],
        u = e.index[c],
        d = e.color ? colorToArr4(e.color[c]) : jD,
        p = this.parameters.vertexHeights ? e.height[c] : this.extrudeValue;
      (t = vD.exports.flatten(h)),
        (i = vD.exports(t.vertices, t.holes, t.dimensions)),
        this.extrude &&
          this._enableBottomFace &&
          this.addGeoPolygonToVertices(
            t,
            i,
            this._zOffset,
            n.length / 3,
            n,
            o,
            s,
            r,
            l,
            d,
            a,
            u,
            !0
          ),
        this.addGeoPolygonToVertices(
          t,
          i,
          this._zOffset + p,
          n.length / 3,
          n,
          o,
          s,
          r,
          l,
          d,
          a,
          u
        );
    }
    const h = o.length;
    if (this.extrude)
      for (let c = 0; c < e.position.length; c++) {
        const t = e.position[c],
          i = e.index[c],
          h = e.color ? colorToArr4(e.color[c]) : jD,
          u = this.parameters.vertexHeights ? e.height[c] : this.extrudeValue;
        u > 0 && this.addSideFace(t, u, n.length / 3, n, o, s, r, l, h, a, i);
      }
    (this.cachedPositions = n),
      (this.cachedObjectIndices = a),
      this.setAttribute("position", new Ki(n, 3)),
      this.parameters.vertexColors && this.setAttribute("aColor", new Ki(l, 4)),
      this._useUV
        ? this.setAttribute("uv", new Ki(r, 2))
        : this.deleteAttribute("uv"),
      this.setAttribute("normal", new Ki(s, 3)),
      this.setIndex(o),
      this.clearGroups(),
      this.addGroup(0, h, 1),
      this.extrude && this.addGroup(h, o.length - h, 0),
      this.computeBoundingSphere(),
      (this._needsUpdate = !1);
  }
  get extrude() {
    return this._extrude;
  }
  set extrude(e) {
    const t = !!e;
    t !== this._extrude && ((this._extrude = t), (this._needsUpdate = !0));
  }
  get extrudeValue() {
    return this._extrudeValue;
  }
  set extrudeValue(e) {
    !isNaN(e) &&
      e >= 0 &&
      e !== this._extrudeValue &&
      ((this._extrudeValue = e), (this._needsUpdate = !0));
  }
  get sideUVNormalized() {
    return this._sideUVNormalized;
  }
  set sideUVNormalized(e) {
    e !== this._sideUVNormalized &&
      (this._extrude && (this._needsUpdate = !0), (this._sideUVNormalized = e));
  }
  get sideUVReversed() {
    return this._sideUVReversed;
  }
  set sideUVReversed(e) {
    e !== this._sideUVReversed &&
      (this._extrude && (this._needsUpdate = !0), (this._sideUVReversed = e));
  }
  get sideUVUseHeight() {
    return this._sideUVUseHeight;
  }
  set sideUVUseHeight(e) {
    e !== this._sideUVUseHeight &&
      (this._extrude && (this._needsUpdate = !0), (this._sideUVUseHeight = e));
  }
  get useUV() {
    return this._useUV;
  }
  set useUV(e) {
    e !== this._useUV && ((this._needsUpdate = !0), (this._useUV = e));
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
}
const qD = new yl(),
  XD = In.merge([
    Xn.fog,
    Xn.lights,
    L_,
    D_,
    {
      isEmissive: { value: !1 },
      opacity: { value: 1 },
      color: { value: [0, 1, 1, 1] },
      vertexColors: { value: !1 },
      map: { value: void 0 },
      mapLength: { value: new Vector2() },
      mapSrc: { value: "" },
      mapScale: { value: 1 },
      normalOffset: { value: 0 },
    },
  ]);
class YD extends CommonShaderMaterial {
  constructor(e) {
    super(),
      (this.type = "PolygonMaterial"),
      (this.isPolygonMaterial = !0),
      (this.lights = !0),
      (this.fog = !0),
      (this.transparent = !0),
      (this.depthWrite = !0),
      (this.depthTest = !0),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n    uniform sampler2D map;\n    uniform vec2 mapLength;\n#else\n    #ifdef MVT_USE_VERTEX_COLOR\n        varying vec4 vColor;\n    #endif\n#endif\n\nuniform vec4 color;\nuniform float opacity;\n\n#include <lights_pars_begin>\n#include <normal_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <mvt_selective_pars_fragment>\n\nvoid main() {\n    #ifdef USE_MAP\n        gl_FragColor = texture2D(map, vec2(mod(vUv.x, mapLength.x) / mapLength.x, mod(vUv.y, mapLength.y) / mapLength.y));\n    #else\n        #ifdef MVT_USE_VERTEX_COLOR\n            gl_FragColor = vColor;\n        #else\n            gl_FragColor = color;\n        #endif\n    #endif\n\n    gl_FragColor.a *= opacity;\n    if (gl_FragColor.a <= 0.) {\n        discard;\n    }\n\n    #if ( NUM_DIR_LIGHTS > 0 )\n        // 根据方向光的方向与法向，来计算颜色衰减程度，值范围为-1~1，给重映射到0.8~1的范围\n        float normalLightIntensity = dot(vNormal, directionalLights[0].direction);\n        gl_FragColor = vec4(gl_FragColor.rgb * (normalLightIntensity / 10.0 + 0.9), gl_FragColor.a);\n    #endif\n    #include <mvt_selective_fragment>\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n    #include <tonemapping_fragment>\n    #include <colorspace_fragment>\n    \n}\n\n"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n#include <fog_pars_vertex>\n\n#ifdef USE_MAP\n    varying vec2 vUv;\n    uniform float mapScale;\n#else\n    #ifdef MVT_USE_VERTEX_COLOR\n        attribute vec4 aColor;\n        varying vec4 vColor;\n    #endif\n#endif\n\nuniform float normalOffset;\n\n#include <normal_pars_vertex>\n\n#include <logdepthbuf_pars_vertex>\n#include <mvt_selective_pars_vertex>\n\nvoid main() {\n\n    #include <mvt_selective_vertex>\n\n    #ifdef USE_MAP\n        vUv = uv / mapScale;\n    #else\n        #ifdef MVT_USE_VERTEX_COLOR\n            vColor = aColor;\n        #endif\n    #endif\n\n    #include <begin_vertex>\n\n    #include <beginnormal_vertex>\n    #include <defaultnormal_vertex>\n    #include <normal_vertex>\n\n    vec4 viewCoord = modelViewMatrix * vec4( transformed, 1.0 );\n    viewCoord.xyz += normalize(transformedNormal) * normalOffset;\n\n    gl_Position = projectionMatrix * viewCoord;\n    #include <fog_vertex>\n    #include <logdepthbuf_vertex>\n\n}\n\n"),
      Object.defineProperty(this, "mapSrc", {
        get: function () {
          return this.uniforms.map.value;
        },
        set: function (e) {
          const t = this.mapSrc,
            i = this.userData[this.urlCacheKey],
            n = this;
          if (i !== e) {
            if ((t && t.dispose(), !e))
              return (
                (this.uniforms.map.value = null),
                delete this.defines.USE_MAP,
                void delete this.userData[this.urlCacheKey]
              );
            qD.load(e, function (t) {
              (t.colorSpace = me),
                (n.uniforms.map.value = t),
                (n.uniforms.mapLength.value = new Vector2(
                  t.image.naturalWidth,
                  t.image.naturalHeight
                )),
                (n.userData[n.urlCacheKey] = e),
                (n.defines.USE_MAP = !0),
                (n.needsUpdate = !0);
            });
          }
        },
      }),
      Object.assign(this.uniforms, In.clone(XD)),
      e.mapSrc && ((this.mapSrc = e.mapSrc), delete e.mapSrc),
      N_(this, ["opacity", "mapScale", "isEmissive", "normalOffset"]),
      B_(this, ["color"]),
      O_(this, [["vertexColors", "MVT_USE_VERTEX_COLOR"]]),
      U_(this),
      G_(this),
      (this.emissiveEnabled = !0),
      (this.emissive = [0, 0, 0]),
      this.setValues(e);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(),
      super.dispose();
  }
}
class KD extends Mesh {
  constructor(e) {
    super(),
      publicField(this, "isEventEntitySupported", !0),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "extrude"),
      publicField(this, "extrudeValue"),
      publicField(this, "color"),
      publicField(this, "vertexColors"),
      publicField(this, "emissive"),
      publicField(this, "opacity"),
      publicField(this, "mapSrc"),
      publicField(this, "mapScale"),
      (this.parameters = e),
      this.defineGeometryProxyProperties([
        "extrude",
        "extrudeValue",
        "vertexHeights",
        "enableBottomFace",
        "zOffset",
      ]),
      this.defineMaterialProxyProperties([
        "opacity",
        "color",
        "vertexColors",
        "emissive",
        "mapSrc",
        "mapScale",
        "side",
        "depthWrite",
        "colorWrite",
        "stencilWrite",
        "stencilFunc",
        "stencilZFail",
        "stencilZPass",
        "normalOffset",
      ]);
  }
  initObject() {
    const {
      extrude: e,
      extrudeValue: t,
      vertexHeights: i,
      enableBottomFace: n,
      zOffset: s,
      ...r
    } = this.parameters;
    this.geometry = new WD(this.parameters);
    (this.material = new YD(r)).setCommonUniforms(
      this.engine.rendering.uniforms
    );
  }
  setData() {
    let e = this.dataSource.data;
    this.geometry.setData(e),
      this.geometry.computeBoundingSphere(),
      this.makeGeometryOffsetPosition(
        this.geometry,
        this.geometry.cachedPositions
      ),
      this.geometry.computeBoundingSphere(),
      this.geometry.computeBoundingBox(),
      (this.needsUpdate = !1);
  }
  afterGeometryUpdate() {
    this.makeGeometryOffsetPosition(
      this.geometry,
      this.geometry.cachedPositions
    ),
      this.geometry.computeBoundingSphere(),
      this.geometry.computeBoundingBox();
  }
  getEntityIndexByFace(e, t) {
    return this.geometry.cachedObjectIndices[t];
  }
}
(KD.prototype.raycast = En.prototype.raycast),
  (KD.prototype._computeIntersections = En.prototype._computeIntersections),
  (KD.prototype.getVertexPosition = En.prototype.getVertexPosition),
  new Vector3(),
  new Vector3();
const ZD = new Matrix4(),
  JD = new jt(),
  $D = new kt();
class eL extends Mesh {
  constructor(e) {
    super(),
      publicField(this, "isEventEntitySupported", !0),
      publicField(this, "_dataSource", new mA()),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "lineJoin"),
      publicField(this, "lineCap"),
      publicField(this, "miterLimit"),
      publicField(this, "keepSize"),
      publicField(this, "color"),
      publicField(this, "vertexColors"),
      publicField(this, "emissive"),
      publicField(this, "map"),
      publicField(this, "opacity"),
      publicField(this, "alphaTest"),
      publicField(this, "dashed"),
      publicField(this, "dashArray"),
      publicField(this, "dashOffset"),
      publicField(this, "dashRatio"),
      publicField(this, "enbaleAnimation"),
      publicField(this, "enableAnimationChaos"),
      publicField(this, "animationSpeed"),
      publicField(this, "animationTailType"),
      publicField(this, "animationTailRatio"),
      publicField(this, "animationTailLength"),
      publicField(this, "animationIdle"),
      (this.parameters = e),
      this.defineGeometryProxyProperties(["lineJoin", "lineCap", "miterLimit"]),
      this.defineMaterialProxyProperties([
        "mapSrc",
        "mapGap",
        "height",
        "keepSize",
        "opacity",
        "alphaTest",
        "dashed",
        "dashArray",
        "dashOffset",
        "dashRatio",
        "enableAnimation",
        "enableAnimationChaos",
        "animationInterval",
        "animationSpeed",
        "animationTailType",
        "animationTailRatio",
        "animationTailLength",
        "animationIdle",
        "color",
        "vertexColors",
        "vertexWidths",
        "emissive",
      ]);
  }
  createVolumeDataSource() {
    const { data: e, userData: t, _attributeMap: i } = this.dataSource;
    let n = 1;
    if (this.keepSize) {
      const e = this.engine.map.getZoomUnits();
      e === Math.min() || Number.isNaN(e) || (n = e);
    }
    const s = {
        position: this.geometry.createVolumeGeometry(e.position, n),
        index: e.index,
        payload: t,
      },
      r = new mA();
    let a = i.keys();
    for (let o of a) {
      const e = i.get(o);
      "string" == typeof e ? r.setAttribute(o, e) : r.setAttribute(o);
    }
    return r.setData(s), r;
  }
  specifiedVolumeClass() {
    this._VolumeClass = KD;
  }
  getDefaultParams() {
    return { lineWidth: 4 };
  }
  initObject() {
    const { lineJoin: e, lineCap: t, ...i } = this.parameters;
    this.geometry = new fD(this.parameters);
    (this.material = new _D(i)).setCommonUniforms(
      this.engine.rendering.uniforms
    );
  }
  setData() {
    const e = this.dataSource.data;
    this.geometry.setData(e),
      this.geometry.computeBoundingSphere(),
      this.geometry.computeBoundingBox(),
      this.makeGeometryOffsetPosition(
        this.geometry,
        this.geometry.cachedPositions
      ),
      (this.needsUpdate = !1);
  }
  get lineWidth() {
    return this.parameters.lineWidth;
  }
  set lineWidth(e) {
    this.parameters.lineWidth = e;
  }
  raycast(e, t) {
    if (!this.receiveRaycast || !this.visible) return;
    const i = this.geometry,
      n = this.matrixWorld,
      s = e.params.Line.threshold,
      r = i.drawRange;
    let a = this.lineWidth / 2;
    if (
      (this.material.keepSize && (a *= this.material.uniforms.zoomUnits.value),
      null === i.boundingSphere && i.computeBoundingSphere(),
      $D.copy(i.boundingSphere),
      $D.applyMatrix4(n),
      ($D.radius += a),
      !1 === e.ray.intersectsSphere($D))
    )
      return;
    ZD.copy(n).invert(), JD.copy(e.ray).applyMatrix4(ZD);
    const o = a / ((this.scale.x + this.scale.y + this.scale.z) / 3),
      l = o * o,
      h = new Vector3(),
      c = new Vector3(),
      u = new Vector3(),
      d = new Vector3();
    if (i.isBufferGeometry) {
      const n = i.index,
        s = i.attributes,
        a = s.position,
        o = s.objectIndex;
      if (null !== n) {
        for (
          let i = Math.max(0, r.start),
            s = Math.min(n.count, r.start + r.count) - 1;
          i < s;
          i += 2
        ) {
          const s = n.getX(i),
            r = n.getX(i + 1);
          h.fromBufferAttribute(a, s), c.fromBufferAttribute(a, r);
          if (JD.distanceSqToSegment(h, c, d, u) > l) continue;
          d.applyMatrix4(this.matrixWorld);
          const p = e.ray.origin.distanceTo(d);
          p < e.near ||
            p > e.far ||
            t.push({
              distance: p,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: o.getX(s),
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      } else {
        for (
          let i = Math.max(0, r.start),
            n = Math.min(a.count, r.start + r.count) - 1;
          i < n;
          i += 2
        ) {
          h.fromBufferAttribute(a, i), c.fromBufferAttribute(a, i + 1);
          if (JD.distanceSqToSegment(h, c, d, u) > l) continue;
          d.applyMatrix4(this.matrixWorld);
          const n = e.ray.origin.distanceTo(d);
          n < e.near ||
            n > e.far ||
            t.push({
              distance: n,
              point: u.clone().applyMatrix4(this.matrixWorld),
              index: i,
              face: null,
              faceIndex: null,
              object: this,
            });
        }
      }
    }
    e.params.Line.threshold = s;
  }
}
class tL extends rn {
  constructor(e) {
    super(),
      publicField(this, "isWallGeometry", !0),
      publicField(this, "_needsUpdate", !1),
      (this.parameters = e);
  }
  setData(e) {
    (this._needsUpdate = !0), (this.cachedData = e), this.updateGeometry();
  }
  updateGeometry() {
    let e = this.cachedData;
    const t = [],
      i = [],
      n = [],
      s = [],
      r = [],
      a = [],
      o = [];
    for (let l = 0; l < e.position.length; l++) {
      const h = e.position[l];
      e.index[l];
      const c = this.parameters.vertexColors
          ? colorToArr4(e.color[l])
          : colorToArr4(this.parameters.color),
        u = this.parameters.vertexHeights
          ? e.height[l]
          : this.parameters.height;
      let d = 0;
      const p = h.length;
      let f = t.length / 3;
      for (let e = 0; e < p; e++) {
        const o = h[e],
          l = [h[e][0], h[e][1], h[e][2] + u],
          m = e < p - 1 ? h[e + 1] : null;
        if (
          (!m || !Av(o, m)) &&
          (t.push(...o, ...l),
          a.push(...c, ...c),
          n.push(e / (p - 1), e / (p - 1)),
          r.push(d, d),
          i.push(d, 0, d, 1),
          e < p - 1)
        ) {
          d += yv(o, m);
          let t = f + 2 * e;
          s.push(t, t + 2, t + 1, t + 1, t + 2, t + 3);
        }
      }
      for (let e = 0; e < p; e++) o.push(d, d);
      f += 2 * p;
    }
    (this.cachedPositions = t),
      this.setAttribute("position", new Ki(t, 3)),
      this.setAttribute("uv", new Ki(i, 2)),
      this.setAttribute("counter", new Ki(n, 1)),
      this.setAttribute("distances", new Ki(r, 1)),
      this.setAttribute("totalDistance", new Ki(o, 1)),
      this.parameters.vertexColors && this.setAttribute("aColor", new Ki(a, 4)),
      this.setIndex(s),
      this.computeBoundingSphere(),
      (this._needsUpdate = !1);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
}
const iL = new yl(),
  nL = In.merge([
    Xn.fog,
    L_,
    D_,
    {
      map: { value: null },
      useMap: { value: !1 },
      uColor: { value: [0, 1, 1, 1] },
      minOpacity: { value: 0 },
      maxOpacity: { value: 1 },
      opacity: { value: 1 },
      vertexColors: { value: !1 },
      elapsedTime: { value: 0 },
      enableAnimation: { value: !1 },
      animationSpeed: { value: 1 },
      animationTailType: { value: 3 },
      animationTailRatio: { value: 0.2 },
      animationTailLength: { value: 100 },
      animationIdle: { value: 1e3 },
      animationRatio: { value: 0.5 },
      animationBales: { value: 5 },
      isEmissive: { value: !1 },
    },
  ]);
class sL extends CommonShaderMaterial {
  constructor(e) {
    super(),
      (this.type = "WallMaterial"),
      (this.isWallMaterial = !0),
      (this.fog = !0),
      (this.transparent = !0),
      (this.depthWrite = !1),
      (this.side = 2),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n#include <bsdfs>\n#include <fog_pars_fragment>\n\n#include <logdepthbuf_pars_fragment>\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n\nuniform sampler2D map;\nuniform bool useMap;\nuniform float minOpacity;\nuniform float maxOpacity;\nuniform float opacity;\nuniform float elapsedTime;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vDistance;\nvarying float vTotalDistance;\n\n#ifdef USE_ANIMATION\nuniform float animationRatio;\nuniform float animationBales;\nuniform float animationSpeed;\nvarying float vAnimationOpacity;\nvarying float vAnimationTailType;\n#endif\n\nvoid main() {\n\n    vec4 c = vColor;\n\n    if(useMap) {\n        vec4 texture = texture2D(map, vec2(vUV.x / vTotalDistance, vUV.y));\n        c *= texture;\n    }\n\n    #ifdef USE_ANIMATION\n        if (vAnimationOpacity > 1.0 || vAnimationOpacity < 0.0) {\n            c.a = 0.0;\n        }\n\n        if(vAnimationTailType == 4.) {\n            float ratio = animationRatio;\n            float bales = animationBales;\n            if(animationRatio > 1.) {\n                ratio = 1.;\n            }\n            if(animationRatio < .0) {\n                ratio = .0;\n            }\n            if(animationBales < 1.) {\n                bales = 1.;\n            }\n            if(mod((vUV.y - elapsedTime * animationSpeed * .0001), 1./bales) < ratio / bales) {\n                c.a = (1. - vUV.y) * maxOpacity;\n            } else {\n                c.a = minOpacity;\n            }\n        } else {\n            c.a *= vAnimationOpacity;\n        }\n    #endif\n\n    gl_FragColor = c;\n    gl_FragColor.a *= opacity;\n\n    if (maxOpacity > minOpacity) {\n        gl_FragColor.a = clamp(gl_FragColor.a, minOpacity, maxOpacity);\n    }\n\n    #include <fog_fragment>\n    #include <logdepthbuf_fragment>\n}"),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n#include <bsdfs>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#ifdef USE_A_COLOR\nattribute vec4 aColor;\n#endif\n\nattribute float counter;\nattribute float totalDistance;\nattribute float distances;\n\nuniform float elapsedTime;\nuniform bool vertexColors;\nuniform vec4 uColor;\nuniform float opacity;\n\nvarying vec2 vUV;\nvarying vec4 vColor;\nvarying float vCounter;\nvarying float vDistance;\nvarying float vTotalDistance;\n\n#ifdef USE_ANIMATION\nuniform float animationSpeed;\nuniform float animationTailType;\nvarying float vAnimationTailType;\nuniform float animationTailRatio;\nuniform float animationTailLength;\nuniform float animationIdle;\nvarying float vAnimationOpacity;\n#endif\n\nvoid main() {\n\n    #ifdef USE_A_COLOR\n        vColor = aColor;\n    #else\n        vColor = uColor;\n    #endif\n\n    vUV = uv;\n    vCounter = counter;\n    vDistance = distances;\n    vTotalDistance = totalDistance;\n\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n\n    #ifdef USE_ANIMATION\n        if (animationTailType < 3.0) {\n            float tailLength = animationTailType == 1.0 ? totalDistance * animationTailRatio : animationTailLength;\n            float currentLength = mod(elapsedTime * animationSpeed, totalDistance + tailLength + animationIdle * animationSpeed);\n            vAnimationOpacity = (distances - (currentLength - tailLength)) / tailLength;\n        }\n        else if (animationTailType == 3.0) {\n            vAnimationOpacity = 1.0 - mod(elapsedTime * animationSpeed / 1000.0, 1.0) + uv.y;\n        } \n        else if (animationTailType == 4.0) {\n            vAnimationTailType = animationTailType;\n        }\n    #endif\n\n    #include <beginnormal_vertex>\n    vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);\n    #include <fog_vertex>\n\n    #include <logdepthbuf_vertex>\n}"),
      Object.assign(this.uniforms, In.clone(nL)),
      N_(this, [
        "map",
        "minOpacity",
        "maxOpacity",
        "opacity",
        "elapsedTime",
        "animationSpeed",
        "animationTailType",
        "animationTailRatio",
        "animationTailLength",
        "animationIdle",
        "animationBales",
        "animationRatio",
        "isEmissive",
      ]),
      k_(this, [["color", "uColor", colorToVec4]]),
      O_(this, [
        ["vertexColors", "USE_A_COLOR"],
        ["enableAnimation", "USE_ANIMATION"],
      ]),
      G_(this),
      Object.defineProperties(this, {
        mapSrc: {
          get: function () {
            return this.uniforms.map.value;
          },
          set: function (e) {
            const t = this.mapSrc,
              i = "url_map";
            if (this.userData[i] === e) return;
            if ((t && t.dispose(), !e))
              return (
                (this.uniforms.map.value = null),
                (this.uniforms.useMap.value = !1),
                void delete this.userData[i]
              );
            const n = iL.load(e);
            (n.wrapS = n.wrapT = T),
              (this.uniforms.map.value = n),
              (this.userData[i] = e),
              (this.uniforms.useMap.value = !0);
          },
        },
      }),
      (this.emissiveEnabled = !0),
      (this.emissive = [0, 0, 0]),
      this.setValues(e);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(),
      super.dispose();
  }
}
class rL extends Mesh {
  constructor(e) {
    super(),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "height"),
      publicField(this, "color"),
      publicField(this, "vertexColors"),
      publicField(this, "emissive"),
      publicField(this, "map"),
      publicField(this, "opacity"),
      publicField(this, "minOpacity"),
      publicField(this, "maxOpacity"),
      publicField(this, "enableAnimation"),
      publicField(this, "animationSpeed"),
      publicField(this, "animationTailType"),
      publicField(this, "animationTailRatio"),
      publicField(this, "animationTailLength"),
      publicField(this, "animationIdle"),
      publicField(this, "animationRatio"),
      publicField(this, "animationBales"),
      (this.parameters = e),
      this.defineGeometryProxyProperties(["height"]),
      this.defineMaterialProxyProperties([
        "color",
        "vertexColors",
        "emissive",
        "map",
        "opacity",
        "minOpacity",
        "maxOpacity",
        "enableAnimation",
        "animationSpeed",
        "animationTailType",
        "animationTailRatio",
        "animationTailLength",
        "animationIdle",
        "animationBales",
        "animationRatio",
      ]);
  }
  getDefaultParams() {
    return { height: 100 };
  }
  initObject() {
    const { height: e, ...t } = this.parameters;
    this.geometry = new tL(this.parameters);
    (this.material = new sL(t)).setCommonUniforms(
      this.engine.rendering.uniforms
    );
  }
  setData() {
    const e = this.dataSource.data;
    this.geometry.setData(e),
      this.geometry.computeBoundingSphere(),
      this.geometry.computeBoundingBox(),
      this.makeGeometryOffsetPosition(
        this.geometry,
        this.geometry.cachedPositions
      ),
      (this.needsUpdate = !1);
  }
}
class LightSphereGeometry extends MR {
  constructor(e) {
    super(e),
      publicField(this, "isLightSphereGeometry", !0),
      publicField(this, "_needsUpdate", !1),
      publicField(this, "setModelData", () => {
        (this._needsUpdate = !0), this.updateGeometry();
      }),
      (this.type = "LightSphereGeometry"),
      (this.parameters = e),
      this.setModelData();
  }
  updateGeometry() {
    const e = [],
      t = [],
      i = [],
      n = [];
    let s = this.parameters.radius || 10,
      r = this.parameters.widthSegments || 32,
      a = this.parameters.heightSegments || 16,
      o = this.parameters.phiStart || 0,
      l = this.parameters.phiLength || 2 * Math.PI,
      h = this.parameters.thetaStart || 0,
      c = this.parameters.thetaLength || Math.PI;
    (this.parameters.widthSegments = Math.max(3, Math.floor(r))),
      (this.parameters.heightSegments = Math.max(2, Math.floor(a)));
    const u = Math.min(h + c, Math.PI);
    let d = 0;
    const p = [],
      f = new Vector3(),
      m = new Vector3();
    for (let g = 0; g <= a; g++) {
      const e = [],
        _ = g / a;
      let v = 0;
      0 === g && 0 === h
        ? (v = 0.5 / r)
        : g === a && u === Math.PI && (v = -0.5 / r);
      for (let a = 0; a <= r; a++) {
        const u = a / r;
        (f.x = -s * Math.cos(o + u * l) * Math.sin(h + _ * c)),
          (f.y = s * Math.cos(h + _ * c)),
          (f.z = s * Math.sin(o + u * l) * Math.sin(h + _ * c)),
          t.push(f.x, f.y, f.z),
          m.copy(f).normalize(),
          i.push(m.x, m.y, m.z),
          n.push(u + v, 1 - _),
          e.push(d++);
      }
      p.push(e);
    }
    for (let g = 0; g < a; g++)
      for (let t = 0; t < r; t++) {
        const i = p[g][t + 1],
          n = p[g][t],
          s = p[g + 1][t],
          r = p[g + 1][t + 1];
        (0 !== g || h > 0) && e.push(i, n, r),
          (g !== a - 1 || u < Math.PI) && e.push(n, s, r);
      }
    this.setIndex(e),
      this.setAttribute("position", new Ki(t, 3)),
      this.setAttribute("normal", new Ki(i, 3)),
      this.setAttribute("uv", new Ki(n, 2)),
      (this._needsUpdate = !1);
  }
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
}
const oL = In.merge([
  { color: { value: [0, 0.7, 1, 1] }, isEmissive: { value: !1 } },
]);
class lL extends PR {
  constructor(e) {
    super(e),
      publicField(this, "type", "LightSphereMaterial"),
      publicField(this, "isLightSphereMaterial", !0),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nvarying vec3 vNormal;\nuniform float elapsedTime;\nuniform bool animationEffect;\nuniform float animationEffectPeriod;\n\nvoid main() {\n    vNormal = normalize(normalMatrix * normal); // 顶点的法向量执行插值计算\n    if (animationEffect) {\n        float scaleRatio = mod(elapsedTime, animationEffectPeriod) / animationEffectPeriod;\n        float t = sin(scaleRatio * 2.0 * PI) * 0.5 + 0.5;\n        vec3 newPosition = mix(position, position * 2.0, t);\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(newPosition, 1.0);\n    }\n    else {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n    }\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nvarying vec3 vNormal;\nuniform vec4 color;\n\nvoid main() {\n    vec3 z = vec3(0.0, 0.0, 1.0); // z轴方向单位向量\n    float x = abs(dot(vNormal, z)); // 点乘结果余弦值绝对值范围[0,1]\n    float alpha = pow(1.0 - x, 2.0);\n    gl_FragColor = vec4(vec3(color[0], color[1], color[2]), alpha);\n}"),
      Object.assign(this.uniforms, In.clone(oL)),
      N_(this, ["maxHeight", "isEmissive"]),
      this.setValues(e);
  }
}
class hL extends MR {
  constructor(e) {
    super(e),
      publicField(this, "_needsUpdate", !1),
      publicField(this, "setModelData", () => {
        (this._needsUpdate = !0), this.updateGeometry();
      }),
      (this.parameters = {
        ...e,
        radiusTop: e.radiusTop || e.radius || 6,
        radiusBottom: e.radiusBottom || e.radius || 6,
        height: e.height || 50,
        openEnded: e.openEnded || !1,
        color: e.color || [80, 20, 170, 0.8],
        isLight: e.isLight || !0,
        lightPos: e.lightPos || 60,
      }),
      (this.parameters.radialSegments = e.radialSegments
        ? Math.floor(e.radialSegments)
        : 4),
      (this.parameters.heightSegments = e.heightSegments
        ? Math.floor(e.heightSegments)
        : 1),
      this.setModelData();
  }
  updateGeometry() {
    const e = [],
      t = [],
      i = [],
      n = [],
      s = [];
    let r = { index: 0, indexArray: [], halfHeight: 0, groupStart: 0 };
    this.generateTorso(e, t, i, n, s, r),
      !1 === this.parameters.openEnded &&
        (this.parameters.radiusTop > 0 &&
          this.generateCap(!0, e, t, i, n, s, r),
        this.parameters.radiusBottom > 0 &&
          this.generateCap(!1, e, t, i, n, s, r)),
      this.addCustomGeometry(e, t, i, n, s, r),
      this.setIndex(e),
      this.setAttribute("position", new Ki(t, 3)),
      this.setAttribute("normal", new Ki(i, 3)),
      this.setAttribute("uv", new Ki(n, 2)),
      this.addCustomAttribute(s),
      (this._needsUpdate = !1);
  }
  addCustomGeometry() {}
  addCustomAttribute() {}
  generateCap(e, t, i, n, s, r, a) {}
  generateTorso(e, t, i, n, s, r) {}
  get needsUpdate() {
    return this._needsUpdate;
  }
  set needsUpdate(e) {
    this._needsUpdate = e;
  }
}
class cL extends hL {
  constructor(e) {
    super(e),
      (this.type = "GridGeometry"),
      (this.parameters.multiColor = e.multiColor || []),
      (this.parameters.isMultiColor = e.isMultiColor || !1);
  }
  generateTorso(e, t, i, n, s, r) {
    const a = new Vector3(),
      o = new Vector3();
    let l = 0;
    const h =
      (this.parameters.radiusBottom - this.parameters.radiusTop) /
      this.parameters.height;
    for (let c = 0; c <= this.parameters.heightSegments; c++) {
      const e = [],
        l = c / this.parameters.heightSegments,
        u =
          (1 - l) * this.parameters.radiusBottom +
          l * this.parameters.radiusTop;
      for (let c = 0; c <= this.parameters.radialSegments; c++) {
        const d = c / this.parameters.radialSegments,
          p = 2 * d * Math.PI,
          f = Math.sin(p),
          m = Math.cos(p);
        (o.x = u * f),
          (o.y = u * m),
          (o.z = l * this.parameters.height),
          t.push(o.x, o.y, o.z),
          this.parameters.isMultiColor &&
            Array.isArray(this.parameters.multiColor) &&
            this.addMultiColors("torso", s, o.z),
          a.set(f, m, h).normalize(),
          i.push(a.x, a.y, a.z),
          n.push(d, l),
          e.push(r.index++);
      }
      r.indexArray.push(e);
    }
    for (let c = 0; c < this.parameters.radialSegments; c++)
      for (let t = 0; t < this.parameters.heightSegments; t++) {
        const i = r.indexArray[t][c],
          n = r.indexArray[t + 1][c],
          s = r.indexArray[t + 1][c + 1],
          a = r.indexArray[t][c + 1];
        e.push(i, n, a), e.push(n, s, a), (l += 6);
      }
    this.addGroup(r.groupStart, l, 0), (r.groupStart += l);
  }
  generateCap(e, t, i, n, s, r, a) {
    const o = a.index,
      l = new Vector2(),
      h = new Vector3();
    let c = 0;
    const u =
        !0 === e ? this.parameters.radiusTop : this.parameters.radiusBottom,
      d = !0 === e ? 1 : 0,
      p = e ? 1 : -1;
    for (let m = 1; m <= this.parameters.radialSegments; m++)
      this.parameters.isMultiColor &&
        Array.isArray(this.parameters.multiColor) &&
        this.addMultiColors("cap", r, this.parameters.height * d),
        i.push(0, 0, this.parameters.height * d),
        n.push(0, 0, p),
        s.push(0.5, 0.5),
        a.index++;
    const f = a.index;
    for (let m = 0; m <= this.parameters.radialSegments; m++) {
      const e = 2 * (m / this.parameters.radialSegments) * Math.PI,
        t = Math.cos(e),
        o = Math.sin(e);
      (h.x = u * o),
        (h.y = u * t),
        (h.z = this.parameters.height * d),
        i.push(h.x, h.y, h.z),
        this.parameters.isMultiColor &&
          Array.isArray(this.parameters.multiColor) &&
          this.addMultiColors("cap", r, h.z),
        n.push(0, 0, p),
        (l.x = 0.5 * t + 0.5),
        (l.y = 0.5 * o * d + 0.5),
        s.push(l.x, l.y),
        a.index++;
    }
    for (let m = 0; m < this.parameters.radialSegments; m++) {
      const i = o + m,
        n = f + m;
      !0 === e ? t.push(n, n + 1, i) : t.push(n + 1, n, i), (c += 3);
    }
    this.addGroup(a.groupStart, c, !0 === e ? 1 : 2), (a.groupStart += c);
  }
  addCustomAttribute(e) {
    this.parameters.isMultiColor && this.setAttribute("mColor", new Ki(e, 4));
  }
  addMultiColors(e, t, i) {
    const n = this.parameters.multiColor.map((e) => colorToArr4(e));
    if ("cap" === e)
      i === this.parameters.height
        ? t.push(...n[n.length - 1])
        : t.push(...n[0]);
    else if ("torso" === e && this.parameters.heightSegments <= n.length) {
      const e = this.parameters.height / this.parameters.heightSegments;
      for (let s = 0; s <= this.parameters.heightSegments; s++)
        i === e * s && t.push(...n[s]);
    }
  }
}
const uL = In.merge([
  {
    color: { value: [0, 0.7, 0.9, 1] },
    lightPos: { value: 60 },
    isEmissive: { value: !1 },
  },
]);
class dL extends PR {
  constructor(e) {
    super(e),
      publicField(this, "type", "GridMaterial"),
      publicField(this, "isGridMaterial", !0),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nattribute vec4 mColor;\n\nvarying vec3 vPosition;\nvarying vec4 vColor;\nuniform vec4 color;\n\nvoid main() {\n\n    #ifdef USE_MULTICOLOR\n        vColor = mColor;\n    #else\n        vColor = color;\n    #endif\n\n    vPosition = position;\n\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nvarying vec3 vPosition;\nuniform vec4 color;\nuniform float lightPos;\nvarying vec4 vColor;\n\nvoid main() {\n\n    #ifdef USE_LIGHT\n        float a = 1.0 - vPosition.z / lightPos;\n        if (a <= 0.) {\n            discard;\n        }\n    #else\n        float a = vColor.a;\n    #endif\n    \n    gl_FragColor = vec4(vec3(vColor[0], vColor[1], vColor[2]), a);\n}"),
      (this.side = 2),
      (this.transparent = !0),
      Object.assign(this.uniforms, In.clone(uL)),
      N_(this, ["lightPos", "isEmissive"]),
      O_(this, [
        ["isMultiColor", "USE_MULTICOLOR"],
        ["isLight", "USE_LIGHT"],
      ]),
      this.setValues(e);
  }
}
class pL extends hL {
  constructor(e) {
    super(e), (this.type = "PillarGeometry");
  }
  generateTorso(e, t, i, n, s, r) {
    const a = new Vector3(),
      o = new Vector3();
    let l = 0;
    for (let h = 0; h <= this.parameters.heightSegments; h++) {
      const e = [],
        s = h / this.parameters.heightSegments,
        l = this.parameters.radius;
      for (let h = 0; h <= this.parameters.radialSegments; h++) {
        const c = h / this.parameters.radialSegments,
          u = 2 * c * Math.PI,
          d = Math.sin(u),
          p = Math.cos(u);
        (o.x = l * d),
          (o.y = l * p),
          this.parameters.vertexHeights
            ? (o.z = s)
            : (o.z = s * this.parameters.height),
          t.push(o.x, o.y, o.z),
          a.set(d, p, 0).normalize(),
          i.push(a.x, a.y, a.z),
          n.push(c, s),
          e.push(r.index++);
      }
      r.indexArray.push(e);
    }
    for (let h = 0; h < this.parameters.radialSegments; h++)
      for (let t = 0; t < this.parameters.heightSegments; t++) {
        const i = r.indexArray[t][h],
          n = r.indexArray[t + 1][h],
          s = r.indexArray[t + 1][h + 1],
          a = r.indexArray[t][h + 1];
        e.push(i, n, a), e.push(n, s, a), (l += 6);
      }
    this.addGroup(r.groupStart, l, 0), (r.groupStart += l);
  }
  generateCap(e, t, i, n, s, r, a) {
    const o = a.index,
      l = new Vector3();
    let h = 0;
    const c = this.parameters.radius,
      u = !0 === e ? 1 : 0,
      d = e ? 1 : -1;
    for (let f = 1; f <= this.parameters.radialSegments; f++)
      this.parameters.vertexHeights
        ? i.push(0, 0, u)
        : i.push(0, 0, u * this.parameters.height),
        n.push(0, 0, d),
        s.push(0.5, u),
        a.index++;
    const p = a.index;
    for (let f = 0; f <= this.parameters.radialSegments; f++) {
      const e = 2 * (f / this.parameters.radialSegments) * Math.PI,
        t = Math.cos(e),
        r = Math.sin(e);
      (l.x = c * r),
        (l.y = c * t),
        this.parameters.vertexHeights
          ? (l.z = u)
          : (l.z = u * this.parameters.height),
        i.push(l.x, l.y, l.z),
        n.push(0, 0, d),
        s.push(0.5, u),
        a.index++;
    }
    for (let f = 0; f < this.parameters.radialSegments; f++) {
      const i = o + f,
        n = p + f;
      !0 === e ? t.push(n, n + 1, i) : t.push(n + 1, n, i), (h += 3);
    }
    this.addGroup(a.groupStart, h, !0 === e ? 1 : 2), (a.groupStart += h);
  }
}
const fL = In.merge([
  {
    color: { value: [0, 0.7, 0.9, 1] },
    lightPos: { value: 60 },
    gradientMap: { value: null },
    maxHeight: { value: 50 },
    vertexHeights: { value: !1 },
    isEmissive: { value: !1 },
  },
]);
class mL extends PR {
  constructor(e) {
    super(e),
      publicField(this, "type", "PillarMaterial"),
      publicField(this, "isGridMaterial", !0),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform float maxHeight;\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n    gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n\n    #ifdef MVT_USE_VERTEX_HEIGHT\n        float instanceHeight = instanceMatrix[2][2];\n        vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));\n    #else\n        vUv = uv;\n    #endif\n\n    #include <logdepthbuf_vertex>\n}"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D gradientMap;\nuniform float opacity;\n\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    gl_FragColor = texture2D(gradientMap, vUv.yx);\n    gl_FragColor.a *= opacity;\n\n    #include <logdepthbuf_fragment>\n}"),
      (this.side = 2),
      (this.transparent = !0),
      N_(this, ["maxHeight", "isEmissive"]),
      O_(this, [["vertexHeights", "MVT_USE_VERTEX_HEIGHT"]]),
      Object.assign(this.uniforms, In.clone(fL)),
      (this._cachedGradient = null),
      Object.defineProperties(this, {
        gradient: {
          get: function () {
            return this._cachedGradient;
          },
          set: function (e) {
            (this._cachedGradient = e), this.updateGradientMap();
          },
        },
      }),
      this.createGradientMap(),
      (this.uniforms.gradientMap.value = this._cachedGradientMap),
      this.setValues(e);
  }
  createGradientMap() {
    let e = document.createElement("canvas");
    (e.width = 64), (e.height = 2);
    let t = e.getContext("2d"),
      i = t.createLinearGradient(0, 0, 64, 0);
    i.addColorStop(0, "rgba(0,0,255,1)"),
      i.addColorStop(0.3, "rgba(0,255,0,1)"),
      i.addColorStop(0.6, "rgba(255,255,0,1)"),
      i.addColorStop(1, "rgba(255,0,0,1)"),
      (t.fillStyle = i),
      t.fillRect(0, 0, 64, 2),
      (this._cachedGradientMap = new CanvasTexture(e));
  }
  updateGradientMap() {
    let e = this._cachedGradient;
    if ("[object Object]" !== Object.prototype.toString.call(e)) return;
    let t = this._cachedGradientMap.image.getContext("2d");
    t.clearRect(0, 0, 64, 2);
    let i = t.createLinearGradient(0, 0, 64, 0);
    for (const n in e)
      Object.hasOwnProperty.call(e, n) && i.addColorStop(n, e[n]);
    (t.fillStyle = i),
      t.fillRect(0, 0, 64, 2),
      (this._cachedGradientMap.needsUpdate = !0);
  }
  dispose() {
    this._cachedGradientMap && this._cachedGradientMap.dispose(),
      super.dispose();
  }
}
class gL extends hL {
  constructor(e) {
    super(e), (this.type = "PillarGeometry");
  }
  addRadiusFunc(e) {
    return 1 - Math.sqrt(e);
  }
  generateTorso(e, t, i, n, s, r) {
    const a = new Vector3();
    let o = 0;
    for (let l = 0; l <= this.parameters.heightSegments; l++) {
      const e = [],
        i = l / this.parameters.heightSegments;
      let s = this.addRadiusFunc(i);
      this.parameters.vertexSizes || (s *= this.parameters.size);
      for (let o = 0; o <= this.parameters.radialSegments; o++) {
        const l = o / this.parameters.radialSegments,
          h = 2 * l * Math.PI,
          c = Math.sin(h),
          u = Math.cos(h);
        (a.x = s * c),
          (a.y = s * u),
          this.parameters.vertexHeights
            ? (a.z = i)
            : (a.z = i * this.parameters.height),
          t.push(a.x, a.y, a.z),
          n.push(l, i),
          e.push(r.index++);
      }
      r.indexArray.push(e);
    }
    for (let l = 0; l < this.parameters.radialSegments; l++)
      for (let t = 0; t < this.parameters.heightSegments; t++) {
        const i = r.indexArray[t][l],
          n = r.indexArray[t + 1][l],
          s = r.indexArray[t + 1][l + 1],
          a = r.indexArray[t][l + 1];
        e.push(i, n, a), e.push(n, s, a), (o += 6);
      }
    this.addGroup(r.groupStart, o, 0), (r.groupStart += o);
  }
  generateCap(e, t, i, n, s, r, a) {
    if (e) return;
    const o = a.index,
      l = new Vector3();
    let h = 0;
    const c = this.parameters.vertexSizes ? 1 : this.parameters.size,
      u = !0 === e ? 1 : 0;
    for (let p = 1; p <= this.parameters.radialSegments; p++)
      this.parameters.vertexHeights
        ? i.push(0, 0, u)
        : i.push(0, 0, u * this.parameters.height),
        s.push(0.5, u),
        a.index++;
    const d = a.index;
    for (let p = 0; p <= this.parameters.radialSegments; p++) {
      const e = 2 * (p / this.parameters.radialSegments) * Math.PI,
        t = Math.cos(e),
        n = Math.sin(e);
      (l.x = c * n),
        (l.y = c * t),
        this.parameters.vertexHeights
          ? (l.z = u)
          : (l.z = u * this.parameters.height),
        i.push(l.x, l.y, l.z),
        s.push(0.5, u),
        a.index++;
    }
    for (let p = 0; p < this.parameters.radialSegments; p++) {
      const i = o + p,
        n = d + p;
      !0 === e ? t.push(n, n + 1, i) : t.push(n + 1, n, i), (h += 3);
    }
    this.addGroup(a.groupStart, h, !0 === e ? 1 : 2), (a.groupStart += h);
  }
  generateTopSphere(e, t, i, n, s, r) {
    this.parameters.sphereIndex = r.index;
    const a = new Vector3(),
      o = r.indexArray.length;
    let l = 0;
    for (let h = 0; h <= 16; h++) {
      const e = (h * Math.PI) / 16,
        i = Math.sin(e),
        s = Math.cos(e),
        o = [];
      for (let l = 0; l <= 32; l++) {
        const e = (2 * l * Math.PI) / 32,
          h = Math.sin(e),
          c = Math.cos(e);
        (a.x = 10 * h * i),
          (a.y = 10 * c * i),
          (a.z = 10 * s),
          this.parameters.vertexHeights || (a.z += this.parameters.height),
          t.push(a.x, a.y, a.z),
          n.push(0.5, 1),
          o.push(r.index++);
      }
      r.indexArray.push(o);
    }
    for (let h = 0; h < 16; h++)
      for (let t = 0; t < 32; t++) {
        const i = o + h,
          n = r.indexArray[i][t + 1],
          s = r.indexArray[i][t],
          a = r.indexArray[i + 1][t],
          c = r.indexArray[i + 1][t + 1];
        e.push(n, s, c), e.push(s, a, c), (l += 6);
      }
    this.addGroup(r.groupStart, l, 0), (r.groupStart += l);
  }
  addCustomGeometry(e, t, i, n, s, r) {
    this.generateTopSphere(e, t, i, n, s, r);
  }
}
const _L = In.merge([
  {
    isEmissive: { value: !1 },
    color: { value: [0, 0.7, 0.9, 1] },
    gradientMap: { value: null },
    maxHeight: { value: 50 },
    sphereIndex: { value: 0 },
    vertexHeights: { value: !1 },
  },
]);
class vL extends PR {
  constructor(e) {
    super(e),
      publicField(this, "type", "PillarMaterial"),
      publicField(this, "isGridMaterial", !0),
      (this.vertexShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform float maxHeight;\nuniform int sphereIndex;\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n    // 球体和非球体部分使用不同的规则\n    if(gl_VertexID < sphereIndex) {\n        gl_Position = projectionMatrix * modelViewMatrix * instanceMatrix * vec4(position, 1.0);\n    } else {\n        float xOffset = instanceMatrix[3][0];\n        float yOffset = instanceMatrix[3][1];\n        float height = instanceMatrix[2][2];\n        gl_Position = projectionMatrix * modelViewMatrix * vec4(position.x + xOffset\n        , position.y + yOffset\n        , position.z + height, 1.0);\n    }\n    \n    #ifdef MVT_USE_VERTEX_HEIGHT\n        float instanceHeight = instanceMatrix[2][2];\n        vUv = vec2(uv.x, uv.y * (instanceHeight / maxHeight));\n    #else\n        vUv = uv;\n    #endif\n\n    #include <logdepthbuf_vertex>\n}\n"),
      (this.fragmentShader =
        "#define GLSLIFY 1\n#include <common>\n\nuniform sampler2D gradientMap;\nuniform float opacity;\n\nvarying vec2 vUv;\n\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n    gl_FragColor = texture2D(gradientMap, vUv.yx);\n    gl_FragColor.a *= opacity;\n\n    #include <logdepthbuf_fragment>\n}"),
      (this.side = h),
      (this.transparent = !0),
      N_(this, ["maxHeight", "sphereIndex", "isEmissive"]),
      O_(this, [["vertexHeights", "MVT_USE_VERTEX_HEIGHT"]]),
      Object.assign(this.uniforms, In.clone(_L)),
      (this._cachedGradient = null),
      Object.defineProperties(this, {
        gradient: {
          get: function () {
            return this._cachedGradient;
          },
          set: function (e) {
            (this._cachedGradient = e), this.updateGradientMap();
          },
        },
      }),
      this.createGradientMap(),
      (this.uniforms.gradientMap.value = this._cachedGradientMap),
      this.setValues(e);
  }
  createGradientMap() {
    let e = document.createElement("canvas");
    (e.width = 64), (e.height = 2);
    let t = e.getContext("2d"),
      i = t.createLinearGradient(0, 0, 64, 0);
    i.addColorStop(0, "rgba(0,0,255,1)"),
      i.addColorStop(0.3, "rgba(0,255,0,1)"),
      i.addColorStop(0.6, "rgba(255,255,0,1)"),
      i.addColorStop(1, "rgba(255,0,0,1)"),
      (t.fillStyle = i),
      t.fillRect(0, 0, 64, 2),
      (this._cachedGradientMap = new CanvasTexture(e));
  }
  updateGradientMap() {
    let e = this._cachedGradient;
    if ("[object Object]" !== Object.prototype.toString.call(e)) return;
    let t = this._cachedGradientMap.image.getContext("2d");
    t.clearRect(0, 0, 64, 2);
    let i = t.createLinearGradient(0, 0, 64, 0);
    for (const n in e)
      Object.hasOwnProperty.call(e, n) && i.addColorStop(n, e[n]);
    (t.fillStyle = i),
      t.fillRect(0, 0, 64, 2),
      (this._cachedGradientMap.needsUpdate = !0);
  }
  dispose() {
    this.uniforms.map.value && this.uniforms.map.value.dispose(),
      super.dispose();
  }
}
const AL = new $l(),
  yL = new zn(new Vector3(0, 0, 1), 0),
  xL = new Vector3();
class bL extends Object3D {
  constructor(e = {}) {
    super(e),
      publicField(this, "_container"),
      publicField(this, "_point"),
      publicField(this, "_dom"),
      publicField(this, "_div"),
      publicField(this, "_visible"),
      publicField(this, "_offset"),
      publicField(this, "_stopPropagation", !1),
      publicField(this, "_enableDragging", !1),
      publicField(this, "handleMouseDown", (e) => {
        const t = this.engine.rendering.canvas.getBoundingClientRect();
        (this._sub = new Vector2().set(
          this._screenPos.x - e.x + t.left,
          this._screenPos.y - e.y + t.top
        )),
          (this.stopPropagation || this.enableDragging) && e.stopPropagation(),
          this.dom.addEventListener(hy.MOVE, this.handleMouseMove);
      }),
      publicField(this, "handleMouseUp", (e) => {
        this.dom.removeEventListener(hy.MOVE, this.handleMouseMove);
      }),
      publicField(this, "handleMouseMove", (e) => {
        e.preventDefault();
        const t = this.engine,
          i = t.rendering.canvas.getBoundingClientRect(),
          n = e.clientX + this._sub.x - i.left,
          s = e.clientY + this._sub.y - i.top,
          r = (n / i.width) * 2 - 1,
          a = 1 - (2 * s) / i.height;
        AL.setFromCamera({ x: r, y: a }, t.rendering.camera),
          AL.ray.intersectPlane(yL, xL);
        const o = [xL.x, xL.y, xL.z],
          l = t.map.unprojectPointArr(o);
        this.point = [l[0], l[1], this.point[2]];
      }),
      publicField(this, "handleWheel", (e) => {
        (this.stopPropagation || this.enableDragging) && e.stopPropagation();
      }),
      (this.isDOMOverlay = !0),
      (this.parameters = e),
      (this._div = document.getElementById(`${t}-overlay`)),
      this._div ||
        ((this._div = document.createElement("div")),
        (this._div.id = `${t}-overlay`),
        i(this._div, `${t}-overlay-pane`));
  }
  afterAddToEngine(e) {
    this.engine = e;
    const i = e.container,
      n =
        i instanceof HTMLElement ||
        (i &&
          "object" == typeof i &&
          1 === i.nodeType &&
          "string" == typeof i.nodeName);
    this._container = n ? i : i.container || i._container;
    document.getElementById(`${t}-overlay`) ||
      this._container.appendChild(this._div),
      (this.dom = this.initDom()),
      (this.point = this.parameters.point || []),
      (this.offset = this.parameters.offset || [0, 0]),
      (this.className = this.parameters.className || ""),
      (this.enableDragging = this.parameters.enableDragging || !1),
      (this.visible = this.parameters.visible || !0),
      this.afterInit();
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  initDom() {
    if (this.parameters.dom) return this.parameters.dom;
    console.warn("`DOMOverlay` must contain a property `dom`.");
  }
  afterInit() {}
  onBeforeScenePrepareRender(e, s, r) {
    if (this.dom && this.visible) {
      (this.camera = r), (this.renderer = e.renderer);
      let s = new Vector2();
      e.renderer.getSize(s);
      const a = this.position.clone().project(r);
      a.z > 1 || a.z < 0
        ? i(this.dom, `${t}-hidden`)
        : n(this.dom, `${t}-hidden`);
      const o = ((1 + a.x) * s.x) / 2,
        l = ((1 - a.y) * s.y) / 2,
        h = this.dom.clientWidth,
        c = this.dom.clientHeight;
      let u,
        d,
        p = o - h / 2 + this.offset[0],
        f = o + h / 2 + this.offset[0];
      if (
        (this.isPopup
          ? ((u = l - c + this.offset[1]), (d = l + this.offset[1]))
          : ((u = l - c / 2 + this.offset[1]),
            (d = l + c / 2 + this.offset[1])),
        f < 0 || p > s.x || d < 0 || u > s.y)
      )
        return void (
          "hidden" !== this.dom.style.visibility &&
          (this.dom.style.visibility = "hidden")
        );
      (this.dom.style.position = "absolute"),
        "hidden" === this.dom.style.visibility &&
          (this.dom.style.visibility = "visible"),
        (this.dom.style.left = p + "px"),
        (this.dom.style.top = u + "px");
      const m = new Vector3(this.position.x, this.position.y, 0)
          .clone()
          .project(r),
        g = ((1 + m.x) * s.x) / 2,
        _ = ((1 - m.y) * s.y) / 2;
      (this._screenPos = new Vector2().set(g, _)),
        this.enableDragging
          ? ((this.dom.ondragstart = null),
            (this.dom.style.touchAction = "auto"))
          : ((this.dom.ondragstart = () => !1),
            (this.dom.style.touchAction = "none"));
    }
  }
  onDispose() {}
  dispose() {
    this.onDispose(),
      this.enableDragging &&
        (this.dom.removeEventListener(hy.DOWN, this.handleMouseDown),
        this.dom.removeEventListener(hy.UP, this.handleMouseUp)),
      this.dom.removeEventListener("wheel", this.handleWheel),
      this.dom.remove(),
      0 === this._div.childElementCount && this._div.remove();
  }
  get dom() {
    return this._dom;
  }
  set dom(e) {
    if (
      (this._dom &&
        (this.enableDragging &&
          (this._dom.removeEventListener(hy.DOWN, this.handleMouseDown),
          this._dom.removeEventListener(hy.UP, this.handleMouseUp)),
        this._div.removeChild(this._dom)),
      "string" == typeof e)
    ) {
      const n = document.createElement("div");
      i(n, `${t}-dom-overlay-custom`);
      const s = new DOMParser().parseFromString(e, "text/html").body.children;
      for (let e = 0; e < s.length; e++) n.appendChild(s.item(e));
      this._dom = n;
    } else this._dom = e;
    this._div.appendChild(this._dom),
      (this._dom.style.visibility = this.visible ? "visble" : "hidden"),
      this.enableDragging &&
        (this._dom.addEventListener(hy.DOWN, this.handleMouseDown),
        this._dom.addEventListener(hy.UP, this.mouseup),
        (this._dom.style.cursor = "pointer")),
      this._dom.addEventListener("wheel", this.handleWheel);
  }
  get point() {
    return this._point;
  }
  set point(e) {
    Array.isArray(e) &&
      e.length > 1 &&
      ((this._point = e),
      this.engine && this.position.set(...this.engine.map.projectPointArr(e)));
  }
  get visible() {
    return this._visible;
  }
  set visible(e) {
    e !== this._visible &&
      ((this._visible = e),
      this.dom && (this.dom.style.visibility = e ? "visible" : "hidden"));
  }
  get offset() {
    return this._offset;
  }
  set offset(e) {
    this._offset = e;
  }
  get stopPropagation() {
    return this._stopPropagation;
  }
  set stopPropagation(e) {
    this._stopPropagation = e;
  }
  get enableDragging() {
    return this._enableDragging;
  }
  set enableDragging(e) {
    this._enableDragging !== e &&
      ((this._enableDragging = e),
      this.dom &&
        (e
          ? (this.dom.addEventListener(hy.DOWN, this.handleMouseDown),
            this.dom.addEventListener(hy.UP, this.handleMouseUp),
            (this.dom.style.cursor = "pointer"))
          : (this.dom.removeEventListener(hy.DOWN, this.handleMouseDown),
            this.dom.removeEventListener(hy.UP, this.handleMouseUp),
            (this.dom.style.cursor = "auto"))));
  }
  get className() {
    return this._className;
  }
  set className(e) {
    e !== this._className &&
      (this.dom &&
        (this._className && n(this.dom, this._className), i(this.dom, e)),
      (this._className = e));
  }
}
const EL = {
    pars: "\n        uniform float minAltitude;\n        uniform float maxAltitude;\n        #ifdef USE_NOISE_MAP\n            varying vec2 vWorldXy;\n        #endif\n    ",
    main_after:
      "\n        vUv.x = (clamp(position.y, minAltitude, maxAltitude) - minAltitude) / (maxAltitude - minAltitude);\n        vUv.y = 0.5;\n        #ifdef USE_NOISE_MAP\n            vWorldXy = worldPosition.xy;\n        #endif\n    ",
  },
  SL = {
    pars: "\n        #ifdef USE_NOISE_MAP\n            uniform sampler2D noiseMap;\n            uniform float noiseUvScale;\n            uniform float noiseScale;\n            uniform float noiseBais;\n            varying vec2 vWorldXy;\n        #endif\n    ",
    main_before:
      "\n        #ifdef USE_NOISE_MAP\n            vec2 noiseUv = mod(vWorldXy, 1000.0) * noiseUvScale;\n            uv.x = clamp(uv.x + noiseScale * (texture2D(noiseMap, noiseUv).y + noiseBais), 0.0, 1.0);\n        #endif\n    ",
    color_after:
      "\n    // diffuseColor.x = uv.x;\n    // diffuseColor.y = 0.0;\n    // diffuseColor.z = 0.0;\n    ",
  };
const CL = new ii(0, 0, 0, "ZXY"),
  ML = new Vector3(),
  wL = { type: "change" },
  TL = { type: "lock" },
  IL = { type: "unlock" },
  RL = Math.PI / 2;
class PL extends EventDispatcher {
  constructor(e, t) {
    super(),
      void 0 === t &&
        (console.warn(
          'THREE.PointerLockControls: The second parameter "domElement" is now mandatory.'
        ),
        (t = document.body)),
      (this.domElement = t),
      (this.isLocked = !1),
      (this.minPolarAngle = 0),
      (this.maxPolarAngle = Math.PI),
      (this.pointerSpeed = 1);
    const i = this;
    function n(t) {
      if (!1 === i.isLocked) return;
      const n = t.movementX || t.mozMovementX || t.webkitMovementX || 0,
        s = t.movementY || t.mozMovementY || t.webkitMovementY || 0;
      CL.setFromQuaternion(e.quaternion),
        (CL.z -= 0.002 * n * i.pointerSpeed),
        (CL.x -= 0.002 * s * i.pointerSpeed),
        (CL.x = Math.max(
          RL - i.maxPolarAngle,
          Math.min(RL - i.minPolarAngle, CL.x)
        )),
        e.quaternion.setFromEuler(CL),
        i.dispatchEvent(wL);
    }
    function s() {
      i.domElement.ownerDocument.pointerLockElement === i.domElement
        ? (i.dispatchEvent(TL), (i.isLocked = !0))
        : (i.dispatchEvent(IL), (i.isLocked = !1));
    }
    function r() {
      console.error(
        "THREE.PointerLockControls: Unable to use Pointer Lock API"
      );
    }
    (this.connect = function () {
      i.domElement.ownerDocument.addEventListener("mousemove", n),
        i.domElement.ownerDocument.addEventListener("pointerlockchange", s),
        i.domElement.ownerDocument.addEventListener("pointerlockerror", r);
    }),
      (this.disconnect = function () {
        i.domElement.ownerDocument.removeEventListener("mousemove", n),
          i.domElement.ownerDocument.removeEventListener(
            "pointerlockchange",
            s
          ),
          i.domElement.ownerDocument.removeEventListener("pointerlockerror", r);
      }),
      (this.dispose = function () {
        this.disconnect();
      }),
      (this.getObject = function () {
        return e;
      }),
      (this.getDirection = (function () {
        const t = new Vector3(0, 0, -1);
        return function (i) {
          return i.copy(t).applyQuaternion(e.quaternion);
        };
      })()),
      (this.moveForward = function (t) {
        ML.setFromMatrixColumn(e.matrix, 0),
          ML.crossVectors(e.up, ML),
          e.position.addScaledVector(ML, t);
      }),
      (this.moveRight = function (t) {
        ML.setFromMatrixColumn(e.matrix, 0), e.position.addScaledVector(ML, t);
      }),
      (this.lock = function () {
        this.domElement.requestPointerLock();
      }),
      (this.unlock = function () {
        i.domElement.ownerDocument.exitPointerLock();
      }),
      this.connect();
  }
}
const DL = "follow",
  LL = "lock",
  FL = "unlock",
  NL = "keyFrame",
  BL = "activeFrame";
class kL extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_enabled", !1),
      publicField(this, "_drawedGraph", []),
      publicField(this, "_transformBox", null),
      publicField(this, "_trnasformIndex", null),
      publicField(this, "_completedDataSource", null),
      publicField(this, "_completedElement", null),
      publicField(this, "_selectedIndex", -1),
      publicField(this, "_stage", 0),
      publicField(this, "_isAdd", !1),
      publicField(this, "_is2D", !1);
  }
  afterAddToEngine() {
    this.initObjects();
  }
  initObjects() {}
  initEvents() {}
  reset() {
    this.clearBuffers(),
      (this._trnasformIndex = null),
      (this._transformBox = null),
      (this._stage = 0);
  }
  clearAll() {
    this.complete(),
      (this._drawedGraph = []),
      this._completedDataSource.setData(),
      this._engine.requestRender();
  }
  attachTransform(e, t = "z") {
    const i = new Cn(1, 1, 1),
      n = new Oi();
    (this._transformBox = new En(i, n)), this._transformBox.position.set(...e);
    let s = this._getNodeNormal(this._transformIndex).angle();
    (this._transformBox.rotation[t] = s),
      this._transformBox.scale.set(2, 2, 2),
      this._engine.add(this._transformBox),
      (this._transformBox.visible = !1),
      this._engine.selection.attachTransform(this._transformBox),
      this.is2D && (this._engine.selection.transformControl.showZ = !1);
  }
  detachTransform() {
    this.is2D && (this._engine.selection.transformControl.showZ = !0),
      this._transformBox &&
        (this._engine.selection.transformControl.removeEventListener(
          "objectChange",
          this._handleTransformChanging
        ),
        this._engine.selection.transformControl.removeEventListener(
          "pointerup",
          this._handleTransformChanged
        ),
        this._engine.selection.detachTransform(),
        this._engine.remove(this._transformBox),
        (this._transformBox = null));
  }
  _getTransformBoxState() {
    const e = this._transformBox,
      t = new Vector3(),
      i = new Vector3(),
      n = new Quaternion(),
      s = new ii();
    e.matrixWorld.decompose(t, n, i), s.setFromQuaternion(n);
    const r = this._engine,
      a = [t.x, t.y, t.z],
      o = r.map.unprojectPointArr(a),
      l = [s.x, s.y, s.z],
      h = i.x,
      c = i.y;
    return {
      point: o,
      position: a,
      width: h,
      height: i.z,
      length: c,
      angle: l,
    };
  }
  clearBuffers() {}
  unbindEvents() {}
  _getNodeNormal() {
    return new Vector2(0, 0);
  }
  complete() {
    if (1 !== this._stage && this._enabled) {
      if (this._isAdd) {
        const e = this.graphInfo(this.drawedGraph.length);
        this._drawedGraph.push(e);
      } else if (-1 !== this._selectedIndex) {
        const e = this.graphInfo(this._selectedIndex);
        this._drawedGraph.splice(this._selectedIndex, 1, e);
      }
      this.cancel();
    }
  }
  deepClone(e) {
    return JSON.parse(JSON.stringify(e));
  }
  cancel() {
    this._completedDataSource.setData();
    for (let e = 0; e < this._drawedGraph.length; e++)
      this._completedDataSource.add(this._drawedGraph[e].dataItem);
    this.detachTransform(),
      this.reset(),
      this.clearObjects(),
      this._engine.event.unbind(this._helpers, "click", this._handleNodeClick),
      this._engine.event.unbind("mousemove", this._handleAddMove),
      this._engine.event.unbind("click", this._handleAddFinish),
      this.initEvents(),
      (this._isAdd = !1),
      (this._selectedIndex = -1),
      this._engine.requestRender();
  }
  _handleNodeClick() {}
  _handleAddMove() {}
  _handleAddFinish() {}
  graphInfo() {}
  beforeRemoveFromEngine() {
    (this._drawedGraph = []),
      this._completedDataSource.setData(),
      this.dispose() && this.dispose();
  }
  get drawedGraph() {
    return this._drawedGraph;
  }
  get selectedIndex() {
    return this._selectedIndex;
  }
  get enabled() {
    return this._enabled;
  }
  get is2D() {
    return this._is2D;
  }
  set is2D(e) {
    this._is2D = e;
  }
  set enabled(e) {
    e !== this._enabled &&
      (e
        ? ((this._selectedIndex = -1), this.reset(), this.initEvents())
        : (this.complete(),
          this.detachTransform(),
          this.unbindEvents(),
          this.clearObjects()),
      (this._enabled = e));
  }
  exportToGeoJSON() {
    const e = [];
    let t;
    if (this.drawedGraph.length > 0) {
      const e = this.drawedGraph[0].dataItem.position;
      t = this._completedDataSource._getDataTypeByCoordinates(e);
    }
    for (let i = 0; i < this.drawedGraph.length; i++) {
      const { attributes: n } = this.drawedGraph[i].dataItem;
      let s;
      Array.isArray(n)
        ? ((s = n.map((e) => e.point)), "Polygon" === t && (s = [s]))
        : (s = n.point),
        e.push({
          type: "Feature",
          geometry: { type: t, coordinates: s },
          properties: this._getProperties(n),
        });
    }
    return { type: "FeatureCollection", features: e };
  }
  _getProperties(e) {
    return {};
  }
}
class OL extends kL {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_virtualLineBuffer", {
        position: [[]],
        index: [],
        payload: [],
      }),
      publicField(this, "_splineBuffer", {
        position: [[]],
        index: [],
        payload: [],
      }),
      publicField(this, "_helpersBuffer", {
        position: [],
        index: [],
        payload: [],
      }),
      publicField(this, "_engine"),
      publicField(this, "_options"),
      publicField(this, "_virtualLine"),
      publicField(this, "_virtualLineDataSource"),
      publicField(this, "_helpers"),
      publicField(this, "_helpersDataSource"),
      publicField(this, "_spline"),
      publicField(this, "_splineDataSource"),
      publicField(this, "_completedDataSource"),
      publicField(this, "_completedElement"),
      publicField(this, "_isAdd"),
      publicField(this, "_selectedIndex"),
      publicField(this, "_stage"),
      publicField(this, "_transformIndex"),
      publicField(this, "_lastDataItem"),
      publicField(this, "_handleCompleteClick", (e) => {
        if (1 !== this._stage) {
          this.complete(),
            (this._selectedIndex = e.entity.value.index),
            this._engine.event.unbind("click", this._handleAddClick),
            (this._lastDataItem = this._drawedGraph.slice(
              this._selectedIndex,
              this._selectedIndex + 1
            )),
            (this._stage = 2),
            this._completedDataSource.setData();
          for (let e = 0; e < this._drawedGraph.length; e++)
            e !== this._selectedIndex &&
              this._completedDataSource.add(this._drawedGraph[e].dataItem);
          (this._splineBuffer = this.deepClone(
            this._lastDataItem[0].splineBuffer
          )),
            this._splineDataSource.setData(this._splineBuffer),
            (this._helpersBuffer = this.deepClone(
              this._lastDataItem[0].helpersBuffer
            )),
            this._helpersDataSource.setData(this._helpersBuffer),
            this._engine.event.bind(
              this._helpers,
              "click",
              this._handleNodeClick
            ),
            this._engine.requestRender();
        }
      }),
      publicField(this, "_handleAddClick", (e) => {
        this._isAdd = !0;
        let t = this.length;
        if (0 === this._stage || 1 === this._stage) {
          if (
            ((this._stage = 1),
            this.length > 2 &&
              Av(e.position, this._helpersBuffer.position.slice(-1)[0]))
          )
            return (
              this.addNode(t, e.position, e.point), void this._handleAddFinish()
            );
          this.addNode(t, e.position, e.point),
            this.dispatchEvent({ type: "addNode", value: this.data }),
            this._engine.event.bind("mousemove", this._handleAddMove);
        }
        this._engine.requestRender();
      }),
      publicField(this, "_handleAddMove", (e) => {
        let t = this._helpersBuffer.position[this.length - 1],
          i = e.position;
        (this._virtualLineBuffer.position[0] = [t, i]),
          (this._virtualLineBuffer.index = [0]),
          this._virtualLineDataSource.setData(this._virtualLineBuffer),
          this.dispatchEvent({ type: "moveNode", value: i });
      }),
      publicField(this, "_handleAddFinish", (e) => {
        if (2 !== this.length) {
          if (1 === this._stage) {
            this._stage = 2;
            let e = this.length - 1;
            this._virtualLineDataSource.setData(), this.removeNode(e);
            for (let t = 0; t < this.length; t++) {
              this._splineBuffer.payload[t].angle =
                this._getNodeNormal(t).angle();
            }
            this.dispatchEvent({ type: "change", value: this.data });
          }
          this._engine.requestRender(),
            this._engine.event.unbind("click", this._handleAddClick),
            this._engine.event.unbind("mousemove", this._handleAddMove),
            this._engine.event.bind(
              this._helpers,
              "click",
              this._handleNodeClick
            ),
            this._engine.event.bind("click", this._handleCancelEdit);
        }
      }),
      publicField(this, "_handleNodeClick", (e) => {
        e.domEvent
          ? e.event.domEvent.preventDefault()
          : e.event.preventDefault(),
          !e.entity ||
            (2 !== this._stage && 3 !== this._stage) ||
            ((this._transformIndex = e.entity.index),
            this.attachTransform(e.entity.position),
            (this._stage = 3),
            this._engine.selection.transformControl.addEventListener(
              "objectChange",
              this._handleTransformChanging
            ),
            this._engine.selection.transformControl.addEventListener(
              "pointerup",
              this._handleTransformChanged
            ));
      }),
      publicField(this, "_handleTransformChanging", (e) => {
        let t = this._getTransformBoxState();
        if (3 === this._stage)
          if (0 === this._transformIndex) {
            let e = t.position,
              i = this._helpersBuffer.position[this._transformIndex + 1];
            (this._virtualLineBuffer.position[0] = [e, i]),
              (this._virtualLineBuffer.index = [0]),
              this._virtualLineDataSource.setData(this._virtualLineBuffer);
          } else if (this._transformIndex === this.length - 1) {
            let e = this._helpersBuffer.position[this._transformIndex - 1],
              i = t.position;
            (this._virtualLineBuffer.position[0] = [e, i]),
              (this._virtualLineBuffer.index = [0]),
              this._virtualLineDataSource.setData(this._virtualLineBuffer);
          } else {
            let e = this._helpersBuffer.position[this._transformIndex - 1],
              i = t.position,
              n = this._helpersBuffer.position[this._transformIndex + 1];
            (this._virtualLineBuffer.position[0] = [e, i, n]),
              (this._virtualLineBuffer.index = [0, 1]),
              this._virtualLineDataSource.setData(this._virtualLineBuffer);
          }
        (3 !== this._stage && 4 !== this._stage) ||
          (this.updateNode(this._transformIndex, t),
          this.dispatchEvent({ type: "change", value: this.data }),
          (this._stage = 4));
      }),
      publicField(this, "_handleTransformChanged", (e) => {
        let t = this._getTransformBoxState();
        4 === this._stage &&
          (this.updateNode(this._transformIndex, t),
          this._virtualLineDataSource.setData(),
          this.dispatchEvent({ type: "change", value: this.data }),
          (this._stage = 3));
      }),
      publicField(this, "_handleCancelEdit", (e) => {
        3 === this._stage && (this.detachTransform(), (this._stage = 2));
      }),
      (this._engine = e),
      t.virtualLineParameter || (t.virtualLineParameter = {}),
      t.lineParameter || (t.lineParameter = {}),
      t.lineColor || (t.lineColor = "rgb(200, 200, 50)"),
      (this._options = t);
  }
  initSpline() {
    let e = (this._splineDataSource = new mA()),
      t = (this._spline = this._engine.add(
        new eL({
          lineWidth: 3,
          color: this._options.lineColor,
          keepSize: !0,
          lineJoin: "round",
          ...this._options.lineParameter,
        })
      ));
    return (t.dataSource = e), t;
  }
  initVirtualLine() {
    let e = (this._virtualLineDataSource = new mA()),
      t = (this._virtualLine = this._engine.add(
        new eL({
          lineWidth: 2,
          color: this._options.lineColor,
          opacity: 0.2,
          keepSize: !0,
          lineJoin: "round",
          ...this._options.virtualLineParameter,
        })
      ));
    return (t.dataSource = e), t;
  }
  initHelpers() {
    let e = (this._helpersDataSource = new mA()),
      t = (this._helpers = this._engine.add(
        new JR({
          color: "rgba(0, 0, 0, 0)",
          mapSrc: Hm("assets/images/node.png"),
          size: 10,
          uShapeType: 1,
        })
      ));
    return (t.receiveRaycast = !0), (t.dataSource = e), t;
  }
  initCompeleteElement() {
    let e = (this._completedDataSource = new mA()),
      t = (this._completedElement = this._engine.add(
        new eL({
          lineWidth: 3,
          color: this._options.lineColor,
          keepSize: !0,
          lineJoin: "round",
        })
      ));
    (t.dataSource = e),
      (t.receiveRaycast = !0),
      this._engine.event.bind(t, "click", this._handleCompleteClick);
  }
  initObjects() {
    this.initSpline(),
      this.initHelpers(),
      this.initVirtualLine(),
      this.initCompeleteElement();
  }
  initEvents() {
    this._engine.event.bind("click", this._handleAddClick),
      this._drawedGraph.length > 0 &&
        this._engine.event.bind(
          this._completedElement,
          "click",
          this._handleCompleteClick
        );
  }
  graphInfo(e) {
    const t = new oA(
      this._splineBuffer.position[0],
      this._splineBuffer.payload
    );
    return (
      (t.index = e),
      {
        splineBuffer: this._splineBuffer,
        helpersBuffer: this._helpersBuffer,
        dataItem: t,
      }
    );
  }
  _getNodeNormal(e) {
    if (0 === e) {
      return Sv(
        Ev(this._helpersBuffer.position[e], this._helpersBuffer.position[e + 1])
      );
    }
    if (e === this.length - 1) {
      return Sv(
        Ev(this._helpersBuffer.position[e - 1], this._helpersBuffer.position[e])
      );
    }
    let t = this._helpersBuffer.position[e - 1],
      i = this._helpersBuffer.position[e],
      n = this._helpersBuffer.position[e + 1],
      s = Ev(t, i),
      r = Ev(i, n),
      a = new Vector2();
    return a.addVectors(s, r), Sv(a);
  }
  addNode(e, t, i) {
    this._splineBuffer.position[0].splice(e, 0, t),
      this._splineBuffer.payload.splice(e, 0, {
        point: i,
        position: t,
        scale: 2,
      }),
      this._splineBuffer.index.push(this.length),
      this._splineDataSource.setData(this._splineBuffer),
      this._helpersBuffer.position.splice(e, 0, t),
      this._helpersBuffer.payload.splice(e, 0, {
        point: i,
        position: t,
        scale: 2,
      }),
      this._helpersBuffer.index.push(this.length),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  removeNode(e) {
    this._splineBuffer.position[0].splice(e, 1),
      this._splineBuffer.payload.splice(e, 1),
      this._splineBuffer.index.pop(),
      this._splineDataSource.setData(this._splineBuffer),
      this._helpersBuffer.position.splice(e, 1),
      this._helpersBuffer.payload.pop(),
      this._helpersBuffer.index.pop(),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  updateNode(e, t) {
    let { point: i, position: n } = t;
    this._splineBuffer.position[0].splice(e, 1, n),
      this._splineBuffer.payload.splice(e, 1, {
        point: i,
        position: n,
        scale: t.width,
        angle: t.angle[2],
      }),
      this._splineDataSource.setData(this._splineBuffer),
      this._helpersBuffer.position.splice(e, 1, n),
      this._helpersBuffer.payload.splice(e, 1, {
        point: i,
        position: n,
        scale: t.width,
        angle: t.angle[2],
      }),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  overwriteNodes(e) {
    this.clearBuffers();
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      this._splineBuffer.position[0].push(i.position),
        this._splineBuffer.index.push(t),
        this._helpersBuffer.position.push(i.position),
        this._helpersBuffer.index.push(t);
    }
    (this._splineBuffer.payload = e),
      (this._helpersBuffer.payload = e),
      this._splineDataSource.setData(this._splineBuffer),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  unbindEvents() {
    this._engine.event.unbind("click", this._handleAddClick),
      this._engine.event.unbind("click", this._handleCancelEdit),
      this._engine.event.unbind("mousemove", this._handleAddMove),
      this._engine.event.unbind(this._helpers, "click", this._handleNodeClick),
      this._engine.event.unbind(
        this._completedElement,
        "click",
        this._handleCompleteClick
      ),
      this._engine.selection.transformControl.removeEventListener(
        "objectChange",
        this._handleTransformChanging
      ),
      this._engine.selection.transformControl.removeEventListener(
        "pointerup",
        this._handleTransformChanged
      );
  }
  clearBuffers() {
    (this._virtualLineBuffer = { position: [[]], index: [], payload: [] }),
      (this._splineBuffer = { position: [[]], index: [], payload: [] }),
      (this._helpersBuffer = { position: [], index: [], payload: [] });
  }
  clearObjects() {
    this._splineDataSource.setData(),
      this._helpersDataSource.setData(),
      this._virtualLineDataSource.setData(),
      this._engine.requestRender();
  }
  dispose() {
    (this.enabled = !1),
      this._engine.remove(this._spline),
      this._engine.remove(this._helpers),
      this._engine.remove(this._virtualLine);
  }
  set data(e) {
    this.overwriteNodes(e),
      this._handleCancelEdit(),
      (this._stage = 2),
      (this._isAdd = !0),
      this._engine.event.bind(this._helpers, "click", this._handleNodeClick),
      this._engine.event.bind("click", this._handleCancelEdit),
      this.dispatchEvent({ type: "change", value: e }),
      this._engine.requestRender();
  }
  get data() {
    return this._splineBuffer.payload;
  }
  get length() {
    return this._helpersBuffer.index.length;
  }
}
class UL extends kL {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_circleBuffer", {
        position: [],
        index: [],
        payload: [],
      }),
      publicField(this, "_virtualLineBuffer", {
        position: [[]],
        index: [],
        payload: [],
      }),
      publicField(this, "_helpersBuffer", {
        position: [],
        index: [],
        payload: [],
      }),
      publicField(this, "_hasBeenMove", !1),
      publicField(this, "_engine"),
      publicField(this, "_options"),
      publicField(this, "_circle"),
      publicField(this, "_circleDataSource"),
      publicField(this, "_virtualLine"),
      publicField(this, "_virtualLineDataSource"),
      publicField(this, "_helpers"),
      publicField(this, "_helpersDataSource"),
      publicField(this, "_completedDataSource"),
      publicField(this, "_completedElement"),
      publicField(this, "_isAdd"),
      publicField(this, "_selectedIndex"),
      publicField(this, "_stage"),
      publicField(this, "_transformIndex"),
      publicField(this, "_lastDataItem"),
      publicField(this, "_handleCompleteClick", (e) => {
        if (1 !== this._stage) {
          this.complete(),
            (this._selectedIndex = e.entity.value.index),
            this._engine.event.unbind("click", this._handleAddClick),
            (this._lastDataItem = this._drawedGraph.slice(
              this._selectedIndex,
              this._selectedIndex + 1
            )),
            (this._stage = 2),
            this._completedDataSource.setData();
          for (let e = 0; e < this._drawedGraph.length; e++)
            e !== this._selectedIndex &&
              this._completedDataSource.add(this._drawedGraph[e].dataItem);
          (this._circleBuffer = this.deepClone(
            this._lastDataItem[0].circleBuffer
          )),
            this._circleDataSource.setData(this._circleBuffer),
            (this._virtualLineBuffer = this.deepClone(
              this._lastDataItem[0].virtualLineBuffer
            )),
            this._virtualLineDataSource.setData(this._virtualLineBuffer),
            (this._helpersBuffer = this.deepClone(
              this._lastDataItem[0].helpersBuffer
            )),
            this._helpersDataSource.setData(this._helpersBuffer),
            this._engine.event.bind(
              this._helpers,
              "click",
              this._handleNodeClick
            ),
            this._engine.requestRender();
        }
      }),
      publicField(this, "_handleAddClick", (e) => {
        (this._isAdd = !0),
          (this._hasBeenMove = !1),
          (0 !== this._stage && 1 !== this._stage) ||
            ((this._stage = 1),
            this.addNode(e.position, e.point),
            this.dispatchEvent({ type: "addNode", value: this.data }),
            this._engine.event.unbind("click", this._handleAddClick),
            this._engine.event.bind("mousemove", this._handleAddMove),
            this._engine.event.bind("click", this._handleAddFinish));
      }),
      publicField(this, "_handleAddFinish", (e) => {
        this._hasBeenMove &&
          (1 === this._stage && (this._stage = 2),
          this.dispatchEvent({ type: "change", value: this.data }),
          this._engine.requestRender(),
          this._engine.event.unbind("click", this._handleAddFinish),
          this._engine.event.unbind("mousemove", this._handleAddMove),
          this._engine.event.bind(
            this._helpers,
            "click",
            this._handleNodeClick
          ),
          this._engine.event.bind("click", this._handleCancelEdit));
      }),
      publicField(this, "_handleNodeClick", (e) => {
        e.domEvent
          ? e.event.domEvent.preventDefault()
          : e.event.preventDefault(),
          !e.entity ||
            (2 !== this._stage && 3 !== this._stage) ||
            ((this._transformIndex = e.entity.index),
            this.attachTransform(e.entity.position),
            this._transformIndex
              ? (this._engine.selection.transformControl.showZ = !1)
              : (this._engine.selection.transformControl.showZ = !0),
            (this._stage = 3),
            this._engine.selection.transformControl.addEventListener(
              "objectChange",
              this._handleTransformChanging
            ),
            this._engine.selection.transformControl.addEventListener(
              "pointerup",
              this._handleTransformChanged
            ));
      }),
      publicField(this, "_handleTransformChanging", (e) => {
        let t = this._getTransformBoxState();
        if (3 === this._stage || 4 === this._stage) {
          if (0 === this._transformIndex) this.moveNode(t);
          else {
            this.adjustRadius(t);
            let e = this._getNodeNormal().angle();
            this._transformBox.rotation.z = e;
          }
          this.dispatchEvent({ type: "change", value: this.data }),
            (this._stage = 4);
        }
      }),
      publicField(this, "_handleTransformChanged", (e) => {
        4 === this._stage &&
          (this.dispatchEvent({ type: "change", value: this.data }),
          (this._stage = 3));
      }),
      publicField(this, "_handleCancelEdit", (e) => {
        3 === this._stage &&
          (this.detachTransform(),
          (this._engine.selection.transformControl.showZ = !0),
          (this._stage = 2));
      }),
      publicField(this, "_handleAddMove", (e) => {
        const t = this._helpersBuffer.position[0],
          i = e.position,
          n = this.calcLength(t, i);
        (this._circleBuffer.payload[0].size = 2 * n),
          this._circleDataSource.setData(this._circleBuffer),
          (this._helpersBuffer.position[1] = i),
          (this._helpersBuffer.payload[1] = {
            position: i,
            point: e.point,
            scale: 2,
          }),
          (this._helpersBuffer.index[1] = 1),
          this._helpersDataSource.setData(this._helpersBuffer),
          (this._virtualLineBuffer.position[0] = this._helpersBuffer.position),
          (this._virtualLineBuffer.index = this._helpersBuffer.index),
          this._virtualLineDataSource.setData(this._virtualLineBuffer),
          this.dispatchEvent({ type: "moveNode", value: this.data }),
          (this._hasBeenMove = !0);
      }),
      (this._engine = e),
      t.editingPolygonParameter || (t.editingPolygonParameter = {}),
      t.editedPolygonParameter || (t.editedPolygonParameter = {}),
      t.circleColor || (t.circleColor = "rgb(200, 200, 50)"),
      (this._options = t);
  }
  initObjects() {
    this.initCircle(),
      this.initvirtualLine(),
      this.initHelper(),
      this.initCompletedElement();
  }
  initCircle() {
    let e = (this._circleDataSource = new mA()),
      t = (this._circle = this._engine.add(
        new eD({
          color: this._options.circleColor,
          borderWidth: 0,
          opacity: 0.3,
          vertexSizes: !0,
          ...this._options.editingPolygonParameter,
        })
      ));
    e.setAttribute("size"), (t.dataSource = e);
  }
  initvirtualLine() {
    let e = (this._virtualLineDataSource = new mA());
    (this._virtualLine = this._engine.add(
      new eL({ lineWidth: 2, keepSize: !0 })
    )).dataSource = e;
  }
  initHelper() {
    let e = (this._helpersDataSource = new mA()),
      t = (this._helpers = this._engine.add(
        new JR({
          color: "rgba(0, 0, 0, 0)",
          mapSrc: Hm("assets/images/node.png"),
          size: 10,
          uShapeType: 1,
        })
      ));
    (t.receiveRaycast = !0), (t.dataSource = e);
  }
  initCompletedElement() {
    let e = (this._completedDataSource = new mA()),
      t = (this._completedElement = this._engine.add(
        new eD({
          color: this._options.circleColor,
          borderWidth: 0,
          opacity: 0.3,
          vertexSizes: !0,
          ...this._options.editedPolygonParameter,
        })
      ));
    e.setAttribute("size").setAttribute("selectedIndex"),
      (t.dataSource = e),
      (t.receiveRaycast = !0),
      this._engine.event.bind(t, "click", this._handleCompleteClick);
  }
  graphInfo(e) {
    const t = new oA(
      this._circleBuffer.position[0],
      this._circleBuffer.payload[0]
    );
    return (
      (t.index = e),
      {
        circleBuffer: this._circleBuffer,
        virtualLineBuffer: this._virtualLineBuffer,
        helpersBuffer: this._helpersBuffer,
        dataItem: t,
      }
    );
  }
  initEvents() {
    this._engine.event.bind("click", this._handleAddClick),
      this._drawedGraph.length > 0 &&
        this._engine.event.bind(
          this._completedElement,
          "click",
          this._handleCompleteClick
        );
  }
  _getNodeNormal() {
    return Sv(
      Ev(this._helpersBuffer.position[0], this._helpersBuffer.position[1])
    );
  }
  calcLength(e, t) {
    let i = Math.pow(Math.abs(e[0] - t[0]), 2),
      n = Math.pow(Math.abs(e[1] - t[1]), 2),
      s = Math.pow(Math.abs(e[2] - t[2]), 2);
    return Math.pow(i + n + s, 0.5);
  }
  addNode(e, t) {
    (this._circleBuffer.position[0] = e),
      (this._circleBuffer.payload[0] = {
        point: t,
        position: e,
        scale: 2,
        size: 0,
      }),
      (this._circleBuffer.index = [0]),
      (this._helpersBuffer.position[0] = e),
      (this._helpersBuffer.payload[0] = {
        point: t,
        position: e,
        scale: 2,
        size: 0,
      }),
      (this._helpersBuffer.index = [0]);
  }
  moveNode(e) {
    let { position: t, point: i } = e;
    (this._circleBuffer.position[0] = t),
      (this._circleBuffer.payload[0] = {
        ...this._circleBuffer.payload[0],
        position: t,
        point: i,
        scale: e.width,
      }),
      this._circleDataSource.setData(this._circleBuffer);
    const n = new Vector3(...this._helpersBuffer.position[0]),
      s = new Vector3(...this._helpersBuffer.payload[0].point),
      r = new Vector3(...t),
      a = new Vector3(...i),
      o = r.sub(n),
      l = a.sub(s);
    let h = this._helpersBuffer.position;
    for (let c = 0, u = h.length; c < u; c++) {
      const t = this._helpersBuffer.payload[c].point,
        i = new Vector3(...h[c]).add(o),
        n = new Vector3(...t).add(l);
      (h[c] = i.toArray()),
        (this._helpersBuffer.payload[c] = {
          position: i,
          point: n,
          scale: e.width,
        }),
        (this._virtualLineBuffer.position[0][c] = h[c]);
    }
    this._helpersDataSource.setData(this._helpersBuffer),
      this._virtualLineDataSource.setData(this._virtualLineBuffer);
  }
  adjustRadius(e) {
    const { position: t, point: i } = e,
      n = this._helpersBuffer.position[0],
      s = this.calcLength(n, t);
    (this._circleBuffer.payload[0].size = 2 * s),
      this._circleDataSource.setData(this._circleBuffer),
      (this._helpersBuffer.position[1] = t),
      (this._helpersBuffer.payload[1] = {
        position: t,
        point: i,
        scale: e.width,
      }),
      (this._helpersBuffer.index[1] = 1),
      this._helpersDataSource.setData(this._helpersBuffer),
      (this._virtualLineBuffer.position[0] = this._helpersBuffer.position),
      (this._virtualLineBuffer.index = this._helpersBuffer.index),
      this._virtualLineDataSource.setData(this._virtualLineBuffer);
  }
  unbindEvents() {
    this._engine.event.unbind("click", this._handleAddClick),
      this._engine.event.unbind("click", this._handleCancelEdit),
      this._engine.event.unbind("mousemove", this._handleCancelEdit),
      this._engine.event.unbind(this._helper, "click", this._handleNodeClick),
      this._engine.event.unbind(
        this._completedElement,
        "click",
        this._handleCompleteClick
      ),
      this._engine.selection.transformControl.removeEventListener(
        "objectChange",
        this._handleTransformChanging
      ),
      this._engine.selection.transformControl.removeEventListener(
        "pointerup",
        this._handleTransformChanged
      );
  }
  dispose() {
    (this.enabled = !1),
      this._engine.remove(this._circle),
      this._engine.remove(this._virtualLine),
      this._engine.remove(this._helpers);
  }
  clearBuffers() {
    (this._circleBuffer = { position: [], index: [], payload: [] }),
      (this._virtualLineBuffer = { position: [[]], index: [], payload: [] }),
      (this._helpersBuffer = { position: [], index: [], payload: [] });
  }
  clearObjects() {
    this._circleDataSource.setData(),
      this._virtualLineDataSource.setData(),
      this._helpersDataSource.setData(),
      this._engine.requestRender();
  }
  overwriteNodes(e) {
    this.clearBuffers();
    const t = e[0].position;
    this._circleBuffer.position.push(t),
      (this._circleBuffer.index[0] = 0),
      (this._circleBuffer.payload = e),
      this._helpersBuffer.position.push(t),
      this._helpersBuffer.payload.push(e[0]);
    const i = [t[0] + e[0].size / 2, t[1], t[2]];
    this._helpersBuffer.position.push(i);
    const n = {
      position: i,
      point: this._engine.map.unprojectPointArr(i),
      scale: e[0].scale,
    };
    this._helpersBuffer.payload.push(n),
      this._helpersBuffer.index.push(0, 1),
      (this._virtualLineBuffer.position[0] = this._helpersBuffer.position),
      (this._virtualLineBuffer.index = this._helpersBuffer.index),
      this._virtualLineDataSource.setData(this._virtualLineBuffer),
      this._circleDataSource.setData(this._circleBuffer),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  _getProperties(e) {
    const { scale: t, size: i } = e;
    return { scale: t, size: i };
  }
  get data() {
    return this._circleBuffer.payload;
  }
  set data(e) {
    this.overwriteNodes(e),
      this._handleCancelEdit(),
      (this._stage = 2),
      (this._isAdd = !0),
      this._engine.event.bind(this._helpers, "click", this._handleNodeClick),
      this._engine.event.bind("click", this._handleCancelEdit),
      this.dispatchEvent({ type: "change", value: e }),
      this._engine.requestRender();
  }
}
class zL extends kL {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_rectBuffer", {
        position: [[[]]],
        index: [],
        payload: [],
      }),
      publicField(this, "_helpersBuffer", {
        position: [],
        index: [],
        payload: [],
      }),
      publicField(this, "_engine"),
      publicField(this, "_options"),
      publicField(this, "_rect"),
      publicField(this, "_rectDataSource"),
      publicField(this, "_helpers"),
      publicField(this, "_helpersDataSource"),
      publicField(this, "_helpers"),
      publicField(this, "_helpersDataSource"),
      publicField(this, "_completedDataSource"),
      publicField(this, "_completedElement"),
      publicField(this, "_isAdd"),
      publicField(this, "_selectedIndex"),
      publicField(this, "_stage"),
      publicField(this, "_transformIndex"),
      publicField(this, "_lastDataItem"),
      publicField(this, "_handleCompleteClick", (e) => {
        if (1 !== this._stage) {
          this.complete(),
            (this._selectedIndex = e.entity.value.index),
            this._engine.event.unbind("click", this._handleAddClick),
            (this._lastDataItem = this._drawedGraph.slice(
              this._selectedIndex,
              this._selectedIndex + 1
            )),
            (this._stage = 2),
            this._completedDataSource.setData();
          for (let e = 0; e < this._drawedGraph.length; e++)
            e !== this._selectedIndex &&
              this._completedDataSource.add(this._drawedGraph[e].dataItem);
          (this._rectBuffer = this.deepClone(this._lastDataItem[0].rectBuffer)),
            this._rectDataSource.setData(this._rectBuffer),
            (this._helpersBuffer = this.deepClone(
              this._lastDataItem[0].helpersBuffer
            )),
            this._helpersDataSource.setData(this._helpersBuffer),
            this._engine.event.bind(
              this._helpers,
              "click",
              this._handleNodeClick
            ),
            this._engine.requestRender();
        }
      }),
      publicField(this, "_handleAddClick", (e) => {
        (this._isAdd = !0),
          (0 !== this._stage && 1 !== this._stage) ||
            ((this._stage = 1),
            this.addNode(e.position, e.point),
            this._engine.event.unbind("click", this._handleAddClick),
            this._engine.event.bind("mousemove", this._handleAddMove),
            this._engine.event.bind("click", this._handleAddFinish));
      }),
      publicField(this, "_handleAddMove", (e) => {
        let t = this._helpersBuffer.position[0],
          i = this._rectBuffer.payload[0].point;
        const { position: n, point: s } = e,
          r = [[n[0], t[1], t[2]], n, [t[0], n[1], n[2]], t],
          a = [
            { point: [s[0], i[1], i[2]], position: r[0], scale: 2 },
            { point: s, position: r[1], scale: 2 },
            { point: [i[0], s[1], s[2]], position: r[2], scale: 2 },
            { point: i, position: r[3], scale: 2 },
          ];
        this._rectBuffer.position[0][0].splice(1, 4, ...r),
          this._rectBuffer.payload.splice(1, 4, ...a),
          (this._rectBuffer.index = [0, 1, 2, 3, 4]),
          this._rectDataSource.setData(this._rectBuffer),
          this._helpersBuffer.position.splice(
            1,
            3,
            ...r.slice(0, r.length - 1)
          ),
          (this._helpersBuffer.payload = this._rectBuffer.payload.slice(0, 4)),
          (this._helpersBuffer.index = [0, 1, 2, 3]),
          this._helpersDataSource.setData(this._helpersBuffer),
          this.dispatchEvent({ type: "moveNode", value: this.data });
      }),
      publicField(this, "_handleAddFinish", (e) => {
        if (!(this._rectBuffer.payload.length < 5)) {
          1 === this._stage && (this._stage = 2);
          for (let e = 0; e < 5; e++) {
            this._rectBuffer.payload[e].angle = this._getNodeNormal().angle();
          }
          this.dispatchEvent({ type: "change", value: this.data }),
            this._engine.requestRender(),
            this._engine.event.unbind("click", this._handleAddFinish),
            this._engine.event.unbind("mousemove", this._handleAddMove),
            this._engine.event.bind(
              this._helpers,
              "click",
              this._handleNodeClick
            ),
            this._engine.event.bind("click", this._handleCancelEdit);
        }
      }),
      publicField(this, "_handleNodeClick", (e) => {
        e.domEvent
          ? e.event.domEvent.preventDefault()
          : e.event.preventDefault(),
          !e.entity ||
            (2 !== this._stage && 3 !== this._stage) ||
            ((this._transformIndex = e.entity.index),
            this.attachTransform(e.entity.position),
            (this._stage = 3),
            this._engine.selection.transformControl.addEventListener(
              "objectChange",
              this._handleTransformChanging
            ),
            this._engine.selection.transformControl.addEventListener(
              "pointerup",
              this._handleTransformChanged
            ));
      }),
      publicField(this, "_handleTransformChanging", (e) => {
        let t = this._getTransformBoxState();
        (3 !== this._stage && 4 !== this._stage) ||
          (this.updateNode(this._transformIndex, t),
          this.dispatchEvent({ type: "change", value: this.data }),
          (this._stage = 4));
      }),
      publicField(this, "_handleTransformChanged", (e) => {
        4 === this._stage &&
          (this.dispatchEvent({ type: "change", value: this.data }),
          (this._stage = 3));
      }),
      publicField(this, "_handleCancelEdit", (e) => {
        3 === this._stage && (this.detachTransform(), (this._stage = 2));
      }),
      (this._engine = e),
      t.editingPolygonParameter || (t.editingPolygonParameter = {}),
      t.editedPolygonParameter || (t.editedPolygonParameter = {}),
      t.rectColor || (t.rectColor = "rgb(200, 200, 50)"),
      (this._options = t);
  }
  initObjects() {
    this.initRect(), this.initHelpers(), this.initCompletedElement();
  }
  initRect() {
    let e = (this._rectDataSource = new mA()),
      t = (this._rect = this._engine.add(
        new KD({
          color: this._options.rectColor,
          ...this._options.editingPolygonParameter,
        })
      ));
    return (t.material.side = 2), (t.dataSource = e), t;
  }
  initHelpers() {
    let e = (this._helpersDataSource = new mA()),
      t = (this._helpers = this._engine.add(
        new JR({
          color: "rgba(0, 0, 0, 0)",
          mapSrc: Hm("assets/images/node.png"),
          size: 10,
          uShapeType: 1,
        })
      ));
    return (t.receiveRaycast = !0), (t.dataSource = e), t;
  }
  initCompletedElement() {
    let e = (this._completedDataSource = new mA()),
      t = (this._completedElement = this._engine.add(
        new KD({
          color: this._options.rectColor,
          ...this._options.editedPolygonParameter,
        })
      ));
    (t.material.side = 2),
      (t.dataSource = e),
      (t.receiveRaycast = !0),
      this._engine.event.bind(t, "click", this._handleCompleteClick);
  }
  graphInfo(e) {
    const t = new oA(this._rectBuffer.position[0], this._rectBuffer.payload);
    return (
      (t.index = e),
      {
        rectBuffer: this._rectBuffer,
        helpersBuffer: this._helpersBuffer,
        dataItem: t,
      }
    );
  }
  initEvents() {
    this._engine.event.bind("click", this._handleAddClick),
      this._drawedGraph.length > 0 &&
        this._engine.event.bind(
          this._completedElement,
          "click",
          this._handleCompleteClick
        );
  }
  _getNodeNormal() {
    let e = new Vector3().fromArray(this._helpersBuffer.position[0]),
      t = new Vector3().fromArray(this._helpersBuffer.position[1]),
      i = new Vector3().fromArray(this._helpersBuffer.position[2]),
      n = new Vector3().subVectors(t, e),
      s = new Vector3().subVectors(t, i),
      r = n.z * s.x - s.z * n.x,
      a = n.x * s.y - s.x * n.y;
    return new Vector2(r, a).normalize();
  }
  addNode(e, t) {
    this._rectBuffer.payload.push({ point: t, position: e, scale: 2 }),
      this._rectBuffer.position[0][0].push(e),
      this._rectBuffer.index.push(0),
      this._helpersBuffer.position.push(e),
      this._helpersBuffer.index.push(0);
  }
  updateNode(e, t) {
    let { position: i, point: n, width: s } = t,
      r = this._getNodeNormal().angle(),
      a = (e + 2) % 4;
    const { position: o, point: l } = this._rectBuffer.payload[a];
    let h = (4 + e - 1) % 4,
      c = (4 + e + 1) % 4,
      u = [i[0], o[1], o[2]],
      d = [o[0], i[1], i[2]],
      p = { point: [n[0], l[1], l[2]], position: u, scale: s, angle: r },
      f = { point: [l[0], n[1], n[2]], position: d, scale: s, angle: r };
    (this._helpersBuffer.position[e] = i),
      (this._rectBuffer.payload[e] = {
        point: n,
        position: i,
        scale: s,
        angle: r,
      }),
      e % 2
        ? ((this._helpersBuffer.position[h] = d),
          (this._helpersBuffer.position[c] = u),
          (this._rectBuffer.payload[h] = f),
          (this._rectBuffer.payload[c] = p))
        : ((this._helpersBuffer.position[h] = u),
          (this._helpersBuffer.position[c] = d),
          (this._rectBuffer.payload[h] = p),
          (this._rectBuffer.payload[c] = f)),
      (this._rectBuffer.position[0][0] = [
        ...this._helpersBuffer.position,
        this._helpersBuffer.position[0],
      ]),
      (this._rectBuffer.payload[4] = this._rectBuffer.payload[0]),
      (this._helpersBuffer.payload = this._rectBuffer.payload.slice(0, 4)),
      this._rectDataSource.setData(this._rectBuffer),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  clearBuffers() {
    (this._rectBuffer = { position: [[[]]], index: [], payload: [] }),
      (this._helpersBuffer = { position: [], index: [], payload: [] });
  }
  clearObjects() {
    this._rectDataSource.setData(),
      this._helpersDataSource.setData(),
      this._engine.requestRender();
  }
  overwriteNodes(e) {
    this.clearBuffers();
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      this._rectBuffer.position[0][0].push(i.position),
        this._rectBuffer.index[t],
        t !== e.length - 1 &&
          (this._helpersBuffer.payload.push(i),
          this._helpersBuffer.position.push(i.position),
          this._helpersBuffer.index.push(t));
    }
    (this._rectBuffer.payload = e),
      this._rectDataSource.setData(this._rectBuffer),
      this._rectDataSource.setData(this._rectBuffer),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  unbindEvents() {
    this._engine.event.unbind("click", this._handleAddClick),
      this._engine.event.unbind("click", this._handleAddFinish),
      this._engine.event.unbind("mousemove", this._handleAddMove),
      this._engine.event.unbind(this._helpers, "click", this._handleNodeClick),
      this._engine.event.unbind(
        this._completedElement,
        "click",
        this._handleCompleteClick
      ),
      this._engine.selection.transformControl.removeEventListener(
        "objectChange",
        this._handleTransformChanging
      ),
      this._engine.selection.transformControl.removeEventListener(
        "pointerup",
        this._handleTransformChanged
      );
  }
  dispose() {
    (this.enabled = !1),
      this._engine.remove(this._rect),
      this._engine.remove(this._helpers);
  }
  get data() {
    return this._rectBuffer.payload;
  }
  set data(e) {
    this.overwriteNodes(e),
      this._handleCancelEdit(),
      (this._stage = 2),
      (this._isAdd = !0),
      this._engine.event.bind(this._helpers, "click", this._handleNodeClick),
      this._engine.event.bind("click", this._handleCancelEdit),
      this.dispatchEvent({ type: "change", value: e });
  }
}
class GL extends kL {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_polygonOpacity", 0.6),
      publicField(this, "_virtualOpacity", 0.3),
      publicField(this, "_polygonBuffer", {
        position: [[[]]],
        index: [],
        payload: [],
      }),
      publicField(this, "_strokeLineBuffer", {
        position: [[]],
        index: [],
        payload: [],
      }),
      publicField(this, "_helpersBuffer", {
        position: [],
        index: [],
        payload: [],
      }),
      publicField(this, "_engine"),
      publicField(this, "_options"),
      publicField(this, "_polygon"),
      publicField(this, "_polygonDataSource"),
      publicField(this, "_strokeLine"),
      publicField(this, "_strokeLineDataSource"),
      publicField(this, "_helpers"),
      publicField(this, "_helpersDataSource"),
      publicField(this, "_completedDataSource"),
      publicField(this, "_completedElement"),
      publicField(this, "_isAdd"),
      publicField(this, "_selectedIndex"),
      publicField(this, "_stage"),
      publicField(this, "_transformIndex"),
      publicField(this, "_transformBox"),
      publicField(this, "_lastDataItem"),
      publicField(this, "_handleCompleteClick", (e) => {
        if (1 !== this._stage) {
          this.complete(),
            (this._selectedIndex = e.entity.value.index),
            this._engine.event.unbind("click", this._handleAddClick),
            (this._lastDataItem = this._drawedGraph.slice(
              this._selectedIndex,
              this._selectedIndex + 1
            )),
            (this._stage = 2),
            this._completedDataSource.setData();
          for (let e = 0; e < this._drawedGraph.length; e++)
            e !== this._selectedIndex &&
              this._completedDataSource.add(this._drawedGraph[e].dataItem);
          (this._polygonBuffer = this.deepClone(
            this._lastDataItem[0].polygonBuffer
          )),
            this._polygonDataSource.setData(this._polygonBuffer),
            (this._strokeLineBuffer = this.deepClone(
              this._lastDataItem[0].strokeLineBuffer
            )),
            this._strokeLineDataSource.setData(this._strokeLineBuffer),
            (this._helpersBuffer = this.deepClone(
              this._lastDataItem[0].helpersBuffer
            )),
            this._helpersDataSource.setData(this._helpersBuffer),
            this._engine.event.bind(
              this._helpers,
              "click",
              this._handleNodeClick
            ),
            this._engine.requestRender();
        }
      }),
      publicField(this, "_handleAddClick", (e) => {
        this._isAdd = !0;
        let t = this.length;
        if (0 === this.stage || 1 === this.stage) {
          if (
            ((this.stage = 1),
            this.length > 2 &&
              Av(e.position, this._helpersBuffer.position.slice(-1)[0]))
          )
            return (
              this._handleAddFinish(),
              this._polygonDataSource.setData(this._polygonBuffer),
              void this._strokeLineDataSource.setData(this._strokeLineBuffer)
            );
          this.length > 0 &&
            (this._strokeLineBuffer.index.splice(-2),
            this._strokeLineBuffer.position[0].splice(-2),
            this._strokeLineBuffer.payload.splice(-2)),
            this.addNode(t, e.position, e.point),
            this.dispatchEvent({ type: "addNode", value: this.data }),
            this._engine.event.bind("mousemove", this._handleAddMove);
        }
        this._engine.requestRender();
      }),
      publicField(this, "_handleAddMove", (e) => {
        let t = this._helpersBuffer.position[0],
          i = e.position;
        this._strokeLineBuffer.position[0].splice(this.length, 2, i, t),
          this._strokeLineBuffer.index.splice(
            this.length,
            2,
            this.length,
            this.length + 1
          ),
          this._strokeLineDataSource.setData(this._strokeLineBuffer),
          (this._polygonBuffer.position[0] = this._strokeLineBuffer.position),
          this._polygonBuffer.payload.splice(
            this.length,
            2,
            { point: e.point, position: i, scale: 2 },
            this._polygonBuffer.payload[0]
          ),
          (this._polygonBuffer.index = this._strokeLineBuffer.index),
          this._polygonDataSource.setData(this._polygonBuffer),
          this.dispatchEvent({ type: "moveNode", value: this.data });
      }),
      publicField(this, "_handleAddFinish", (e) => {
        if (1 === this.stage) {
          this.stage = 2;
          for (let e = 0; e < this.length; e++) {
            this._polygonBuffer.payload[e].angle =
              this._getNodeNormal(e).angle();
          }
          this.dispatchEvent({ type: "change", value: this.data }),
            this._engine.requestRender(),
            this._engine.event.unbind("click", this._handleAddClick),
            this._engine.event.unbind("mousemove", this._handleAddMove),
            this._engine.event.bind(
              this._helpers,
              "click",
              this._handleNodeClick
            ),
            this._engine.event.bind("click", this._handleCancelEdit);
        }
      }),
      publicField(this, "_handleNodeClick", (e) => {
        e.domEvent
          ? e.event.domEvent.preventDefault()
          : e.event.preventDefault(),
          !e.entity ||
            (2 !== this.stage && 3 !== this.stage) ||
            ((this._transformIndex = e.entity.index),
            this.attachTransform(e.entity.position),
            (this.stage = 3),
            this._engine.selection.transformControl.addEventListener(
              "objectChange",
              this._handleTransformChanging
            ),
            this._engine.selection.transformControl.addEventListener(
              "pointerup",
              this._handleTransformChanged
            ));
      }),
      publicField(this, "_handleTransformChanging", (e) => {
        let t = this._getTransformBoxState();
        (3 !== this.stage && 4 !== this.stage) ||
          (this.updateNode(this._transformIndex, t),
          this.dispatchEvent({ type: "change", value: this.data }),
          (this.stage = 4));
      }),
      publicField(this, "_handleTransformChanged", (e) => {
        let t = this._getTransformBoxState();
        4 === this.stage &&
          (this.updateNode(this._transformIndex, t),
          this.dispatchEvent({ type: "change", value: this.data }),
          (this.stage = 3));
      }),
      publicField(this, "_handleCancelEdit", (e) => {
        3 === this.stage && (this.detachTransform(), (this.stage = 2));
      }),
      (this._engine = e),
      t.editingPolygonParameter || (t.editingPolygonParameter = {}),
      t.editedPolygonParameter || (t.editedPolygonParameter = {}),
      t.borderLineParameter || (t.borderLineParameter = {}),
      t.polygonColor || (t.polygonColor = "rgb(200, 200, 50)"),
      t.borderColor || (t.borderColor = "rgb(200, 50, 50)"),
      (this._options = t);
  }
  initObjects() {
    this.initPolygon(),
      this.initStrokeLine(),
      this.initHelpers(),
      this.initCompletedElement();
  }
  initPolygon() {
    let e = (this._polygonDataSource = new mA()),
      t = (this._polygon = this._engine.add(
        new KD({
          color: this._options.polygonColor,
          opacity: this._virtualOpacity,
          normalOffset: 0.001,
          ...this._options.editingPolygonParameter,
        })
      ));
    return (t.material.side = 2), (t.dataSource = e), t;
  }
  initStrokeLine() {
    let e = (this._strokeLineDataSource = new mA()),
      t = (this._strokeLine = this._engine.add(
        new eL({
          lineWidth: 3,
          color: this._options.borderColor,
          keepSize: !0,
          lineJoin: "round",
          ...this._options.borderLineParameter,
        })
      ));
    return (t.dataSource = e), t;
  }
  initHelpers() {
    let e = (this._helpersDataSource = new mA()),
      t = (this._helpers = this._engine.add(
        new JR({
          color: "rgba(0, 0, 0, 0)",
          mapSrc: Hm("assets/images/node.png"),
          size: 10,
          uShapeType: 1,
        })
      ));
    return (t.receiveRaycast = !0), (t.dataSource = e), t;
  }
  initCompletedElement() {
    let e = (this._completedDataSource = new mA()),
      t = (this._completedElement = this._engine.add(
        new KD({
          color: this._options.polygonColor,
          opacity: this._polygonOpacity,
          normalOffset: 0.001,
          ...this._options.editedPolygonParameter,
        })
      ));
    (t.material.side = 2),
      (t.dataSource = e),
      (t.receiveRaycast = !0),
      this._engine.event.bind(t, "click", this._handleCompleteClick);
  }
  initEvents() {
    this._engine.event.bind("click", this._handleAddClick),
      this._drawedGraph.length > 0 &&
        this._engine.event.bind(
          this._completedElement,
          "click",
          this._handleCompleteClick
        );
  }
  graphInfo(e) {
    let t = new oA(
      this._polygonBuffer.position[0],
      this._polygonBuffer.payload
    );
    return (
      (t.index = e),
      {
        polygonBuffer: this._polygonBuffer,
        strokeLineBuffer: this._strokeLineBuffer,
        helpersBuffer: this._helpersBuffer,
        dataItem: t,
      }
    );
  }
  _getNodeNormal(e) {
    let t, i, n;
    0 === e || e
      ? ((e = 0),
        (t = this._helpersBuffer.position[this.length - 1]),
        (i = this._helpersBuffer.position[e]),
        (n = this._helpersBuffer.position[e + 1]))
      : e === this.length - 1
      ? ((t = this._helpersBuffer.position[e - 1]),
        (i = this._helpersBuffer.position[e]),
        (n = this._helpersBuffer.position[0]))
      : ((t = this._helpersBuffer.position[e - 1]),
        (i = this._helpersBuffer.position[e]),
        (n = this._helpersBuffer.position[e + 1]));
    let s = Ev(t, i),
      r = Ev(i, n),
      a = new Vector2();
    return a.addVectors(s, r), Sv(a);
  }
  addNode(e, t, i) {
    this._strokeLineBuffer.position[0].push(t),
      this._strokeLineBuffer.index.push(e),
      this.length > 0 &&
        (this._strokeLineBuffer.position[0].push(
          this._helpersBuffer.position[0]
        ),
        this._strokeLineBuffer.index.push(e + 1)),
      this._strokeLineDataSource.setData(this._strokeLineBuffer),
      (this._polygonBuffer.position[0] = this._strokeLineBuffer.position),
      (this._polygonBuffer.index = this._strokeLineBuffer.index);
    const n = this._polygonBuffer.payload.slice(0, e);
    n.splice(e, 0, { point: i, position: t, scale: 2 }),
      n.push(n[0]),
      (this._polygonBuffer.payload = n),
      this._helpersBuffer.position.push(t),
      this._helpersBuffer.payload.splice(e, 0, {
        point: i,
        position: t,
        scale: 2,
      }),
      this._helpersBuffer.index.push(e),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  updateNode(e, t) {
    let { point: i, position: n } = t,
      s = this._strokeLineBuffer.position[0].length;
    0 === this._transformIndex
      ? (this._strokeLineBuffer.position[0].splice(0, 1, n),
        this._strokeLineBuffer.position[0].splice(s - 1, 1, n),
        this._polygonBuffer.payload.splice(0, 1, {
          point: i,
          position: n,
          scale: t.width,
          angle: t.angle[2],
        }),
        this._polygonBuffer.payload.splice(s - 1, 1, {
          point: i,
          position: n,
          scale: t.width,
          angle: t.angle[2],
        }),
        this._strokeLineDataSource.setData(this._strokeLineBuffer))
      : (this._strokeLineBuffer.position[0].splice(e, 1, n),
        this._polygonBuffer.payload.splice(e, 1, {
          point: i,
          position: n,
          scale: t.width,
          angle: t.angle[2],
        }),
        this._strokeLineDataSource.setData(this._strokeLineBuffer)),
      (this._polygonBuffer.position[0] = this._strokeLineBuffer.position),
      this._polygonDataSource.setData(this._polygonBuffer),
      this._helpersBuffer.position.splice(e, 1, n),
      this._helpersBuffer.payload.splice(e, 1, {
        position: n,
        point: i,
        scale: t.width,
        angle: t.angle[2],
      }),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  overwriteNodes(e) {
    this.clearBuffers();
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      this._polygonBuffer.position[0][0].push(i.position),
        this._polygonBuffer.index.push(t),
        this._strokeLineBuffer.position[0].push(i.position),
        this._strokeLineBuffer.index.push(t),
        t !== e.length - 1 &&
          (this._helpersBuffer.position.push(i.position),
          this._helpersBuffer.payload.push(i),
          this._helpersBuffer.index.push(t));
    }
    (this._polygonBuffer.payload = e),
      (this._strokeLineBuffer.payload = e),
      this._polygonDataSource.setData(this._polygonBuffer),
      this._strokeLineDataSource.setData(this._strokeLineBuffer),
      this._helpersDataSource.setData(this._helpersBuffer);
  }
  unbindEvents() {
    this._engine.event.unbind("click", this._handleAddClick),
      this._engine.event.unbind("click", this._handleCancelEdit),
      this._engine.event.unbind("mousemove", this._handleAddMove),
      this._engine.event.unbind(this._helpers, "click", this._handleNodeClick),
      this._engine.event.unbind(
        this._completedElement,
        "click",
        this._handleCompleteClick
      ),
      this._engine.selection.transformControl.removeEventListener(
        "objectChange",
        this._handleTransformChanging
      ),
      this._engine.selection.transformControl.removeEventListener(
        "pointerup",
        this._handleTransformChanged
      );
  }
  reset() {
    this.clearBuffers(),
      (this._transformBox = null),
      (this._transformIndex = null),
      (this.stage = 0);
  }
  clearBuffers() {
    (this._polygonBuffer = { position: [[[]]], index: [], payload: [] }),
      (this._strokeLineBuffer = { position: [[]], index: [], payload: [] }),
      (this._helpersBuffer = { position: [], index: [], payload: [] });
  }
  clearObjects() {
    this._polygonDataSource.setData(),
      this._strokeLineDataSource.setData(),
      this._helpersDataSource.setData(),
      this._engine.requestRender();
  }
  dispose() {
    (this.enabled = !1),
      this._engine.remove(this._polygon),
      this._engine.remove(this._strokeLine),
      this._engine.remove(this._helpers);
  }
  get stage() {
    return this._stage;
  }
  set stage(e) {
    (this._polygon.opacity =
      2 === e ? this._polygonOpacity : this._virtualOpacity),
      (this._stage = e);
  }
  get data() {
    return this._polygonBuffer.payload;
  }
  set data(e) {
    this.overwriteNodes(e),
      this._handleCancelEdit(),
      (this.stage = 2),
      (this._isAdd = !0),
      this._engine.event.bind(this._helpers, "click", this._handleNodeClick),
      this._engine.event.bind("click", this._handleCancelEdit),
      this.dispatchEvent({ type: "change", value: e }),
      this._engine.requestRender();
  }
  get length() {
    return this._helpersBuffer.index.length;
  }
}
const VL = 6371008.8;

class QL extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_enabled", !1),
      publicField(this, "_fixedNum", 2),
      publicField(this, "_addNode", (e) => {}),
      publicField(this, "_moveNode", (e) => {}),
      publicField(this, "_changeNode", (e) => {});
  }
  afterAddToEngine() {
    this.initEditor(), this.initInfoMarkers();
  }
  static getLength(e, t, i, n) {
    n = n || VL;
    const { pointToLngLat: s } = Tv.prototype,
      r = Tv.toRadians,
      a = s(new Pv(...e)),
      o = s(new Pv(...t)),
      l = r(o.lat - a.lat) / 2,
      h = r(o.lng - a.lng) / 2,
      c = r(a.lat),
      u = r(o.lat),
      d =
        Math.pow(Math.sin(l), 2) +
        Math.pow(Math.sin(h), 2) * Math.cos(c) * Math.cos(u),
      p = n * (2 * Math.atan2(Math.sqrt(d), Math.sqrt(1 - d))),
      f = Math.abs((e[2] || 0) - (t[2] || 0));
    return "vertical" === i
      ? f
      : "horizontal" === i
      ? p
      : Math.sqrt(Math.pow(p, 2) + Math.pow(f, 2));
  }
  static getSegementLength(e, t) {
    if (e.length < 2) return;
    const i = [];
    let n = e[0];
    for (let s = 1, r = e.length; s < r; s++) {
      let r = e[s];
      const a = QL.getLength(n, r, t);
      i.push(a), (n = r);
    }
    return i;
  }
  static getArea(e, t) {
    t = t || VL;
    const i = Tv.toRadians,
      { pointToLngLat: n } = Tv.prototype;
    let s = 0;
    const r = e.length;
    let { lng: a, lat: o } = n(new Pv(...e[r - 1]));
    for (let h = 0; h < r; h++) {
      let { lng: t, lat: r } = n(new Pv(...e[h]));
      (s += i(t - a) * (2 + Math.sin(i(o)) + Math.sin(i(r)))), (a = t), (o = r);
    }
    const l = (s * t * t) / 2;
    return Math.abs(l);
  }
  static getSpaceArea(e, t) {
    const i = vD.exports.flatten([e]),
      n = vD.exports(i.vertices, i.holes, i.dimensions),
      s = e.map((e) => {
        const t = Tv.prototype.mercatorToLngLat({ lng: e[0], lat: e[1] });
        return qw(t.lng, t.lat, e[2]);
      });
    let r = 0;
    for (let a = 0; a < n.length; a += 3) {
      const e = n[a],
        t = n[a + 1],
        i = n[a + 2],
        o = new Vector3(...s[e]),
        l = new Vector3(...s[t]),
        h = new Vector3(...s[i]),
        c = new Vector3().subVectors(l, o),
        u = new Vector3().subVectors(l, h);
      r += new Vector3().crossVectors(u, c).length() / 2;
    }
    return r;
  }
  get fixedNum() {
    return this._fixedNum;
  }
  set fixedNum(e) {
    this._fixedNum = e;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    e !== this._enabled &&
      ((this._editor.enabled = e),
      (this._enabled = e),
      e
        ? (this._editor.addEventListener("change", this._changeNode),
          this._editor.addEventListener("addNode", this._addNode))
        : (this._editor.removeEventListener("change", this._changeNode),
          this._editor.addEventListener("addNode", this._addNode)));
  }
}

class ClippingPlane {
  constructor(e, t) {
    publicField(this, "isClippingPlane", !0),
      (this._distance = t),
      (this._normal = e),
      (this.index = -1);
  }
  get distance() {
    return this._distance;
  }
  set distance(e) {
    this._distance = e;
  }
  get normal() {
    return this._normal;
  }
  set normal(e) {
    this._normal = e;
  }
  static fromPoint(e, t) {
    const i = new Vector2((e[0] + t[0]) / 2, (e[1] + t[1]) / 2),
      n = Sv(new Vector2(e[0] - t[0], e[1] - t[1])).normalize(),
      s = i.dot(n);
    return new ClippingPlane(new Vector3(n.x, n.y, 0), -s);
  }
}

class ClippingPlaneCollection extends Object3D {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_planes", []),
      publicField(this, "_dirtyIndex", -1),
      publicField(this, "_multipleDirtyPlanes", !1),
      publicField(this, "_enabled", !0),
      publicField(this, "_clippingPlanesTexture"),
      publicField(this, "_useFloatPointTexture", !0),
      publicField(this, "_uint8View"),
      publicField(this, "_float32View"),
      publicField(this, "isClippingPlaneCollection", !0),
      (this._engine = e),
      (this.options = Object.assign(this.getDefaultOptions(), t)),
      (this.modelMatrix = t.modelMatrix || new Matrix4());
    const i = t.planes;
    if (i) {
      const e = i.length;
      for (let t = 0; t < e; t++) this.add(i[t]);
    }
  }
  getDefaultOptions() {
    return {};
  }
  _setIndexDirty(e) {
    (this._multipleDirtyPlanes =
      this._multipleDirtyPlanes ||
      (-1 !== this._dirtyIndex && this._dirtyIndex !== e)),
      (this._dirtyIndex = e);
  }
  _packPlanesAsFloats(e, t) {
    const i = this._float32View;
    let n = 4 * e;
    for (let s = e; s < t; s++) {
      const e = this._planes[s],
        t = e.normal;
      (i[n] = t.x),
        (i[n + 1] = t.y),
        (i[n + 2] = t.z),
        (i[n + 3] = e.distance),
        (n += 4);
    }
  }
  _computeTextureResolution(e) {
    const t = new Vector2(),
      i = this._engine.renderer.getContext(),
      n = i.getParameter(i.MAX_TEXTURE_SIZE);
    return (t.x = Math.min(e, n)), (t.y = Math.ceil(e / t.x)), t;
  }
  update() {
    let e = this._clippingPlanesTexture;
    const t = this._useFloatPointTexture,
      i = this._useFloatPointTexture ? this.length : 2 * this.length;
    if (e) {
      const t = e.width * e.height;
      (t < i || i < 0.25 * t) &&
        (e.dispose(), (e = void 0), (this._clippingPlanesTexture = void 0));
    }
    if (0 === this.length) return;
    if (!e) {
      const n = this._computeTextureResolution(i);
      (n.y *= 2),
        (e = new Va()),
        (e.format = Q),
        (e.flipY = !1),
        (e.minFilter = R),
        (e.magFilter = R),
        (e.image = { width: n.x, height: n.y }),
        (e.width = n.x),
        (e.height = n.y),
        t
          ? ((e.type = z),
            (this._float32View = new Float32Array(n.x * n.y * 4)))
          : ((e.type = B), (this._uint8View = new Uint8Array(n.x * n.y * 4))),
        (this._clippingPlanesTexture = e),
        (this._multipleDirtyPlanes = !0);
    }
    const n = this._dirtyIndex;
    (this._multipleDirtyPlanes || -1 !== this._dirtyIndex) &&
      (this._multipleDirtyPlanes
        ? t &&
          (this._packPlanesAsFloats(0, this._planes.length),
          (e.image = {
            width: e.width,
            height: e.height,
            data: this._float32View,
          }),
          (e.needsUpdate = !0),
          this.dispatchEvent({ type: "update" }))
        : t &&
          (this._packPlanesAsFloats(n, n + 1),
          (e.image.data = this._float32View),
          (e.needsUpdate = !0),
          this.dispatchEvent({ type: "update" })),
      (this._multipleDirtyPlanes = !1),
      (this._dirtyIndex = -1));
  }
  getTextureResolution() {
    const e = new Vector2(),
      t = this._clippingPlanesTexture;
    if (t) return (e.x = t.image.width), (e.y = t.image.height), e;
    const i = this._useFloatPointTexture ? this.length : 2 * this.length,
      n = this._computeTextureResolution(i);
    return (n.y *= 2), n;
  }
  destroy() {
    this._clippingPlanesTexture =
      this._clippingPlanesTexture && this._clippingPlanesTexture.dispose();
  }
  add(e) {
    const t = this._planes.length;
    (e.index = t), this._setIndexDirty(t), this._planes.push(e);
  }
  remove(e) {
    const t = this._planes,
      i = t.indexOf(e);
    if (-1 === i) return !1;
    e.index = -1;
    const n = t.length - 1;
    for (let s = i; s < n; s++) {
      const e = t[s + 1];
      (t[s] = e), (e.index = s);
    }
    return (this._multipleDirtyPlanes = !0), (t.length = n), !0;
  }
  removeAll() {
    const e = this._planes,
      t = e.length;
    for (let i = 0; i < t; ++i) {
      e[i].index = -1;
    }
    (this._multipleDirtyPlanes = !0), (this._planes = []);
  }
  static fromPoints(e, t, i = {}) {
    const n = [],
      s = t.length;
    for (let r = 0; r < s; r++) {
      const e = (r + 1) % s,
        i = t[r],
        a = t[e],
        o = ClippingPlane.fromPoint(i, a);
      n.push(o);
    }
    return new ClippingPlaneCollection(e, { planes: n, edgeWidth: 0, ...i });
  }
  get(e) {
    return this._planes[e];
  }
  get texture() {
    return this._clippingPlanesTexture;
  }
  get length() {
    return this._planes.length;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled !== e && (this._enabled = e);
  }
}
class WL {
  constructor(e, t = {}) {
    publicField(this, "_multiCollections", []),
      publicField(this, "_dataArrayBuffer", null),
      publicField(this, "_lengthArrayBuffer", null),
      publicField(this, "_dirty", !1),
      publicField(this, "_multiClippingPlanesTexture", null),
      publicField(this, "_lengthTexture", null),
      publicField(this, "_maxCollectionLength", 0),
      publicField(this, "_totalPlanesCount", 0),
      publicField(this, "_owner", !1),
      publicField(this, "_unionClipping"),
      publicField(this, "_enabled"),
      (this._engine = e),
      (this._options = Object.assign(this.getDefaultOptions(), t)),
      (this.edgeColor = this._options.edgeColor),
      (this.edgeWidth = this._options.edgeWidth),
      (this.unionClipping = this._options.unionClipping || !1),
      (this._owner = this._options.owner),
      (this._modelMatrix = t.modelMatrix || new Matrix4()),
      (this._enabled = this._options.enabled || !0);
  }
  getDefaultOptions() {
    return { edgeColor: "#ffffff", edgeWidth: 1 };
  }
  add(e) {
    this._multiCollections.push(e), (this._dirty = !0);
  }
  get(e) {
    return this._multiCollections[e];
  }
  contains(e) {
    return (
      -1 !==
      this._multiCollections.findIndex(function (t) {
        return t === e;
      })
    );
  }
  remove(e) {
    const t = this._multiCollections,
      i = t.findIndex(function (t) {
        return t === e;
      });
    return (
      -1 !== i &&
      (t.splice(i, 1),
      e instanceof ClippingPlaneCollection && e.destroy(),
      (this._dirty = !0),
      !0)
    );
  }
  removeAll() {
    this._multiCollections.forEach(function (e) {
      e instanceof ClippingPlaneCollection && e.destroy();
    }),
      (this._multiCollections = []),
      (this._dirty = !0);
  }
  update() {
    const e = this._multiCollections;
    if (
      (e.forEach(function (e) {
        e.enabled && e.update();
      }),
      this._dirty)
    ) {
      let t,
        i = 0,
        n = !0,
        s = 0,
        r = 0;
      for (let a = 0; a < e.length; a++) {
        const o = e[a];
        (s += o.length),
          (r = Math.max(r, o.length)),
          (t = o.texture.height),
          (i += o.texture.width),
          o.texture || (n = !0);
      }
      if (
        ((this._totalPlanesCount = s),
        (this._maxCollectionLength = r),
        n && e.length > 0)
      ) {
        (this._dataArrayBuffer = new Float32Array(i * t * 4)),
          (this._lengthArrayBuffer = new Float32Array(4 * e.length));
        const n = this._dataArrayBuffer,
          s = this._lengthArrayBuffer;
        let r = 0;
        e.forEach(function (e, t) {
          const i = e._float32View;
          let a = 0;
          for (let s = 0; s < e.length; s++)
            (n[r] = i[a]),
              (n[r + 1] = i[a + 1]),
              (n[r + 2] = i[a + 2]),
              (n[r + 3] = i[a + 3]),
              (a += 4),
              (r += 4);
          s[4 * t + 3] = e.length;
        });
        const a = new Va();
        (a.type = z),
          (a.format = Q),
          (a.flipY = !1),
          (a.minFilter = R),
          (a.magFilter = R),
          (a.image = { width: i, height: t, data: n }),
          (a.width = i),
          (a.height = t);
        const o = new Va();
        (o.type = z),
          (o.format = Q),
          (o.flipY = !1),
          (o.minFilter = R),
          (o.magFilter = R),
          (o.image = { width: e.length, height: 1, data: s }),
          (a.needsUpdate = !0),
          (o.needsUpdate = !0),
          (this._multiClippingPlanesTexture = a),
          (this._lengthTexture = o);
      }
      this._dirty = !1;
    }
  }
  destroy() {
    this._multiCollections.forEach(function (e) {
      e instanceof ClippingPlaneCollection && e.destroy();
    }),
      (this._multiCollections = void 0),
      this.texture && this.texture.dispose();
  }
  get length() {
    return this._multiCollections.length;
  }
  get totalPlanesCount() {
    return this._totalPlanesCount;
  }
  get texture() {
    return this._multiClippingPlanesTexture;
  }
  get maxCollectionLength() {
    return this._maxCollectionLength;
  }
  get lengthTexture() {
    return this._lengthTexture;
  }
  get edgeWidth() {
    return this._edgeWidth;
  }
  set edgeWidth(e) {
    this._edgeWidth = e;
  }
  get edgeColor() {
    return this._edgeColor;
  }
  set edgeColor(e) {
    this._edgeColor = e instanceof Color ? e : new Color(e);
  }
  get edgeStyle() {
    const e = this.edgeColor;
    return new Vector4(e.r, e.g, e.b, this._edgeWidth);
  }
  get dirty() {
    return this._dirty;
  }
  get unionClipping() {
    return this._unionClipping;
  }
  set unionClipping(e) {
    this._unionClipping !== e && (this._unionClipping = e);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled !== e && (this._enabled = e);
  }
  get modelMatrix() {
    if (this._owner) {
      const { cameraOffsetX: e, cameraOffsetY: t } =
          this._engine.rendering.renderState,
        i = new Matrix4().makeTranslation(-e, -t, 0);
      return new Matrix4().multiplyMatrices(this._modelMatrix, i);
    }
    return this._modelMatrix;
  }
  get clippingPlanesMatrix() {
    const e = new Matrix4();
    return (
      e.multiplyMatrices(
        this._engine.camera.matrixWorldInverse,
        this.modelMatrix
      ),
      e.invert(),
      e.transpose(),
      e
    );
  }
}
class qL extends Object3D {
  constructor(e = {}) {
    super(),
      publicField(this, "_coveragePosition", []),
      publicField(this, "_splitNum", 100),
      publicField(this, "_bottomImg"),
      publicField(this, "_wallImg"),
      publicField(this, "_bottomPolygon"),
      publicField(this, "_sideWall"),
      publicField(this, "_multiClippingPlaneCollection"),
      publicField(this, "_terrainHeight"),
      publicField(this, "_dirty"),
      publicField(this, "_dirtyList", { lists: [[]], lastIndex: 0 }),
      publicField(this, "isClockWise", (e) => {
        let t = e.length,
          i = 0;
        for (let n = t - 1, s = 0; s < t; n = s++)
          i += e[n][0] * e[s][1] - e[s][0] * e[n][1];
        return i < 0;
      }),
      (this._options = e),
      (this._terrain = this._options.terrain),
      (this._height = this._options.height || 1e3),
      (this._terrainHeight = this._options.terrainHeight),
      (this._isTerrainHeight = this._options.isTerrainHeight || !1),
      (this.coveragePosition = this._options.coveragePosition || []),
      this._options.splitNum && (this._splitNum = this._options.splitNum),
      (this._bottomImg = this._options.bottomImg),
      (this._wallImg = this._options.wallImg);
  }
  afterAddToEngine(e) {
    this._engine = e;
  }
  updateData() {
    this.clear();
    const e = this.coveragePosition;
    if (0 === e.length) return;
    if (!this._terrain)
      return void console.warn("The excavation terrain must be bound");
    this.excavateMinHeight = 1e4;
    const t = this.isConcavePoly(e);
    if (this.dirty) {
      this._clearMultiClippingPlane();
      const i = new WL(this._engine, { owner: !0, edgeWidth: 0 });
      if (t) {
        const t = vD.exports.flatten([e]);
        (this._cutCoordinates = t),
          (this._cutTriangle = vD.exports(t.vertices, t.holes, t.dimensions));
        const n = this._cutCoordinates.vertices,
          s = this._cutTriangle;
        for (let e = 0; e < this._cutTriangle.length; ) {
          const t = s.slice(e, e + 3).map((e) => n.slice(3 * e, 3 * (e + 1))),
            r = ClippingPlaneCollection.fromPoints(this._engine, t, {});
          this._updateExcavateMinHeight(t), i.add(r), (e += 3);
        }
      } else {
        const t = ClippingPlaneCollection.fromPoints(this._engine, e, {});
        this._updateExcavateMinHeight(e), i.add(t);
      }
      (this._multiClippingPlaneCollection = i), (this.dirty = !1);
    } else if (t) {
      const e = this._cutCoordinates.vertices,
        t = this._cutTriangle;
      for (let i = 0; i < this._cutTriangle.length; ) {
        const n = t.slice(i, i + 3).map((t) => e.slice(3 * t, 3 * (t + 1)));
        this._updateExcavateMinHeight(n), (i += 3);
      }
    } else this._updateExcavateMinHeight(e);
    this._prepareData(), this.build();
  }
  _updateExcavateMinHeight(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t],
        n = this._terrain.getHeight(i) || 0;
      n < this.excavateMinHeight && (this.excavateMinHeight = n);
    }
  }
  _clearMultiClippingPlane() {
    this._multiClippingPlaneCollection &&
      (this._multiClippingPlaneCollection.destroy(),
      (this._multiClippingPlaneCollection = null),
      (this._terrain.multiClippingPlanes = null),
      (this.dirty = !0));
  }
  _prepareData() {
    const e = this._coveragePosition;
    let t = 0;
    this.isTerrainHeight &&
      (this.height = this.excavateMinHeight - this.terrainHeight),
      (t = this.excavateMinHeight - this.height);
    const i = [],
      n = [],
      s = [];
    if (this.length > 0)
      for (let r = 0; r < this.length; r++) {
        const a = (r + 1) % this.length,
          o = new Vector2().fromArray(e[r]),
          l = new Vector2().fromArray(e[a]);
        i.push([o.x, o.y]), n.push([o.x, o.y, t]), s.push([o.x, o.y, 0]);
        for (let e = 1; e < this._splitNum; e++) {
          const { x: t, y: n } = new Vector2().lerpVectors(
            o,
            l,
            e / this._splitNum
          );
          i.push([t, n]), s.push([t, n, 0]);
        }
      }
    this.prepareData = { lerp_pos: i, bottom_pos: n, no_height_top: s };
  }
  build() {
    const { bottom_pos: e, lerp_pos: t } = this.prepareData;
    e.push(e[0]);
    const i = [],
      n = e[0][2];
    (this.excavateMaxHeight = -1e4), (this.lerpExcavateMinHeight = 1e4);
    for (let s = 0; s < t.length; s++) {
      const e = t[s];
      let r = this._terrain.getHeight(e);
      if (void 0 === r) {
        let { lists: e, lastIndex: t } = this._dirtyList;
        const i = e[t];
        i.length < 2
          ? i.push(s)
          : i[1] + 1 === s
          ? (i[1] = s)
          : ((t += 1), (e[t] = [s]), (this._dirtyList.lastIndex = t)),
          (r = 0);
      }
      r > this.excavateMaxHeight && (this.excavateMaxHeight = r),
        r < this.lerpExcavateMinHeight && (this.lerpExcavateMinHeight = r),
        r < n && (r = n),
        i.push([...e, r]);
    }
    this._handleDirtyList(i),
      i.push(i[0]),
      (this._terrain.multiClippingPlanes = this._multiClippingPlaneCollection),
      this._createBottomSurface(e),
      this._createWall(i);
  }
  _handleDirtyList(e) {
    const { lists: t } = this._dirtyList,
      i = e.length;
    let n = t.length;
    n > 1 &&
      0 === t[0][0] &&
      t[n - 1][1] === i - 1 &&
      ((t[0][0] = t[n - 1][0]), t.splice(n - 1, 1), (n -= 1));
    for (let s = 0; s < n; s++) {
      const n = t[s];
      if (2 !== n.length) continue;
      let r, a;
      (r = 0 === n[0] ? i - 1 : n[0] - 1), (a = n[1] === i - 1 ? 0 : n[1] + 1);
      const o = e[r][2],
        l = e[a][2] - o;
      let h = 0;
      a > r ? (h = a - r) : a < r && (h = i - r + a);
      let c = 1;
      for (let t = r; t !== a; ) {
        const n = (t + 1) % i,
          s = o + ((c + 1) / h) * l;
        (c += 1), (e[t][2] = s), (t = n);
      }
    }
  }
  _createBottomSurface(e) {
    const t = UT.fromGeoJSONObject({
        type: "FeatureCollection",
        features: [
          { type: "Feature", properties: {}, geometry: { coordinates: [e] } },
        ],
      }),
      i = (this._bottomPolygon = new KD({
        color: "white",
        mapSrc: this._bottomImg,
        mapScale: 1,
      }));
    this._engine.add(i), (i.geometry.useUV = !0), (i.dataSource = t);
  }
  _createWall(e) {
    const t = [];
    let i;
    i = this.isTerrainHeight
      ? this.excavateMaxHeight > this.terrainHeight
        ? this.excavateMaxHeight - this.terrainHeight
        : this.terrainHeight - this.excavateMinHeight
      : this.height + (this.excavateMaxHeight - this.lerpExcavateMinHeight);
    const n = i + (this.excavateMaxHeight - this.lerpExcavateMinHeight) + 500;
    for (let a = 0; a < e.length; a++) {
      const i = [...e[a]];
      (i[2] -= n), t.push(i);
    }
    const s = UT.fromGeoJSONObject({
        type: "FeatureCollection",
        features: [
          {
            type: "Feature",
            properties: {},
            geometry: { type: "LineString", coordinates: t },
          },
        ],
      }),
      r = (this._sideWall = new rL({
        height: n,
        mapSrc: this._wallImg,
        depthWrite: !0,
        color: "#ffffff",
      }));
    this._engine.add(r), (r.geometry.useUV = !0), (r.dataSource = s);
  }
  isConcavePoly(e) {
    let t, i;
    for (let n = 1, s = e.length; n < s - 1; n++) {
      const s = new Vector2().fromArray(e[n - 1]),
        r = new Vector2().fromArray(e[n]),
        a = new Vector2().fromArray(e[n + 1]),
        o = new Vector2().subVectors(r, s),
        l = new Vector2().subVectors(a, r);
      if (((i = o.cross(l) >= 0 ? 1 : -1), void 0 !== t && t !== i)) return !0;
      t = i;
    }
    return !1;
  }
  clear() {
    this._bottomPolygon && this._engine.remove(this._bottomPolygon),
      this._sideWall && this._engine.remove(this._sideWall),
      this._bottomPolygon && this._bottomPolygon.setData(),
      this._sideWall && this._sideWall.setData(),
      (this._dirtyList = { lists: [[]], lastIndex: 0 });
  }
  dispose() {
    this.clear(), this._clearMultiClippingPlane();
  }
  get dirty() {
    return this._dirty;
  }
  set dirty(e) {
    this._dirty !== e && (this._dirty = e);
  }
  get bottomImg() {
    return this._bottomImg;
  }
  set bottomImg(e) {
    this._bottomImg = e;
  }
  get wallImg() {
    return this._wallImg;
  }
  set wallImg(e) {
    this._wallImg = e;
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this._height = e;
  }
  get isTerrainHeight() {
    return this._isTerrainHeight;
  }
  set isTerrainHeight(e) {
    e !== this._isTerrainHeight && (this._isTerrainHeight = e);
  }
  get terrainHeight() {
    return this._terrainHeight;
  }
  set terrainHeight(e) {
    this._terrainHeight = e;
  }
  get coveragePosition() {
    return this._coveragePosition;
  }
  set coveragePosition(e) {
    const t = e.length;
    if (e && t > 2) {
      const t = this.isClockWise(e);
      this._coveragePosition = t ? [...e].reverse() : e;
    } else this._coveragePosition = [];
    this.dirty = !0;
  }
  get length() {
    return this._coveragePosition.length;
  }
  set terrain(e) {
    this._terrain = e;
  }
}
class XL extends ug {
  constructor(e, t, i, n) {
    super(),
      (this.renderScene = t),
      (this.renderCamera = i),
      (this.selectedObjects = void 0 !== n ? n : []),
      (this.visibleEdgeColor = new Color(1, 1, 1)),
      (this.hiddenEdgeColor = new Color(0.1, 0.04, 0.02)),
      (this.edgeGlow = 0),
      (this.usePatternTexture = !1),
      (this.edgeThickness = 1),
      (this.edgeStrength = 3),
      (this.downSampleRatio = 2),
      (this.pulsePeriod = 0),
      (this._visibilityCache = new Map()),
      (this.resolution =
        void 0 !== e ? new Vector2(e.x, e.y) : new Vector2(256, 256));
    const s = Math.round(this.resolution.x / this.downSampleRatio),
      r = Math.round(this.resolution.y / this.downSampleRatio);
    (this.renderTargetMaskBuffer = new ut(
      this.resolution.x,
      this.resolution.y
    )),
      (this.renderTargetMaskBuffer.texture.name = "OutlinePass.mask"),
      (this.renderTargetMaskBuffer.texture.generateMipmaps = !1),
      (this.depthMaterial = new ua()),
      (this.depthMaterial.side = 2),
      (this.depthMaterial.depthPacking = 3201),
      (this.depthMaterial.blending = 0),
      (this.prepareMaskMaterial = this.getPrepareMaskMaterial()),
      (this.prepareMaskMaterial.side = 2),
      (this.prepareMaskMaterial.fragmentShader = (function (e, t) {
        const i = t.isPerspectiveCamera ? "perspective" : "orthographic";
        return e.replace(/DEPTH_TO_VIEW_Z/g, i + "DepthToViewZ");
      })(this.prepareMaskMaterial.fragmentShader, this.renderCamera)),
      (this.renderTargetDepthBuffer = new ut(
        this.resolution.x,
        this.resolution.y,
        { type: G }
      )),
      (this.renderTargetDepthBuffer.texture.name = "OutlinePass.depth"),
      (this.renderTargetDepthBuffer.texture.generateMipmaps = !1),
      (this.renderTargetMaskDownSampleBuffer = new ut(s, r, { type: G })),
      (this.renderTargetMaskDownSampleBuffer.texture.name =
        "OutlinePass.depthDownSample"),
      (this.renderTargetMaskDownSampleBuffer.texture.generateMipmaps = !1),
      (this.renderTargetBlurBuffer1 = new ut(s, r, { type: G })),
      (this.renderTargetBlurBuffer1.texture.name = "OutlinePass.blur1"),
      (this.renderTargetBlurBuffer1.texture.generateMipmaps = !1),
      (this.renderTargetBlurBuffer2 = new ut(
        Math.round(s / 2),
        Math.round(r / 2),
        { type: G }
      )),
      (this.renderTargetBlurBuffer2.texture.name = "OutlinePass.blur2"),
      (this.renderTargetBlurBuffer2.texture.generateMipmaps = !1),
      (this.edgeDetectionMaterial = this.getEdgeDetectionMaterial()),
      (this.renderTargetEdgeBuffer1 = new ut(s, r, { type: G })),
      (this.renderTargetEdgeBuffer1.texture.name = "OutlinePass.edge1"),
      (this.renderTargetEdgeBuffer1.texture.generateMipmaps = !1),
      (this.renderTargetEdgeBuffer2 = new ut(
        Math.round(s / 2),
        Math.round(r / 2),
        { type: G }
      )),
      (this.renderTargetEdgeBuffer2.texture.name = "OutlinePass.edge2"),
      (this.renderTargetEdgeBuffer2.texture.generateMipmaps = !1);
    (this.separableBlurMaterial1 = this.getSeperableBlurMaterial(4)),
      this.separableBlurMaterial1.uniforms.texSize.value.set(s, r),
      (this.separableBlurMaterial1.uniforms.kernelRadius.value = 1),
      (this.separableBlurMaterial2 = this.getSeperableBlurMaterial(4)),
      this.separableBlurMaterial2.uniforms.texSize.value.set(
        Math.round(s / 2),
        Math.round(r / 2)
      ),
      (this.separableBlurMaterial2.uniforms.kernelRadius.value = 4),
      (this.overlayMaterial = this.getOverlayMaterial());
    const a = hg;
    (this.copyUniforms = In.clone(a.uniforms)),
      (this.materialCopy = new ShaderMaterial({
        uniforms: this.copyUniforms,
        vertexShader: a.vertexShader,
        fragmentShader: a.fragmentShader,
        blending: 0,
        depthTest: !1,
        depthWrite: !1,
      })),
      (this.enabled = !0),
      (this.needsSwap = !1),
      (this._oldClearColor = new Color()),
      (this.oldClearAlpha = 1),
      (this.fsQuad = new fg(null)),
      (this.tempPulseColor1 = new Color()),
      (this.tempPulseColor2 = new Color()),
      (this.textureMatrix = new Matrix4());
  }
  dispose() {
    this.renderTargetMaskBuffer.dispose(),
      this.renderTargetDepthBuffer.dispose(),
      this.renderTargetMaskDownSampleBuffer.dispose(),
      this.renderTargetBlurBuffer1.dispose(),
      this.renderTargetBlurBuffer2.dispose(),
      this.renderTargetEdgeBuffer1.dispose(),
      this.renderTargetEdgeBuffer2.dispose(),
      this.depthMaterial.dispose(),
      this.prepareMaskMaterial.dispose(),
      this.edgeDetectionMaterial.dispose(),
      this.separableBlurMaterial1.dispose(),
      this.separableBlurMaterial2.dispose(),
      this.overlayMaterial.dispose(),
      this.materialCopy.dispose(),
      this.fsQuad.dispose();
  }
  setSize(e, t) {
    this.renderTargetMaskBuffer.setSize(e, t),
      this.renderTargetDepthBuffer.setSize(e, t);
    let i = Math.round(e / this.downSampleRatio),
      n = Math.round(t / this.downSampleRatio);
    this.renderTargetMaskDownSampleBuffer.setSize(i, n),
      this.renderTargetBlurBuffer1.setSize(i, n),
      this.renderTargetEdgeBuffer1.setSize(i, n),
      this.separableBlurMaterial1.uniforms.texSize.value.set(i, n),
      (i = Math.round(i / 2)),
      (n = Math.round(n / 2)),
      this.renderTargetBlurBuffer2.setSize(i, n),
      this.renderTargetEdgeBuffer2.setSize(i, n),
      this.separableBlurMaterial2.uniforms.texSize.value.set(i, n);
  }
  changeVisibilityOfSelectedObjects(e) {
    const t = this._visibilityCache;
    function i(i) {
      i.isMesh &&
        (!0 === e
          ? (i.visible = t.get(i))
          : (t.set(i, i.visible), (i.visible = e)));
    }
    for (let n = 0; n < this.selectedObjects.length; n++) {
      this.selectedObjects[n].traverse(i);
    }
  }
  changeVisibilityOfNonSelectedObjects(e) {
    const t = this._visibilityCache,
      i = [];
    function n(e) {
      e.isMesh && i.push(e);
    }
    for (let s = 0; s < this.selectedObjects.length; s++) {
      this.selectedObjects[s].traverse(n);
    }
    this.renderScene.traverse(function (n) {
      if (n.isMesh || n.isSprite) {
        let s = !1;
        for (let e = 0; e < i.length; e++) {
          if (i[e].id === n.id) {
            s = !0;
            break;
          }
        }
        if (!1 === s) {
          const i = n.visible;
          (!1 !== e && !0 !== t.get(n)) || (n.visible = e), t.set(n, i);
        }
      } else (n.isPoints || n.isLine) && (!0 === e ? (n.visible = t.get(n)) : (t.set(n, n.visible), (n.visible = e)));
    });
  }
  updateTextureMatrix() {
    this.textureMatrix.set(
      0.5,
      0,
      0,
      0.5,
      0,
      0.5,
      0,
      0.5,
      0,
      0,
      0.5,
      0.5,
      0,
      0,
      0,
      1
    ),
      this.textureMatrix.multiply(this.renderCamera.projectionMatrix),
      this.textureMatrix.multiply(this.renderCamera.matrixWorldInverse);
  }
  render(e, t, i, n, s) {
    if (this.selectedObjects.length > 0) {
      e.getClearColor(this._oldClearColor),
        (this.oldClearAlpha = e.getClearAlpha());
      const t = e.autoClear;
      (e.autoClear = !1),
        s && e.state.buffers.stencil.setTest(!1),
        e.setClearColor(16777215, 1),
        this.changeVisibilityOfSelectedObjects(!1);
      const n = this.renderScene.background;
      if (
        ((this.renderScene.background = null),
        (this.renderScene.overrideMaterial = this.depthMaterial),
        e.setRenderTarget(this.renderTargetDepthBuffer),
        e.clear(),
        e.render(this.renderScene, this.renderCamera),
        this.changeVisibilityOfSelectedObjects(!0),
        this._visibilityCache.clear(),
        this.updateTextureMatrix(),
        this.changeVisibilityOfNonSelectedObjects(!1),
        (this.renderScene.overrideMaterial = this.prepareMaskMaterial),
        this.prepareMaskMaterial.uniforms.cameraNearFar.value.set(
          this.renderCamera.near,
          this.renderCamera.far
        ),
        (this.prepareMaskMaterial.uniforms.depthTexture.value =
          this.renderTargetDepthBuffer.texture),
        (this.prepareMaskMaterial.uniforms.textureMatrix.value =
          this.textureMatrix),
        e.setRenderTarget(this.renderTargetMaskBuffer),
        e.clear(),
        e.render(this.renderScene, this.renderCamera),
        (this.renderScene.overrideMaterial = null),
        this.changeVisibilityOfNonSelectedObjects(!0),
        this._visibilityCache.clear(),
        (this.renderScene.background = n),
        (this.fsQuad.material = this.materialCopy),
        (this.copyUniforms.tDiffuse.value =
          this.renderTargetMaskBuffer.texture),
        e.setRenderTarget(this.renderTargetMaskDownSampleBuffer),
        e.clear(),
        this.fsQuad.render(e),
        this.tempPulseColor1.copy(this.visibleEdgeColor),
        this.tempPulseColor2.copy(this.hiddenEdgeColor),
        this.pulsePeriod > 0)
      ) {
        const e =
          0.625 +
          (0.75 * Math.cos((0.01 * performance.now()) / this.pulsePeriod)) / 2;
        this.tempPulseColor1.multiplyScalar(e),
          this.tempPulseColor2.multiplyScalar(e);
      }
      (this.fsQuad.material = this.edgeDetectionMaterial),
        (this.edgeDetectionMaterial.uniforms.maskTexture.value =
          this.renderTargetMaskDownSampleBuffer.texture),
        this.edgeDetectionMaterial.uniforms.texSize.value.set(
          this.renderTargetMaskDownSampleBuffer.width,
          this.renderTargetMaskDownSampleBuffer.height
        ),
        (this.edgeDetectionMaterial.uniforms.visibleEdgeColor.value =
          this.tempPulseColor1),
        (this.edgeDetectionMaterial.uniforms.hiddenEdgeColor.value =
          this.tempPulseColor2),
        e.setRenderTarget(this.renderTargetEdgeBuffer1),
        e.clear(),
        this.fsQuad.render(e),
        (this.fsQuad.material = this.separableBlurMaterial1),
        (this.separableBlurMaterial1.uniforms.colorTexture.value =
          this.renderTargetEdgeBuffer1.texture),
        (this.separableBlurMaterial1.uniforms.direction.value =
          XL.BlurDirectionX),
        (this.separableBlurMaterial1.uniforms.kernelRadius.value =
          this.edgeThickness),
        e.setRenderTarget(this.renderTargetBlurBuffer1),
        e.clear(),
        this.fsQuad.render(e),
        (this.separableBlurMaterial1.uniforms.colorTexture.value =
          this.renderTargetBlurBuffer1.texture),
        (this.separableBlurMaterial1.uniforms.direction.value =
          XL.BlurDirectionY),
        e.setRenderTarget(this.renderTargetEdgeBuffer1),
        e.clear(),
        this.fsQuad.render(e),
        (this.fsQuad.material = this.separableBlurMaterial2),
        (this.separableBlurMaterial2.uniforms.colorTexture.value =
          this.renderTargetEdgeBuffer1.texture),
        (this.separableBlurMaterial2.uniforms.direction.value =
          XL.BlurDirectionX),
        e.setRenderTarget(this.renderTargetBlurBuffer2),
        e.clear(),
        this.fsQuad.render(e),
        (this.separableBlurMaterial2.uniforms.colorTexture.value =
          this.renderTargetBlurBuffer2.texture),
        (this.separableBlurMaterial2.uniforms.direction.value =
          XL.BlurDirectionY),
        e.setRenderTarget(this.renderTargetEdgeBuffer2),
        e.clear(),
        this.fsQuad.render(e),
        (this.fsQuad.material = this.overlayMaterial),
        (this.overlayMaterial.uniforms.maskTexture.value =
          this.renderTargetMaskBuffer.texture),
        (this.overlayMaterial.uniforms.edgeTexture1.value =
          this.renderTargetEdgeBuffer1.texture),
        (this.overlayMaterial.uniforms.edgeTexture2.value =
          this.renderTargetEdgeBuffer2.texture),
        (this.overlayMaterial.uniforms.patternTexture.value =
          this.patternTexture),
        (this.overlayMaterial.uniforms.edgeStrength.value = this.edgeStrength),
        (this.overlayMaterial.uniforms.edgeGlow.value = this.edgeGlow),
        (this.overlayMaterial.uniforms.usePatternTexture.value =
          this.usePatternTexture),
        s && e.state.buffers.stencil.setTest(!0),
        e.setRenderTarget(i),
        this.fsQuad.render(e),
        e.setClearColor(this._oldClearColor, this.oldClearAlpha),
        (e.autoClear = t);
    }
    this.renderToScreen &&
      ((this.fsQuad.material = this.materialCopy),
      (this.copyUniforms.tDiffuse.value = i.texture),
      e.setRenderTarget(null),
      this.fsQuad.render(e));
  }
  getPrepareMaskMaterial() {
    return new ShaderMaterial({
      uniforms: {
        depthTexture: { value: null },
        cameraNearFar: { value: new Vector2(0.5, 0.5) },
        textureMatrix: { value: null },
      },
      vertexShader:
        "#include <morphtarget_pars_vertex>\n\t\t\t\t#include <skinning_pars_vertex>\n\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tuniform mat4 textureMatrix;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\t#include <skinbase_vertex>\n\t\t\t\t\t#include <begin_vertex>\n\t\t\t\t\t#include <morphtarget_vertex>\n\t\t\t\t\t#include <skinning_vertex>\n\t\t\t\t\t#include <project_vertex>\n\n\t\t\t\t\tvPosition = mvPosition;\n\n\t\t\t\t\tvec4 worldPosition = vec4( transformed, 1.0 );\n\n\t\t\t\t\t#ifdef USE_INSTANCING\n\n\t\t\t\t\t\tworldPosition = instanceMatrix * worldPosition;\n\n\t\t\t\t\t#endif\n\t\t\t\t\t\n\t\t\t\t\tworldPosition = modelMatrix * worldPosition;\n\n\t\t\t\t\tprojTexCoord = textureMatrix * worldPosition;\n\n\t\t\t\t}",
      fragmentShader:
        "#include <packing>\n\t\t\t\tvarying vec4 vPosition;\n\t\t\t\tvarying vec4 projTexCoord;\n\t\t\t\tuniform sampler2D depthTexture;\n\t\t\t\tuniform vec2 cameraNearFar;\n\n\t\t\t\tvoid main() {\n\n\t\t\t\t\tfloat depth = unpackRGBAToDepth(texture2DProj( depthTexture, projTexCoord ));\n\t\t\t\t\tfloat viewZ = - DEPTH_TO_VIEW_Z( depth, cameraNearFar.x, cameraNearFar.y );\n\t\t\t\t\tfloat depthTest = (-vPosition.z > viewZ) ? 1.0 : 0.0;\n\t\t\t\t\tgl_FragColor = vec4(0.0, depthTest, 1.0, 1.0);\n\n\t\t\t\t}",
    });
  }
  getEdgeDetectionMaterial() {
    return new ShaderMaterial({
      uniforms: {
        maskTexture: { value: null },
        texSize: { value: new Vector2(0.5, 0.5) },
        visibleEdgeColor: { value: new Vector3(1, 1, 1) },
        hiddenEdgeColor: { value: new Vector3(1, 1, 1) },
      },
      vertexShader:
        "varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
      fragmentShader:
        "varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec3 visibleEdgeColor;\n\t\t\t\tuniform vec3 hiddenEdgeColor;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tvec4 uvOffset = vec4(1.0, 0.0, 0.0, 1.0) * vec4(invSize, invSize);\n\t\t\t\t\tvec4 c1 = texture2D( maskTexture, vUv + uvOffset.xy);\n\t\t\t\t\tvec4 c2 = texture2D( maskTexture, vUv - uvOffset.xy);\n\t\t\t\t\tvec4 c3 = texture2D( maskTexture, vUv + uvOffset.yw);\n\t\t\t\t\tvec4 c4 = texture2D( maskTexture, vUv - uvOffset.yw);\n\t\t\t\t\tfloat diff1 = (c1.r - c2.r)*0.5;\n\t\t\t\t\tfloat diff2 = (c3.r - c4.r)*0.5;\n\t\t\t\t\tfloat d = length( vec2(diff1, diff2) );\n\t\t\t\t\tfloat a1 = min(c1.g, c2.g);\n\t\t\t\t\tfloat a2 = min(c3.g, c4.g);\n\t\t\t\t\tfloat visibilityFactor = min(a1, a2);\n\t\t\t\t\tvec3 edgeColor = 1.0 - visibilityFactor > 0.001 ? visibleEdgeColor : hiddenEdgeColor;\n\t\t\t\t\tgl_FragColor = vec4(edgeColor, 1.0) * vec4(d);\n\t\t\t\t}",
    });
  }
  getSeperableBlurMaterial(e) {
    return new ShaderMaterial({
      defines: { MAX_RADIUS: e },
      uniforms: {
        colorTexture: { value: null },
        texSize: { value: new Vector2(0.5, 0.5) },
        direction: { value: new Vector2(0.5, 0.5) },
        kernelRadius: { value: 1 },
      },
      vertexShader:
        "varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
      fragmentShader:
        "#include <common>\n\t\t\t\tvarying vec2 vUv;\n\t\t\t\tuniform sampler2D colorTexture;\n\t\t\t\tuniform vec2 texSize;\n\t\t\t\tuniform vec2 direction;\n\t\t\t\tuniform float kernelRadius;\n\n\t\t\t\tfloat gaussianPdf(in float x, in float sigma) {\n\t\t\t\t\treturn 0.39894 * exp( -0.5 * x * x/( sigma * sigma))/sigma;\n\t\t\t\t}\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec2 invSize = 1.0 / texSize;\n\t\t\t\t\tfloat sigma = kernelRadius/2.0;\n\t\t\t\t\tfloat weightSum = gaussianPdf(0.0, sigma);\n\t\t\t\t\tvec4 diffuseSum = texture2D( colorTexture, vUv) * weightSum;\n\t\t\t\t\tvec2 delta = direction * invSize * kernelRadius/float(MAX_RADIUS);\n\t\t\t\t\tvec2 uvOffset = delta;\n\t\t\t\t\tfor( int i = 1; i <= MAX_RADIUS; i ++ ) {\n\t\t\t\t\t\tfloat x = kernelRadius * float(i) / float(MAX_RADIUS);\n\t\t\t\t\t\tfloat w = gaussianPdf(x, sigma);\n\t\t\t\t\t\tvec4 sample1 = texture2D( colorTexture, vUv + uvOffset);\n\t\t\t\t\t\tvec4 sample2 = texture2D( colorTexture, vUv - uvOffset);\n\t\t\t\t\t\tdiffuseSum += ((sample1 + sample2) * w);\n\t\t\t\t\t\tweightSum += (2.0 * w);\n\t\t\t\t\t\tuvOffset += delta;\n\t\t\t\t\t}\n\t\t\t\t\tgl_FragColor = diffuseSum/weightSum;\n\t\t\t\t}",
    });
  }
  getOverlayMaterial() {
    return new ShaderMaterial({
      uniforms: {
        maskTexture: { value: null },
        edgeTexture1: { value: null },
        edgeTexture2: { value: null },
        patternTexture: { value: null },
        edgeStrength: { value: 1 },
        edgeGlow: { value: 1 },
        usePatternTexture: { value: 0 },
      },
      vertexShader:
        "varying vec2 vUv;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvUv = uv;\n\t\t\t\t\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n\t\t\t\t}",
      fragmentShader:
        "varying vec2 vUv;\n\n\t\t\t\tuniform sampler2D maskTexture;\n\t\t\t\tuniform sampler2D edgeTexture1;\n\t\t\t\tuniform sampler2D edgeTexture2;\n\t\t\t\tuniform sampler2D patternTexture;\n\t\t\t\tuniform float edgeStrength;\n\t\t\t\tuniform float edgeGlow;\n\t\t\t\tuniform bool usePatternTexture;\n\n\t\t\t\tvoid main() {\n\t\t\t\t\tvec4 edgeValue1 = texture2D(edgeTexture1, vUv);\n\t\t\t\t\tvec4 edgeValue2 = texture2D(edgeTexture2, vUv);\n\t\t\t\t\tvec4 maskColor = texture2D(maskTexture, vUv);\n\t\t\t\t\tvec4 patternColor = texture2D(patternTexture, 6.0 * vUv);\n\t\t\t\t\tfloat visibilityFactor = 1.0 - maskColor.g > 0.0 ? 1.0 : 0.5;\n\t\t\t\t\tvec4 edgeValue = edgeValue1 + edgeValue2 * edgeGlow;\n\t\t\t\t\tvec4 finalColor = edgeStrength * maskColor.r * edgeValue;\n\t\t\t\t\tif(usePatternTexture)\n\t\t\t\t\t\tfinalColor += + visibilityFactor * (1.0 - maskColor.r) * (1.0 - patternColor.r);\n\t\t\t\t\tgl_FragColor = finalColor;\n\t\t\t\t}",
      blending: 2,
      depthTest: !1,
      depthWrite: !1,
      transparent: !0,
    });
  }
}
(XL.BlurDirectionX = new Vector2(1, 0)),
  (XL.BlurDirectionY = new Vector2(0, 1));
class YL {
  constructor(e) {
    (this.lnglat = e), (this.h = null);
  }
}
var KL = { exports: {} };
function ZL() {
  return new JL();
}
function JL() {
  this.reset();
}
!(function (e, t) {
  e.exports = (function () {
    function e(e, t) {
      if (!(e instanceof t))
        throw new TypeError("Cannot call a class as a function");
    }
    function t(e, t) {
      for (var i = 0; i < t.length; i++) {
        var n = t[i];
        (n.enumerable = n.enumerable || !1),
          (n.configurable = !0),
          "value" in n && (n.writable = !0),
          Object.defineProperty(e, n.key, n);
      }
    }
    function i(e, i, n) {
      return i && t(e.prototype, i), n && t(e, n), e;
    }
    function n(e, t) {
      if ("function" != typeof t && null !== t)
        throw new TypeError(
          "Super expression must either be null or a function"
        );
      (e.prototype = Object.create(t && t.prototype, {
        constructor: { value: e, writable: !0, configurable: !0 },
      })),
        t && r(e, t);
    }
    function s(e) {
      return (s = Object.setPrototypeOf
        ? Object.getPrototypeOf
        : function (e) {
            return e.__proto__ || Object.getPrototypeOf(e);
          })(e);
    }
    function r(e, t) {
      return (r =
        Object.setPrototypeOf ||
        function (e, t) {
          return (e.__proto__ = t), e;
        })(e, t);
    }
    function a() {
      if ("undefined" == typeof Reflect || !Reflect.construct) return !1;
      if (Reflect.construct.sham) return !1;
      if ("function" == typeof Proxy) return !0;
      try {
        return (
          Boolean.prototype.valueOf.call(
            Reflect.construct(Boolean, [], function () {})
          ),
          !0
        );
      } catch (e) {
        return !1;
      }
    }
    function o(e, t, i) {
      return (o = a()
        ? Reflect.construct
        : function (e, t, i) {
            var n = [null];
            n.push.apply(n, t);
            var s = new (Function.bind.apply(e, n))();
            return i && r(s, i.prototype), s;
          }).apply(null, arguments);
    }
    function l(e) {
      var t = "function" == typeof Map ? new Map() : void 0;
      return (
        (l = function (e) {
          if (
            null === e ||
            ((i = e), -1 === Function.toString.call(i).indexOf("[native code]"))
          )
            return e;
          var i;
          if ("function" != typeof e)
            throw new TypeError(
              "Super expression must either be null or a function"
            );
          if (void 0 !== t) {
            if (t.has(e)) return t.get(e);
            t.set(e, n);
          }
          function n() {
            return o(e, arguments, s(this).constructor);
          }
          return (
            (n.prototype = Object.create(e.prototype, {
              constructor: {
                value: n,
                enumerable: !1,
                writable: !0,
                configurable: !0,
              },
            })),
            r(n, e)
          );
        }),
        l(e)
      );
    }
    function h(e) {
      if (void 0 === e)
        throw new ReferenceError(
          "this hasn't been initialised - super() hasn't been called"
        );
      return e;
    }
    function c(e, t) {
      if (t && ("object" == typeof t || "function" == typeof t)) return t;
      if (void 0 !== t)
        throw new TypeError(
          "Derived constructors may only return object or undefined"
        );
      return h(e);
    }
    function u(e) {
      var t = a();
      return function () {
        var i,
          n = s(e);
        if (t) {
          var r = s(this).constructor;
          i = Reflect.construct(n, arguments, r);
        } else i = n.apply(this, arguments);
        return c(this, i);
      };
    }
    function d(e, t, i) {
      return (d =
        "undefined" != typeof Reflect && Reflect.get
          ? Reflect.get
          : function (e, t, i) {
              var n = (function (e, t) {
                for (
                  ;
                  !Object.prototype.hasOwnProperty.call(e, t) &&
                  null !== (e = s(e));

                );
                return e;
              })(e, t);
              if (n) {
                var r = Object.getOwnPropertyDescriptor(n, t);
                return r.get ? r.get.call(i) : r.value;
              }
            })(e, t, i || e);
    }
    function p(e) {
      return (
        (function (e) {
          if (Array.isArray(e)) return m(e);
        })(e) ||
        (function (e) {
          if (
            ("undefined" != typeof Symbol && null != e[Symbol.iterator]) ||
            null != e["@@iterator"]
          )
            return Array.from(e);
        })(e) ||
        f(e) ||
        (function () {
          throw new TypeError(
            "Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
          );
        })()
      );
    }
    function f(e, t) {
      if (e) {
        if ("string" == typeof e) return m(e, t);
        var i = Object.prototype.toString.call(e).slice(8, -1);
        return (
          "Object" === i && e.constructor && (i = e.constructor.name),
          "Map" === i || "Set" === i
            ? Array.from(e)
            : "Arguments" === i ||
              /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(i)
            ? m(e, t)
            : void 0
        );
      }
    }
    function m(e, t) {
      (null == t || t > e.length) && (t = e.length);
      for (var i = 0, n = new Array(t); i < t; i++) n[i] = e[i];
      return n;
    }
    function g(e, t) {
      var i =
        ("undefined" != typeof Symbol && e[Symbol.iterator]) || e["@@iterator"];
      if (!i) {
        if (
          Array.isArray(e) ||
          (i = f(e)) ||
          (t && e && "number" == typeof e.length)
        ) {
          i && (e = i);
          var n = 0,
            s = function () {};
          return {
            s: s,
            n: function () {
              return n >= e.length ? { done: !0 } : { done: !1, value: e[n++] };
            },
            e: function (e) {
              throw e;
            },
            f: s,
          };
        }
        throw new TypeError(
          "Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."
        );
      }
      var r,
        a = !0,
        o = !1;
      return {
        s: function () {
          i = i.call(e);
        },
        n: function () {
          var e = i.next();
          return (a = e.done), e;
        },
        e: function (e) {
          (o = !0), (r = e);
        },
        f: function () {
          try {
            a || null == i.return || i.return();
          } finally {
            if (o) throw r;
          }
        },
      };
    }
    var _ = (function () {
      function t() {
        e(this, t), t.constructor_.apply(this, arguments);
      }
      return (
        i(
          t,
          [
            {
              key: "getEndCapStyle",
              value: function () {
                return this._endCapStyle;
              },
            },
            {
              key: "isSingleSided",
              value: function () {
                return this._isSingleSided;
              },
            },
            {
              key: "setQuadrantSegments",
              value: function (e) {
                (this._quadrantSegments = e),
                  0 === this._quadrantSegments &&
                    (this._joinStyle = t.JOIN_BEVEL),
                  this._quadrantSegments < 0 &&
                    ((this._joinStyle = t.JOIN_MITRE),
                    (this._mitreLimit = Math.abs(this._quadrantSegments))),
                  e <= 0 && (this._quadrantSegments = 1),
                  this._joinStyle !== t.JOIN_ROUND &&
                    (this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS);
              },
            },
            {
              key: "getJoinStyle",
              value: function () {
                return this._joinStyle;
              },
            },
            {
              key: "setJoinStyle",
              value: function (e) {
                this._joinStyle = e;
              },
            },
            {
              key: "setSimplifyFactor",
              value: function (e) {
                this._simplifyFactor = e < 0 ? 0 : e;
              },
            },
            {
              key: "getSimplifyFactor",
              value: function () {
                return this._simplifyFactor;
              },
            },
            {
              key: "getQuadrantSegments",
              value: function () {
                return this._quadrantSegments;
              },
            },
            {
              key: "setEndCapStyle",
              value: function (e) {
                this._endCapStyle = e;
              },
            },
            {
              key: "getMitreLimit",
              value: function () {
                return this._mitreLimit;
              },
            },
            {
              key: "setMitreLimit",
              value: function (e) {
                this._mitreLimit = e;
              },
            },
            {
              key: "setSingleSided",
              value: function (e) {
                this._isSingleSided = e;
              },
            },
          ],
          [
            {
              key: "constructor_",
              value: function () {
                if (
                  ((this._quadrantSegments = t.DEFAULT_QUADRANT_SEGMENTS),
                  (this._endCapStyle = t.CAP_ROUND),
                  (this._joinStyle = t.JOIN_ROUND),
                  (this._mitreLimit = t.DEFAULT_MITRE_LIMIT),
                  (this._isSingleSided = !1),
                  (this._simplifyFactor = t.DEFAULT_SIMPLIFY_FACTOR),
                  0 === arguments.length)
                );
                else if (1 === arguments.length) {
                  var e = arguments[0];
                  this.setQuadrantSegments(e);
                } else if (2 === arguments.length) {
                  var i = arguments[0],
                    n = arguments[1];
                  this.setQuadrantSegments(i), this.setEndCapStyle(n);
                } else if (4 === arguments.length) {
                  var s = arguments[0],
                    r = arguments[1],
                    a = arguments[2],
                    o = arguments[3];
                  this.setQuadrantSegments(s),
                    this.setEndCapStyle(r),
                    this.setJoinStyle(a),
                    this.setMitreLimit(o);
                }
              },
            },
            {
              key: "bufferDistanceError",
              value: function (e) {
                var t = Math.PI / 2 / e;
                return 1 - Math.cos(t / 2);
              },
            },
          ]
        ),
        t
      );
    })();
    (_.CAP_ROUND = 1),
      (_.CAP_FLAT = 2),
      (_.CAP_SQUARE = 3),
      (_.JOIN_ROUND = 1),
      (_.JOIN_MITRE = 2),
      (_.JOIN_BEVEL = 3),
      (_.DEFAULT_QUADRANT_SEGMENTS = 8),
      (_.DEFAULT_MITRE_LIMIT = 5),
      (_.DEFAULT_SIMPLIFY_FACTOR = 0.01);
    var v = (function (t) {
        n(r, t);
        var s = u(r);
        function r(t) {
          var i;
          return (
            e(this, r),
            ((i = s.call(this, t)).name = Object.keys({ Exception: r })[0]),
            i
          );
        }
        return (
          i(r, [
            {
              key: "toString",
              value: function () {
                return this.message;
              },
            },
          ]),
          r
        );
      })(l(Error)),
      A = (function (t) {
        n(s, t);
        var i = u(s);
        function s(t) {
          var n;
          return (
            e(this, s),
            ((n = i.call(this, t)).name = Object.keys({
              IllegalArgumentException: s,
            })[0]),
            n
          );
        }
        return s;
      })(v),
      y = (function () {
        function t() {
          e(this, t);
        }
        return i(t, [{ key: "filter", value: function (e) {} }]), t;
      })();
    function x() {}
    function b() {}
    function E() {}
    var S,
      C,
      M,
      w,
      T,
      I,
      R,
      P,
      D = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "equalsWithTolerance",
              value: function (e, t, i) {
                return Math.abs(e - t) <= i;
              },
            },
          ]),
          t
        );
      })(),
      L = (function () {
        function t(i, n) {
          e(this, t), (this.low = n || 0), (this.high = i || 0);
        }
        return (
          i(t, null, [
            {
              key: "toBinaryString",
              value: function (e) {
                var t,
                  i = "";
                for (t = 2147483648; t > 0; t >>>= 1)
                  i += (e.high & t) === t ? "1" : "0";
                for (t = 2147483648; t > 0; t >>>= 1)
                  i += (e.low & t) === t ? "1" : "0";
                return i;
              },
            },
          ]),
          t
        );
      })();
    function F() {}
    function N() {}
    (F.NaN = NaN),
      (F.isNaN = function (e) {
        return Number.isNaN(e);
      }),
      (F.isInfinite = function (e) {
        return !Number.isFinite(e);
      }),
      (F.MAX_VALUE = Number.MAX_VALUE),
      (F.POSITIVE_INFINITY = Number.POSITIVE_INFINITY),
      (F.NEGATIVE_INFINITY = Number.NEGATIVE_INFINITY),
      "function" == typeof Float64Array && "function" == typeof Int32Array
        ? ((I = 2146435072),
          (R = new Float64Array(1)),
          (P = new Int32Array(R.buffer)),
          (F.doubleToLongBits = function (e) {
            R[0] = e;
            var t = 0 | P[0],
              i = 0 | P[1];
            return (
              (i & I) === I &&
                0 != (1048575 & i) &&
                0 !== t &&
                ((t = 0), (i = 2146959360)),
              new L(i, t)
            );
          }),
          (F.longBitsToDouble = function (e) {
            return (P[0] = e.low), (P[1] = e.high), R[0];
          }))
        : ((S = 1023),
          (C = Math.log2),
          (M = Math.floor),
          (w = Math.pow),
          (T = (function () {
            for (var e = 53; e > 0; e--) {
              var t = w(2, e) - 1;
              if (M(C(t)) + 1 === e) return t;
            }
            return 0;
          })()),
          (F.doubleToLongBits = function (e) {
            var t, i, n, s, r, a, o, l, h;
            if (
              (e < 0 || 1 / e === Number.NEGATIVE_INFINITY
                ? ((a = 1 << 31), (e = -e))
                : (a = 0),
              0 === e)
            )
              return new L((l = a), (h = 0));
            if (e === 1 / 0) return new L((l = 2146435072 | a), (h = 0));
            if (e != e) return new L((l = 2146959360), (h = 0));
            if (((s = 0), (h = 0), (t = M(e)) > 1))
              if (t <= T)
                (s = M(C(t))) <= 20
                  ? ((h = 0), (l = (t << (20 - s)) & 1048575))
                  : ((h = t % (i = w(2, (n = s - 20))) << (32 - n)),
                    (l = (t / i) & 1048575));
              else
                for (n = t, h = 0; 0 !== (n = M((i = n / 2))); )
                  s++,
                    (h >>>= 1),
                    (h |= (1 & l) << 31),
                    (l >>>= 1),
                    i !== n && (l |= 524288);
            if (((o = s + S), (r = 0 === t), (t = e - t), s < 52 && 0 !== t))
              for (n = 0; ; ) {
                if (
                  ((i = 2 * t) >= 1
                    ? ((t = i - 1),
                      r ? (o--, (r = !1)) : ((n <<= 1), (n |= 1), s++))
                    : ((t = i),
                      r ? 0 == --o && (s++, (r = !1)) : ((n <<= 1), s++)),
                  20 === s)
                )
                  (l |= n), (n = 0);
                else if (52 === s) {
                  h |= n;
                  break;
                }
                if (1 === i) {
                  s < 20
                    ? (l |= n << (20 - s))
                    : s < 52 && (h |= n << (52 - s));
                  break;
                }
              }
            return (l |= o << 20), new L((l |= a), h);
          }),
          (F.longBitsToDouble = function (e) {
            var t,
              i,
              n,
              s,
              r = e.high,
              a = e.low,
              o = r & (1 << 31) ? -1 : 1;
            for (
              n = ((2146435072 & r) >> 20) - S, s = 0, i = 1 << 19, t = 1;
              t <= 20;
              t++
            )
              r & i && (s += w(2, -t)), (i >>>= 1);
            for (i = 1 << 31, t = 21; t <= 52; t++)
              a & i && (s += w(2, -t)), (i >>>= 1);
            if (-1023 === n) {
              if (0 === s) return 0 * o;
              n = -1022;
            } else {
              if (1024 === n) return 0 === s ? o / 0 : NaN;
              s += 1;
            }
            return o * s * w(2, n);
          }));
    var B = (function (t) {
        n(s, t);
        var i = u(s);
        function s(t) {
          var n;
          return (
            e(this, s),
            ((n = i.call(this, t)).name = Object.keys({
              RuntimeException: s,
            })[0]),
            n
          );
        }
        return s;
      })(v),
      k = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return (
            e(this, r),
            (t = s.call(this)),
            r.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(r, null, [
            {
              key: "constructor_",
              value: function () {
                if (0 === arguments.length) B.constructor_.call(this);
                else if (1 === arguments.length) {
                  var e = arguments[0];
                  B.constructor_.call(this, e);
                }
              },
            },
          ]),
          r
        );
      })(B),
      O = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "shouldNeverReachHere",
              value: function () {
                if (0 === arguments.length) t.shouldNeverReachHere(null);
                else if (1 === arguments.length) {
                  var e = arguments[0];
                  throw new k(
                    "Should never reach here" + (null !== e ? ": " + e : "")
                  );
                }
              },
            },
            {
              key: "isTrue",
              value: function () {
                if (1 === arguments.length) {
                  var e = arguments[0];
                  t.isTrue(e, null);
                } else if (2 === arguments.length) {
                  var i = arguments[1];
                  if (!arguments[0]) throw null === i ? new k() : new k(i);
                }
              },
            },
            {
              key: "equals",
              value: function () {
                if (2 === arguments.length) {
                  var e = arguments[0],
                    i = arguments[1];
                  t.equals(e, i, null);
                } else if (3 === arguments.length) {
                  var n = arguments[0],
                    s = arguments[1],
                    r = arguments[2];
                  if (!s.equals(n))
                    throw new k(
                      "Expected " +
                        n +
                        " but encountered " +
                        s +
                        (null !== r ? ": " + r : "")
                    );
                }
              },
            },
          ]),
          t
        );
      })(),
      U = new ArrayBuffer(8),
      z = new Float64Array(U),
      G = new Int32Array(U),
      V = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getM",
                value: function () {
                  return F.NaN;
                },
              },
              {
                key: "setOrdinate",
                value: function (e, i) {
                  switch (e) {
                    case t.X:
                      this.x = i;
                      break;
                    case t.Y:
                      this.y = i;
                      break;
                    case t.Z:
                      this.setZ(i);
                      break;
                    default:
                      throw new A("Invalid ordinate index: " + e);
                  }
                },
              },
              {
                key: "equals2D",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    return this.x === e.x && this.y === e.y;
                  }
                  if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    return (
                      !!D.equalsWithTolerance(this.x, t.x, i) &&
                      !!D.equalsWithTolerance(this.y, t.y, i)
                    );
                  }
                },
              },
              {
                key: "setM",
                value: function (e) {
                  throw new A("Invalid ordinate index: " + t.M);
                },
              },
              {
                key: "getZ",
                value: function () {
                  return this.z;
                },
              },
              {
                key: "getOrdinate",
                value: function (e) {
                  switch (e) {
                    case t.X:
                      return this.x;
                    case t.Y:
                      return this.y;
                    case t.Z:
                      return this.getZ();
                  }
                  throw new A("Invalid ordinate index: " + e);
                },
              },
              {
                key: "equals3D",
                value: function (e) {
                  return (
                    this.x === e.x &&
                    this.y === e.y &&
                    (this.getZ() === e.getZ() ||
                      (F.isNaN(this.getZ()) && F.isNaN(e.getZ())))
                  );
                },
              },
              {
                key: "equals",
                value: function (e) {
                  return e instanceof t && this.equals2D(e);
                },
              },
              {
                key: "equalInZ",
                value: function (e, t) {
                  return D.equalsWithTolerance(this.getZ(), e.getZ(), t);
                },
              },
              {
                key: "setX",
                value: function (e) {
                  this.x = e;
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e;
                  return this.x < t.x
                    ? -1
                    : this.x > t.x
                    ? 1
                    : this.y < t.y
                    ? -1
                    : this.y > t.y
                    ? 1
                    : 0;
                },
              },
              {
                key: "getX",
                value: function () {
                  return this.x;
                },
              },
              {
                key: "setZ",
                value: function (e) {
                  this.z = e;
                },
              },
              {
                key: "clone",
                value: function () {
                  try {
                    return null;
                  } catch (e) {
                    if (e instanceof CloneNotSupportedException)
                      return (
                        O.shouldNeverReachHere(
                          "this shouldn't happen because this class is Cloneable"
                        ),
                        null
                      );
                    throw e;
                  }
                },
              },
              {
                key: "copy",
                value: function () {
                  return new t(this);
                },
              },
              {
                key: "toString",
                value: function () {
                  return (
                    "(" + this.x + ", " + this.y + ", " + this.getZ() + ")"
                  );
                },
              },
              {
                key: "distance3D",
                value: function (e) {
                  var t = this.x - e.x,
                    i = this.y - e.y,
                    n = this.getZ() - e.getZ();
                  return Math.sqrt(t * t + i * i + n * n);
                },
              },
              {
                key: "getY",
                value: function () {
                  return this.y;
                },
              },
              {
                key: "setY",
                value: function (e) {
                  this.y = e;
                },
              },
              {
                key: "distance",
                value: function (e) {
                  var t = this.x - e.x,
                    i = this.y - e.y;
                  return Math.sqrt(t * t + i * i);
                },
              },
              {
                key: "hashCode",
                value: function () {
                  var e = 17;
                  return (
                    37 * (e = 37 * e + t.hashCode(this.x)) + t.hashCode(this.y)
                  );
                },
              },
              {
                key: "setCoordinate",
                value: function (e) {
                  (this.x = e.x), (this.y = e.y), (this.z = e.getZ());
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x, b, E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this.x = null),
                    (this.y = null),
                    (this.z = null),
                    0 === arguments.length)
                  )
                    t.constructor_.call(this, 0, 0);
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    t.constructor_.call(this, e.x, e.y, e.getZ());
                  } else if (2 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1];
                    t.constructor_.call(this, i, n, t.NULL_ORDINATE);
                  } else if (3 === arguments.length) {
                    var s = arguments[0],
                      r = arguments[1],
                      a = arguments[2];
                    (this.x = s), (this.y = r), (this.z = a);
                  }
                },
              },
              {
                key: "hashCode",
                value: function (e) {
                  return (z[0] = e), G[0] ^ G[1];
                },
              },
            ]
          ),
          t
        );
      })(),
      Q = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "compare",
                value: function (e, i) {
                  var n = t.compare(e.x, i.x);
                  if (0 !== n) return n;
                  var s = t.compare(e.y, i.y);
                  return 0 !== s
                    ? s
                    : this._dimensionsToTest <= 2
                    ? 0
                    : t.compare(e.getZ(), i.getZ());
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [N];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (((this._dimensionsToTest = 2), 0 === arguments.length))
                    t.constructor_.call(this, 2);
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    if (2 !== e && 3 !== e)
                      throw new A("only 2 or 3 dimensions may be specified");
                    this._dimensionsToTest = e;
                  }
                },
              },
              {
                key: "compare",
                value: function (e, t) {
                  return e < t
                    ? -1
                    : e > t
                    ? 1
                    : F.isNaN(e)
                    ? F.isNaN(t)
                      ? 0
                      : -1
                    : F.isNaN(t)
                    ? 1
                    : 0;
                },
              },
            ]
          ),
          t
        );
      })();
    (V.DimensionalComparator = Q),
      (V.NULL_ORDINATE = F.NaN),
      (V.X = 0),
      (V.Y = 1),
      (V.Z = 2),
      (V.M = 3);
    var H = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getArea",
                value: function () {
                  return this.getWidth() * this.getHeight();
                },
              },
              {
                key: "equals",
                value: function (e) {
                  if (!(e instanceof t)) return !1;
                  var i = e;
                  return this.isNull()
                    ? i.isNull()
                    : this._maxx === i.getMaxX() &&
                        this._maxy === i.getMaxY() &&
                        this._minx === i.getMinX() &&
                        this._miny === i.getMinY();
                },
              },
              {
                key: "intersection",
                value: function (e) {
                  if (this.isNull() || e.isNull() || !this.intersects(e))
                    return new t();
                  var i = this._minx > e._minx ? this._minx : e._minx,
                    n = this._miny > e._miny ? this._miny : e._miny;
                  return new t(
                    i,
                    this._maxx < e._maxx ? this._maxx : e._maxx,
                    n,
                    this._maxy < e._maxy ? this._maxy : e._maxy
                  );
                },
              },
              {
                key: "isNull",
                value: function () {
                  return this._maxx < this._minx;
                },
              },
              {
                key: "getMaxX",
                value: function () {
                  return this._maxx;
                },
              },
              {
                key: "covers",
                value: function () {
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof V) {
                      var e = arguments[0];
                      return this.covers(e.x, e.y);
                    }
                    if (arguments[0] instanceof t) {
                      var i = arguments[0];
                      return (
                        !this.isNull() &&
                        !i.isNull() &&
                        i.getMinX() >= this._minx &&
                        i.getMaxX() <= this._maxx &&
                        i.getMinY() >= this._miny &&
                        i.getMaxY() <= this._maxy
                      );
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1];
                    return (
                      !this.isNull() &&
                      n >= this._minx &&
                      n <= this._maxx &&
                      s >= this._miny &&
                      s <= this._maxy
                    );
                  }
                },
              },
              {
                key: "intersects",
                value: function () {
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof t) {
                      var e = arguments[0];
                      return (
                        !this.isNull() &&
                        !e.isNull() &&
                        !(
                          e._minx > this._maxx ||
                          e._maxx < this._minx ||
                          e._miny > this._maxy ||
                          e._maxy < this._miny
                        )
                      );
                    }
                    if (arguments[0] instanceof V) {
                      var i = arguments[0];
                      return this.intersects(i.x, i.y);
                    }
                  } else if (2 === arguments.length) {
                    if (
                      arguments[0] instanceof V &&
                      arguments[1] instanceof V
                    ) {
                      var n = arguments[0],
                        s = arguments[1];
                      return !(
                        this.isNull() ||
                        (n.x < s.x ? n.x : s.x) > this._maxx ||
                        (n.x > s.x ? n.x : s.x) < this._minx ||
                        (n.y < s.y ? n.y : s.y) > this._maxy ||
                        (n.y > s.y ? n.y : s.y) < this._miny
                      );
                    }
                    if (
                      "number" == typeof arguments[0] &&
                      "number" == typeof arguments[1]
                    ) {
                      var r = arguments[0],
                        a = arguments[1];
                      return (
                        !this.isNull() &&
                        !(
                          r > this._maxx ||
                          r < this._minx ||
                          a > this._maxy ||
                          a < this._miny
                        )
                      );
                    }
                  }
                },
              },
              {
                key: "getMinY",
                value: function () {
                  return this._miny;
                },
              },
              {
                key: "getDiameter",
                value: function () {
                  if (this.isNull()) return 0;
                  var e = this.getWidth(),
                    t = this.getHeight();
                  return Math.sqrt(e * e + t * t);
                },
              },
              {
                key: "getMinX",
                value: function () {
                  return this._minx;
                },
              },
              {
                key: "expandToInclude",
                value: function () {
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof V) {
                      var e = arguments[0];
                      this.expandToInclude(e.x, e.y);
                    } else if (arguments[0] instanceof t) {
                      var i = arguments[0];
                      if (i.isNull()) return null;
                      this.isNull()
                        ? ((this._minx = i.getMinX()),
                          (this._maxx = i.getMaxX()),
                          (this._miny = i.getMinY()),
                          (this._maxy = i.getMaxY()))
                        : (i._minx < this._minx && (this._minx = i._minx),
                          i._maxx > this._maxx && (this._maxx = i._maxx),
                          i._miny < this._miny && (this._miny = i._miny),
                          i._maxy > this._maxy && (this._maxy = i._maxy));
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1];
                    this.isNull()
                      ? ((this._minx = n),
                        (this._maxx = n),
                        (this._miny = s),
                        (this._maxy = s))
                      : (n < this._minx && (this._minx = n),
                        n > this._maxx && (this._maxx = n),
                        s < this._miny && (this._miny = s),
                        s > this._maxy && (this._maxy = s));
                  }
                },
              },
              {
                key: "minExtent",
                value: function () {
                  if (this.isNull()) return 0;
                  var e = this.getWidth(),
                    t = this.getHeight();
                  return e < t ? e : t;
                },
              },
              {
                key: "getWidth",
                value: function () {
                  return this.isNull() ? 0 : this._maxx - this._minx;
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e;
                  return this.isNull()
                    ? t.isNull()
                      ? 0
                      : -1
                    : t.isNull()
                    ? 1
                    : this._minx < t._minx
                    ? -1
                    : this._minx > t._minx
                    ? 1
                    : this._miny < t._miny
                    ? -1
                    : this._miny > t._miny
                    ? 1
                    : this._maxx < t._maxx
                    ? -1
                    : this._maxx > t._maxx
                    ? 1
                    : this._maxy < t._maxy
                    ? -1
                    : this._maxy > t._maxy
                    ? 1
                    : 0;
                },
              },
              {
                key: "translate",
                value: function (e, t) {
                  if (this.isNull()) return null;
                  this.init(
                    this.getMinX() + e,
                    this.getMaxX() + e,
                    this.getMinY() + t,
                    this.getMaxY() + t
                  );
                },
              },
              {
                key: "copy",
                value: function () {
                  return new t(this);
                },
              },
              {
                key: "toString",
                value: function () {
                  return (
                    "Env[" +
                    this._minx +
                    " : " +
                    this._maxx +
                    ", " +
                    this._miny +
                    " : " +
                    this._maxy +
                    "]"
                  );
                },
              },
              {
                key: "setToNull",
                value: function () {
                  (this._minx = 0),
                    (this._maxx = -1),
                    (this._miny = 0),
                    (this._maxy = -1);
                },
              },
              {
                key: "disjoint",
                value: function (e) {
                  return (
                    !(!this.isNull() && !e.isNull()) ||
                    e._minx > this._maxx ||
                    e._maxx < this._minx ||
                    e._miny > this._maxy ||
                    e._maxy < this._miny
                  );
                },
              },
              {
                key: "getHeight",
                value: function () {
                  return this.isNull() ? 0 : this._maxy - this._miny;
                },
              },
              {
                key: "maxExtent",
                value: function () {
                  if (this.isNull()) return 0;
                  var e = this.getWidth(),
                    t = this.getHeight();
                  return e > t ? e : t;
                },
              },
              {
                key: "expandBy",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    this.expandBy(e, e);
                  } else if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    if (this.isNull()) return null;
                    (this._minx -= t),
                      (this._maxx += t),
                      (this._miny -= i),
                      (this._maxy += i),
                      (this._minx > this._maxx || this._miny > this._maxy) &&
                        this.setToNull();
                  }
                },
              },
              {
                key: "contains",
                value: function () {
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof t) {
                      var e = arguments[0];
                      return this.covers(e);
                    }
                    if (arguments[0] instanceof V) {
                      var i = arguments[0];
                      return this.covers(i);
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1];
                    return this.covers(n, s);
                  }
                },
              },
              {
                key: "centre",
                value: function () {
                  return this.isNull()
                    ? null
                    : new V(
                        (this.getMinX() + this.getMaxX()) / 2,
                        (this.getMinY() + this.getMaxY()) / 2
                      );
                },
              },
              {
                key: "init",
                value: function () {
                  if (0 === arguments.length) this.setToNull();
                  else if (1 === arguments.length) {
                    if (arguments[0] instanceof V) {
                      var e = arguments[0];
                      this.init(e.x, e.x, e.y, e.y);
                    } else if (arguments[0] instanceof t) {
                      var i = arguments[0];
                      (this._minx = i._minx),
                        (this._maxx = i._maxx),
                        (this._miny = i._miny),
                        (this._maxy = i._maxy);
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1];
                    this.init(n.x, s.x, n.y, s.y);
                  } else if (4 === arguments.length) {
                    var r = arguments[0],
                      a = arguments[1],
                      o = arguments[2],
                      l = arguments[3];
                    r < a
                      ? ((this._minx = r), (this._maxx = a))
                      : ((this._minx = a), (this._maxx = r)),
                      o < l
                        ? ((this._miny = o), (this._maxy = l))
                        : ((this._miny = l), (this._maxy = o));
                  }
                },
              },
              {
                key: "getMaxY",
                value: function () {
                  return this._maxy;
                },
              },
              {
                key: "distance",
                value: function (e) {
                  if (this.intersects(e)) return 0;
                  var t = 0;
                  this._maxx < e._minx
                    ? (t = e._minx - this._maxx)
                    : this._minx > e._maxx && (t = this._minx - e._maxx);
                  var i = 0;
                  return (
                    this._maxy < e._miny
                      ? (i = e._miny - this._maxy)
                      : this._miny > e._maxy && (i = this._miny - e._maxy),
                    0 === t ? i : 0 === i ? t : Math.sqrt(t * t + i * i)
                  );
                },
              },
              {
                key: "hashCode",
                value: function () {
                  var e = 17;
                  return (
                    37 *
                      (e =
                        37 *
                          (e =
                            37 * (e = 37 * e + V.hashCode(this._minx)) +
                            V.hashCode(this._maxx)) +
                        V.hashCode(this._miny)) +
                    V.hashCode(this._maxy)
                  );
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x, E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._minx = null),
                    (this._maxx = null),
                    (this._miny = null),
                    (this._maxy = null),
                    0 === arguments.length)
                  )
                    this.init();
                  else if (1 === arguments.length) {
                    if (arguments[0] instanceof V) {
                      var e = arguments[0];
                      this.init(e.x, e.x, e.y, e.y);
                    } else if (arguments[0] instanceof t) {
                      var i = arguments[0];
                      this.init(i);
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1];
                    this.init(n.x, s.x, n.y, s.y);
                  } else if (4 === arguments.length) {
                    var r = arguments[0],
                      a = arguments[1],
                      o = arguments[2],
                      l = arguments[3];
                    this.init(r, a, o, l);
                  }
                },
              },
              {
                key: "intersects",
                value: function () {
                  if (3 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1],
                      i = arguments[2];
                    return (
                      i.x >= (e.x < t.x ? e.x : t.x) &&
                      i.x <= (e.x > t.x ? e.x : t.x) &&
                      i.y >= (e.y < t.y ? e.y : t.y) &&
                      i.y <= (e.y > t.y ? e.y : t.y)
                    );
                  }
                  if (4 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1],
                      r = arguments[2],
                      a = arguments[3],
                      o = Math.min(r.x, a.x),
                      l = Math.max(r.x, a.x),
                      h = Math.min(n.x, s.x),
                      c = Math.max(n.x, s.x);
                    return !(
                      h > l ||
                      c < o ||
                      ((o = Math.min(r.y, a.y)),
                      (l = Math.max(r.y, a.y)),
                      (h = Math.min(n.y, s.y)),
                      (c = Math.max(n.y, s.y)),
                      h > l || c < o)
                    );
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      j = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "isGeometryCollection",
                value: function () {
                  return this.getTypeCode() === t.TYPECODE_GEOMETRYCOLLECTION;
                },
              },
              {
                key: "getFactory",
                value: function () {
                  return this._factory;
                },
              },
              {
                key: "getGeometryN",
                value: function (e) {
                  return this;
                },
              },
              {
                key: "getArea",
                value: function () {
                  return 0;
                },
              },
              {
                key: "isRectangle",
                value: function () {
                  return !1;
                },
              },
              {
                key: "equalsExact",
                value: function (e) {
                  return this === e || this.equalsExact(e, 0);
                },
              },
              {
                key: "geometryChanged",
                value: function () {
                  this.apply(t.geometryChangedFilter);
                },
              },
              {
                key: "geometryChangedAction",
                value: function () {
                  this._envelope = null;
                },
              },
              {
                key: "equalsNorm",
                value: function (e) {
                  return null !== e && this.norm().equalsExact(e.norm());
                },
              },
              {
                key: "getLength",
                value: function () {
                  return 0;
                },
              },
              {
                key: "getNumGeometries",
                value: function () {
                  return 1;
                },
              },
              {
                key: "compareTo",
                value: function () {
                  var e;
                  if (1 === arguments.length) {
                    var t = arguments[0];
                    return (
                      (e = t),
                      this.getTypeCode() !== e.getTypeCode()
                        ? this.getTypeCode() - e.getTypeCode()
                        : this.isEmpty() && e.isEmpty()
                        ? 0
                        : this.isEmpty()
                        ? -1
                        : e.isEmpty()
                        ? 1
                        : this.compareToSameClass(t)
                    );
                  }
                  if (2 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1];
                    return (
                      (e = i),
                      this.getTypeCode() !== e.getTypeCode()
                        ? this.getTypeCode() - e.getTypeCode()
                        : this.isEmpty() && e.isEmpty()
                        ? 0
                        : this.isEmpty()
                        ? -1
                        : e.isEmpty()
                        ? 1
                        : this.compareToSameClass(i, n)
                    );
                  }
                },
              },
              {
                key: "getUserData",
                value: function () {
                  return this._userData;
                },
              },
              {
                key: "getSRID",
                value: function () {
                  return this._SRID;
                },
              },
              {
                key: "getEnvelope",
                value: function () {
                  return this.getFactory().toGeometry(
                    this.getEnvelopeInternal()
                  );
                },
              },
              {
                key: "checkNotGeometryCollection",
                value: function (e) {
                  if (e.getTypeCode() === t.TYPECODE_GEOMETRYCOLLECTION)
                    throw new A(
                      "This method does not support GeometryCollection arguments"
                    );
                },
              },
              {
                key: "equal",
                value: function (e, t, i) {
                  return 0 === i ? e.equals(t) : e.distance(t) <= i;
                },
              },
              {
                key: "norm",
                value: function () {
                  var e = this.copy();
                  return e.normalize(), e;
                },
              },
              {
                key: "reverse",
                value: function () {
                  var e = this.reverseInternal();
                  return (
                    null != this.envelope &&
                      (e.envelope = this.envelope.copy()),
                    e.setSRID(this.getSRID()),
                    e
                  );
                },
              },
              {
                key: "copy",
                value: function () {
                  var e = this.copyInternal();
                  return (
                    (e.envelope =
                      null == this._envelope ? null : this._envelope.copy()),
                    (e._SRID = this._SRID),
                    (e._userData = this._userData),
                    e
                  );
                },
              },
              {
                key: "getPrecisionModel",
                value: function () {
                  return this._factory.getPrecisionModel();
                },
              },
              {
                key: "getEnvelopeInternal",
                value: function () {
                  return (
                    null === this._envelope &&
                      (this._envelope = this.computeEnvelopeInternal()),
                    new H(this._envelope)
                  );
                },
              },
              {
                key: "setSRID",
                value: function (e) {
                  this._SRID = e;
                },
              },
              {
                key: "setUserData",
                value: function (e) {
                  this._userData = e;
                },
              },
              {
                key: "compare",
                value: function (e, t) {
                  for (
                    var i = e.iterator(), n = t.iterator();
                    i.hasNext() && n.hasNext();

                  ) {
                    var s = i.next(),
                      r = n.next(),
                      a = s.compareTo(r);
                    if (0 !== a) return a;
                  }
                  return i.hasNext() ? 1 : n.hasNext() ? -1 : 0;
                },
              },
              {
                key: "hashCode",
                value: function () {
                  return this.getEnvelopeInternal().hashCode();
                },
              },
              {
                key: "isEquivalentClass",
                value: function (e) {
                  return this.getClass() === e.getClass();
                },
              },
              {
                key: "isGeometryCollectionOrDerived",
                value: function () {
                  return (
                    this.getTypeCode() === t.TYPECODE_GEOMETRYCOLLECTION ||
                    this.getTypeCode() === t.TYPECODE_MULTIPOINT ||
                    this.getTypeCode() === t.TYPECODE_MULTILINESTRING ||
                    this.getTypeCode() === t.TYPECODE_MULTIPOLYGON
                  );
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [b, x, E];
                },
              },
              {
                key: "getClass",
                value: function () {
                  return t;
                },
              },
            ],
            [
              {
                key: "hasNonEmptyElements",
                value: function (e) {
                  for (var t = 0; t < e.length; t++)
                    if (!e[t].isEmpty()) return !0;
                  return !1;
                },
              },
              {
                key: "hasNullElements",
                value: function (e) {
                  for (var t = 0; t < e.length; t++)
                    if (null === e[t]) return !0;
                  return !1;
                },
              },
            ]
          ),
          t
        );
      })();
    (j.constructor_ = function (e) {
      e &&
        ((this._envelope = null),
        (this._userData = null),
        (this._factory = e),
        (this._SRID = e.getSRID()));
    }),
      (j.TYPECODE_POINT = 0),
      (j.TYPECODE_MULTIPOINT = 1),
      (j.TYPECODE_LINESTRING = 2),
      (j.TYPECODE_LINEARRING = 3),
      (j.TYPECODE_MULTILINESTRING = 4),
      (j.TYPECODE_POLYGON = 5),
      (j.TYPECODE_MULTIPOLYGON = 6),
      (j.TYPECODE_GEOMETRYCOLLECTION = 7),
      (j.TYPENAME_POINT = "Point"),
      (j.TYPENAME_MULTIPOINT = "MultiPoint"),
      (j.TYPENAME_LINESTRING = "LineString"),
      (j.TYPENAME_LINEARRING = "LinearRing"),
      (j.TYPENAME_MULTILINESTRING = "MultiLineString"),
      (j.TYPENAME_POLYGON = "Polygon"),
      (j.TYPENAME_MULTIPOLYGON = "MultiPolygon"),
      (j.TYPENAME_GEOMETRYCOLLECTION = "GeometryCollection"),
      (j.geometryChangedFilter = {
        get interfaces_() {
          return [y];
        },
        filter: function (e) {
          e.geometryChangedAction();
        },
      });
    var W = (function () {
      function t() {
        e(this, t);
      }
      return (
        i(t, null, [
          {
            key: "toLocationSymbol",
            value: function (e) {
              switch (e) {
                case t.EXTERIOR:
                  return "e";
                case t.BOUNDARY:
                  return "b";
                case t.INTERIOR:
                  return "i";
                case t.NONE:
                  return "-";
              }
              throw new A("Unknown location value: " + e);
            },
          },
        ]),
        t
      );
    })();
    (W.INTERIOR = 0), (W.BOUNDARY = 1), (W.EXTERIOR = 2), (W.NONE = -1);
    var q = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            { key: "add", value: function () {} },
            { key: "addAll", value: function () {} },
            { key: "isEmpty", value: function () {} },
            { key: "iterator", value: function () {} },
            { key: "size", value: function () {} },
            { key: "toArray", value: function () {} },
            { key: "remove", value: function () {} },
          ]),
          t
        );
      })(),
      X = (function (t) {
        n(s, t);
        var i = u(s);
        function s(t) {
          var n;
          return (
            e(this, s),
            ((n = i.call(this, t)).name = Object.keys({
              NoSuchElementException: s,
            })[0]),
            n
          );
        }
        return s;
      })(v),
      Y = (function (t) {
        n(s, t);
        var i = u(s);
        function s(t) {
          var n;
          return (
            e(this, s),
            ((n = i.call(this, t)).name = Object.keys({
              UnsupportedOperationException: s,
            })[0]),
            n
          );
        }
        return s;
      })(v),
      K = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          return e(this, r), s.apply(this, arguments);
        }
        return i(r, [{ key: "contains", value: function () {} }]), r;
      })(q),
      Z = (function (t, s) {
        n(a, t);
        var r = u(a);
        function a(t) {
          var i;
          return (
            e(this, a),
            ((i = r.call(this)).map = new Map()),
            t instanceof q && i.addAll(t),
            i
          );
        }
        return (
          i(a, [
            {
              key: "contains",
              value: function (e) {
                var t = e.hashCode ? e.hashCode() : e;
                return !!this.map.has(t);
              },
            },
            {
              key: "add",
              value: function (e) {
                var t = e.hashCode ? e.hashCode() : e;
                return !this.map.has(t) && !!this.map.set(t, e);
              },
            },
            {
              key: "addAll",
              value: function (e) {
                var t,
                  i = g(e);
                try {
                  for (i.s(); !(t = i.n()).done; ) {
                    var n = t.value;
                    this.add(n);
                  }
                } catch (s) {
                  i.e(s);
                } finally {
                  i.f();
                }
                return !0;
              },
            },
            {
              key: "remove",
              value: function () {
                throw new Y();
              },
            },
            {
              key: "size",
              value: function () {
                return this.map.size;
              },
            },
            {
              key: "isEmpty",
              value: function () {
                return 0 === this.map.size;
              },
            },
            {
              key: "toArray",
              value: function () {
                return Array.from(this.map.values());
              },
            },
            {
              key: "iterator",
              value: function () {
                return new J(this.map);
              },
            },
            {
              key: s,
              value: function () {
                return this.map;
              },
            },
          ]),
          a
        );
      })(K, Symbol.iterator),
      J = (function () {
        function t(i) {
          e(this, t), (this.iterator = i.values());
          var n = this.iterator.next(),
            s = n.done,
            r = n.value;
          (this.done = s), (this.value = r);
        }
        return (
          i(t, [
            {
              key: "next",
              value: function () {
                if (this.done) throw new X();
                var e = this.value,
                  t = this.iterator.next(),
                  i = t.done,
                  n = t.value;
                return (this.done = i), (this.value = n), e;
              },
            },
            {
              key: "hasNext",
              value: function () {
                return !this.done;
              },
            },
            {
              key: "remove",
              value: function () {
                throw new Y();
              },
            },
          ]),
          t
        );
      })(),
      $ = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "opposite",
              value: function (e) {
                return e === t.LEFT ? t.RIGHT : e === t.RIGHT ? t.LEFT : e;
              },
            },
          ]),
          t
        );
      })();
    ($.ON = 0), ($.LEFT = 1), ($.RIGHT = 2);
    var ee = (function (t) {
        n(s, t);
        var i = u(s);
        function s(t) {
          var n;
          return (
            e(this, s),
            ((n = i.call(this, t)).name = Object.keys({
              EmptyStackException: s,
            })[0]),
            n
          );
        }
        return s;
      })(v),
      te = (function (t) {
        n(s, t);
        var i = u(s);
        function s(t) {
          var n;
          return (
            e(this, s),
            ((n = i.call(this, t)).name = Object.keys({
              IndexOutOfBoundsException: s,
            })[0]),
            n
          );
        }
        return s;
      })(v),
      ie = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          return e(this, r), s.apply(this, arguments);
        }
        return (
          i(r, [
            { key: "get", value: function () {} },
            { key: "set", value: function () {} },
            { key: "isEmpty", value: function () {} },
          ]),
          r
        );
      })(q),
      ne = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return e(this, r), ((t = s.call(this)).array = []), t;
        }
        return (
          i(r, [
            {
              key: "add",
              value: function (e) {
                return this.array.push(e), !0;
              },
            },
            {
              key: "get",
              value: function (e) {
                if (e < 0 || e >= this.size()) throw new te();
                return this.array[e];
              },
            },
            {
              key: "push",
              value: function (e) {
                return this.array.push(e), e;
              },
            },
            {
              key: "pop",
              value: function () {
                if (0 === this.array.length) throw new ee();
                return this.array.pop();
              },
            },
            {
              key: "peek",
              value: function () {
                if (0 === this.array.length) throw new ee();
                return this.array[this.array.length - 1];
              },
            },
            {
              key: "empty",
              value: function () {
                return 0 === this.array.length;
              },
            },
            {
              key: "isEmpty",
              value: function () {
                return this.empty();
              },
            },
            {
              key: "search",
              value: function (e) {
                return this.array.indexOf(e);
              },
            },
            {
              key: "size",
              value: function () {
                return this.array.length;
              },
            },
            {
              key: "toArray",
              value: function () {
                return this.array.slice();
              },
            },
          ]),
          r
        );
      })(ie);
    function se(e, t) {
      return e.interfaces_ && e.interfaces_.indexOf(t) > -1;
    }
    var re = (function () {
        function t(i) {
          e(this, t), (this.str = i);
        }
        return (
          i(t, [
            {
              key: "append",
              value: function (e) {
                this.str += e;
              },
            },
            {
              key: "setCharAt",
              value: function (e, t) {
                this.str = this.str.substr(0, e) + t + this.str.substr(e + 1);
              },
            },
            {
              key: "toString",
              value: function () {
                return this.str;
              },
            },
          ]),
          t
        );
      })(),
      ae = (function () {
        function t(i) {
          e(this, t), (this.value = i);
        }
        return (
          i(
            t,
            [
              {
                key: "intValue",
                value: function () {
                  return this.value;
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  return this.value < e ? -1 : this.value > e ? 1 : 0;
                },
              },
            ],
            [
              {
                key: "compare",
                value: function (e, t) {
                  return e < t ? -1 : e > t ? 1 : 0;
                },
              },
              {
                key: "isNan",
                value: function (e) {
                  return Number.isNaN(e);
                },
              },
              {
                key: "valueOf",
                value: function (e) {
                  return new t(e);
                },
              },
            ]
          ),
          t
        );
      })(),
      oe = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "isWhitespace",
              value: function (e) {
                return (e <= 32 && e >= 0) || 127 === e;
              },
            },
            {
              key: "toUpperCase",
              value: function (e) {
                return e.toUpperCase();
              },
            },
          ]),
          t
        );
      })(),
      le = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "le",
                value: function (e) {
                  return (
                    this._hi < e._hi ||
                    (this._hi === e._hi && this._lo <= e._lo)
                  );
                },
              },
              {
                key: "extractSignificantDigits",
                value: function (e, i) {
                  var n = this.abs(),
                    s = t.magnitude(n._hi),
                    r = t.TEN.pow(s);
                  (n = n.divide(r)).gt(t.TEN)
                    ? ((n = n.divide(t.TEN)), (s += 1))
                    : n.lt(t.ONE) && ((n = n.multiply(t.TEN)), (s -= 1));
                  for (
                    var a = s + 1,
                      o = new re(),
                      l = t.MAX_PRINT_DIGITS - 1,
                      h = 0;
                    h <= l;
                    h++
                  ) {
                    e && h === a && o.append(".");
                    var c = Math.trunc(n._hi);
                    if (c < 0) break;
                    var u = !1,
                      d = 0;
                    c > 9 ? ((u = !0), (d = "9")) : (d = "0" + c),
                      o.append(d),
                      (n = n.subtract(t.valueOf(c)).multiply(t.TEN)),
                      u && n.selfAdd(t.TEN);
                    var p = !0,
                      f = t.magnitude(n._hi);
                    if ((f < 0 && Math.abs(f) >= l - h && (p = !1), !p)) break;
                  }
                  return (i[0] = s), o.toString();
                },
              },
              {
                key: "sqr",
                value: function () {
                  return this.multiply(this);
                },
              },
              {
                key: "doubleValue",
                value: function () {
                  return this._hi + this._lo;
                },
              },
              {
                key: "subtract",
                value: function () {
                  if (arguments[0] instanceof t) {
                    var e = arguments[0];
                    return this.add(e.negate());
                  }
                  if ("number" == typeof arguments[0]) {
                    var i = arguments[0];
                    return this.add(-i);
                  }
                },
              },
              {
                key: "equals",
                value: function () {
                  if (1 === arguments.length && arguments[0] instanceof t) {
                    var e = arguments[0];
                    return this._hi === e._hi && this._lo === e._lo;
                  }
                },
              },
              {
                key: "isZero",
                value: function () {
                  return 0 === this._hi && 0 === this._lo;
                },
              },
              {
                key: "selfSubtract",
                value: function () {
                  if (arguments[0] instanceof t) {
                    var e = arguments[0];
                    return this.isNaN() ? this : this.selfAdd(-e._hi, -e._lo);
                  }
                  if ("number" == typeof arguments[0]) {
                    var i = arguments[0];
                    return this.isNaN() ? this : this.selfAdd(-i, 0);
                  }
                },
              },
              {
                key: "getSpecialNumberString",
                value: function () {
                  return this.isZero() ? "0.0" : this.isNaN() ? "NaN " : null;
                },
              },
              {
                key: "min",
                value: function (e) {
                  return this.le(e) ? this : e;
                },
              },
              {
                key: "selfDivide",
                value: function () {
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof t) {
                      var e = arguments[0];
                      return this.selfDivide(e._hi, e._lo);
                    }
                    if ("number" == typeof arguments[0]) {
                      var i = arguments[0];
                      return this.selfDivide(i, 0);
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1],
                      r = null,
                      a = null,
                      o = null,
                      l = null,
                      h = null,
                      c = null,
                      u = null,
                      d = null;
                    return (
                      (h = this._hi / n),
                      (d =
                        (r = (c = t.SPLIT * h) - (r = c - h)) *
                          (o = (d = t.SPLIT * n) - (o = d - n)) -
                        (u = h * n) +
                        r * (l = n - o) +
                        (a = h - r) * o +
                        a * l),
                      (d = h + (c = (this._hi - u - d + this._lo - h * s) / n)),
                      (this._hi = d),
                      (this._lo = h - d + c),
                      this
                    );
                  }
                },
              },
              {
                key: "dump",
                value: function () {
                  return "DD<" + this._hi + ", " + this._lo + ">";
                },
              },
              {
                key: "divide",
                value: function () {
                  if (arguments[0] instanceof t) {
                    var e = arguments[0],
                      i = null,
                      n = null,
                      s = null,
                      r = null,
                      a = null,
                      o = null,
                      l = null,
                      h = null;
                    return (
                      (n =
                        (a = this._hi / e._hi) -
                        (i = (o = t.SPLIT * a) - (i = o - a))),
                      (h =
                        i * (s = (h = t.SPLIT * e._hi) - (s = h - e._hi)) -
                        (l = a * e._hi) +
                        i * (r = e._hi - s) +
                        n * s +
                        n * r),
                      new t(
                        (h =
                          a +
                          (o =
                            (this._hi - l - h + this._lo - a * e._lo) / e._hi)),
                        a - h + o
                      )
                    );
                  }
                  if ("number" == typeof arguments[0]) {
                    var c = arguments[0];
                    return F.isNaN(c)
                      ? t.createNaN()
                      : t.copy(this).selfDivide(c, 0);
                  }
                },
              },
              {
                key: "ge",
                value: function (e) {
                  return (
                    this._hi > e._hi ||
                    (this._hi === e._hi && this._lo >= e._lo)
                  );
                },
              },
              {
                key: "pow",
                value: function (e) {
                  if (0 === e) return t.valueOf(1);
                  var i = new t(this),
                    n = t.valueOf(1),
                    s = Math.abs(e);
                  if (s > 1)
                    for (; s > 0; )
                      s % 2 == 1 && n.selfMultiply(i),
                        (s /= 2) > 0 && (i = i.sqr());
                  else n = i;
                  return e < 0 ? n.reciprocal() : n;
                },
              },
              {
                key: "ceil",
                value: function () {
                  if (this.isNaN()) return t.NaN;
                  var e = Math.ceil(this._hi),
                    i = 0;
                  return (
                    e === this._hi && (i = Math.ceil(this._lo)), new t(e, i)
                  );
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e;
                  return this._hi < t._hi
                    ? -1
                    : this._hi > t._hi
                    ? 1
                    : this._lo < t._lo
                    ? -1
                    : this._lo > t._lo
                    ? 1
                    : 0;
                },
              },
              {
                key: "rint",
                value: function () {
                  return this.isNaN() ? this : this.add(0.5).floor();
                },
              },
              {
                key: "setValue",
                value: function () {
                  if (arguments[0] instanceof t) {
                    var e = arguments[0];
                    return this.init(e), this;
                  }
                  if ("number" == typeof arguments[0]) {
                    var i = arguments[0];
                    return this.init(i), this;
                  }
                },
              },
              {
                key: "max",
                value: function (e) {
                  return this.ge(e) ? this : e;
                },
              },
              {
                key: "sqrt",
                value: function () {
                  if (this.isZero()) return t.valueOf(0);
                  if (this.isNegative()) return t.NaN;
                  var e = 1 / Math.sqrt(this._hi),
                    i = this._hi * e,
                    n = t.valueOf(i),
                    s = this.subtract(n.sqr())._hi * (0.5 * e);
                  return n.add(s);
                },
              },
              {
                key: "selfAdd",
                value: function () {
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof t) {
                      var e = arguments[0];
                      return this.selfAdd(e._hi, e._lo);
                    }
                    if ("number" == typeof arguments[0]) {
                      var i = arguments[0],
                        n = null,
                        s = null,
                        r = null,
                        a = null,
                        o = null,
                        l = null;
                      return (
                        (a = (r = this._hi + i) - (o = r - this._hi)),
                        (s =
                          (l = (a = i - o + (this._hi - a)) + this._lo) +
                          (r - (n = r + l))),
                        (this._hi = n + s),
                        (this._lo = s + (n - this._hi)),
                        this
                      );
                    }
                  } else if (2 === arguments.length) {
                    var h = arguments[0],
                      c = arguments[1],
                      u = null,
                      d = null,
                      p = null,
                      f = null,
                      m = null,
                      g = null,
                      _ = null;
                    (f = this._hi + h),
                      (d = this._lo + c),
                      (m = f - (g = f - this._hi)),
                      (p = d - (_ = d - this._lo));
                    var v =
                        (u = f + (g = (m = h - g + (this._hi - m)) + d)) +
                        (g = (p = c - _ + (this._lo - p)) + (g + (f - u))),
                      A = g + (u - v);
                    return (this._hi = v), (this._lo = A), this;
                  }
                },
              },
              {
                key: "selfMultiply",
                value: function () {
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof t) {
                      var e = arguments[0];
                      return this.selfMultiply(e._hi, e._lo);
                    }
                    if ("number" == typeof arguments[0]) {
                      var i = arguments[0];
                      return this.selfMultiply(i, 0);
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1],
                      r = null,
                      a = null,
                      o = null,
                      l = null,
                      h = null,
                      c = null;
                    (r = (h = t.SPLIT * this._hi) - this._hi),
                      (c = t.SPLIT * n),
                      (r = h - r),
                      (a = this._hi - r),
                      (o = c - n);
                    var u =
                        (h = this._hi * n) +
                        (c =
                          r * (o = c - o) -
                          h +
                          r * (l = n - o) +
                          a * o +
                          a * l +
                          (this._hi * s + this._lo * n)),
                      d = c + (r = h - u);
                    return (this._hi = u), (this._lo = d), this;
                  }
                },
              },
              {
                key: "selfSqr",
                value: function () {
                  return this.selfMultiply(this);
                },
              },
              {
                key: "floor",
                value: function () {
                  if (this.isNaN()) return t.NaN;
                  var e = Math.floor(this._hi),
                    i = 0;
                  return (
                    e === this._hi && (i = Math.floor(this._lo)), new t(e, i)
                  );
                },
              },
              {
                key: "negate",
                value: function () {
                  return this.isNaN() ? this : new t(-this._hi, -this._lo);
                },
              },
              {
                key: "clone",
                value: function () {
                  try {
                    return null;
                  } catch (e) {
                    if (e instanceof CloneNotSupportedException) return null;
                    throw e;
                  }
                },
              },
              {
                key: "multiply",
                value: function () {
                  if (arguments[0] instanceof t) {
                    var e = arguments[0];
                    return e.isNaN()
                      ? t.createNaN()
                      : t.copy(this).selfMultiply(e);
                  }
                  if ("number" == typeof arguments[0]) {
                    var i = arguments[0];
                    return F.isNaN(i)
                      ? t.createNaN()
                      : t.copy(this).selfMultiply(i, 0);
                  }
                },
              },
              {
                key: "isNaN",
                value: function () {
                  return F.isNaN(this._hi);
                },
              },
              {
                key: "intValue",
                value: function () {
                  return Math.trunc(this._hi);
                },
              },
              {
                key: "toString",
                value: function () {
                  var e = t.magnitude(this._hi);
                  return e >= -3 && e <= 20
                    ? this.toStandardNotation()
                    : this.toSciNotation();
                },
              },
              {
                key: "toStandardNotation",
                value: function () {
                  var e = this.getSpecialNumberString();
                  if (null !== e) return e;
                  var i = new Array(1).fill(null),
                    n = this.extractSignificantDigits(!0, i),
                    s = i[0] + 1,
                    r = n;
                  if ("." === n.charAt(0)) r = "0" + n;
                  else if (s < 0) r = "0." + t.stringOfChar("0", -s) + n;
                  else if (-1 === n.indexOf(".")) {
                    var a = s - n.length;
                    r = n + t.stringOfChar("0", a) + ".0";
                  }
                  return this.isNegative() ? "-" + r : r;
                },
              },
              {
                key: "reciprocal",
                value: function () {
                  var e,
                    i,
                    n,
                    s,
                    r = null,
                    a = null,
                    o = null,
                    l = null;
                  (e =
                    (n = 1 / this._hi) - (r = (o = t.SPLIT * n) - (r = o - n))),
                    (a = (l = t.SPLIT * this._hi) - this._hi);
                  var h =
                    n +
                    (o =
                      (1 -
                        (s = n * this._hi) -
                        (l =
                          r * (a = l - a) -
                          s +
                          r * (i = this._hi - a) +
                          e * a +
                          e * i) -
                        n * this._lo) /
                      this._hi);
                  return new t(h, n - h + o);
                },
              },
              {
                key: "toSciNotation",
                value: function () {
                  if (this.isZero()) return t.SCI_NOT_ZERO;
                  var e = this.getSpecialNumberString();
                  if (null !== e) return e;
                  var i = new Array(1).fill(null),
                    n = this.extractSignificantDigits(!1, i),
                    s = t.SCI_NOT_EXPONENT_CHAR + i[0];
                  if ("0" === n.charAt(0))
                    throw new IllegalStateException("Found leading zero: " + n);
                  var r = "";
                  n.length > 1 && (r = n.substring(1));
                  var a = n.charAt(0) + "." + r;
                  return this.isNegative() ? "-" + a + s : a + s;
                },
              },
              {
                key: "abs",
                value: function () {
                  return this.isNaN()
                    ? t.NaN
                    : this.isNegative()
                    ? this.negate()
                    : new t(this);
                },
              },
              {
                key: "isPositive",
                value: function () {
                  return this._hi > 0 || (0 === this._hi && this._lo > 0);
                },
              },
              {
                key: "lt",
                value: function (e) {
                  return (
                    this._hi < e._hi || (this._hi === e._hi && this._lo < e._lo)
                  );
                },
              },
              {
                key: "add",
                value: function () {
                  if (arguments[0] instanceof t) {
                    var e = arguments[0];
                    return t.copy(this).selfAdd(e);
                  }
                  if ("number" == typeof arguments[0]) {
                    var i = arguments[0];
                    return t.copy(this).selfAdd(i);
                  }
                },
              },
              {
                key: "init",
                value: function () {
                  if (1 === arguments.length) {
                    if ("number" == typeof arguments[0]) {
                      var e = arguments[0];
                      (this._hi = e), (this._lo = 0);
                    } else if (arguments[0] instanceof t) {
                      var i = arguments[0];
                      (this._hi = i._hi), (this._lo = i._lo);
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1];
                    (this._hi = n), (this._lo = s);
                  }
                },
              },
              {
                key: "gt",
                value: function (e) {
                  return (
                    this._hi > e._hi || (this._hi === e._hi && this._lo > e._lo)
                  );
                },
              },
              {
                key: "isNegative",
                value: function () {
                  return this._hi < 0 || (0 === this._hi && this._lo < 0);
                },
              },
              {
                key: "trunc",
                value: function () {
                  return this.isNaN()
                    ? t.NaN
                    : this.isPositive()
                    ? this.floor()
                    : this.ceil();
                },
              },
              {
                key: "signum",
                value: function () {
                  return this._hi > 0
                    ? 1
                    : this._hi < 0
                    ? -1
                    : this._lo > 0
                    ? 1
                    : this._lo < 0
                    ? -1
                    : 0;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [E, x, b];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (((this._hi = 0), (this._lo = 0), 0 === arguments.length))
                    this.init(0);
                  else if (1 === arguments.length) {
                    if ("number" == typeof arguments[0]) {
                      var e = arguments[0];
                      this.init(e);
                    } else if (arguments[0] instanceof t) {
                      var i = arguments[0];
                      this.init(i);
                    } else if ("string" == typeof arguments[0]) {
                      var n = arguments[0];
                      t.constructor_.call(this, t.parse(n));
                    }
                  } else if (2 === arguments.length) {
                    var s = arguments[0],
                      r = arguments[1];
                    this.init(s, r);
                  }
                },
              },
              {
                key: "determinant",
                value: function () {
                  if (
                    "number" == typeof arguments[3] &&
                    "number" == typeof arguments[2] &&
                    "number" == typeof arguments[0] &&
                    "number" == typeof arguments[1]
                  ) {
                    var e = arguments[0],
                      i = arguments[1],
                      n = arguments[2],
                      s = arguments[3];
                    return t.determinant(
                      t.valueOf(e),
                      t.valueOf(i),
                      t.valueOf(n),
                      t.valueOf(s)
                    );
                  }
                  if (
                    arguments[3] instanceof t &&
                    arguments[2] instanceof t &&
                    arguments[0] instanceof t &&
                    arguments[1] instanceof t
                  ) {
                    var r = arguments[1],
                      a = arguments[2],
                      o = arguments[3];
                    return arguments[0].multiply(o).selfSubtract(r.multiply(a));
                  }
                },
              },
              {
                key: "sqr",
                value: function (e) {
                  return t.valueOf(e).selfMultiply(e);
                },
              },
              {
                key: "valueOf",
                value: function () {
                  if ("string" == typeof arguments[0]) {
                    var e = arguments[0];
                    return t.parse(e);
                  }
                  if ("number" == typeof arguments[0])
                    return new t(arguments[0]);
                },
              },
              {
                key: "sqrt",
                value: function (e) {
                  return t.valueOf(e).sqrt();
                },
              },
              {
                key: "parse",
                value: function (e) {
                  for (var i = 0, n = e.length; oe.isWhitespace(e.charAt(i)); )
                    i++;
                  var s = !1;
                  if (i < n) {
                    var r = e.charAt(i);
                    ("-" !== r && "+" !== r) || (i++, "-" === r && (s = !0));
                  }
                  for (
                    var a = new t(), o = 0, l = 0, h = 0, c = !1;
                    !(i >= n);

                  ) {
                    var u = e.charAt(i);
                    if ((i++, oe.isDigit(u))) {
                      var d = u - "0";
                      a.selfMultiply(t.TEN), a.selfAdd(d), o++;
                    } else {
                      if ("." !== u) {
                        if ("e" === u || "E" === u) {
                          var p = e.substring(i);
                          try {
                            h = ae.parseInt(p);
                          } catch (v) {
                            throw v instanceof NumberFormatException
                              ? new NumberFormatException(
                                  "Invalid exponent " + p + " in string " + e
                                )
                              : v;
                          }
                          break;
                        }
                        throw new NumberFormatException(
                          "Unexpected character '" +
                            u +
                            "' at position " +
                            i +
                            " in string " +
                            e
                        );
                      }
                      (l = o), (c = !0);
                    }
                  }
                  var f = a;
                  c || (l = o);
                  var m = o - l - h;
                  if (0 === m) f = a;
                  else if (m > 0) {
                    var g = t.TEN.pow(m);
                    f = a.divide(g);
                  } else if (m < 0) {
                    var _ = t.TEN.pow(-m);
                    f = a.multiply(_);
                  }
                  return s ? f.negate() : f;
                },
              },
              {
                key: "createNaN",
                value: function () {
                  return new t(F.NaN, F.NaN);
                },
              },
              {
                key: "copy",
                value: function (e) {
                  return new t(e);
                },
              },
              {
                key: "magnitude",
                value: function (e) {
                  var t = Math.abs(e),
                    i = Math.log(t) / Math.log(10),
                    n = Math.trunc(Math.floor(i));
                  return 10 * Math.pow(10, n) <= t && (n += 1), n;
                },
              },
              {
                key: "stringOfChar",
                value: function (e, t) {
                  for (var i = new re(), n = 0; n < t; n++) i.append(e);
                  return i.toString();
                },
              },
            ]
          ),
          t
        );
      })();
    (le.PI = new le(3.141592653589793, 12246467991473532e-32)),
      (le.TWO_PI = new le(6.283185307179586, 24492935982947064e-32)),
      (le.PI_2 = new le(1.5707963267948966, 6123233995736766e-32)),
      (le.E = new le(2.718281828459045, 14456468917292502e-32)),
      (le.NaN = new le(F.NaN, F.NaN)),
      (le.EPS = 123259516440783e-46),
      (le.SPLIT = 134217729),
      (le.MAX_PRINT_DIGITS = 32),
      (le.TEN = le.valueOf(10)),
      (le.ONE = le.valueOf(1)),
      (le.SCI_NOT_EXPONENT_CHAR = "E"),
      (le.SCI_NOT_ZERO = "0.0E0");
    var he = (function () {
      function t() {
        e(this, t);
      }
      return (
        i(t, null, [
          {
            key: "orientationIndex",
            value: function (e, i, n) {
              var s = t.orientationIndexFilter(e, i, n);
              if (s <= 1) return s;
              var r = le.valueOf(i.x).selfAdd(-e.x),
                a = le.valueOf(i.y).selfAdd(-e.y),
                o = le.valueOf(n.x).selfAdd(-i.x),
                l = le.valueOf(n.y).selfAdd(-i.y);
              return r.selfMultiply(l).selfSubtract(a.selfMultiply(o)).signum();
            },
          },
          {
            key: "signOfDet2x2",
            value: function () {
              if (
                arguments[3] instanceof le &&
                arguments[2] instanceof le &&
                arguments[0] instanceof le &&
                arguments[1] instanceof le
              ) {
                var e = arguments[1],
                  t = arguments[2],
                  i = arguments[3];
                return arguments[0]
                  .multiply(i)
                  .selfSubtract(e.multiply(t))
                  .signum();
              }
              if (
                "number" == typeof arguments[3] &&
                "number" == typeof arguments[2] &&
                "number" == typeof arguments[0] &&
                "number" == typeof arguments[1]
              ) {
                var n = arguments[0],
                  s = arguments[1],
                  r = arguments[2],
                  a = arguments[3],
                  o = le.valueOf(n),
                  l = le.valueOf(s),
                  h = le.valueOf(r),
                  c = le.valueOf(a);
                return o.multiply(c).selfSubtract(l.multiply(h)).signum();
              }
            },
          },
          {
            key: "intersection",
            value: function (e, t, i, n) {
              var s = new le(e.y).selfSubtract(t.y),
                r = new le(t.x).selfSubtract(e.x),
                a = new le(e.x)
                  .selfMultiply(t.y)
                  .selfSubtract(new le(t.x).selfMultiply(e.y)),
                o = new le(i.y).selfSubtract(n.y),
                l = new le(n.x).selfSubtract(i.x),
                h = new le(i.x)
                  .selfMultiply(n.y)
                  .selfSubtract(new le(n.x).selfMultiply(i.y)),
                c = r.multiply(h).selfSubtract(l.multiply(a)),
                u = o.multiply(a).selfSubtract(s.multiply(h)),
                d = s.multiply(l).selfSubtract(o.multiply(r)),
                p = c.selfDivide(d).doubleValue(),
                f = u.selfDivide(d).doubleValue();
              return F.isNaN(p) ||
                F.isInfinite(p) ||
                F.isNaN(f) ||
                F.isInfinite(f)
                ? null
                : new V(p, f);
            },
          },
          {
            key: "orientationIndexFilter",
            value: function (e, i, n) {
              var s = null,
                r = (e.x - n.x) * (i.y - n.y),
                a = (e.y - n.y) * (i.x - n.x),
                o = r - a;
              if (r > 0) {
                if (a <= 0) return t.signum(o);
                s = r + a;
              } else {
                if (!(r < 0)) return t.signum(o);
                if (a >= 0) return t.signum(o);
                s = -r - a;
              }
              var l = t.DP_SAFE_EPSILON * s;
              return o >= l || -o >= l ? t.signum(o) : 2;
            },
          },
          {
            key: "signum",
            value: function (e) {
              return e > 0 ? 1 : e < 0 ? -1 : 0;
            },
          },
        ]),
        t
      );
    })();
    he.DP_SAFE_EPSILON = 1e-15;
    var ce = (function () {
      function t() {
        e(this, t);
      }
      return (
        i(t, [
          {
            key: "getM",
            value: function (e) {
              if (this.hasM()) {
                var t = this.getDimension() - this.getMeasures();
                return this.getOrdinate(e, t);
              }
              return F.NaN;
            },
          },
          { key: "setOrdinate", value: function (e, t, i) {} },
          {
            key: "getZ",
            value: function (e) {
              return this.hasZ() ? this.getOrdinate(e, 2) : F.NaN;
            },
          },
          { key: "size", value: function () {} },
          { key: "getOrdinate", value: function (e, t) {} },
          { key: "getCoordinate", value: function () {} },
          { key: "getCoordinateCopy", value: function (e) {} },
          { key: "createCoordinate", value: function () {} },
          { key: "getDimension", value: function () {} },
          {
            key: "hasM",
            value: function () {
              return this.getMeasures() > 0;
            },
          },
          { key: "getX", value: function (e) {} },
          {
            key: "hasZ",
            value: function () {
              return this.getDimension() - this.getMeasures() > 2;
            },
          },
          {
            key: "getMeasures",
            value: function () {
              return 0;
            },
          },
          { key: "expandEnvelope", value: function (e) {} },
          { key: "copy", value: function () {} },
          { key: "getY", value: function (e) {} },
          { key: "toCoordinateArray", value: function () {} },
          {
            key: "interfaces_",
            get: function () {
              return [b];
            },
          },
        ]),
        t
      );
    })();
    (ce.X = 0), (ce.Y = 1), (ce.Z = 2), (ce.M = 3);
    var ue = (function () {
      function t() {
        e(this, t);
      }
      return (
        i(t, null, [
          {
            key: "index",
            value: function (e, t, i) {
              return he.orientationIndex(e, t, i);
            },
          },
          {
            key: "isCCW",
            value: function () {
              if (arguments[0] instanceof Array) {
                var e = arguments[0],
                  i = e.length - 1;
                if (i < 3)
                  throw new A(
                    "Ring has fewer than 4 points, so orientation cannot be determined"
                  );
                for (var n = e[0], s = 0, r = 1; r <= i; r++) {
                  var a = e[r];
                  a.y > n.y && ((n = a), (s = r));
                }
                var o = s;
                do {
                  (o -= 1) < 0 && (o = i);
                } while (e[o].equals2D(n) && o !== s);
                var l = s;
                do {
                  l = (l + 1) % i;
                } while (e[l].equals2D(n) && l !== s);
                var h = e[o],
                  c = e[l];
                if (h.equals2D(n) || c.equals2D(n) || h.equals2D(c)) return !1;
                var u = t.index(h, n, c);
                return 0 === u ? h.x > c.x : u > 0;
              }
              if (se(arguments[0], ce)) {
                var d = arguments[0],
                  p = d.size() - 1;
                if (p < 3)
                  throw new A(
                    "Ring has fewer than 4 points, so orientation cannot be determined"
                  );
                for (var f = d.getCoordinate(0), m = 0, g = 1; g <= p; g++) {
                  var _ = d.getCoordinate(g);
                  _.y > f.y && ((f = _), (m = g));
                }
                var v = null,
                  y = m;
                do {
                  (y -= 1) < 0 && (y = p), (v = d.getCoordinate(y));
                } while (v.equals2D(f) && y !== m);
                var x = null,
                  b = m;
                do {
                  (b = (b + 1) % p), (x = d.getCoordinate(b));
                } while (x.equals2D(f) && b !== m);
                if (v.equals2D(f) || x.equals2D(f) || v.equals2D(x)) return !1;
                var E = t.index(v, f, x);
                return 0 === E ? v.x > x.x : E > 0;
              }
            },
          },
        ]),
        t
      );
    })();
    (ue.CLOCKWISE = -1),
      (ue.RIGHT = ue.CLOCKWISE),
      (ue.COUNTERCLOCKWISE = 1),
      (ue.LEFT = ue.COUNTERCLOCKWISE),
      (ue.COLLINEAR = 0),
      (ue.STRAIGHT = ue.COLLINEAR);
    var de = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getCoordinate",
                value: function () {
                  return this._minCoord;
                },
              },
              {
                key: "getRightmostSide",
                value: function (e, t) {
                  var i = this.getRightmostSideOfSegment(e, t);
                  return (
                    i < 0 && (i = this.getRightmostSideOfSegment(e, t - 1)),
                    i < 0 &&
                      ((this._minCoord = null),
                      this.checkForRightmostCoordinate(e)),
                    i
                  );
                },
              },
              {
                key: "findRightmostEdgeAtVertex",
                value: function () {
                  var e = this._minDe.getEdge().getCoordinates();
                  O.isTrue(
                    this._minIndex > 0 && this._minIndex < e.length,
                    "rightmost point expected to be interior vertex of edge"
                  );
                  var t = e[this._minIndex - 1],
                    i = e[this._minIndex + 1],
                    n = ue.index(this._minCoord, i, t),
                    s = !1;
                  ((t.y < this._minCoord.y &&
                    i.y < this._minCoord.y &&
                    n === ue.COUNTERCLOCKWISE) ||
                    (t.y > this._minCoord.y &&
                      i.y > this._minCoord.y &&
                      n === ue.CLOCKWISE)) &&
                    (s = !0),
                    s && (this._minIndex = this._minIndex - 1);
                },
              },
              {
                key: "getRightmostSideOfSegment",
                value: function (e, t) {
                  var i = e.getEdge().getCoordinates();
                  if (t < 0 || t + 1 >= i.length) return -1;
                  if (i[t].y === i[t + 1].y) return -1;
                  var n = $.LEFT;
                  return i[t].y < i[t + 1].y && (n = $.RIGHT), n;
                },
              },
              {
                key: "getEdge",
                value: function () {
                  return this._orientedDe;
                },
              },
              {
                key: "checkForRightmostCoordinate",
                value: function (e) {
                  for (
                    var t = e.getEdge().getCoordinates(), i = 0;
                    i < t.length - 1;
                    i++
                  )
                    (null === this._minCoord || t[i].x > this._minCoord.x) &&
                      ((this._minDe = e),
                      (this._minIndex = i),
                      (this._minCoord = t[i]));
                },
              },
              {
                key: "findRightmostEdgeAtNode",
                value: function () {
                  var e = this._minDe.getNode().getEdges();
                  (this._minDe = e.getRightmostEdge()),
                    this._minDe.isForward() ||
                      ((this._minDe = this._minDe.getSym()),
                      (this._minIndex =
                        this._minDe.getEdge().getCoordinates().length - 1));
                },
              },
              {
                key: "findEdge",
                value: function (e) {
                  for (var t = e.iterator(); t.hasNext(); ) {
                    var i = t.next();
                    i.isForward() && this.checkForRightmostCoordinate(i);
                  }
                  O.isTrue(
                    0 !== this._minIndex ||
                      this._minCoord.equals(this._minDe.getCoordinate()),
                    "inconsistency in rightmost processing"
                  ),
                    0 === this._minIndex
                      ? this.findRightmostEdgeAtNode()
                      : this.findRightmostEdgeAtVertex(),
                    (this._orientedDe = this._minDe),
                    this.getRightmostSide(this._minDe, this._minIndex) ===
                      $.LEFT && (this._orientedDe = this._minDe.getSym());
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._minIndex = -1),
                    (this._minCoord = null),
                    (this._minDe = null),
                    (this._orientedDe = null);
                },
              },
            ]
          ),
          t
        );
      })(),
      pe = (function (t) {
        n(r, t);
        var s = u(r);
        function r(t, i) {
          var n;
          return (
            e(this, r),
            ((n = s.call(this, i ? t + " [ " + i + " ]" : t)).pt = i
              ? new V(i)
              : void 0),
            (n.name = Object.keys({ TopologyException: r })[0]),
            n
          );
        }
        return (
          i(r, [
            {
              key: "getCoordinate",
              value: function () {
                return this.pt;
              },
            },
          ]),
          r
        );
      })(B),
      fe = (function () {
        function t() {
          e(this, t), (this.array = []);
        }
        return (
          i(t, [
            {
              key: "addLast",
              value: function (e) {
                this.array.push(e);
              },
            },
            {
              key: "removeFirst",
              value: function () {
                return this.array.shift();
              },
            },
            {
              key: "isEmpty",
              value: function () {
                return 0 === this.array.length;
              },
            },
          ]),
          t
        );
      })(),
      me = (function (t, s) {
        n(a, t);
        var r = u(a);
        function a(t) {
          var i;
          return (
            e(this, a),
            ((i = r.call(this)).array = []),
            t instanceof q && i.addAll(t),
            i
          );
        }
        return (
          i(a, [
            {
              key: "interfaces_",
              get: function () {
                return [ie, q];
              },
            },
            { key: "ensureCapacity", value: function () {} },
            {
              key: "add",
              value: function (e) {
                return (
                  1 === arguments.length
                    ? this.array.push(e)
                    : this.array.splice(arguments[0], 0, arguments[1]),
                  !0
                );
              },
            },
            {
              key: "clear",
              value: function () {
                this.array = [];
              },
            },
            {
              key: "addAll",
              value: function (e) {
                var t,
                  i = g(e);
                try {
                  for (i.s(); !(t = i.n()).done; ) {
                    var n = t.value;
                    this.array.push(n);
                  }
                } catch (s) {
                  i.e(s);
                } finally {
                  i.f();
                }
              },
            },
            {
              key: "set",
              value: function (e, t) {
                var i = this.array[e];
                return (this.array[e] = t), i;
              },
            },
            {
              key: "iterator",
              value: function () {
                return new ge(this);
              },
            },
            {
              key: "get",
              value: function (e) {
                if (e < 0 || e >= this.size()) throw new te();
                return this.array[e];
              },
            },
            {
              key: "isEmpty",
              value: function () {
                return 0 === this.array.length;
              },
            },
            {
              key: "sort",
              value: function (e) {
                e
                  ? this.array.sort(function (t, i) {
                      return e.compare(t, i);
                    })
                  : this.array.sort();
              },
            },
            {
              key: "size",
              value: function () {
                return this.array.length;
              },
            },
            {
              key: "toArray",
              value: function () {
                return this.array.slice();
              },
            },
            {
              key: "remove",
              value: function (e) {
                for (var t = 0, i = this.array.length; t < i; t++)
                  if (this.array[t] === e) return !!this.array.splice(t, 1);
                return !1;
              },
            },
            {
              key: s,
              value: function () {
                return this.array.values();
              },
            },
          ]),
          a
        );
      })(ie, Symbol.iterator),
      ge = (function () {
        function t(i) {
          e(this, t), (this.arrayList = i), (this.position = 0);
        }
        return (
          i(t, [
            {
              key: "next",
              value: function () {
                if (this.position === this.arrayList.size()) throw new X();
                return this.arrayList.get(this.position++);
              },
            },
            {
              key: "hasNext",
              value: function () {
                return this.position < this.arrayList.size();
              },
            },
            {
              key: "set",
              value: function (e) {
                return this.arrayList.set(this.position - 1, e);
              },
            },
            {
              key: "remove",
              value: function () {
                this.arrayList.remove(this.arrayList.get(this.position));
              },
            },
          ]),
          t
        );
      })(),
      _e = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "clearVisitedEdges",
                value: function () {
                  for (var e = this._dirEdgeList.iterator(); e.hasNext(); )
                    e.next().setVisited(!1);
                },
              },
              {
                key: "getRightmostCoordinate",
                value: function () {
                  return this._rightMostCoord;
                },
              },
              {
                key: "computeNodeDepth",
                value: function (e) {
                  for (
                    var t = null, i = e.getEdges().iterator();
                    i.hasNext();

                  ) {
                    var n = i.next();
                    if (n.isVisited() || n.getSym().isVisited()) {
                      t = n;
                      break;
                    }
                  }
                  if (null === t)
                    throw new pe(
                      "unable to find edge to compute depths at " +
                        e.getCoordinate()
                    );
                  e.getEdges().computeDepths(t);
                  for (var s = e.getEdges().iterator(); s.hasNext(); ) {
                    var r = s.next();
                    r.setVisited(!0), this.copySymDepths(r);
                  }
                },
              },
              {
                key: "computeDepth",
                value: function (e) {
                  this.clearVisitedEdges();
                  var t = this._finder.getEdge();
                  t.getNode(),
                    t.getLabel(),
                    t.setEdgeDepths($.RIGHT, e),
                    this.copySymDepths(t),
                    this.computeDepths(t);
                },
              },
              {
                key: "create",
                value: function (e) {
                  this.addReachable(e),
                    this._finder.findEdge(this._dirEdgeList),
                    (this._rightMostCoord = this._finder.getCoordinate());
                },
              },
              {
                key: "findResultEdges",
                value: function () {
                  for (var e = this._dirEdgeList.iterator(); e.hasNext(); ) {
                    var t = e.next();
                    t.getDepth($.RIGHT) >= 1 &&
                      t.getDepth($.LEFT) <= 0 &&
                      !t.isInteriorAreaEdge() &&
                      t.setInResult(!0);
                  }
                },
              },
              {
                key: "computeDepths",
                value: function (e) {
                  var t = new Z(),
                    i = new fe(),
                    n = e.getNode();
                  for (
                    i.addLast(n), t.add(n), e.setVisited(!0);
                    !i.isEmpty();

                  ) {
                    var s = i.removeFirst();
                    t.add(s), this.computeNodeDepth(s);
                    for (var r = s.getEdges().iterator(); r.hasNext(); ) {
                      var a = r.next().getSym();
                      if (!a.isVisited()) {
                        var o = a.getNode();
                        t.contains(o) || (i.addLast(o), t.add(o));
                      }
                    }
                  }
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e;
                  return this._rightMostCoord.x < t._rightMostCoord.x
                    ? -1
                    : this._rightMostCoord.x > t._rightMostCoord.x
                    ? 1
                    : 0;
                },
              },
              {
                key: "getEnvelope",
                value: function () {
                  if (null === this._env) {
                    for (
                      var e = new H(), t = this._dirEdgeList.iterator();
                      t.hasNext();

                    )
                      for (
                        var i = t.next().getEdge().getCoordinates(), n = 0;
                        n < i.length - 1;
                        n++
                      )
                        e.expandToInclude(i[n]);
                    this._env = e;
                  }
                  return this._env;
                },
              },
              {
                key: "addReachable",
                value: function (e) {
                  var t = new ne();
                  for (t.add(e); !t.empty(); ) {
                    var i = t.pop();
                    this.add(i, t);
                  }
                },
              },
              {
                key: "copySymDepths",
                value: function (e) {
                  var t = e.getSym();
                  t.setDepth($.LEFT, e.getDepth($.RIGHT)),
                    t.setDepth($.RIGHT, e.getDepth($.LEFT));
                },
              },
              {
                key: "add",
                value: function (e, t) {
                  e.setVisited(!0), this._nodes.add(e);
                  for (var i = e.getEdges().iterator(); i.hasNext(); ) {
                    var n = i.next();
                    this._dirEdgeList.add(n);
                    var s = n.getSym().getNode();
                    s.isVisited() || t.push(s);
                  }
                },
              },
              {
                key: "getNodes",
                value: function () {
                  return this._nodes;
                },
              },
              {
                key: "getDirectedEdges",
                value: function () {
                  return this._dirEdgeList;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._finder = null),
                    (this._dirEdgeList = new me()),
                    (this._nodes = new me()),
                    (this._rightMostCoord = null),
                    (this._env = null),
                    (this._finder = new de());
                },
              },
            ]
          ),
          t
        );
      })(),
      ve = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "intersection",
              value: function (e, t, i, n) {
                var s = e.x < t.x ? e.x : t.x,
                  r = e.y < t.y ? e.y : t.y,
                  a = e.x > t.x ? e.x : t.x,
                  o = e.y > t.y ? e.y : t.y,
                  l = i.x < n.x ? i.x : n.x,
                  h = i.y < n.y ? i.y : n.y,
                  c = i.x > n.x ? i.x : n.x,
                  u = i.y > n.y ? i.y : n.y,
                  d = ((s > l ? s : l) + (a < c ? a : c)) / 2,
                  p = ((r > h ? r : h) + (o < u ? o : u)) / 2,
                  f = e.x - d,
                  m = e.y - p,
                  g = t.x - d,
                  _ = t.y - p,
                  v = i.x - d,
                  A = i.y - p,
                  y = n.x - d,
                  x = n.y - p,
                  b = m - _,
                  E = g - f,
                  S = f * _ - g * m,
                  C = A - x,
                  M = y - v,
                  w = v * x - y * A,
                  T = b * M - C * E,
                  I = (E * w - M * S) / T,
                  R = (C * S - b * w) / T;
                return F.isNaN(I) ||
                  F.isInfinite(I) ||
                  F.isNaN(R) ||
                  F.isInfinite(R)
                  ? null
                  : new V(I + d, R + p);
              },
            },
          ]),
          t
        );
      })(),
      Ae = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "arraycopy",
              value: function (e, t, i, n, s) {
                for (var r = 0, a = t; a < t + s; a++) (i[n + r] = e[a]), r++;
              },
            },
            {
              key: "getProperty",
              value: function (e) {
                return { "line.separator": "\n" }[e];
              },
            },
          ]),
          t
        );
      })(),
      ye = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "log10",
              value: function (e) {
                var i = Math.log(e);
                return F.isInfinite(i) || F.isNaN(i) ? i : i / t.LOG_10;
              },
            },
            {
              key: "min",
              value: function (e, t, i, n) {
                var s = e;
                return t < s && (s = t), i < s && (s = i), n < s && (s = n), s;
              },
            },
            {
              key: "clamp",
              value: function () {
                if (
                  "number" == typeof arguments[2] &&
                  "number" == typeof arguments[0] &&
                  "number" == typeof arguments[1]
                ) {
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2];
                  return e < t ? t : e > i ? i : e;
                }
                if (
                  Number.isInteger(arguments[2]) &&
                  Number.isInteger(arguments[0]) &&
                  Number.isInteger(arguments[1])
                ) {
                  var n = arguments[0],
                    s = arguments[1],
                    r = arguments[2];
                  return n < s ? s : n > r ? r : n;
                }
              },
            },
            {
              key: "wrap",
              value: function (e, t) {
                return e < 0 ? t - (-e % t) : e % t;
              },
            },
            {
              key: "max",
              value: function () {
                if (3 === arguments.length) {
                  var e = arguments[1],
                    t = arguments[2],
                    i = arguments[0];
                  return e > i && (i = e), t > i && (i = t), i;
                }
                if (4 === arguments.length) {
                  var n = arguments[1],
                    s = arguments[2],
                    r = arguments[3],
                    a = arguments[0];
                  return (
                    n > a && (a = n), s > a && (a = s), r > a && (a = r), a
                  );
                }
              },
            },
            {
              key: "average",
              value: function (e, t) {
                return (e + t) / 2;
              },
            },
          ]),
          t
        );
      })();
    ye.LOG_10 = Math.log(10);
    var xe = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "segmentToSegment",
              value: function (e, i, n, s) {
                if (e.equals(i)) return t.pointToSegment(e, n, s);
                if (n.equals(s)) return t.pointToSegment(s, e, i);
                var r = !1;
                if (H.intersects(e, i, n, s)) {
                  var a = (i.x - e.x) * (s.y - n.y) - (i.y - e.y) * (s.x - n.x);
                  if (0 === a) r = !0;
                  else {
                    var o =
                        (e.y - n.y) * (s.x - n.x) - (e.x - n.x) * (s.y - n.y),
                      l =
                        ((e.y - n.y) * (i.x - e.x) -
                          (e.x - n.x) * (i.y - e.y)) /
                        a,
                      h = o / a;
                    (h < 0 || h > 1 || l < 0 || l > 1) && (r = !0);
                  }
                } else r = !0;
                return r
                  ? ye.min(
                      t.pointToSegment(e, n, s),
                      t.pointToSegment(i, n, s),
                      t.pointToSegment(n, e, i),
                      t.pointToSegment(s, e, i)
                    )
                  : 0;
              },
            },
            {
              key: "pointToSegment",
              value: function (e, t, i) {
                if (t.x === i.x && t.y === i.y) return e.distance(t);
                var n = (i.x - t.x) * (i.x - t.x) + (i.y - t.y) * (i.y - t.y),
                  s =
                    ((e.x - t.x) * (i.x - t.x) + (e.y - t.y) * (i.y - t.y)) / n;
                if (s <= 0) return e.distance(t);
                if (s >= 1) return e.distance(i);
                var r =
                  ((t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)) / n;
                return Math.abs(r) * Math.sqrt(n);
              },
            },
            {
              key: "pointToLinePerpendicular",
              value: function (e, t, i) {
                var n = (i.x - t.x) * (i.x - t.x) + (i.y - t.y) * (i.y - t.y),
                  s =
                    ((t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)) / n;
                return Math.abs(s) * Math.sqrt(n);
              },
            },
            {
              key: "pointToSegmentString",
              value: function (e, i) {
                if (0 === i.length)
                  throw new A("Line array must contain at least one vertex");
                for (var n = e.distance(i[0]), s = 0; s < i.length - 1; s++) {
                  var r = t.pointToSegment(e, i[s], i[s + 1]);
                  r < n && (n = r);
                }
                return n;
              },
            },
          ]),
          t
        );
      })(),
      be = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            {
              key: "create",
              value: function () {
                if (1 === arguments.length)
                  arguments[0] instanceof Array || se(arguments[0], ce);
                else if (2 === arguments.length);
                else if (3 === arguments.length) {
                  var e = arguments[0],
                    t = arguments[1];
                  return this.create(e, t);
                }
              },
            },
          ]),
          t
        );
      })(),
      Ee = (function () {
        function t() {
          e(this, t);
        }
        return i(t, [{ key: "filter", value: function (e) {} }]), t;
      })(),
      Se = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "ofLine",
              value: function (e) {
                var t = e.size();
                if (t <= 1) return 0;
                var i = 0,
                  n = new V();
                e.getCoordinate(0, n);
                for (var s = n.x, r = n.y, a = 1; a < t; a++) {
                  e.getCoordinate(a, n);
                  var o = n.x,
                    l = n.y,
                    h = o - s,
                    c = l - r;
                  (i += Math.sqrt(h * h + c * c)), (s = o), (r = l);
                }
                return i;
              },
            },
          ]),
          t
        );
      })(),
      Ce = function t() {
        e(this, t);
      },
      Me = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "copyCoord",
              value: function (e, t, i, n) {
                for (
                  var s = Math.min(e.getDimension(), i.getDimension()), r = 0;
                  r < s;
                  r++
                )
                  i.setOrdinate(n, r, e.getOrdinate(t, r));
              },
            },
            {
              key: "isRing",
              value: function (e) {
                var t = e.size();
                return (
                  0 === t ||
                  (!(t <= 3) &&
                    e.getOrdinate(0, ce.X) === e.getOrdinate(t - 1, ce.X) &&
                    e.getOrdinate(0, ce.Y) === e.getOrdinate(t - 1, ce.Y))
                );
              },
            },
            {
              key: "scroll",
              value: function () {
                if (2 === arguments.length) {
                  if (se(arguments[0], ce) && Number.isInteger(arguments[1])) {
                    var e = arguments[0],
                      i = arguments[1];
                    t.scroll(e, i, t.isRing(e));
                  } else if (
                    se(arguments[0], ce) &&
                    arguments[1] instanceof V
                  ) {
                    var n = arguments[0],
                      s = arguments[1],
                      r = t.indexOf(s, n);
                    if (r <= 0) return null;
                    t.scroll(n, r);
                  }
                } else if (3 === arguments.length) {
                  var a = arguments[0],
                    o = arguments[1],
                    l = arguments[2];
                  if (o <= 0) return null;
                  for (
                    var h = a.copy(), c = l ? a.size() - 1 : a.size(), u = 0;
                    u < c;
                    u++
                  )
                    for (var d = 0; d < a.getDimension(); d++)
                      a.setOrdinate(u, d, h.getOrdinate((o + u) % c, d));
                  if (l)
                    for (var p = 0; p < a.getDimension(); p++)
                      a.setOrdinate(c, p, a.getOrdinate(0, p));
                }
              },
            },
            {
              key: "isEqual",
              value: function (e, t) {
                var i = e.size();
                if (i !== t.size()) return !1;
                for (
                  var n = Math.min(e.getDimension(), t.getDimension()), s = 0;
                  s < i;
                  s++
                )
                  for (var r = 0; r < n; r++) {
                    var a = e.getOrdinate(s, r),
                      o = t.getOrdinate(s, r);
                    if (
                      !(
                        e.getOrdinate(s, r) === t.getOrdinate(s, r) ||
                        (F.isNaN(a) && F.isNaN(o))
                      )
                    )
                      return !1;
                  }
                return !0;
              },
            },
            {
              key: "minCoordinateIndex",
              value: function () {
                if (1 === arguments.length) {
                  var e = arguments[0];
                  return t.minCoordinateIndex(e, 0, e.size() - 1);
                }
                if (3 === arguments.length) {
                  for (
                    var i = arguments[0],
                      n = arguments[2],
                      s = -1,
                      r = null,
                      a = arguments[1];
                    a <= n;
                    a++
                  ) {
                    var o = i.getCoordinate(a);
                    (null === r || r.compareTo(o) > 0) && ((r = o), (s = a));
                  }
                  return s;
                }
              },
            },
            {
              key: "extend",
              value: function (e, i, n) {
                var s = e.create(n, i.getDimension()),
                  r = i.size();
                if ((t.copy(i, 0, s, 0, r), r > 0))
                  for (var a = r; a < n; a++) t.copy(i, r - 1, s, a, 1);
                return s;
              },
            },
            {
              key: "reverse",
              value: function (e) {
                for (
                  var i = e.size() - 1, n = Math.trunc(i / 2), s = 0;
                  s <= n;
                  s++
                )
                  t.swap(e, s, i - s);
              },
            },
            {
              key: "swap",
              value: function (e, t, i) {
                if (t === i) return null;
                for (var n = 0; n < e.getDimension(); n++) {
                  var s = e.getOrdinate(t, n);
                  e.setOrdinate(t, n, e.getOrdinate(i, n)),
                    e.setOrdinate(i, n, s);
                }
              },
            },
            {
              key: "copy",
              value: function (e, i, n, s, r) {
                for (var a = 0; a < r; a++) t.copyCoord(e, i + a, n, s + a);
              },
            },
            {
              key: "ensureValidRing",
              value: function (e, i) {
                var n = i.size();
                return 0 === n
                  ? i
                  : n <= 3
                  ? t.createClosedRing(e, i, 4)
                  : i.getOrdinate(0, ce.X) === i.getOrdinate(n - 1, ce.X) &&
                    i.getOrdinate(0, ce.Y) === i.getOrdinate(n - 1, ce.Y)
                  ? i
                  : t.createClosedRing(e, i, n + 1);
              },
            },
            {
              key: "indexOf",
              value: function (e, t) {
                for (var i = 0; i < t.size(); i++)
                  if (
                    e.x === t.getOrdinate(i, ce.X) &&
                    e.y === t.getOrdinate(i, ce.Y)
                  )
                    return i;
                return -1;
              },
            },
            {
              key: "createClosedRing",
              value: function (e, i, n) {
                var s = e.create(n, i.getDimension()),
                  r = i.size();
                t.copy(i, 0, s, 0, r);
                for (var a = r; a < n; a++) t.copy(i, 0, s, a, 1);
                return s;
              },
            },
            {
              key: "minCoordinate",
              value: function (e) {
                for (var t = null, i = 0; i < e.size(); i++) {
                  var n = e.getCoordinate(i);
                  (null === t || t.compareTo(n) > 0) && (t = n);
                }
                return t;
              },
            },
          ]),
          t
        );
      })(),
      we = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "toDimensionSymbol",
              value: function (e) {
                switch (e) {
                  case t.FALSE:
                    return t.SYM_FALSE;
                  case t.TRUE:
                    return t.SYM_TRUE;
                  case t.DONTCARE:
                    return t.SYM_DONTCARE;
                  case t.P:
                    return t.SYM_P;
                  case t.L:
                    return t.SYM_L;
                  case t.A:
                    return t.SYM_A;
                }
                throw new A("Unknown dimension value: " + e);
              },
            },
            {
              key: "toDimensionValue",
              value: function (e) {
                switch (oe.toUpperCase(e)) {
                  case t.SYM_FALSE:
                    return t.FALSE;
                  case t.SYM_TRUE:
                    return t.TRUE;
                  case t.SYM_DONTCARE:
                    return t.DONTCARE;
                  case t.SYM_P:
                    return t.P;
                  case t.SYM_L:
                    return t.L;
                  case t.SYM_A:
                    return t.A;
                }
                throw new A("Unknown dimension symbol: " + e);
              },
            },
          ]),
          t
        );
      })();
    (we.P = 0),
      (we.L = 1),
      (we.A = 2),
      (we.FALSE = -1),
      (we.TRUE = -2),
      (we.DONTCARE = -3),
      (we.SYM_FALSE = "F"),
      (we.SYM_TRUE = "T"),
      (we.SYM_DONTCARE = "*"),
      (we.SYM_P = "0"),
      (we.SYM_L = "1"),
      (we.SYM_A = "2");
    var Te = (function () {
        function t() {
          e(this, t);
        }
        return i(t, [{ key: "filter", value: function (e) {} }]), t;
      })(),
      Ie = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            { key: "filter", value: function (e, t) {} },
            { key: "isDone", value: function () {} },
            { key: "isGeometryChanged", value: function () {} },
          ]),
          t
        );
      })(),
      Re = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "computeEnvelopeInternal",
                value: function () {
                  return this.isEmpty()
                    ? new H()
                    : this._points.expandEnvelope(new H());
                },
              },
              {
                key: "isRing",
                value: function () {
                  return this.isClosed() && this.isSimple();
                },
              },
              {
                key: "getCoordinates",
                value: function () {
                  return this._points.toCoordinateArray();
                },
              },
              {
                key: "copyInternal",
                value: function () {
                  return new a(this._points.copy(), this._factory);
                },
              },
              {
                key: "equalsExact",
                value: function () {
                  if (
                    2 === arguments.length &&
                    "number" == typeof arguments[1] &&
                    arguments[0] instanceof j
                  ) {
                    var e = arguments[0],
                      t = arguments[1];
                    if (!this.isEquivalentClass(e)) return !1;
                    var i = e;
                    if (this._points.size() !== i._points.size()) return !1;
                    for (var n = 0; n < this._points.size(); n++)
                      if (
                        !this.equal(
                          this._points.getCoordinate(n),
                          i._points.getCoordinate(n),
                          t
                        )
                      )
                        return !1;
                    return !0;
                  }
                  return d(s(a.prototype), "equalsExact", this).apply(
                    this,
                    arguments
                  );
                },
              },
              {
                key: "normalize",
                value: function () {
                  for (
                    var e = 0;
                    e < Math.trunc(this._points.size() / 2);
                    e++
                  ) {
                    var t = this._points.size() - 1 - e;
                    if (
                      !this._points
                        .getCoordinate(e)
                        .equals(this._points.getCoordinate(t))
                    ) {
                      if (
                        this._points
                          .getCoordinate(e)
                          .compareTo(this._points.getCoordinate(t)) > 0
                      ) {
                        var i = this._points.copy();
                        Me.reverse(i), (this._points = i);
                      }
                      return null;
                    }
                  }
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  return this.isEmpty() ? null : this._points.getCoordinate(0);
                },
              },
              {
                key: "getBoundaryDimension",
                value: function () {
                  return this.isClosed() ? we.FALSE : 0;
                },
              },
              {
                key: "isClosed",
                value: function () {
                  return (
                    !this.isEmpty() &&
                    this.getCoordinateN(0).equals2D(
                      this.getCoordinateN(this.getNumPoints() - 1)
                    )
                  );
                },
              },
              {
                key: "reverseInternal",
                value: function () {
                  var e = this._points.copy();
                  return Me.reverse(e), this.getFactory().createLineString(e);
                },
              },
              {
                key: "getEndPoint",
                value: function () {
                  return this.isEmpty()
                    ? null
                    : this.getPointN(this.getNumPoints() - 1);
                },
              },
              {
                key: "getTypeCode",
                value: function () {
                  return j.TYPECODE_LINESTRING;
                },
              },
              {
                key: "getDimension",
                value: function () {
                  return 1;
                },
              },
              {
                key: "getLength",
                value: function () {
                  return Se.ofLine(this._points);
                },
              },
              {
                key: "getNumPoints",
                value: function () {
                  return this._points.size();
                },
              },
              {
                key: "compareToSameClass",
                value: function () {
                  if (1 === arguments.length) {
                    for (
                      var e = arguments[0], t = 0, i = 0;
                      t < this._points.size() && i < e._points.size();

                    ) {
                      var n = this._points
                        .getCoordinate(t)
                        .compareTo(e._points.getCoordinate(i));
                      if (0 !== n) return n;
                      t++, i++;
                    }
                    return t < this._points.size()
                      ? 1
                      : i < e._points.size()
                      ? -1
                      : 0;
                  }
                  if (2 === arguments.length) {
                    var s = arguments[0];
                    return arguments[1].compare(this._points, s._points);
                  }
                },
              },
              {
                key: "apply",
                value: function () {
                  if (se(arguments[0], Ee))
                    for (
                      var e = arguments[0], t = 0;
                      t < this._points.size();
                      t++
                    )
                      e.filter(this._points.getCoordinate(t));
                  else if (se(arguments[0], Ie)) {
                    var i = arguments[0];
                    if (0 === this._points.size()) return null;
                    for (
                      var n = 0;
                      n < this._points.size() &&
                      (i.filter(this._points, n), !i.isDone());
                      n++
                    );
                    i.isGeometryChanged() && this.geometryChanged();
                  } else
                    (se(arguments[0], Te) || se(arguments[0], y)) &&
                      arguments[0].filter(this);
                },
              },
              {
                key: "getBoundary",
                value: function () {
                  throw new Y();
                },
              },
              {
                key: "isEquivalentClass",
                value: function (e) {
                  return e instanceof a;
                },
              },
              {
                key: "getCoordinateN",
                value: function (e) {
                  return this._points.getCoordinate(e);
                },
              },
              {
                key: "getGeometryType",
                value: function () {
                  return j.TYPENAME_LINESTRING;
                },
              },
              {
                key: "getCoordinateSequence",
                value: function () {
                  return this._points;
                },
              },
              {
                key: "isEmpty",
                value: function () {
                  return 0 === this._points.size();
                },
              },
              {
                key: "init",
                value: function (e) {
                  if (
                    (null === e &&
                      (e = this.getFactory()
                        .getCoordinateSequenceFactory()
                        .create([])),
                    1 === e.size())
                  )
                    throw new A(
                      "Invalid number of points in LineString (found " +
                        e.size() +
                        " - must be 0 or >= 2)"
                    );
                  this._points = e;
                },
              },
              {
                key: "isCoordinate",
                value: function (e) {
                  for (var t = 0; t < this._points.size(); t++)
                    if (this._points.getCoordinate(t).equals(e)) return !0;
                  return !1;
                },
              },
              {
                key: "getStartPoint",
                value: function () {
                  return this.isEmpty() ? null : this.getPointN(0);
                },
              },
              {
                key: "getPointN",
                value: function (e) {
                  return this.getFactory().createPoint(
                    this._points.getCoordinate(e)
                  );
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Ce];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (((this._points = null), 0 === arguments.length));
                  else if (2 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1];
                    j.constructor_.call(this, t), this.init(e);
                  }
                },
              },
            ]
          ),
          a
        );
      })(j),
      Pe = function t() {
        e(this, t);
      },
      De = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "computeEnvelopeInternal",
                value: function () {
                  if (this.isEmpty()) return new H();
                  var e = new H();
                  return (
                    e.expandToInclude(
                      this._coordinates.getX(0),
                      this._coordinates.getY(0)
                    ),
                    e
                  );
                },
              },
              {
                key: "getCoordinates",
                value: function () {
                  return this.isEmpty() ? [] : [this.getCoordinate()];
                },
              },
              {
                key: "copyInternal",
                value: function () {
                  return new a(this._coordinates.copy(), this._factory);
                },
              },
              {
                key: "equalsExact",
                value: function () {
                  if (
                    2 === arguments.length &&
                    "number" == typeof arguments[1] &&
                    arguments[0] instanceof j
                  ) {
                    var e = arguments[0],
                      t = arguments[1];
                    return (
                      !!this.isEquivalentClass(e) &&
                      (!(!this.isEmpty() || !e.isEmpty()) ||
                        (this.isEmpty() === e.isEmpty() &&
                          this.equal(
                            e.getCoordinate(),
                            this.getCoordinate(),
                            t
                          )))
                    );
                  }
                  return d(s(a.prototype), "equalsExact", this).apply(
                    this,
                    arguments
                  );
                },
              },
              { key: "normalize", value: function () {} },
              {
                key: "getCoordinate",
                value: function () {
                  return 0 !== this._coordinates.size()
                    ? this._coordinates.getCoordinate(0)
                    : null;
                },
              },
              {
                key: "getBoundaryDimension",
                value: function () {
                  return we.FALSE;
                },
              },
              {
                key: "reverseInternal",
                value: function () {
                  return this.getFactory().createPoint(
                    this._coordinates.copy()
                  );
                },
              },
              {
                key: "getTypeCode",
                value: function () {
                  return j.TYPECODE_POINT;
                },
              },
              {
                key: "getDimension",
                value: function () {
                  return 0;
                },
              },
              {
                key: "getNumPoints",
                value: function () {
                  return this.isEmpty() ? 0 : 1;
                },
              },
              {
                key: "getX",
                value: function () {
                  if (null === this.getCoordinate())
                    throw new IllegalStateException(
                      "getX called on empty Point"
                    );
                  return this.getCoordinate().x;
                },
              },
              {
                key: "compareToSameClass",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    return this.getCoordinate().compareTo(e.getCoordinate());
                  }
                  if (2 === arguments.length) {
                    var t = arguments[0];
                    return arguments[1].compare(
                      this._coordinates,
                      t._coordinates
                    );
                  }
                },
              },
              {
                key: "apply",
                value: function () {
                  if (se(arguments[0], Ee)) {
                    var e = arguments[0];
                    if (this.isEmpty()) return null;
                    e.filter(this.getCoordinate());
                  } else if (se(arguments[0], Ie)) {
                    var t = arguments[0];
                    if (this.isEmpty()) return null;
                    t.filter(this._coordinates, 0),
                      t.isGeometryChanged() && this.geometryChanged();
                  } else
                    (se(arguments[0], Te) || se(arguments[0], y)) &&
                      arguments[0].filter(this);
                },
              },
              {
                key: "getBoundary",
                value: function () {
                  return this.getFactory().createGeometryCollection();
                },
              },
              {
                key: "getGeometryType",
                value: function () {
                  return j.TYPENAME_POINT;
                },
              },
              {
                key: "getCoordinateSequence",
                value: function () {
                  return this._coordinates;
                },
              },
              {
                key: "getY",
                value: function () {
                  if (null === this.getCoordinate())
                    throw new IllegalStateException(
                      "getY called on empty Point"
                    );
                  return this.getCoordinate().y;
                },
              },
              {
                key: "isEmpty",
                value: function () {
                  return 0 === this._coordinates.size();
                },
              },
              {
                key: "init",
                value: function (e) {
                  null === e &&
                    (e = this.getFactory()
                      .getCoordinateSequenceFactory()
                      .create([])),
                    O.isTrue(e.size() <= 1),
                    (this._coordinates = e);
                },
              },
              {
                key: "isSimple",
                value: function () {
                  return !0;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Pe];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  this._coordinates = null;
                  var e = arguments[0],
                    t = arguments[1];
                  j.constructor_.call(this, t), this.init(e);
                },
              },
            ]
          ),
          a
        );
      })(j),
      Le = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "ofRing",
              value: function () {
                if (arguments[0] instanceof Array) {
                  var e = arguments[0];
                  return Math.abs(t.ofRingSigned(e));
                }
                if (se(arguments[0], ce)) {
                  var i = arguments[0];
                  return Math.abs(t.ofRingSigned(i));
                }
              },
            },
            {
              key: "ofRingSigned",
              value: function () {
                if (arguments[0] instanceof Array) {
                  var e = arguments[0];
                  if (e.length < 3) return 0;
                  for (var t = 0, i = e[0].x, n = 1; n < e.length - 1; n++) {
                    var s = e[n].x - i,
                      r = e[n + 1].y;
                    t += s * (e[n - 1].y - r);
                  }
                  return t / 2;
                }
                if (se(arguments[0], ce)) {
                  var a = arguments[0],
                    o = a.size();
                  if (o < 3) return 0;
                  var l = new V(),
                    h = new V(),
                    c = new V();
                  a.getCoordinate(0, h), a.getCoordinate(1, c);
                  var u = h.x;
                  c.x -= u;
                  for (var d = 0, p = 1; p < o - 1; p++)
                    (l.y = h.y),
                      (h.x = c.x),
                      (h.y = c.y),
                      a.getCoordinate(p + 1, c),
                      (c.x -= u),
                      (d += h.x * (l.y - c.y));
                  return d / 2;
                }
              },
            },
          ]),
          t
        );
      })(),
      Fe = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "sort",
              value: function () {
                var e = arguments,
                  t = arguments[0];
                if (1 === arguments.length)
                  t.sort(function (e, t) {
                    return e.compareTo(t);
                  });
                else if (2 === arguments.length)
                  t.sort(function (t, i) {
                    return e[1].compare(t, i);
                  });
                else if (3 === arguments.length) {
                  var i = t.slice(arguments[1], arguments[2]);
                  i.sort();
                  var n = t
                    .slice(0, arguments[1])
                    .concat(i, t.slice(arguments[2], t.length));
                  t.splice(0, t.length);
                  var s,
                    r = g(n);
                  try {
                    for (r.s(); !(s = r.n()).done; ) {
                      var a = s.value;
                      t.push(a);
                    }
                  } catch (d) {
                    r.e(d);
                  } finally {
                    r.f();
                  }
                } else if (4 === arguments.length) {
                  var o = t.slice(arguments[1], arguments[2]);
                  o.sort(function (t, i) {
                    return e[3].compare(t, i);
                  });
                  var l = t
                    .slice(0, arguments[1])
                    .concat(o, t.slice(arguments[2], t.length));
                  t.splice(0, t.length);
                  var h,
                    c = g(l);
                  try {
                    for (c.s(); !(h = c.n()).done; ) {
                      var u = h.value;
                      t.push(u);
                    }
                  } catch (d) {
                    c.e(d);
                  } finally {
                    c.f();
                  }
                }
              },
            },
            {
              key: "asList",
              value: function (e) {
                var t,
                  i = new me(),
                  n = g(e);
                try {
                  for (n.s(); !(t = n.n()).done; ) {
                    var s = t.value;
                    i.add(s);
                  }
                } catch (r) {
                  n.e(r);
                } finally {
                  n.f();
                }
                return i;
              },
            },
            {
              key: "copyOf",
              value: function (e, t) {
                return e.slice(0, t);
              },
            },
          ]),
          t
        );
      })(),
      Ne = function t() {
        e(this, t);
      },
      Be = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "computeEnvelopeInternal",
                value: function () {
                  return this._shell.getEnvelopeInternal();
                },
              },
              {
                key: "getCoordinates",
                value: function () {
                  if (this.isEmpty()) return [];
                  for (
                    var e = new Array(this.getNumPoints()).fill(null),
                      t = -1,
                      i = this._shell.getCoordinates(),
                      n = 0;
                    n < i.length;
                    n++
                  )
                    e[++t] = i[n];
                  for (var s = 0; s < this._holes.length; s++)
                    for (
                      var r = this._holes[s].getCoordinates(), a = 0;
                      a < r.length;
                      a++
                    )
                      e[++t] = r[a];
                  return e;
                },
              },
              {
                key: "getArea",
                value: function () {
                  var e = 0;
                  e += Le.ofRing(this._shell.getCoordinateSequence());
                  for (var t = 0; t < this._holes.length; t++)
                    e -= Le.ofRing(this._holes[t].getCoordinateSequence());
                  return e;
                },
              },
              {
                key: "copyInternal",
                value: function () {
                  for (
                    var e = this._shell.copy(),
                      t = new Array(this._holes.length).fill(null),
                      i = 0;
                    i < this._holes.length;
                    i++
                  )
                    t[i] = this._holes[i].copy();
                  return new a(e, t, this._factory);
                },
              },
              {
                key: "isRectangle",
                value: function () {
                  if (0 !== this.getNumInteriorRing()) return !1;
                  if (null === this._shell) return !1;
                  if (5 !== this._shell.getNumPoints()) return !1;
                  for (
                    var e = this._shell.getCoordinateSequence(),
                      t = this.getEnvelopeInternal(),
                      i = 0;
                    i < 5;
                    i++
                  ) {
                    var n = e.getX(i);
                    if (n !== t.getMinX() && n !== t.getMaxX()) return !1;
                    var s = e.getY(i);
                    if (s !== t.getMinY() && s !== t.getMaxY()) return !1;
                  }
                  for (var r = e.getX(0), a = e.getY(0), o = 1; o <= 4; o++) {
                    var l = e.getX(o),
                      h = e.getY(o);
                    if ((l !== r) == (h !== a)) return !1;
                    (r = l), (a = h);
                  }
                  return !0;
                },
              },
              {
                key: "equalsExact",
                value: function () {
                  if (
                    2 === arguments.length &&
                    "number" == typeof arguments[1] &&
                    arguments[0] instanceof j
                  ) {
                    var e = arguments[0],
                      t = arguments[1];
                    if (!this.isEquivalentClass(e)) return !1;
                    var i = e,
                      n = this._shell,
                      r = i._shell;
                    if (!n.equalsExact(r, t)) return !1;
                    if (this._holes.length !== i._holes.length) return !1;
                    for (var o = 0; o < this._holes.length; o++)
                      if (!this._holes[o].equalsExact(i._holes[o], t))
                        return !1;
                    return !0;
                  }
                  return d(s(a.prototype), "equalsExact", this).apply(
                    this,
                    arguments
                  );
                },
              },
              {
                key: "normalize",
                value: function () {
                  if (0 === arguments.length) {
                    this._shell = this.normalized(this._shell, !0);
                    for (var e = 0; e < this._holes.length; e++)
                      this._holes[e] = this.normalized(this._holes[e], !1);
                    Fe.sort(this._holes);
                  } else if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    if (t.isEmpty()) return null;
                    var n = t.getCoordinateSequence(),
                      s = Me.minCoordinateIndex(n, 0, n.size() - 2);
                    Me.scroll(n, s, !0), ue.isCCW(n) === i && Me.reverse(n);
                  }
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  return this._shell.getCoordinate();
                },
              },
              {
                key: "getNumInteriorRing",
                value: function () {
                  return this._holes.length;
                },
              },
              {
                key: "getBoundaryDimension",
                value: function () {
                  return 1;
                },
              },
              {
                key: "reverseInternal",
                value: function () {
                  for (
                    var e = this.getExteriorRing().reverse(),
                      t = new Array(this.getNumInteriorRing()).fill(null),
                      i = 0;
                    i < t.length;
                    i++
                  )
                    t[i] = this.getInteriorRingN(i).reverse();
                  return this.getFactory().createPolygon(e, t);
                },
              },
              {
                key: "getTypeCode",
                value: function () {
                  return j.TYPECODE_POLYGON;
                },
              },
              {
                key: "getDimension",
                value: function () {
                  return 2;
                },
              },
              {
                key: "getLength",
                value: function () {
                  var e = 0;
                  e += this._shell.getLength();
                  for (var t = 0; t < this._holes.length; t++)
                    e += this._holes[t].getLength();
                  return e;
                },
              },
              {
                key: "getNumPoints",
                value: function () {
                  for (
                    var e = this._shell.getNumPoints(), t = 0;
                    t < this._holes.length;
                    t++
                  )
                    e += this._holes[t].getNumPoints();
                  return e;
                },
              },
              {
                key: "convexHull",
                value: function () {
                  return this.getExteriorRing().convexHull();
                },
              },
              {
                key: "normalized",
                value: function (e, t) {
                  var i = e.copy();
                  return this.normalize(i, t), i;
                },
              },
              {
                key: "compareToSameClass",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0],
                      t = this._shell,
                      i = e._shell;
                    return t.compareToSameClass(i);
                  }
                  if (2 === arguments.length) {
                    var n = arguments[1],
                      s = arguments[0],
                      r = this._shell,
                      a = s._shell,
                      o = r.compareToSameClass(a, n);
                    if (0 !== o) return o;
                    for (
                      var l = this.getNumInteriorRing(),
                        h = s.getNumInteriorRing(),
                        c = 0;
                      c < l && c < h;

                    ) {
                      var u = this.getInteriorRingN(c),
                        d = s.getInteriorRingN(c),
                        p = u.compareToSameClass(d, n);
                      if (0 !== p) return p;
                      c++;
                    }
                    return c < l ? 1 : c < h ? -1 : 0;
                  }
                },
              },
              {
                key: "apply",
                value: function () {
                  if (se(arguments[0], Ee)) {
                    var e = arguments[0];
                    this._shell.apply(e);
                    for (var t = 0; t < this._holes.length; t++)
                      this._holes[t].apply(e);
                  } else if (se(arguments[0], Ie)) {
                    var i = arguments[0];
                    if ((this._shell.apply(i), !i.isDone()))
                      for (
                        var n = 0;
                        n < this._holes.length &&
                        (this._holes[n].apply(i), !i.isDone());
                        n++
                      );
                    i.isGeometryChanged() && this.geometryChanged();
                  } else if (se(arguments[0], Te)) arguments[0].filter(this);
                  else if (se(arguments[0], y)) {
                    var s = arguments[0];
                    s.filter(this), this._shell.apply(s);
                    for (var r = 0; r < this._holes.length; r++)
                      this._holes[r].apply(s);
                  }
                },
              },
              {
                key: "getBoundary",
                value: function () {
                  if (this.isEmpty())
                    return this.getFactory().createMultiLineString();
                  var e = new Array(this._holes.length + 1).fill(null);
                  e[0] = this._shell;
                  for (var t = 0; t < this._holes.length; t++)
                    e[t + 1] = this._holes[t];
                  return e.length <= 1
                    ? this.getFactory().createLinearRing(
                        e[0].getCoordinateSequence()
                      )
                    : this.getFactory().createMultiLineString(e);
                },
              },
              {
                key: "getGeometryType",
                value: function () {
                  return j.TYPENAME_POLYGON;
                },
              },
              {
                key: "getExteriorRing",
                value: function () {
                  return this._shell;
                },
              },
              {
                key: "isEmpty",
                value: function () {
                  return this._shell.isEmpty();
                },
              },
              {
                key: "getInteriorRingN",
                value: function (e) {
                  return this._holes[e];
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Ne];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._shell = null), (this._holes = null);
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2];
                  if (
                    (j.constructor_.call(this, i),
                    null === e && (e = this.getFactory().createLinearRing()),
                    null === t && (t = []),
                    j.hasNullElements(t))
                  )
                    throw new A("holes must not contain null elements");
                  if (e.isEmpty() && j.hasNonEmptyElements(t))
                    throw new A("shell is empty but holes are not");
                  (this._shell = e), (this._holes = t);
                },
              },
            ]
          ),
          a
        );
      })(j),
      ke = (function (t) {
        n(s, t);
        var i = u(s);
        function s() {
          return e(this, s), i.apply(this, arguments);
        }
        return s;
      })(K),
      Oe = (function (t) {
        n(r, t);
        var s = u(r);
        function r(t) {
          var i;
          return (
            e(this, r),
            ((i = s.call(this)).array = []),
            t instanceof q && i.addAll(t),
            i
          );
        }
        return (
          i(r, [
            {
              key: "contains",
              value: function (e) {
                var t,
                  i = g(this.array);
                try {
                  for (i.s(); !(t = i.n()).done; )
                    if (0 === t.value.compareTo(e)) return !0;
                } catch (n) {
                  i.e(n);
                } finally {
                  i.f();
                }
                return !1;
              },
            },
            {
              key: "add",
              value: function (e) {
                if (this.contains(e)) return !1;
                for (var t = 0, i = this.array.length; t < i; t++)
                  if (1 === this.array[t].compareTo(e))
                    return !!this.array.splice(t, 0, e);
                return this.array.push(e), !0;
              },
            },
            {
              key: "addAll",
              value: function (e) {
                var t,
                  i = g(e);
                try {
                  for (i.s(); !(t = i.n()).done; ) {
                    var n = t.value;
                    this.add(n);
                  }
                } catch (s) {
                  i.e(s);
                } finally {
                  i.f();
                }
                return !0;
              },
            },
            {
              key: "remove",
              value: function () {
                throw new Y();
              },
            },
            {
              key: "size",
              value: function () {
                return this.array.length;
              },
            },
            {
              key: "isEmpty",
              value: function () {
                return 0 === this.array.length;
              },
            },
            {
              key: "toArray",
              value: function () {
                return this.array.slice();
              },
            },
            {
              key: "iterator",
              value: function () {
                return new Ue(this.array);
              },
            },
          ]),
          r
        );
      })(ke),
      Ue = (function () {
        function t(i) {
          e(this, t), (this.array = i), (this.position = 0);
        }
        return (
          i(t, [
            {
              key: "next",
              value: function () {
                if (this.position === this.array.length) throw new X();
                return this.array[this.position++];
              },
            },
            {
              key: "hasNext",
              value: function () {
                return this.position < this.array.length;
              },
            },
            {
              key: "remove",
              value: function () {
                throw new Y();
              },
            },
          ]),
          t
        );
      })(),
      ze = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "computeEnvelopeInternal",
                value: function () {
                  for (var e = new H(), t = 0; t < this._geometries.length; t++)
                    e.expandToInclude(
                      this._geometries[t].getEnvelopeInternal()
                    );
                  return e;
                },
              },
              {
                key: "getGeometryN",
                value: function (e) {
                  return this._geometries[e];
                },
              },
              {
                key: "getCoordinates",
                value: function () {
                  for (
                    var e = new Array(this.getNumPoints()).fill(null),
                      t = -1,
                      i = 0;
                    i < this._geometries.length;
                    i++
                  )
                    for (
                      var n = this._geometries[i].getCoordinates(), s = 0;
                      s < n.length;
                      s++
                    )
                      e[++t] = n[s];
                  return e;
                },
              },
              {
                key: "getArea",
                value: function () {
                  for (var e = 0, t = 0; t < this._geometries.length; t++)
                    e += this._geometries[t].getArea();
                  return e;
                },
              },
              {
                key: "copyInternal",
                value: function () {
                  for (
                    var e = new Array(this._geometries.length).fill(null),
                      t = 0;
                    t < e.length;
                    t++
                  )
                    e[t] = this._geometries[t].copy();
                  return new a(e, this._factory);
                },
              },
              {
                key: "equalsExact",
                value: function () {
                  if (
                    2 === arguments.length &&
                    "number" == typeof arguments[1] &&
                    arguments[0] instanceof j
                  ) {
                    var e = arguments[0],
                      t = arguments[1];
                    if (!this.isEquivalentClass(e)) return !1;
                    var i = e;
                    if (this._geometries.length !== i._geometries.length)
                      return !1;
                    for (var n = 0; n < this._geometries.length; n++)
                      if (!this._geometries[n].equalsExact(i._geometries[n], t))
                        return !1;
                    return !0;
                  }
                  return d(s(a.prototype), "equalsExact", this).apply(
                    this,
                    arguments
                  );
                },
              },
              {
                key: "normalize",
                value: function () {
                  for (var e = 0; e < this._geometries.length; e++)
                    this._geometries[e].normalize();
                  Fe.sort(this._geometries);
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  return this.isEmpty()
                    ? null
                    : this._geometries[0].getCoordinate();
                },
              },
              {
                key: "getBoundaryDimension",
                value: function () {
                  for (
                    var e = we.FALSE, t = 0;
                    t < this._geometries.length;
                    t++
                  )
                    e = Math.max(e, this._geometries[t].getBoundaryDimension());
                  return e;
                },
              },
              {
                key: "reverseInternal",
                value: function () {
                  for (
                    var e = this._geometries.length, t = new me(e), i = 0;
                    i < e;
                    i++
                  )
                    t.add(this._geometries[i].reverse());
                  return this.getFactory().buildGeometry(t);
                },
              },
              {
                key: "getTypeCode",
                value: function () {
                  return j.TYPECODE_GEOMETRYCOLLECTION;
                },
              },
              {
                key: "getDimension",
                value: function () {
                  for (
                    var e = we.FALSE, t = 0;
                    t < this._geometries.length;
                    t++
                  )
                    e = Math.max(e, this._geometries[t].getDimension());
                  return e;
                },
              },
              {
                key: "getLength",
                value: function () {
                  for (var e = 0, t = 0; t < this._geometries.length; t++)
                    e += this._geometries[t].getLength();
                  return e;
                },
              },
              {
                key: "getNumPoints",
                value: function () {
                  for (var e = 0, t = 0; t < this._geometries.length; t++)
                    e += this._geometries[t].getNumPoints();
                  return e;
                },
              },
              {
                key: "getNumGeometries",
                value: function () {
                  return this._geometries.length;
                },
              },
              {
                key: "compareToSameClass",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0],
                      t = new Oe(Fe.asList(this._geometries)),
                      i = new Oe(Fe.asList(e._geometries));
                    return this.compare(t, i);
                  }
                  if (2 === arguments.length) {
                    for (
                      var n = arguments[1],
                        s = arguments[0],
                        r = this.getNumGeometries(),
                        a = s.getNumGeometries(),
                        o = 0;
                      o < r && o < a;

                    ) {
                      var l = this.getGeometryN(o),
                        h = s.getGeometryN(o),
                        c = l.compareToSameClass(h, n);
                      if (0 !== c) return c;
                      o++;
                    }
                    return o < r ? 1 : o < a ? -1 : 0;
                  }
                },
              },
              {
                key: "apply",
                value: function () {
                  if (se(arguments[0], Ee))
                    for (
                      var e = arguments[0], t = 0;
                      t < this._geometries.length;
                      t++
                    )
                      this._geometries[t].apply(e);
                  else if (se(arguments[0], Ie)) {
                    var i = arguments[0];
                    if (0 === this._geometries.length) return null;
                    for (
                      var n = 0;
                      n < this._geometries.length &&
                      (this._geometries[n].apply(i), !i.isDone());
                      n++
                    );
                    i.isGeometryChanged() && this.geometryChanged();
                  } else if (se(arguments[0], Te)) {
                    var s = arguments[0];
                    s.filter(this);
                    for (var r = 0; r < this._geometries.length; r++)
                      this._geometries[r].apply(s);
                  } else if (se(arguments[0], y)) {
                    var a = arguments[0];
                    a.filter(this);
                    for (var o = 0; o < this._geometries.length; o++)
                      this._geometries[o].apply(a);
                  }
                },
              },
              {
                key: "getBoundary",
                value: function () {
                  return (
                    j.checkNotGeometryCollection(this),
                    O.shouldNeverReachHere(),
                    null
                  );
                },
              },
              {
                key: "getGeometryType",
                value: function () {
                  return j.TYPENAME_GEOMETRYCOLLECTION;
                },
              },
              {
                key: "isEmpty",
                value: function () {
                  for (var e = 0; e < this._geometries.length; e++)
                    if (!this._geometries[e].isEmpty()) return !1;
                  return !0;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (((this._geometries = null), 0 === arguments.length));
                  else if (2 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1];
                    if (
                      (j.constructor_.call(this, t),
                      null === e && (e = []),
                      j.hasNullElements(e))
                    )
                      throw new A("geometries must not contain null elements");
                    this._geometries = e;
                  }
                },
              },
            ]
          ),
          a
        );
      })(j),
      Ge = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "copyInternal",
                value: function () {
                  for (
                    var e = new Array(this._geometries.length).fill(null),
                      t = 0;
                    t < e.length;
                    t++
                  )
                    e[t] = this._geometries[t].copy();
                  return new a(e, this._factory);
                },
              },
              {
                key: "isValid",
                value: function () {
                  return !0;
                },
              },
              {
                key: "equalsExact",
                value: function () {
                  if (
                    2 === arguments.length &&
                    "number" == typeof arguments[1] &&
                    arguments[0] instanceof j
                  ) {
                    var e = arguments[0],
                      t = arguments[1];
                    return (
                      !!this.isEquivalentClass(e) &&
                      d(s(a.prototype), "equalsExact", this).call(this, e, t)
                    );
                  }
                  return d(s(a.prototype), "equalsExact", this).apply(
                    this,
                    arguments
                  );
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  if (
                    1 === arguments.length &&
                    Number.isInteger(arguments[0])
                  ) {
                    var e = arguments[0];
                    return this._geometries[e].getCoordinate();
                  }
                  return d(s(a.prototype), "getCoordinate", this).apply(
                    this,
                    arguments
                  );
                },
              },
              {
                key: "getBoundaryDimension",
                value: function () {
                  return we.FALSE;
                },
              },
              {
                key: "getTypeCode",
                value: function () {
                  return j.TYPECODE_MULTIPOINT;
                },
              },
              {
                key: "getDimension",
                value: function () {
                  return 0;
                },
              },
              {
                key: "getBoundary",
                value: function () {
                  return this.getFactory().createGeometryCollection();
                },
              },
              {
                key: "getGeometryType",
                value: function () {
                  return j.TYPENAME_MULTIPOINT;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Pe];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  var e = arguments[0],
                    t = arguments[1];
                  ze.constructor_.call(this, e, t);
                },
              },
            ]
          ),
          a
        );
      })(ze),
      Ve = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "copyInternal",
                value: function () {
                  return new a(this._points.copy(), this._factory);
                },
              },
              {
                key: "getBoundaryDimension",
                value: function () {
                  return we.FALSE;
                },
              },
              {
                key: "isClosed",
                value: function () {
                  return (
                    !!this.isEmpty() ||
                    d(s(a.prototype), "isClosed", this).call(this)
                  );
                },
              },
              {
                key: "reverseInternal",
                value: function () {
                  var e = this._points.copy();
                  return Me.reverse(e), this.getFactory().createLinearRing(e);
                },
              },
              {
                key: "getTypeCode",
                value: function () {
                  return j.TYPECODE_LINEARRING;
                },
              },
              {
                key: "validateConstruction",
                value: function () {
                  if (
                    !this.isEmpty() &&
                    !d(s(a.prototype), "isClosed", this).call(this)
                  )
                    throw new A(
                      "Points of LinearRing do not form a closed linestring"
                    );
                  if (
                    this.getCoordinateSequence().size() >= 1 &&
                    this.getCoordinateSequence().size() < a.MINIMUM_VALID_SIZE
                  )
                    throw new A(
                      "Invalid number of points in LinearRing (found " +
                        this.getCoordinateSequence().size() +
                        " - must be 0 or >= 4)"
                    );
                },
              },
              {
                key: "getGeometryType",
                value: function () {
                  return j.TYPENAME_LINEARRING;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  var e = arguments[0],
                    t = arguments[1];
                  Re.constructor_.call(this, e, t), this.validateConstruction();
                },
              },
            ]
          ),
          a
        );
      })(Re);
    Ve.MINIMUM_VALID_SIZE = 4;
    var Qe = (function (t) {
      n(r, t);
      var s = u(r);
      function r() {
        var t;
        return (
          e(this, r),
          (t = s.call(this)),
          r.constructor_.apply(h(t), arguments),
          t
        );
      }
      return (
        i(
          r,
          [
            {
              key: "setOrdinate",
              value: function (e, t) {
                switch (e) {
                  case r.X:
                    this.x = t;
                    break;
                  case r.Y:
                    this.y = t;
                    break;
                  default:
                    throw new A("Invalid ordinate index: " + e);
                }
              },
            },
            {
              key: "getZ",
              value: function () {
                return V.NULL_ORDINATE;
              },
            },
            {
              key: "getOrdinate",
              value: function (e) {
                switch (e) {
                  case r.X:
                    return this.x;
                  case r.Y:
                    return this.y;
                }
                throw new A("Invalid ordinate index: " + e);
              },
            },
            {
              key: "setZ",
              value: function (e) {
                throw new A(
                  "CoordinateXY dimension 2 does not support z-ordinate"
                );
              },
            },
            {
              key: "copy",
              value: function () {
                return new r(this);
              },
            },
            {
              key: "toString",
              value: function () {
                return "(" + this.x + ", " + this.y + ")";
              },
            },
            {
              key: "setCoordinate",
              value: function (e) {
                (this.x = e.x), (this.y = e.y), (this.z = e.getZ());
              },
            },
          ],
          [
            {
              key: "constructor_",
              value: function () {
                if (0 === arguments.length) V.constructor_.call(this);
                else if (1 === arguments.length) {
                  if (arguments[0] instanceof r) {
                    var e = arguments[0];
                    V.constructor_.call(this, e.x, e.y);
                  } else if (arguments[0] instanceof V) {
                    var t = arguments[0];
                    V.constructor_.call(this, t.x, t.y);
                  }
                } else if (2 === arguments.length) {
                  var i = arguments[0],
                    n = arguments[1];
                  V.constructor_.call(this, i, n, V.NULL_ORDINATE);
                }
              },
            },
          ]
        ),
        r
      );
    })(V);
    (Qe.X = 0), (Qe.Y = 1), (Qe.Z = -1), (Qe.M = -1);
    var He = (function (t) {
      n(r, t);
      var s = u(r);
      function r() {
        var t;
        return (
          e(this, r),
          (t = s.call(this)),
          r.constructor_.apply(h(t), arguments),
          t
        );
      }
      return (
        i(
          r,
          [
            {
              key: "getM",
              value: function () {
                return this._m;
              },
            },
            {
              key: "setOrdinate",
              value: function (e, t) {
                switch (e) {
                  case r.X:
                    this.x = t;
                    break;
                  case r.Y:
                    this.y = t;
                    break;
                  case r.M:
                    this._m = t;
                    break;
                  default:
                    throw new A("Invalid ordinate index: " + e);
                }
              },
            },
            {
              key: "setM",
              value: function (e) {
                this._m = e;
              },
            },
            {
              key: "getZ",
              value: function () {
                return V.NULL_ORDINATE;
              },
            },
            {
              key: "getOrdinate",
              value: function (e) {
                switch (e) {
                  case r.X:
                    return this.x;
                  case r.Y:
                    return this.y;
                  case r.M:
                    return this._m;
                }
                throw new A("Invalid ordinate index: " + e);
              },
            },
            {
              key: "setZ",
              value: function (e) {
                throw new A(
                  "CoordinateXY dimension 2 does not support z-ordinate"
                );
              },
            },
            {
              key: "copy",
              value: function () {
                return new r(this);
              },
            },
            {
              key: "toString",
              value: function () {
                return "(" + this.x + ", " + this.y + " m=" + this.getM() + ")";
              },
            },
            {
              key: "setCoordinate",
              value: function (e) {
                (this.x = e.x),
                  (this.y = e.y),
                  (this.z = e.getZ()),
                  (this._m = e.getM());
              },
            },
          ],
          [
            {
              key: "constructor_",
              value: function () {
                if (((this._m = null), 0 === arguments.length))
                  V.constructor_.call(this), (this._m = 0);
                else if (1 === arguments.length) {
                  if (arguments[0] instanceof r) {
                    var e = arguments[0];
                    V.constructor_.call(this, e.x, e.y), (this._m = e._m);
                  } else if (arguments[0] instanceof V) {
                    var t = arguments[0];
                    V.constructor_.call(this, t.x, t.y),
                      (this._m = this.getM());
                  }
                } else if (3 === arguments.length) {
                  var i = arguments[0],
                    n = arguments[1],
                    s = arguments[2];
                  V.constructor_.call(this, i, n, V.NULL_ORDINATE),
                    (this._m = s);
                }
              },
            },
          ]
        ),
        r
      );
    })(V);
    (He.X = 0), (He.Y = 1), (He.Z = -1), (He.M = 2);
    var je = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return (
            e(this, r),
            (t = s.call(this)),
            r.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            r,
            [
              {
                key: "getM",
                value: function () {
                  return this._m;
                },
              },
              {
                key: "setOrdinate",
                value: function (e, t) {
                  switch (e) {
                    case V.X:
                      this.x = t;
                      break;
                    case V.Y:
                      this.y = t;
                      break;
                    case V.Z:
                      this.z = t;
                      break;
                    case V.M:
                      this._m = t;
                      break;
                    default:
                      throw new A("Invalid ordinate index: " + e);
                  }
                },
              },
              {
                key: "setM",
                value: function (e) {
                  this._m = e;
                },
              },
              {
                key: "getOrdinate",
                value: function (e) {
                  switch (e) {
                    case V.X:
                      return this.x;
                    case V.Y:
                      return this.y;
                    case V.Z:
                      return this.getZ();
                    case V.M:
                      return this.getM();
                  }
                  throw new A("Invalid ordinate index: " + e);
                },
              },
              {
                key: "copy",
                value: function () {
                  return new r(this);
                },
              },
              {
                key: "toString",
                value: function () {
                  return (
                    "(" +
                    this.x +
                    ", " +
                    this.y +
                    ", " +
                    this.getZ() +
                    " m=" +
                    this.getM() +
                    ")"
                  );
                },
              },
              {
                key: "setCoordinate",
                value: function (e) {
                  (this.x = e.x),
                    (this.y = e.y),
                    (this.z = e.getZ()),
                    (this._m = e.getM());
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (((this._m = null), 0 === arguments.length))
                    V.constructor_.call(this), (this._m = 0);
                  else if (1 === arguments.length) {
                    if (arguments[0] instanceof r) {
                      var e = arguments[0];
                      V.constructor_.call(this, e), (this._m = e._m);
                    } else if (arguments[0] instanceof V) {
                      var t = arguments[0];
                      V.constructor_.call(this, t), (this._m = this.getM());
                    }
                  } else if (4 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1],
                      s = arguments[2],
                      a = arguments[3];
                    V.constructor_.call(this, i, n, s), (this._m = a);
                  }
                },
              },
            ]
          ),
          r
        );
      })(V),
      We = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "measures",
              value: function (e) {
                return e instanceof Qe
                  ? 0
                  : e instanceof He || e instanceof je
                  ? 1
                  : 0;
              },
            },
            {
              key: "dimension",
              value: function (e) {
                return e instanceof Qe
                  ? 2
                  : e instanceof He
                  ? 3
                  : e instanceof je
                  ? 4
                  : 3;
              },
            },
            {
              key: "create",
              value: function () {
                if (1 === arguments.length) {
                  var e = arguments[0];
                  return t.create(e, 0);
                }
                if (2 === arguments.length) {
                  var i = arguments[0],
                    n = arguments[1];
                  return 2 === i
                    ? new Qe()
                    : 3 === i && 0 === n
                    ? new V()
                    : 3 === i && 1 === n
                    ? new He()
                    : 4 === i && 1 === n
                    ? new je()
                    : new V();
                }
              },
            },
          ]),
          t
        );
      })(),
      qe = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "getCoordinate",
                value: function (e) {
                  return this.get(e);
                },
              },
              {
                key: "addAll",
                value: function () {
                  if (
                    2 === arguments.length &&
                    "boolean" == typeof arguments[1] &&
                    se(arguments[0], q)
                  ) {
                    for (
                      var e = arguments[1], t = !1, i = arguments[0].iterator();
                      i.hasNext();

                    )
                      this.add(i.next(), e), (t = !0);
                    return t;
                  }
                  return d(s(a.prototype), "addAll", this).apply(
                    this,
                    arguments
                  );
                },
              },
              {
                key: "clone",
                value: function () {
                  for (
                    var e = d(s(a.prototype), "clone", this).call(this), t = 0;
                    t < this.size();
                    t++
                  )
                    e.add(t, this.get(t).clone());
                  return e;
                },
              },
              {
                key: "toCoordinateArray",
                value: function () {
                  if (0 === arguments.length)
                    return this.toArray(a.coordArrayType);
                  if (1 === arguments.length) {
                    if (arguments[0]) return this.toArray(a.coordArrayType);
                    for (
                      var e = this.size(), t = new Array(e).fill(null), i = 0;
                      i < e;
                      i++
                    )
                      t[i] = this.get(e - i - 1);
                    return t;
                  }
                },
              },
              {
                key: "add",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    return d(s(a.prototype), "add", this).call(this, e);
                  }
                  if (2 === arguments.length) {
                    if (
                      arguments[0] instanceof Array &&
                      "boolean" == typeof arguments[1]
                    ) {
                      var t = arguments[0],
                        i = arguments[1];
                      return this.add(t, i, !0), !0;
                    }
                    if (
                      arguments[0] instanceof V &&
                      "boolean" == typeof arguments[1]
                    ) {
                      var n = arguments[0];
                      if (
                        !arguments[1] &&
                        this.size() >= 1 &&
                        this.get(this.size() - 1).equals2D(n)
                      )
                        return null;
                      d(s(a.prototype), "add", this).call(this, n);
                    } else if (
                      arguments[0] instanceof Object &&
                      "boolean" == typeof arguments[1]
                    ) {
                      var r = arguments[0],
                        o = arguments[1];
                      return this.add(r, o), !0;
                    }
                  } else if (3 === arguments.length) {
                    if (
                      "boolean" == typeof arguments[2] &&
                      arguments[0] instanceof Array &&
                      "boolean" == typeof arguments[1]
                    ) {
                      var l = arguments[0],
                        h = arguments[1];
                      if (arguments[2])
                        for (var c = 0; c < l.length; c++) this.add(l[c], h);
                      else
                        for (var u = l.length - 1; u >= 0; u--)
                          this.add(l[u], h);
                      return !0;
                    }
                    if (
                      "boolean" == typeof arguments[2] &&
                      Number.isInteger(arguments[0]) &&
                      arguments[1] instanceof V
                    ) {
                      var p = arguments[0],
                        f = arguments[1];
                      if (!arguments[2]) {
                        var m = this.size();
                        if (m > 0) {
                          if (p > 0 && this.get(p - 1).equals2D(f)) return null;
                          if (p < m && this.get(p).equals2D(f)) return null;
                        }
                      }
                      d(s(a.prototype), "add", this).call(this, p, f);
                    }
                  } else if (4 === arguments.length) {
                    var g = arguments[0],
                      _ = arguments[1],
                      v = arguments[2],
                      A = arguments[3],
                      y = 1;
                    v > A && (y = -1);
                    for (var x = v; x !== A; x += y) this.add(g[x], _);
                    return !0;
                  }
                },
              },
              {
                key: "closeRing",
                value: function () {
                  if (this.size() > 0) {
                    var e = this.get(0).copy();
                    this.add(e, !1);
                  }
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (0 === arguments.length);
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    this.ensureCapacity(e.length), this.add(e, !0);
                  } else if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    this.ensureCapacity(t.length), this.add(t, i);
                  }
                },
              },
            ]
          ),
          a
        );
      })(me);
    qe.coordArrayType = new Array(0).fill(null);
    var Xe = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "isRing",
              value: function (e) {
                return !(e.length < 4 || !e[0].equals2D(e[e.length - 1]));
              },
            },
            {
              key: "ptNotInList",
              value: function (e, i) {
                for (var n = 0; n < e.length; n++) {
                  var s = e[n];
                  if (t.indexOf(s, i) < 0) return s;
                }
                return null;
              },
            },
            {
              key: "scroll",
              value: function (e, i) {
                var n = t.indexOf(i, e);
                if (n < 0) return null;
                var s = new Array(e.length).fill(null);
                Ae.arraycopy(e, n, s, 0, e.length - n),
                  Ae.arraycopy(e, 0, s, e.length - n, n),
                  Ae.arraycopy(s, 0, e, 0, e.length);
              },
            },
            {
              key: "equals",
              value: function () {
                if (2 === arguments.length) {
                  var e = arguments[0],
                    t = arguments[1];
                  if (e === t) return !0;
                  if (null === e || null === t) return !1;
                  if (e.length !== t.length) return !1;
                  for (var i = 0; i < e.length; i++)
                    if (!e[i].equals(t[i])) return !1;
                  return !0;
                }
                if (3 === arguments.length) {
                  var n = arguments[0],
                    s = arguments[1],
                    r = arguments[2];
                  if (n === s) return !0;
                  if (null === n || null === s) return !1;
                  if (n.length !== s.length) return !1;
                  for (var a = 0; a < n.length; a++)
                    if (0 !== r.compare(n[a], s[a])) return !1;
                  return !0;
                }
              },
            },
            {
              key: "intersection",
              value: function (e, t) {
                for (var i = new qe(), n = 0; n < e.length; n++)
                  t.intersects(e[n]) && i.add(e[n], !0);
                return i.toCoordinateArray();
              },
            },
            {
              key: "measures",
              value: function (e) {
                if (null === e || 0 === e.length) return 0;
                var t,
                  i = 0,
                  n = g(e);
                try {
                  for (n.s(); !(t = n.n()).done; ) {
                    var s = t.value;
                    i = Math.max(i, We.measures(s));
                  }
                } catch (r) {
                  n.e(r);
                } finally {
                  n.f();
                }
                return i;
              },
            },
            {
              key: "hasRepeatedPoints",
              value: function (e) {
                for (var t = 1; t < e.length; t++)
                  if (e[t - 1].equals(e[t])) return !0;
                return !1;
              },
            },
            {
              key: "removeRepeatedPoints",
              value: function (e) {
                return t.hasRepeatedPoints(e)
                  ? new qe(e, !1).toCoordinateArray()
                  : e;
              },
            },
            {
              key: "reverse",
              value: function (e) {
                for (
                  var t = e.length - 1, i = Math.trunc(t / 2), n = 0;
                  n <= i;
                  n++
                ) {
                  var s = e[n];
                  (e[n] = e[t - n]), (e[t - n] = s);
                }
              },
            },
            {
              key: "removeNull",
              value: function (e) {
                for (var t = 0, i = 0; i < e.length; i++) null !== e[i] && t++;
                var n = new Array(t).fill(null);
                if (0 === t) return n;
                for (var s = 0, r = 0; r < e.length; r++)
                  null !== e[r] && (n[s++] = e[r]);
                return n;
              },
            },
            {
              key: "copyDeep",
              value: function () {
                if (1 === arguments.length) {
                  for (
                    var e = arguments[0],
                      t = new Array(e.length).fill(null),
                      i = 0;
                    i < e.length;
                    i++
                  )
                    t[i] = e[i].copy();
                  return t;
                }
                if (5 === arguments.length)
                  for (
                    var n = arguments[0],
                      s = arguments[1],
                      r = arguments[2],
                      a = arguments[3],
                      o = arguments[4],
                      l = 0;
                    l < o;
                    l++
                  )
                    r[a + l] = n[s + l].copy();
              },
            },
            {
              key: "isEqualReversed",
              value: function (e, t) {
                for (var i = 0; i < e.length; i++) {
                  var n = e[i],
                    s = t[e.length - i - 1];
                  if (0 !== n.compareTo(s)) return !1;
                }
                return !0;
              },
            },
            {
              key: "envelope",
              value: function (e) {
                for (var t = new H(), i = 0; i < e.length; i++)
                  t.expandToInclude(e[i]);
                return t;
              },
            },
            {
              key: "toCoordinateArray",
              value: function (e) {
                return e.toArray(t.coordArrayType);
              },
            },
            {
              key: "dimension",
              value: function (e) {
                if (null === e || 0 === e.length) return 3;
                var t,
                  i = 0,
                  n = g(e);
                try {
                  for (n.s(); !(t = n.n()).done; ) {
                    var s = t.value;
                    i = Math.max(i, We.dimension(s));
                  }
                } catch (r) {
                  n.e(r);
                } finally {
                  n.f();
                }
                return i;
              },
            },
            {
              key: "atLeastNCoordinatesOrNothing",
              value: function (e, t) {
                return t.length >= e ? t : [];
              },
            },
            {
              key: "indexOf",
              value: function (e, t) {
                for (var i = 0; i < t.length; i++) if (e.equals(t[i])) return i;
                return -1;
              },
            },
            {
              key: "increasingDirection",
              value: function (e) {
                for (var t = 0; t < Math.trunc(e.length / 2); t++) {
                  var i = e.length - 1 - t,
                    n = e[t].compareTo(e[i]);
                  if (0 !== n) return n;
                }
                return 1;
              },
            },
            {
              key: "compare",
              value: function (e, t) {
                for (var i = 0; i < e.length && i < t.length; ) {
                  var n = e[i].compareTo(t[i]);
                  if (0 !== n) return n;
                  i++;
                }
                return i < t.length ? -1 : i < e.length ? 1 : 0;
              },
            },
            {
              key: "minCoordinate",
              value: function (e) {
                for (var t = null, i = 0; i < e.length; i++)
                  (null === t || t.compareTo(e[i]) > 0) && (t = e[i]);
                return t;
              },
            },
            {
              key: "extract",
              value: function (e, t, i) {
                t = ye.clamp(t, 0, e.length);
                var n = (i = ye.clamp(i, -1, e.length)) - t + 1;
                i < 0 && (n = 0), t >= e.length && (n = 0), i < t && (n = 0);
                var s = new Array(n).fill(null);
                if (0 === n) return s;
                for (var r = 0, a = t; a <= i; a++) s[r++] = e[a];
                return s;
              },
            },
          ]),
          t
        );
      })(),
      Ye = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            {
              key: "compare",
              value: function (e, t) {
                var i = e,
                  n = t;
                return Xe.compare(i, n);
              },
            },
            {
              key: "interfaces_",
              get: function () {
                return [N];
              },
            },
          ]),
          t
        );
      })(),
      Ke = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            {
              key: "compare",
              value: function (e, t) {
                var i = e,
                  n = t;
                if (i.length < n.length) return -1;
                if (i.length > n.length) return 1;
                if (0 === i.length) return 0;
                var s = Xe.compare(i, n);
                return Xe.isEqualReversed(i, n) ? 0 : s;
              },
            },
            {
              key: "OLDcompare",
              value: function (e, t) {
                var i = e,
                  n = t;
                if (i.length < n.length) return -1;
                if (i.length > n.length) return 1;
                if (0 === i.length) return 0;
                for (
                  var s = Xe.increasingDirection(i),
                    r = Xe.increasingDirection(n),
                    a = s > 0 ? 0 : i.length - 1,
                    o = r > 0 ? 0 : i.length - 1,
                    l = 0;
                  l < i.length;
                  l++
                ) {
                  var h = i[a].compareTo(n[o]);
                  if (0 !== h) return h;
                  (a += s), (o += r);
                }
                return 0;
              },
            },
            {
              key: "interfaces_",
              get: function () {
                return [N];
              },
            },
          ]),
          t
        );
      })();
    (Xe.ForwardComparator = Ye),
      (Xe.BidirectionalComparator = Ke),
      (Xe.coordArrayType = new Array(0).fill(null));
    var Ze = (function () {
        function t(i) {
          e(this, t), (this.str = i);
        }
        return (
          i(t, [
            {
              key: "append",
              value: function (e) {
                this.str += e;
              },
            },
            {
              key: "setCharAt",
              value: function (e, t) {
                this.str = this.str.substr(0, e) + t + this.str.substr(e + 1);
              },
            },
            {
              key: "toString",
              value: function () {
                return this.str;
              },
            },
          ]),
          t
        );
      })(),
      Je = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getM",
                value: function (e) {
                  return this.hasM() ? this._coordinates[e].getM() : F.NaN;
                },
              },
              {
                key: "setOrdinate",
                value: function (e, t, i) {
                  switch (t) {
                    case ce.X:
                      this._coordinates[e].x = i;
                      break;
                    case ce.Y:
                      this._coordinates[e].y = i;
                      break;
                    default:
                      this._coordinates[e].setOrdinate(t, i);
                  }
                },
              },
              {
                key: "getZ",
                value: function (e) {
                  return this.hasZ() ? this._coordinates[e].getZ() : F.NaN;
                },
              },
              {
                key: "size",
                value: function () {
                  return this._coordinates.length;
                },
              },
              {
                key: "getOrdinate",
                value: function (e, t) {
                  switch (t) {
                    case ce.X:
                      return this._coordinates[e].x;
                    case ce.Y:
                      return this._coordinates[e].y;
                    default:
                      return this._coordinates[e].getOrdinate(t);
                  }
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    return this._coordinates[e];
                  }
                  if (2 === arguments.length) {
                    var t = arguments[0];
                    arguments[1].setCoordinate(this._coordinates[t]);
                  }
                },
              },
              {
                key: "getCoordinateCopy",
                value: function (e) {
                  var t = this.createCoordinate();
                  return t.setCoordinate(this._coordinates[e]), t;
                },
              },
              {
                key: "createCoordinate",
                value: function () {
                  return We.create(this.getDimension(), this.getMeasures());
                },
              },
              {
                key: "getDimension",
                value: function () {
                  return this._dimension;
                },
              },
              {
                key: "getX",
                value: function (e) {
                  return this._coordinates[e].x;
                },
              },
              {
                key: "getMeasures",
                value: function () {
                  return this._measures;
                },
              },
              {
                key: "expandEnvelope",
                value: function (e) {
                  for (var t = 0; t < this._coordinates.length; t++)
                    e.expandToInclude(this._coordinates[t]);
                  return e;
                },
              },
              {
                key: "copy",
                value: function () {
                  for (
                    var e = new Array(this.size()).fill(null), i = 0;
                    i < this._coordinates.length;
                    i++
                  ) {
                    var n = this.createCoordinate();
                    n.setCoordinate(this._coordinates[i]), (e[i] = n);
                  }
                  return new t(e, this._dimension, this._measures);
                },
              },
              {
                key: "toString",
                value: function () {
                  if (this._coordinates.length > 0) {
                    var e = new Ze(17 * this._coordinates.length);
                    e.append("("), e.append(this._coordinates[0]);
                    for (var t = 1; t < this._coordinates.length; t++)
                      e.append(", "), e.append(this._coordinates[t]);
                    return e.append(")"), e.toString();
                  }
                  return "()";
                },
              },
              {
                key: "getY",
                value: function (e) {
                  return this._coordinates[e].y;
                },
              },
              {
                key: "toCoordinateArray",
                value: function () {
                  return this._coordinates;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [ce, E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._dimension = 3),
                    (this._measures = 0),
                    (this._coordinates = null),
                    1 === arguments.length)
                  ) {
                    if (arguments[0] instanceof Array) {
                      var e = arguments[0];
                      t.constructor_.call(
                        this,
                        e,
                        Xe.dimension(e),
                        Xe.measures(e)
                      );
                    } else if (Number.isInteger(arguments[0])) {
                      var i = arguments[0];
                      this._coordinates = new Array(i).fill(null);
                      for (var n = 0; n < i; n++)
                        this._coordinates[n] = new V();
                    } else if (se(arguments[0], ce)) {
                      var s = arguments[0];
                      if (null === s)
                        return (
                          (this._coordinates = new Array(0).fill(null)), null
                        );
                      (this._dimension = s.getDimension()),
                        (this._measures = s.getMeasures()),
                        (this._coordinates = new Array(s.size()).fill(null));
                      for (var r = 0; r < this._coordinates.length; r++)
                        this._coordinates[r] = s.getCoordinateCopy(r);
                    }
                  } else if (2 === arguments.length) {
                    if (
                      arguments[0] instanceof Array &&
                      Number.isInteger(arguments[1])
                    ) {
                      var a = arguments[0],
                        o = arguments[1];
                      t.constructor_.call(this, a, o, Xe.measures(a));
                    } else if (
                      Number.isInteger(arguments[0]) &&
                      Number.isInteger(arguments[1])
                    ) {
                      var l = arguments[0],
                        h = arguments[1];
                      (this._coordinates = new Array(l).fill(null)),
                        (this._dimension = h);
                      for (var c = 0; c < l; c++)
                        this._coordinates[c] = We.create(h);
                    }
                  } else if (3 === arguments.length)
                    if (
                      Number.isInteger(arguments[2]) &&
                      arguments[0] instanceof Array &&
                      Number.isInteger(arguments[1])
                    ) {
                      var u = arguments[0],
                        d = arguments[1],
                        p = arguments[2];
                      (this._dimension = d),
                        (this._measures = p),
                        (this._coordinates =
                          null === u ? new Array(0).fill(null) : u);
                    } else if (
                      Number.isInteger(arguments[2]) &&
                      Number.isInteger(arguments[0]) &&
                      Number.isInteger(arguments[1])
                    ) {
                      var f = arguments[0],
                        m = arguments[1],
                        g = arguments[2];
                      (this._coordinates = new Array(f).fill(null)),
                        (this._dimension = m),
                        (this._measures = g);
                      for (var _ = 0; _ < f; _++)
                        this._coordinates[_] = this.createCoordinate();
                    }
                },
              },
            ]
          ),
          t
        );
      })(),
      $e = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(
            t,
            [
              {
                key: "readResolve",
                value: function () {
                  return t.instance();
                },
              },
              {
                key: "create",
                value: function () {
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof Array)
                      return new Je(arguments[0]);
                    if (se(arguments[0], ce)) return new Je(arguments[0]);
                  } else {
                    if (2 === arguments.length) {
                      var e = arguments[1];
                      return (
                        e > 3 && (e = 3),
                        e < 2 && (e = 2),
                        new Je(arguments[0], e)
                      );
                    }
                    if (3 === arguments.length) {
                      var t = arguments[2],
                        i = arguments[1] - t;
                      return (
                        t > 1 && (t = 1),
                        i > 3 && (i = 3),
                        i < 2 && (i = 2),
                        new Je(arguments[0], i + t, t)
                      );
                    }
                  }
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [be, E];
                },
              },
            ],
            [
              {
                key: "instance",
                value: function () {
                  return t.instanceObject;
                },
              },
            ]
          ),
          t
        );
      })();
    $e.instanceObject = new $e();
    var et = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "copyInternal",
                value: function () {
                  for (
                    var e = new Array(this._geometries.length).fill(null),
                      t = 0;
                    t < e.length;
                    t++
                  )
                    e[t] = this._geometries[t].copy();
                  return new a(e, this._factory);
                },
              },
              {
                key: "equalsExact",
                value: function () {
                  if (
                    2 === arguments.length &&
                    "number" == typeof arguments[1] &&
                    arguments[0] instanceof j
                  ) {
                    var e = arguments[0],
                      t = arguments[1];
                    return (
                      !!this.isEquivalentClass(e) &&
                      d(s(a.prototype), "equalsExact", this).call(this, e, t)
                    );
                  }
                  return d(s(a.prototype), "equalsExact", this).apply(
                    this,
                    arguments
                  );
                },
              },
              {
                key: "getBoundaryDimension",
                value: function () {
                  return 1;
                },
              },
              {
                key: "getTypeCode",
                value: function () {
                  return j.TYPECODE_MULTIPOLYGON;
                },
              },
              {
                key: "getDimension",
                value: function () {
                  return 2;
                },
              },
              {
                key: "getBoundary",
                value: function () {
                  if (this.isEmpty())
                    return this.getFactory().createMultiLineString();
                  for (
                    var e = new me(), t = 0;
                    t < this._geometries.length;
                    t++
                  )
                    for (
                      var i = this._geometries[t].getBoundary(), n = 0;
                      n < i.getNumGeometries();
                      n++
                    )
                      e.add(i.getGeometryN(n));
                  var s = new Array(e.size()).fill(null);
                  return this.getFactory().createMultiLineString(e.toArray(s));
                },
              },
              {
                key: "getGeometryType",
                value: function () {
                  return j.TYPENAME_MULTIPOLYGON;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Ne];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  var e = arguments[0],
                    t = arguments[1];
                  ze.constructor_.call(this, e, t);
                },
              },
            ]
          ),
          a
        );
      })(ze),
      tt = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            { key: "get", value: function () {} },
            { key: "put", value: function () {} },
            { key: "size", value: function () {} },
            { key: "values", value: function () {} },
            { key: "entrySet", value: function () {} },
          ]),
          t
        );
      })(),
      it = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return e(this, r), ((t = s.call(this)).map = new Map()), t;
        }
        return (
          i(r, [
            {
              key: "get",
              value: function (e) {
                return this.map.get(e) || null;
              },
            },
            {
              key: "put",
              value: function (e, t) {
                return this.map.set(e, t), t;
              },
            },
            {
              key: "values",
              value: function () {
                for (
                  var e = new me(), t = this.map.values(), i = t.next();
                  !i.done;

                )
                  e.add(i.value), (i = t.next());
                return e;
              },
            },
            {
              key: "entrySet",
              value: function () {
                var e = new Z();
                return (
                  this.map.entries().forEach(function (t) {
                    return e.add(t);
                  }),
                  e
                );
              },
            },
            {
              key: "size",
              value: function () {
                return this.map.size();
              },
            },
          ]),
          r
        );
      })(tt),
      nt = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "equals",
                value: function (e) {
                  if (!(e instanceof t)) return !1;
                  var i = e;
                  return (
                    this._modelType === i._modelType && this._scale === i._scale
                  );
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e,
                    i = this.getMaximumSignificantDigits(),
                    n = t.getMaximumSignificantDigits();
                  return ae.compare(i, n);
                },
              },
              {
                key: "getScale",
                value: function () {
                  return this._scale;
                },
              },
              {
                key: "isFloating",
                value: function () {
                  return (
                    this._modelType === t.FLOATING ||
                    this._modelType === t.FLOATING_SINGLE
                  );
                },
              },
              {
                key: "getType",
                value: function () {
                  return this._modelType;
                },
              },
              {
                key: "toString",
                value: function () {
                  var e = "UNKNOWN";
                  return (
                    this._modelType === t.FLOATING
                      ? (e = "Floating")
                      : this._modelType === t.FLOATING_SINGLE
                      ? (e = "Floating-Single")
                      : this._modelType === t.FIXED &&
                        (e = "Fixed (Scale=" + this.getScale() + ")"),
                    e
                  );
                },
              },
              {
                key: "makePrecise",
                value: function () {
                  if ("number" == typeof arguments[0]) {
                    var e = arguments[0];
                    return F.isNaN(e) || this._modelType === t.FLOATING_SINGLE
                      ? e
                      : this._modelType === t.FIXED
                      ? Math.round(e * this._scale) / this._scale
                      : e;
                  }
                  if (arguments[0] instanceof V) {
                    var i = arguments[0];
                    if (this._modelType === t.FLOATING) return null;
                    (i.x = this.makePrecise(i.x)),
                      (i.y = this.makePrecise(i.y));
                  }
                },
              },
              {
                key: "getMaximumSignificantDigits",
                value: function () {
                  var e = 16;
                  return (
                    this._modelType === t.FLOATING
                      ? (e = 16)
                      : this._modelType === t.FLOATING_SINGLE
                      ? (e = 6)
                      : this._modelType === t.FIXED &&
                        (e =
                          1 +
                          Math.trunc(
                            Math.ceil(Math.log(this.getScale()) / Math.log(10))
                          )),
                    e
                  );
                },
              },
              {
                key: "setScale",
                value: function (e) {
                  this._scale = Math.abs(e);
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [E, x];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._modelType = null),
                    (this._scale = null),
                    0 === arguments.length)
                  )
                    this._modelType = t.FLOATING;
                  else if (1 === arguments.length)
                    if (arguments[0] instanceof st) {
                      var e = arguments[0];
                      (this._modelType = e), e === t.FIXED && this.setScale(1);
                    } else if ("number" == typeof arguments[0]) {
                      var i = arguments[0];
                      (this._modelType = t.FIXED), this.setScale(i);
                    } else if (arguments[0] instanceof t) {
                      var n = arguments[0];
                      (this._modelType = n._modelType),
                        (this._scale = n._scale);
                    }
                },
              },
              {
                key: "mostPrecise",
                value: function (e, t) {
                  return e.compareTo(t) >= 0 ? e : t;
                },
              },
            ]
          ),
          t
        );
      })(),
      st = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "readResolve",
                value: function () {
                  return t.nameToTypeMap.get(this._name);
                },
              },
              {
                key: "toString",
                value: function () {
                  return this._name;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  this._name = null;
                  var e = arguments[0];
                  (this._name = e), t.nameToTypeMap.put(e, this);
                },
              },
            ]
          ),
          t
        );
      })();
    (st.nameToTypeMap = new it()),
      (nt.Type = st),
      (nt.FIXED = new st("FIXED")),
      (nt.FLOATING = new st("FLOATING")),
      (nt.FLOATING_SINGLE = new st("FLOATING SINGLE")),
      (nt.maximumPreciseValue = 9007199254740992);
    var rt = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "copyInternal",
                value: function () {
                  for (
                    var e = new Array(this._geometries.length).fill(null),
                      t = 0;
                    t < e.length;
                    t++
                  )
                    e[t] = this._geometries[t].copy();
                  return new a(e, this._factory);
                },
              },
              {
                key: "equalsExact",
                value: function () {
                  if (
                    2 === arguments.length &&
                    "number" == typeof arguments[1] &&
                    arguments[0] instanceof j
                  ) {
                    var e = arguments[0],
                      t = arguments[1];
                    return (
                      !!this.isEquivalentClass(e) &&
                      d(s(a.prototype), "equalsExact", this).call(this, e, t)
                    );
                  }
                  return d(s(a.prototype), "equalsExact", this).apply(
                    this,
                    arguments
                  );
                },
              },
              {
                key: "getBoundaryDimension",
                value: function () {
                  return this.isClosed() ? we.FALSE : 0;
                },
              },
              {
                key: "isClosed",
                value: function () {
                  if (this.isEmpty()) return !1;
                  for (var e = 0; e < this._geometries.length; e++)
                    if (!this._geometries[e].isClosed()) return !1;
                  return !0;
                },
              },
              {
                key: "getTypeCode",
                value: function () {
                  return j.TYPECODE_MULTILINESTRING;
                },
              },
              {
                key: "getDimension",
                value: function () {
                  return 1;
                },
              },
              {
                key: "getBoundary",
                value: function () {
                  throw new Y();
                },
              },
              {
                key: "getGeometryType",
                value: function () {
                  return j.TYPENAME_MULTILINESTRING;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Ce];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  var e = arguments[0],
                    t = arguments[1];
                  ze.constructor_.call(this, e, t);
                },
              },
            ]
          ),
          a
        );
      })(ze),
      at = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "createEmpty",
                value: function (e) {
                  switch (e) {
                    case -1:
                      return this.createGeometryCollection();
                    case 0:
                      return this.createPoint();
                    case 1:
                      return this.createLineString();
                    case 2:
                      return this.createPolygon();
                    default:
                      throw new A("Invalid dimension: " + e);
                  }
                },
              },
              {
                key: "toGeometry",
                value: function (e) {
                  return e.isNull()
                    ? this.createPoint()
                    : e.getMinX() === e.getMaxX() && e.getMinY() === e.getMaxY()
                    ? this.createPoint(new V(e.getMinX(), e.getMinY()))
                    : e.getMinX() === e.getMaxX() || e.getMinY() === e.getMaxY()
                    ? this.createLineString([
                        new V(e.getMinX(), e.getMinY()),
                        new V(e.getMaxX(), e.getMaxY()),
                      ])
                    : this.createPolygon(
                        this.createLinearRing([
                          new V(e.getMinX(), e.getMinY()),
                          new V(e.getMinX(), e.getMaxY()),
                          new V(e.getMaxX(), e.getMaxY()),
                          new V(e.getMaxX(), e.getMinY()),
                          new V(e.getMinX(), e.getMinY()),
                        ]),
                        null
                      );
                },
              },
              {
                key: "createLineString",
                value: function () {
                  if (0 === arguments.length)
                    return this.createLineString(
                      this.getCoordinateSequenceFactory().create([])
                    );
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof Array) {
                      var e = arguments[0];
                      return this.createLineString(
                        null !== e
                          ? this.getCoordinateSequenceFactory().create(e)
                          : null
                      );
                    }
                    if (se(arguments[0], ce)) return new Re(arguments[0], this);
                  }
                },
              },
              {
                key: "createMultiLineString",
                value: function () {
                  return 0 === arguments.length
                    ? new rt(null, this)
                    : 1 === arguments.length
                    ? new rt(arguments[0], this)
                    : void 0;
                },
              },
              {
                key: "buildGeometry",
                value: function (e) {
                  for (
                    var i = null, n = !1, s = !1, r = e.iterator();
                    r.hasNext();

                  ) {
                    var a = r.next(),
                      o = a.getTypeCode();
                    null === i && (i = o),
                      o !== i && (n = !0),
                      a instanceof ze && (s = !0);
                  }
                  if (null === i) return this.createGeometryCollection();
                  if (n || s)
                    return this.createGeometryCollection(t.toGeometryArray(e));
                  var l = e.iterator().next();
                  if (e.size() > 1) {
                    if (l instanceof Be)
                      return this.createMultiPolygon(t.toPolygonArray(e));
                    if (l instanceof Re)
                      return this.createMultiLineString(t.toLineStringArray(e));
                    if (l instanceof De)
                      return this.createMultiPoint(t.toPointArray(e));
                    O.shouldNeverReachHere(
                      "Unhandled geometry type: " + l.getGeometryType()
                    );
                  }
                  return l;
                },
              },
              {
                key: "createMultiPointFromCoords",
                value: function (e) {
                  return this.createMultiPoint(
                    null !== e
                      ? this.getCoordinateSequenceFactory().create(e)
                      : null
                  );
                },
              },
              {
                key: "createPoint",
                value: function () {
                  if (0 === arguments.length)
                    return this.createPoint(
                      this.getCoordinateSequenceFactory().create([])
                    );
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof V) {
                      var e = arguments[0];
                      return this.createPoint(
                        null !== e
                          ? this.getCoordinateSequenceFactory().create([e])
                          : null
                      );
                    }
                    if (se(arguments[0], ce)) return new De(arguments[0], this);
                  }
                },
              },
              {
                key: "getCoordinateSequenceFactory",
                value: function () {
                  return this._coordinateSequenceFactory;
                },
              },
              {
                key: "createPolygon",
                value: function () {
                  if (0 === arguments.length)
                    return this.createPolygon(null, null);
                  if (1 === arguments.length) {
                    if (se(arguments[0], ce)) {
                      var e = arguments[0];
                      return this.createPolygon(this.createLinearRing(e));
                    }
                    if (arguments[0] instanceof Array) {
                      var t = arguments[0];
                      return this.createPolygon(this.createLinearRing(t));
                    }
                    if (arguments[0] instanceof Ve) {
                      var i = arguments[0];
                      return this.createPolygon(i, null);
                    }
                  } else if (2 === arguments.length)
                    return new Be(arguments[0], arguments[1], this);
                },
              },
              {
                key: "getSRID",
                value: function () {
                  return this._SRID;
                },
              },
              {
                key: "createGeometryCollection",
                value: function () {
                  return 0 === arguments.length
                    ? new ze(null, this)
                    : 1 === arguments.length
                    ? new ze(arguments[0], this)
                    : void 0;
                },
              },
              {
                key: "getPrecisionModel",
                value: function () {
                  return this._precisionModel;
                },
              },
              {
                key: "createLinearRing",
                value: function () {
                  if (0 === arguments.length)
                    return this.createLinearRing(
                      this.getCoordinateSequenceFactory().create([])
                    );
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof Array) {
                      var e = arguments[0];
                      return this.createLinearRing(
                        null !== e
                          ? this.getCoordinateSequenceFactory().create(e)
                          : null
                      );
                    }
                    if (se(arguments[0], ce)) return new Ve(arguments[0], this);
                  }
                },
              },
              {
                key: "createMultiPolygon",
                value: function () {
                  return 0 === arguments.length
                    ? new et(null, this)
                    : 1 === arguments.length
                    ? new et(arguments[0], this)
                    : void 0;
                },
              },
              {
                key: "createMultiPoint",
                value: function () {
                  if (0 === arguments.length) return new Ge(null, this);
                  if (1 === arguments.length) {
                    if (arguments[0] instanceof Array)
                      return new Ge(arguments[0], this);
                    if (se(arguments[0], ce)) {
                      var e = arguments[0];
                      if (null === e)
                        return this.createMultiPoint(new Array(0).fill(null));
                      for (
                        var t = new Array(e.size()).fill(null), i = 0;
                        i < e.size();
                        i++
                      ) {
                        var n = this.getCoordinateSequenceFactory().create(
                          1,
                          e.getDimension(),
                          e.getMeasures()
                        );
                        Me.copy(e, i, n, 0, 1), (t[i] = this.createPoint(n));
                      }
                      return this.createMultiPoint(t);
                    }
                  }
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._precisionModel = null),
                    (this._coordinateSequenceFactory = null),
                    (this._SRID = null),
                    0 === arguments.length)
                  )
                    t.constructor_.call(this, new nt(), 0);
                  else if (1 === arguments.length) {
                    if (se(arguments[0], be)) {
                      var e = arguments[0];
                      t.constructor_.call(this, new nt(), 0, e);
                    } else if (arguments[0] instanceof nt) {
                      var i = arguments[0];
                      t.constructor_.call(
                        this,
                        i,
                        0,
                        t.getDefaultCoordinateSequenceFactory()
                      );
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1];
                    t.constructor_.call(
                      this,
                      n,
                      s,
                      t.getDefaultCoordinateSequenceFactory()
                    );
                  } else if (3 === arguments.length) {
                    var r = arguments[0],
                      a = arguments[1],
                      o = arguments[2];
                    (this._precisionModel = r),
                      (this._coordinateSequenceFactory = o),
                      (this._SRID = a);
                  }
                },
              },
              {
                key: "toMultiPolygonArray",
                value: function (e) {
                  var t = new Array(e.size()).fill(null);
                  return e.toArray(t);
                },
              },
              {
                key: "toGeometryArray",
                value: function (e) {
                  if (null === e) return null;
                  var t = new Array(e.size()).fill(null);
                  return e.toArray(t);
                },
              },
              {
                key: "getDefaultCoordinateSequenceFactory",
                value: function () {
                  return $e.instance();
                },
              },
              {
                key: "toMultiLineStringArray",
                value: function (e) {
                  var t = new Array(e.size()).fill(null);
                  return e.toArray(t);
                },
              },
              {
                key: "toLineStringArray",
                value: function (e) {
                  var t = new Array(e.size()).fill(null);
                  return e.toArray(t);
                },
              },
              {
                key: "toMultiPointArray",
                value: function (e) {
                  var t = new Array(e.size()).fill(null);
                  return e.toArray(t);
                },
              },
              {
                key: "toLinearRingArray",
                value: function (e) {
                  var t = new Array(e.size()).fill(null);
                  return e.toArray(t);
                },
              },
              {
                key: "toPointArray",
                value: function (e) {
                  var t = new Array(e.size()).fill(null);
                  return e.toArray(t);
                },
              },
              {
                key: "toPolygonArray",
                value: function (e) {
                  var t = new Array(e.size()).fill(null);
                  return e.toArray(t);
                },
              },
              {
                key: "createPointFromInternalCoord",
                value: function (e, t) {
                  return (
                    t.getPrecisionModel().makePrecise(e),
                    t.getFactory().createPoint(e)
                  );
                },
              },
            ]
          ),
          t
        );
      })(),
      ot = "XY",
      lt = "XYZ",
      ht = "XYM",
      ct = "XYZM",
      ut = {
        POINT: "Point",
        LINE_STRING: "LineString",
        LINEAR_RING: "LinearRing",
        POLYGON: "Polygon",
        MULTI_POINT: "MultiPoint",
        MULTI_LINE_STRING: "MultiLineString",
        MULTI_POLYGON: "MultiPolygon",
        GEOMETRY_COLLECTION: "GeometryCollection",
        CIRCLE: "Circle",
      },
      dt = "EMPTY",
      pt = 1,
      ft = 2,
      mt = 3,
      gt = 4,
      _t = 5,
      vt = 6;
    for (var At in ut) ut[At].toUpperCase();
    var yt = (function () {
        function t(i) {
          e(this, t), (this.wkt = i), (this.index_ = -1);
        }
        return (
          i(t, [
            {
              key: "isAlpha_",
              value: function (e) {
                return (e >= "a" && e <= "z") || (e >= "A" && e <= "Z");
              },
            },
            {
              key: "isNumeric_",
              value: function (e, t) {
                return (
                  (e >= "0" && e <= "9") || ("." == e && !(void 0 !== t && t))
                );
              },
            },
            {
              key: "isWhiteSpace_",
              value: function (e) {
                return " " == e || "\t" == e || "\r" == e || "\n" == e;
              },
            },
            {
              key: "nextChar_",
              value: function () {
                return this.wkt.charAt(++this.index_);
              },
            },
            {
              key: "nextToken",
              value: function () {
                var e,
                  t = this.nextChar_(),
                  i = this.index_,
                  n = t;
                if ("(" == t) e = ft;
                else if ("," == t) e = _t;
                else if (")" == t) e = mt;
                else if (this.isNumeric_(t) || "-" == t)
                  (e = gt), (n = this.readNumber_());
                else if (this.isAlpha_(t)) (e = pt), (n = this.readText_());
                else {
                  if (this.isWhiteSpace_(t)) return this.nextToken();
                  if ("" !== t) throw new Error("Unexpected character: " + t);
                  e = vt;
                }
                return { position: i, value: n, type: e };
              },
            },
            {
              key: "readNumber_",
              value: function () {
                var e,
                  t = this.index_,
                  i = !1,
                  n = !1;
                do {
                  "." == e ? (i = !0) : ("e" != e && "E" != e) || (n = !0),
                    (e = this.nextChar_());
                } while (
                  this.isNumeric_(e, i) ||
                  (!n && ("e" == e || "E" == e)) ||
                  (n && ("-" == e || "+" == e))
                );
                return parseFloat(this.wkt.substring(t, this.index_--));
              },
            },
            {
              key: "readText_",
              value: function () {
                var e,
                  t = this.index_;
                do {
                  e = this.nextChar_();
                } while (this.isAlpha_(e));
                return this.wkt.substring(t, this.index_--).toUpperCase();
              },
            },
          ]),
          t
        );
      })(),
      xt = (function () {
        function t(i, n) {
          e(this, t),
            (this.lexer_ = i),
            this.token_,
            (this.layout_ = ot),
            (this.factory = n);
        }
        return (
          i(t, [
            {
              key: "consume_",
              value: function () {
                this.token_ = this.lexer_.nextToken();
              },
            },
            {
              key: "isTokenType",
              value: function (e) {
                return this.token_.type == e;
              },
            },
            {
              key: "match",
              value: function (e) {
                var t = this.isTokenType(e);
                return t && this.consume_(), t;
              },
            },
            {
              key: "parse",
              value: function () {
                return this.consume_(), this.parseGeometry_();
              },
            },
            {
              key: "parseGeometryLayout_",
              value: function () {
                var e = ot,
                  t = this.token_;
                if (this.isTokenType(pt)) {
                  var i = t.value;
                  "Z" === i
                    ? (e = lt)
                    : "M" === i
                    ? (e = ht)
                    : "ZM" === i && (e = ct),
                    e !== ot && this.consume_();
                }
                return e;
              },
            },
            {
              key: "parseGeometryCollectionText_",
              value: function () {
                if (this.match(ft)) {
                  var e = [];
                  do {
                    e.push(this.parseGeometry_());
                  } while (this.match(_t));
                  if (this.match(mt)) return e;
                } else if (this.isEmptyGeometry_()) return [];
                throw new Error(this.formatErrorMessage_());
              },
            },
            {
              key: "parsePointText_",
              value: function () {
                if (this.match(ft)) {
                  var e = this.parsePoint_();
                  if (this.match(mt)) return e;
                } else if (this.isEmptyGeometry_()) return null;
                throw new Error(this.formatErrorMessage_());
              },
            },
            {
              key: "parseLineStringText_",
              value: function () {
                if (this.match(ft)) {
                  var e = this.parsePointList_();
                  if (this.match(mt)) return e;
                } else if (this.isEmptyGeometry_()) return [];
                throw new Error(this.formatErrorMessage_());
              },
            },
            {
              key: "parsePolygonText_",
              value: function () {
                if (this.match(ft)) {
                  var e = this.parseLineStringTextList_();
                  if (this.match(mt)) return e;
                } else if (this.isEmptyGeometry_()) return [];
                throw new Error(this.formatErrorMessage_());
              },
            },
            {
              key: "parseMultiPointText_",
              value: function () {
                var e;
                if (this.match(ft)) {
                  if (
                    ((e =
                      this.token_.type == ft
                        ? this.parsePointTextList_()
                        : this.parsePointList_()),
                    this.match(mt))
                  )
                    return e;
                } else if (this.isEmptyGeometry_()) return [];
                throw new Error(this.formatErrorMessage_());
              },
            },
            {
              key: "parseMultiLineStringText_",
              value: function () {
                if (this.match(ft)) {
                  var e = this.parseLineStringTextList_();
                  if (this.match(mt)) return e;
                } else if (this.isEmptyGeometry_()) return [];
                throw new Error(this.formatErrorMessage_());
              },
            },
            {
              key: "parseMultiPolygonText_",
              value: function () {
                if (this.match(ft)) {
                  var e = this.parsePolygonTextList_();
                  if (this.match(mt)) return e;
                } else if (this.isEmptyGeometry_()) return [];
                throw new Error(this.formatErrorMessage_());
              },
            },
            {
              key: "parsePoint_",
              value: function () {
                for (var e = [], t = this.layout_.length, i = 0; i < t; ++i) {
                  var n = this.token_;
                  if (!this.match(gt)) break;
                  e.push(n.value);
                }
                if (e.length == t) return e;
                throw new Error(this.formatErrorMessage_());
              },
            },
            {
              key: "parsePointList_",
              value: function () {
                for (var e = [this.parsePoint_()]; this.match(_t); )
                  e.push(this.parsePoint_());
                return e;
              },
            },
            {
              key: "parsePointTextList_",
              value: function () {
                for (var e = [this.parsePointText_()]; this.match(_t); )
                  e.push(this.parsePointText_());
                return e;
              },
            },
            {
              key: "parseLineStringTextList_",
              value: function () {
                for (var e = [this.parseLineStringText_()]; this.match(_t); )
                  e.push(this.parseLineStringText_());
                return e;
              },
            },
            {
              key: "parsePolygonTextList_",
              value: function () {
                for (var e = [this.parsePolygonText_()]; this.match(_t); )
                  e.push(this.parsePolygonText_());
                return e;
              },
            },
            {
              key: "isEmptyGeometry_",
              value: function () {
                var e = this.isTokenType(pt) && this.token_.value == dt;
                return e && this.consume_(), e;
              },
            },
            {
              key: "formatErrorMessage_",
              value: function () {
                return (
                  "Unexpected `" +
                  this.token_.value +
                  "` at position " +
                  this.token_.position +
                  " in `" +
                  this.lexer_.wkt +
                  "`"
                );
              },
            },
            {
              key: "parseGeometry_",
              value: function () {
                var e = this.factory,
                  t = function (e) {
                    return o(V, p(e));
                  },
                  i = function (i) {
                    var n = i.map(function (i) {
                      return e.createLinearRing(i.map(t));
                    });
                    return n.length > 1
                      ? e.createPolygon(n[0], n.slice(1))
                      : e.createPolygon(n[0]);
                  },
                  n = this.token_;
                if (this.match(pt)) {
                  var s = n.value;
                  if (
                    ((this.layout_ = this.parseGeometryLayout_()),
                    "GEOMETRYCOLLECTION" == s)
                  ) {
                    var r = this.parseGeometryCollectionText_();
                    return e.createGeometryCollection(r);
                  }
                  switch (s) {
                    case "POINT":
                      var a = this.parsePointText_();
                      return a ? e.createPoint(o(V, p(a))) : e.createPoint();
                    case "LINESTRING":
                      var l = this.parseLineStringText_().map(t);
                      return e.createLineString(l);
                    case "LINEARRING":
                      var h = this.parseLineStringText_().map(t);
                      return e.createLinearRing(h);
                    case "POLYGON":
                      var c = this.parsePolygonText_();
                      return c && 0 !== c.length ? i(c) : e.createPolygon();
                    case "MULTIPOINT":
                      var u = this.parseMultiPointText_();
                      if (!u || 0 === u.length) return e.createMultiPoint();
                      var d = u.map(t).map(function (t) {
                        return e.createPoint(t);
                      });
                      return e.createMultiPoint(d);
                    case "MULTILINESTRING":
                      var f = this.parseMultiLineStringText_().map(function (
                        i
                      ) {
                        return e.createLineString(i.map(t));
                      });
                      return e.createMultiLineString(f);
                    case "MULTIPOLYGON":
                      var m = this.parseMultiPolygonText_();
                      if (!m || 0 === m.length) return e.createMultiPolygon();
                      var g = m.map(i);
                      return e.createMultiPolygon(g);
                    default:
                      throw new Error("Invalid geometry type: " + s);
                  }
                }
                throw new Error(this.formatErrorMessage_());
              },
            },
          ]),
          t
        );
      })();
    function bt(e) {
      if (e.isEmpty()) return "";
      var t = e.getCoordinate(),
        i = [t.x, t.y];
      return (
        void 0 === t.z || Number.isNaN(t.z) || i.push(t.z),
        void 0 === t.m || Number.isNaN(t.m) || i.push(t.m),
        i.join(" ")
      );
    }
    function Et(e) {
      for (
        var t = e.getCoordinates().map(function (e) {
            var t = [e.x, e.y];
            return (
              void 0 === e.z || Number.isNaN(e.z) || t.push(e.z),
              void 0 === e.m || Number.isNaN(e.m) || t.push(e.m),
              t
            );
          }),
          i = [],
          n = 0,
          s = t.length;
        n < s;
        ++n
      )
        i.push(t[n].join(" "));
      return i.join(", ");
    }
    function St(e) {
      var t = [];
      t.push("(" + Et(e.getExteriorRing()) + ")");
      for (var i = 0, n = e.getNumInteriorRing(); i < n; ++i)
        t.push("(" + Et(e.getInteriorRingN(i)) + ")");
      return t.join(", ");
    }
    var Ct = {
      Point: bt,
      LineString: Et,
      LinearRing: Et,
      Polygon: St,
      MultiPoint: function (e) {
        for (var t = [], i = 0, n = e.getNumGeometries(); i < n; ++i)
          t.push("(" + bt(e.getGeometryN(i)) + ")");
        return t.join(", ");
      },
      MultiLineString: function (e) {
        for (var t = [], i = 0, n = e.getNumGeometries(); i < n; ++i)
          t.push("(" + Et(e.getGeometryN(i)) + ")");
        return t.join(", ");
      },
      MultiPolygon: function (e) {
        for (var t = [], i = 0, n = e.getNumGeometries(); i < n; ++i)
          t.push("(" + St(e.getGeometryN(i)) + ")");
        return t.join(", ");
      },
      GeometryCollection: function (e) {
        for (var t = [], i = 0, n = e.getNumGeometries(); i < n; ++i)
          t.push(Mt(e.getGeometryN(i)));
        return t.join(", ");
      },
    };
    function Mt(e) {
      var t = e.getGeometryType(),
        i = Ct[t];
      t = t.toUpperCase();
      var n = (function (e) {
        var t = "";
        if (e.isEmpty()) return t;
        var i = e.getCoordinate();
        return (
          void 0 === i.z || Number.isNaN(i.z) || (t += "Z"),
          void 0 === i.m || Number.isNaN(i.m) || (t += "M"),
          t
        );
      })(e);
      return (
        n.length > 0 && (t += " " + n),
        e.isEmpty() ? t + " " + dt : t + " (" + i(e) + ")"
      );
    }
    var wt = (function () {
        function t(i) {
          e(this, t),
            (this.geometryFactory = i || new at()),
            (this.precisionModel = this.geometryFactory.getPrecisionModel());
        }
        return (
          i(t, [
            {
              key: "read",
              value: function (e) {
                var t = new yt(e);
                return new xt(t, this.geometryFactory).parse();
              },
            },
            {
              key: "write",
              value: function (e) {
                return Mt(e);
              },
            },
          ]),
          t
        );
      })(),
      Tt = (function () {
        function t(i) {
          e(this, t), (this.parser = new wt(i));
        }
        return (
          i(
            t,
            [
              {
                key: "write",
                value: function (e) {
                  return this.parser.write(e);
                },
              },
            ],
            [
              {
                key: "toLineString",
                value: function (e, t) {
                  if (2 !== arguments.length)
                    throw new Error("Not implemented");
                  return (
                    "LINESTRING ( " +
                    e.x +
                    " " +
                    e.y +
                    ", " +
                    t.x +
                    " " +
                    t.y +
                    " )"
                  );
                },
              },
            ]
          ),
          t
        );
      })(),
      It = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getIndexAlongSegment",
                value: function (e, t) {
                  return this.computeIntLineIndex(), this._intLineIndex[e][t];
                },
              },
              {
                key: "getTopologySummary",
                value: function () {
                  var e = new Ze();
                  return (
                    this.isEndPoint() && e.append(" endpoint"),
                    this._isProper && e.append(" proper"),
                    this.isCollinear() && e.append(" collinear"),
                    e.toString()
                  );
                },
              },
              {
                key: "computeIntersection",
                value: function (e, t, i, n) {
                  (this._inputLines[0][0] = e),
                    (this._inputLines[0][1] = t),
                    (this._inputLines[1][0] = i),
                    (this._inputLines[1][1] = n),
                    (this._result = this.computeIntersect(e, t, i, n));
                },
              },
              {
                key: "getIntersectionNum",
                value: function () {
                  return this._result;
                },
              },
              {
                key: "computeIntLineIndex",
                value: function () {
                  if (0 === arguments.length)
                    null === this._intLineIndex &&
                      ((this._intLineIndex = Array(2)
                        .fill()
                        .map(function () {
                          return Array(2);
                        })),
                      this.computeIntLineIndex(0),
                      this.computeIntLineIndex(1));
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    this.getEdgeDistance(e, 0) > this.getEdgeDistance(e, 1)
                      ? ((this._intLineIndex[e][0] = 0),
                        (this._intLineIndex[e][1] = 1))
                      : ((this._intLineIndex[e][0] = 1),
                        (this._intLineIndex[e][1] = 0));
                  }
                },
              },
              {
                key: "isProper",
                value: function () {
                  return this.hasIntersection() && this._isProper;
                },
              },
              {
                key: "setPrecisionModel",
                value: function (e) {
                  this._precisionModel = e;
                },
              },
              {
                key: "isInteriorIntersection",
                value: function () {
                  if (0 === arguments.length)
                    return (
                      !!this.isInteriorIntersection(0) ||
                      !!this.isInteriorIntersection(1)
                    );
                  if (1 === arguments.length) {
                    for (var e = arguments[0], t = 0; t < this._result; t++)
                      if (
                        !this._intPt[t].equals2D(this._inputLines[e][0]) &&
                        !this._intPt[t].equals2D(this._inputLines[e][1])
                      )
                        return !0;
                    return !1;
                  }
                },
              },
              {
                key: "getIntersection",
                value: function (e) {
                  return this._intPt[e];
                },
              },
              {
                key: "isEndPoint",
                value: function () {
                  return this.hasIntersection() && !this._isProper;
                },
              },
              {
                key: "hasIntersection",
                value: function () {
                  return this._result !== t.NO_INTERSECTION;
                },
              },
              {
                key: "getEdgeDistance",
                value: function (e, i) {
                  return t.computeEdgeDistance(
                    this._intPt[i],
                    this._inputLines[e][0],
                    this._inputLines[e][1]
                  );
                },
              },
              {
                key: "isCollinear",
                value: function () {
                  return this._result === t.COLLINEAR_INTERSECTION;
                },
              },
              {
                key: "toString",
                value: function () {
                  return (
                    Tt.toLineString(
                      this._inputLines[0][0],
                      this._inputLines[0][1]
                    ) +
                    " - " +
                    Tt.toLineString(
                      this._inputLines[1][0],
                      this._inputLines[1][1]
                    ) +
                    this.getTopologySummary()
                  );
                },
              },
              {
                key: "getEndpoint",
                value: function (e, t) {
                  return this._inputLines[e][t];
                },
              },
              {
                key: "isIntersection",
                value: function (e) {
                  for (var t = 0; t < this._result; t++)
                    if (this._intPt[t].equals2D(e)) return !0;
                  return !1;
                },
              },
              {
                key: "getIntersectionAlongSegment",
                value: function (e, t) {
                  return (
                    this.computeIntLineIndex(),
                    this._intPt[this._intLineIndex[e][t]]
                  );
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._result = null),
                    (this._inputLines = Array(2)
                      .fill()
                      .map(function () {
                        return Array(2);
                      })),
                    (this._intPt = new Array(2).fill(null)),
                    (this._intLineIndex = null),
                    (this._isProper = null),
                    (this._pa = null),
                    (this._pb = null),
                    (this._precisionModel = null),
                    (this._intPt[0] = new V()),
                    (this._intPt[1] = new V()),
                    (this._pa = this._intPt[0]),
                    (this._pb = this._intPt[1]),
                    (this._result = 0);
                },
              },
              {
                key: "computeEdgeDistance",
                value: function (e, t, i) {
                  var n = Math.abs(i.x - t.x),
                    s = Math.abs(i.y - t.y),
                    r = -1;
                  if (e.equals(t)) r = 0;
                  else if (e.equals(i)) r = n > s ? n : s;
                  else {
                    var a = Math.abs(e.x - t.x),
                      o = Math.abs(e.y - t.y);
                    0 !== (r = n > s ? a : o) ||
                      e.equals(t) ||
                      (r = Math.max(a, o));
                  }
                  return (
                    O.isTrue(
                      !(0 === r && !e.equals(t)),
                      "Bad distance calculation"
                    ),
                    r
                  );
                },
              },
              {
                key: "nonRobustComputeEdgeDistance",
                value: function (e, t, i) {
                  var n = e.x - t.x,
                    s = e.y - t.y,
                    r = Math.sqrt(n * n + s * s);
                  return (
                    O.isTrue(
                      !(0 === r && !e.equals(t)),
                      "Invalid distance calculation"
                    ),
                    r
                  );
                },
              },
            ]
          ),
          t
        );
      })();
    (It.DONT_INTERSECT = 0),
      (It.DO_INTERSECT = 1),
      (It.COLLINEAR = 2),
      (It.NO_INTERSECTION = 0),
      (It.POINT_INTERSECTION = 1),
      (It.COLLINEAR_INTERSECTION = 2);
    var Rt = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          return e(this, a), r.call(this);
        }
        return (
          i(
            a,
            [
              {
                key: "isInSegmentEnvelopes",
                value: function (e) {
                  var t = new H(this._inputLines[0][0], this._inputLines[0][1]),
                    i = new H(this._inputLines[1][0], this._inputLines[1][1]);
                  return t.contains(e) && i.contains(e);
                },
              },
              {
                key: "computeIntersection",
                value: function () {
                  if (3 !== arguments.length)
                    return d(s(a.prototype), "computeIntersection", this).apply(
                      this,
                      arguments
                    );
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2];
                  if (
                    ((this._isProper = !1),
                    H.intersects(t, i, e) &&
                      0 === ue.index(t, i, e) &&
                      0 === ue.index(i, t, e))
                  )
                    return (
                      (this._isProper = !0),
                      (e.equals(t) || e.equals(i)) && (this._isProper = !1),
                      (this._result = It.POINT_INTERSECTION),
                      null
                    );
                  this._result = It.NO_INTERSECTION;
                },
              },
              {
                key: "intersection",
                value: function (e, t, i, n) {
                  var s = this.intersectionSafe(e, t, i, n);
                  return (
                    this.isInSegmentEnvelopes(s) ||
                      (s = new V(a.nearestEndpoint(e, t, i, n))),
                    null !== this._precisionModel &&
                      this._precisionModel.makePrecise(s),
                    s
                  );
                },
              },
              {
                key: "checkDD",
                value: function (e, t, i, n, s) {
                  var r = he.intersection(e, t, i, n),
                    a = this.isInSegmentEnvelopes(r);
                  Ae.out.println(
                    "DD in env = " + a + "  --------------------- " + r
                  ),
                    s.distance(r) > 1e-4 &&
                      Ae.out.println("Distance = " + s.distance(r));
                },
              },
              {
                key: "intersectionSafe",
                value: function (e, t, i, n) {
                  var s = ve.intersection(e, t, i, n);
                  return null === s && (s = a.nearestEndpoint(e, t, i, n)), s;
                },
              },
              {
                key: "computeCollinearIntersection",
                value: function (e, t, i, n) {
                  var s = H.intersects(e, t, i),
                    r = H.intersects(e, t, n),
                    a = H.intersects(i, n, e),
                    o = H.intersects(i, n, t);
                  return s && r
                    ? ((this._intPt[0] = i),
                      (this._intPt[1] = n),
                      It.COLLINEAR_INTERSECTION)
                    : a && o
                    ? ((this._intPt[0] = e),
                      (this._intPt[1] = t),
                      It.COLLINEAR_INTERSECTION)
                    : s && a
                    ? ((this._intPt[0] = i),
                      (this._intPt[1] = e),
                      !i.equals(e) || r || o
                        ? It.COLLINEAR_INTERSECTION
                        : It.POINT_INTERSECTION)
                    : s && o
                    ? ((this._intPt[0] = i),
                      (this._intPt[1] = t),
                      !i.equals(t) || r || a
                        ? It.COLLINEAR_INTERSECTION
                        : It.POINT_INTERSECTION)
                    : r && a
                    ? ((this._intPt[0] = n),
                      (this._intPt[1] = e),
                      !n.equals(e) || s || o
                        ? It.COLLINEAR_INTERSECTION
                        : It.POINT_INTERSECTION)
                    : r && o
                    ? ((this._intPt[0] = n),
                      (this._intPt[1] = t),
                      !n.equals(t) || s || a
                        ? It.COLLINEAR_INTERSECTION
                        : It.POINT_INTERSECTION)
                    : It.NO_INTERSECTION;
                },
              },
              {
                key: "computeIntersect",
                value: function (e, t, i, n) {
                  if (((this._isProper = !1), !H.intersects(e, t, i, n)))
                    return It.NO_INTERSECTION;
                  var s = ue.index(e, t, i),
                    r = ue.index(e, t, n);
                  if ((s > 0 && r > 0) || (s < 0 && r < 0))
                    return It.NO_INTERSECTION;
                  var a = ue.index(i, n, e),
                    o = ue.index(i, n, t);
                  return (a > 0 && o > 0) || (a < 0 && o < 0)
                    ? It.NO_INTERSECTION
                    : 0 === s && 0 === r && 0 === a && 0 === o
                    ? this.computeCollinearIntersection(e, t, i, n)
                    : (0 === s || 0 === r || 0 === a || 0 === o
                        ? ((this._isProper = !1),
                          e.equals2D(i) || e.equals2D(n)
                            ? (this._intPt[0] = e)
                            : t.equals2D(i) || t.equals2D(n)
                            ? (this._intPt[0] = t)
                            : 0 === s
                            ? (this._intPt[0] = new V(i))
                            : 0 === r
                            ? (this._intPt[0] = new V(n))
                            : 0 === a
                            ? (this._intPt[0] = new V(e))
                            : 0 === o && (this._intPt[0] = new V(t)))
                        : ((this._isProper = !0),
                          (this._intPt[0] = this.intersection(e, t, i, n))),
                      It.POINT_INTERSECTION);
                },
              },
            ],
            [
              {
                key: "nearestEndpoint",
                value: function (e, t, i, n) {
                  var s = e,
                    r = xe.pointToSegment(e, i, n),
                    a = xe.pointToSegment(t, i, n);
                  return (
                    a < r && ((r = a), (s = t)),
                    (a = xe.pointToSegment(i, e, t)) < r && ((r = a), (s = i)),
                    (a = xe.pointToSegment(n, e, t)) < r && ((r = a), (s = n)),
                    s
                  );
                },
              },
            ]
          ),
          a
        );
      })(It),
      Pt = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "countSegment",
                value: function (e, t) {
                  if (e.x < this._p.x && t.x < this._p.x) return null;
                  if (this._p.x === t.x && this._p.y === t.y)
                    return (this._isPointOnSegment = !0), null;
                  if (e.y === this._p.y && t.y === this._p.y) {
                    var i = e.x,
                      n = t.x;
                    return (
                      i > n && ((i = t.x), (n = e.x)),
                      this._p.x >= i &&
                        this._p.x <= n &&
                        (this._isPointOnSegment = !0),
                      null
                    );
                  }
                  if (
                    (e.y > this._p.y && t.y <= this._p.y) ||
                    (t.y > this._p.y && e.y <= this._p.y)
                  ) {
                    var s = ue.index(e, t, this._p);
                    if (s === ue.COLLINEAR)
                      return (this._isPointOnSegment = !0), null;
                    t.y < e.y && (s = -s),
                      s === ue.LEFT && this._crossingCount++;
                  }
                },
              },
              {
                key: "isPointInPolygon",
                value: function () {
                  return this.getLocation() !== W.EXTERIOR;
                },
              },
              {
                key: "getLocation",
                value: function () {
                  return this._isPointOnSegment
                    ? W.BOUNDARY
                    : this._crossingCount % 2 == 1
                    ? W.INTERIOR
                    : W.EXTERIOR;
                },
              },
              {
                key: "isOnSegment",
                value: function () {
                  return this._isPointOnSegment;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._p = null),
                    (this._crossingCount = 0),
                    (this._isPointOnSegment = !1);
                  var e = arguments[0];
                  this._p = e;
                },
              },
              {
                key: "locatePointInRing",
                value: function () {
                  if (arguments[0] instanceof V && se(arguments[1], ce)) {
                    for (
                      var e = arguments[1],
                        i = new t(arguments[0]),
                        n = new V(),
                        s = new V(),
                        r = 1;
                      r < e.size();
                      r++
                    )
                      if (
                        (e.getCoordinate(r, n),
                        e.getCoordinate(r - 1, s),
                        i.countSegment(n, s),
                        i.isOnSegment())
                      )
                        return i.getLocation();
                    return i.getLocation();
                  }
                  if (
                    arguments[0] instanceof V &&
                    arguments[1] instanceof Array
                  ) {
                    for (
                      var a = arguments[1], o = new t(arguments[0]), l = 1;
                      l < a.length;
                      l++
                    ) {
                      var h = a[l],
                        c = a[l - 1];
                      if ((o.countSegment(h, c), o.isOnSegment()))
                        return o.getLocation();
                    }
                    return o.getLocation();
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      Dt = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "isOnLine",
              value: function () {
                if (arguments[0] instanceof V && se(arguments[1], ce)) {
                  for (
                    var e = arguments[0],
                      t = arguments[1],
                      i = new Rt(),
                      n = new V(),
                      s = new V(),
                      r = t.size(),
                      a = 1;
                    a < r;
                    a++
                  )
                    if (
                      (t.getCoordinate(a - 1, n),
                      t.getCoordinate(a, s),
                      i.computeIntersection(e, n, s),
                      i.hasIntersection())
                    )
                      return !0;
                  return !1;
                }
                if (
                  arguments[0] instanceof V &&
                  arguments[1] instanceof Array
                ) {
                  for (
                    var o = arguments[0], l = arguments[1], h = new Rt(), c = 1;
                    c < l.length;
                    c++
                  ) {
                    var u = l[c - 1],
                      d = l[c];
                    if ((h.computeIntersection(o, u, d), h.hasIntersection()))
                      return !0;
                  }
                  return !1;
                }
              },
            },
            {
              key: "locateInRing",
              value: function (e, t) {
                return Pt.locatePointInRing(e, t);
              },
            },
            {
              key: "isInRing",
              value: function (e, i) {
                return t.locateInRing(e, i) !== W.EXTERIOR;
              },
            },
          ]),
          t
        );
      })(),
      Lt = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "setAllLocations",
                value: function (e) {
                  for (var t = 0; t < this.location.length; t++)
                    this.location[t] = e;
                },
              },
              {
                key: "isNull",
                value: function () {
                  for (var e = 0; e < this.location.length; e++)
                    if (this.location[e] !== W.NONE) return !1;
                  return !0;
                },
              },
              {
                key: "setAllLocationsIfNull",
                value: function (e) {
                  for (var t = 0; t < this.location.length; t++)
                    this.location[t] === W.NONE && (this.location[t] = e);
                },
              },
              {
                key: "isLine",
                value: function () {
                  return 1 === this.location.length;
                },
              },
              {
                key: "merge",
                value: function (e) {
                  if (e.location.length > this.location.length) {
                    var t = new Array(3).fill(null);
                    (t[$.ON] = this.location[$.ON]),
                      (t[$.LEFT] = W.NONE),
                      (t[$.RIGHT] = W.NONE),
                      (this.location = t);
                  }
                  for (var i = 0; i < this.location.length; i++)
                    this.location[i] === W.NONE &&
                      i < e.location.length &&
                      (this.location[i] = e.location[i]);
                },
              },
              {
                key: "getLocations",
                value: function () {
                  return this.location;
                },
              },
              {
                key: "flip",
                value: function () {
                  if (this.location.length <= 1) return null;
                  var e = this.location[$.LEFT];
                  (this.location[$.LEFT] = this.location[$.RIGHT]),
                    (this.location[$.RIGHT] = e);
                },
              },
              {
                key: "toString",
                value: function () {
                  var e = new re();
                  return (
                    this.location.length > 1 &&
                      e.append(W.toLocationSymbol(this.location[$.LEFT])),
                    e.append(W.toLocationSymbol(this.location[$.ON])),
                    this.location.length > 1 &&
                      e.append(W.toLocationSymbol(this.location[$.RIGHT])),
                    e.toString()
                  );
                },
              },
              {
                key: "setLocations",
                value: function (e, t, i) {
                  (this.location[$.ON] = e),
                    (this.location[$.LEFT] = t),
                    (this.location[$.RIGHT] = i);
                },
              },
              {
                key: "get",
                value: function (e) {
                  return e < this.location.length ? this.location[e] : W.NONE;
                },
              },
              {
                key: "isArea",
                value: function () {
                  return this.location.length > 1;
                },
              },
              {
                key: "isAnyNull",
                value: function () {
                  for (var e = 0; e < this.location.length; e++)
                    if (this.location[e] === W.NONE) return !0;
                  return !1;
                },
              },
              {
                key: "setLocation",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    this.setLocation($.ON, e);
                  } else if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    this.location[t] = i;
                  }
                },
              },
              {
                key: "init",
                value: function (e) {
                  (this.location = new Array(e).fill(null)),
                    this.setAllLocations(W.NONE);
                },
              },
              {
                key: "isEqualOnSide",
                value: function (e, t) {
                  return this.location[t] === e.location[t];
                },
              },
              {
                key: "allPositionsEqual",
                value: function (e) {
                  for (var t = 0; t < this.location.length; t++)
                    if (this.location[t] !== e) return !1;
                  return !0;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (((this.location = null), 1 === arguments.length)) {
                    if (arguments[0] instanceof Array) {
                      var e = arguments[0];
                      this.init(e.length);
                    } else if (Number.isInteger(arguments[0])) {
                      var i = arguments[0];
                      this.init(1), (this.location[$.ON] = i);
                    } else if (arguments[0] instanceof t) {
                      var n = arguments[0];
                      if ((this.init(n.location.length), null !== n))
                        for (var s = 0; s < this.location.length; s++)
                          this.location[s] = n.location[s];
                    }
                  } else if (3 === arguments.length) {
                    var r = arguments[0],
                      a = arguments[1],
                      o = arguments[2];
                    this.init(3),
                      (this.location[$.ON] = r),
                      (this.location[$.LEFT] = a),
                      (this.location[$.RIGHT] = o);
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      Ft = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getGeometryCount",
                value: function () {
                  var e = 0;
                  return (
                    this.elt[0].isNull() || e++, this.elt[1].isNull() || e++, e
                  );
                },
              },
              {
                key: "setAllLocations",
                value: function (e, t) {
                  this.elt[e].setAllLocations(t);
                },
              },
              {
                key: "isNull",
                value: function (e) {
                  return this.elt[e].isNull();
                },
              },
              {
                key: "setAllLocationsIfNull",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    this.setAllLocationsIfNull(0, e),
                      this.setAllLocationsIfNull(1, e);
                  } else if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    this.elt[t].setAllLocationsIfNull(i);
                  }
                },
              },
              {
                key: "isLine",
                value: function (e) {
                  return this.elt[e].isLine();
                },
              },
              {
                key: "merge",
                value: function (e) {
                  for (var t = 0; t < 2; t++)
                    null === this.elt[t] && null !== e.elt[t]
                      ? (this.elt[t] = new Lt(e.elt[t]))
                      : this.elt[t].merge(e.elt[t]);
                },
              },
              {
                key: "flip",
                value: function () {
                  this.elt[0].flip(), this.elt[1].flip();
                },
              },
              {
                key: "getLocation",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    return this.elt[e].get($.ON);
                  }
                  if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    return this.elt[t].get(i);
                  }
                },
              },
              {
                key: "toString",
                value: function () {
                  var e = new re();
                  return (
                    null !== this.elt[0] &&
                      (e.append("A:"), e.append(this.elt[0].toString())),
                    null !== this.elt[1] &&
                      (e.append(" B:"), e.append(this.elt[1].toString())),
                    e.toString()
                  );
                },
              },
              {
                key: "isArea",
                value: function () {
                  if (0 === arguments.length)
                    return this.elt[0].isArea() || this.elt[1].isArea();
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    return this.elt[e].isArea();
                  }
                },
              },
              {
                key: "isAnyNull",
                value: function (e) {
                  return this.elt[e].isAnyNull();
                },
              },
              {
                key: "setLocation",
                value: function () {
                  if (2 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1];
                    this.elt[e].setLocation($.ON, t);
                  } else if (3 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1],
                      s = arguments[2];
                    this.elt[i].setLocation(n, s);
                  }
                },
              },
              {
                key: "isEqualOnSide",
                value: function (e, t) {
                  return (
                    this.elt[0].isEqualOnSide(e.elt[0], t) &&
                    this.elt[1].isEqualOnSide(e.elt[1], t)
                  );
                },
              },
              {
                key: "allPositionsEqual",
                value: function (e, t) {
                  return this.elt[e].allPositionsEqual(t);
                },
              },
              {
                key: "toLine",
                value: function (e) {
                  this.elt[e].isArea() &&
                    (this.elt[e] = new Lt(this.elt[e].location[0]));
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this.elt = new Array(2).fill(null)),
                    1 === arguments.length)
                  ) {
                    if (Number.isInteger(arguments[0])) {
                      var e = arguments[0];
                      (this.elt[0] = new Lt(e)), (this.elt[1] = new Lt(e));
                    } else if (arguments[0] instanceof t) {
                      var i = arguments[0];
                      (this.elt[0] = new Lt(i.elt[0])),
                        (this.elt[1] = new Lt(i.elt[1]));
                    }
                  } else if (2 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1];
                    (this.elt[0] = new Lt(W.NONE)),
                      (this.elt[1] = new Lt(W.NONE)),
                      this.elt[n].setLocation(s);
                  } else if (3 === arguments.length) {
                    var r = arguments[0],
                      a = arguments[1],
                      o = arguments[2];
                    (this.elt[0] = new Lt(r, a, o)),
                      (this.elt[1] = new Lt(r, a, o));
                  } else if (4 === arguments.length) {
                    var l = arguments[0],
                      h = arguments[1],
                      c = arguments[2],
                      u = arguments[3];
                    (this.elt[0] = new Lt(W.NONE, W.NONE, W.NONE)),
                      (this.elt[1] = new Lt(W.NONE, W.NONE, W.NONE)),
                      this.elt[l].setLocations(h, c, u);
                  }
                },
              },
              {
                key: "toLineLabel",
                value: function (e) {
                  for (var i = new t(W.NONE), n = 0; n < 2; n++)
                    i.setLocation(n, e.getLocation(n));
                  return i;
                },
              },
            ]
          ),
          t
        );
      })(),
      Nt = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "computeRing",
                value: function () {
                  if (null !== this._ring) return null;
                  for (
                    var e = new Array(this._pts.size()).fill(null), t = 0;
                    t < this._pts.size();
                    t++
                  )
                    e[t] = this._pts.get(t);
                  (this._ring = this._geometryFactory.createLinearRing(e)),
                    (this._isHole = ue.isCCW(this._ring.getCoordinates()));
                },
              },
              {
                key: "isIsolated",
                value: function () {
                  return 1 === this._label.getGeometryCount();
                },
              },
              {
                key: "computePoints",
                value: function (e) {
                  this._startDe = e;
                  var t = e,
                    i = !0;
                  do {
                    if (null === t) throw new pe("Found null DirectedEdge");
                    if (t.getEdgeRing() === this)
                      throw new pe(
                        "Directed Edge visited twice during ring-building at " +
                          t.getCoordinate()
                      );
                    this._edges.add(t);
                    var n = t.getLabel();
                    O.isTrue(n.isArea()),
                      this.mergeLabel(n),
                      this.addPoints(t.getEdge(), t.isForward(), i),
                      (i = !1),
                      this.setEdgeRing(t, this),
                      (t = this.getNext(t));
                  } while (t !== this._startDe);
                },
              },
              {
                key: "getLinearRing",
                value: function () {
                  return this._ring;
                },
              },
              {
                key: "getCoordinate",
                value: function (e) {
                  return this._pts.get(e);
                },
              },
              {
                key: "computeMaxNodeDegree",
                value: function () {
                  this._maxNodeDegree = 0;
                  var e = this._startDe;
                  do {
                    var t = e.getNode().getEdges().getOutgoingDegree(this);
                    t > this._maxNodeDegree && (this._maxNodeDegree = t),
                      (e = this.getNext(e));
                  } while (e !== this._startDe);
                  this._maxNodeDegree *= 2;
                },
              },
              {
                key: "addPoints",
                value: function (e, t, i) {
                  var n = e.getCoordinates();
                  if (t) {
                    var s = 1;
                    i && (s = 0);
                    for (var r = s; r < n.length; r++) this._pts.add(n[r]);
                  } else {
                    var a = n.length - 2;
                    i && (a = n.length - 1);
                    for (var o = a; o >= 0; o--) this._pts.add(n[o]);
                  }
                },
              },
              {
                key: "isHole",
                value: function () {
                  return this._isHole;
                },
              },
              {
                key: "setInResult",
                value: function () {
                  var e = this._startDe;
                  do {
                    e.getEdge().setInResult(!0), (e = e.getNext());
                  } while (e !== this._startDe);
                },
              },
              {
                key: "containsPoint",
                value: function (e) {
                  var t = this.getLinearRing();
                  if (!t.getEnvelopeInternal().contains(e)) return !1;
                  if (!Dt.isInRing(e, t.getCoordinates())) return !1;
                  for (var i = this._holes.iterator(); i.hasNext(); )
                    if (i.next().containsPoint(e)) return !1;
                  return !0;
                },
              },
              {
                key: "addHole",
                value: function (e) {
                  this._holes.add(e);
                },
              },
              {
                key: "isShell",
                value: function () {
                  return null === this._shell;
                },
              },
              {
                key: "getLabel",
                value: function () {
                  return this._label;
                },
              },
              {
                key: "getEdges",
                value: function () {
                  return this._edges;
                },
              },
              {
                key: "getMaxNodeDegree",
                value: function () {
                  return (
                    this._maxNodeDegree < 0 && this.computeMaxNodeDegree(),
                    this._maxNodeDegree
                  );
                },
              },
              {
                key: "getShell",
                value: function () {
                  return this._shell;
                },
              },
              {
                key: "mergeLabel",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    this.mergeLabel(e, 0), this.mergeLabel(e, 1);
                  } else if (2 === arguments.length) {
                    var t = arguments[1],
                      i = arguments[0].getLocation(t, $.RIGHT);
                    if (i === W.NONE) return null;
                    if (this._label.getLocation(t) === W.NONE)
                      return this._label.setLocation(t, i), null;
                  }
                },
              },
              {
                key: "setShell",
                value: function (e) {
                  (this._shell = e), null !== e && e.addHole(this);
                },
              },
              {
                key: "toPolygon",
                value: function (e) {
                  for (
                    var t = new Array(this._holes.size()).fill(null), i = 0;
                    i < this._holes.size();
                    i++
                  )
                    t[i] = this._holes.get(i).getLinearRing();
                  return e.createPolygon(this.getLinearRing(), t);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._startDe = null),
                    (this._maxNodeDegree = -1),
                    (this._edges = new me()),
                    (this._pts = new me()),
                    (this._label = new Ft(W.NONE)),
                    (this._ring = null),
                    (this._isHole = null),
                    (this._shell = null),
                    (this._holes = new me()),
                    (this._geometryFactory = null),
                    0 === arguments.length)
                  );
                  else if (2 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1];
                    (this._geometryFactory = t),
                      this.computePoints(e),
                      this.computeRing();
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      Bt = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return (
            e(this, r),
            (t = s.call(this)),
            r.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            r,
            [
              {
                key: "setEdgeRing",
                value: function (e, t) {
                  e.setMinEdgeRing(t);
                },
              },
              {
                key: "getNext",
                value: function (e) {
                  return e.getNextMin();
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  var e = arguments[0],
                    t = arguments[1];
                  Nt.constructor_.call(this, e, t);
                },
              },
            ]
          ),
          r
        );
      })(Nt),
      kt = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return (
            e(this, r),
            (t = s.call(this)),
            r.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            r,
            [
              {
                key: "buildMinimalRings",
                value: function () {
                  var e = new me(),
                    t = this._startDe;
                  do {
                    if (null === t.getMinEdgeRing()) {
                      var i = new Bt(t, this._geometryFactory);
                      e.add(i);
                    }
                    t = t.getNext();
                  } while (t !== this._startDe);
                  return e;
                },
              },
              {
                key: "setEdgeRing",
                value: function (e, t) {
                  e.setEdgeRing(t);
                },
              },
              {
                key: "linkDirectedEdgesForMinimalEdgeRings",
                value: function () {
                  var e = this._startDe;
                  do {
                    e.getNode().getEdges().linkMinimalDirectedEdges(this),
                      (e = e.getNext());
                  } while (e !== this._startDe);
                },
              },
              {
                key: "getNext",
                value: function (e) {
                  return e.getNext();
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  var e = arguments[0],
                    t = arguments[1];
                  Nt.constructor_.call(this, e, t);
                },
              },
            ]
          ),
          r
        );
      })(Nt),
      Ot = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "setVisited",
                value: function (e) {
                  this._isVisited = e;
                },
              },
              {
                key: "setInResult",
                value: function (e) {
                  this._isInResult = e;
                },
              },
              {
                key: "isCovered",
                value: function () {
                  return this._isCovered;
                },
              },
              {
                key: "isCoveredSet",
                value: function () {
                  return this._isCoveredSet;
                },
              },
              {
                key: "setLabel",
                value: function (e) {
                  this._label = e;
                },
              },
              {
                key: "getLabel",
                value: function () {
                  return this._label;
                },
              },
              {
                key: "setCovered",
                value: function (e) {
                  (this._isCovered = e), (this._isCoveredSet = !0);
                },
              },
              {
                key: "updateIM",
                value: function (e) {
                  O.isTrue(
                    this._label.getGeometryCount() >= 2,
                    "found partial label"
                  ),
                    this.computeIM(e);
                },
              },
              {
                key: "isInResult",
                value: function () {
                  return this._isInResult;
                },
              },
              {
                key: "isVisited",
                value: function () {
                  return this._isVisited;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._label = null),
                    (this._isInResult = !1),
                    (this._isCovered = !1),
                    (this._isCoveredSet = !1),
                    (this._isVisited = !1),
                    0 === arguments.length)
                  );
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    this._label = e;
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      Ut = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "isIncidentEdgeInResult",
                value: function () {
                  for (
                    var e = this.getEdges().getEdges().iterator();
                    e.hasNext();

                  )
                    if (e.next().getEdge().isInResult()) return !0;
                  return !1;
                },
              },
              {
                key: "isIsolated",
                value: function () {
                  return 1 === this._label.getGeometryCount();
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  return this._coord;
                },
              },
              {
                key: "print",
                value: function (e) {
                  e.println("node " + this._coord + " lbl: " + this._label);
                },
              },
              { key: "computeIM", value: function (e) {} },
              {
                key: "computeMergedLocation",
                value: function (e, t) {
                  var i = W.NONE;
                  if (((i = this._label.getLocation(t)), !e.isNull(t))) {
                    var n = e.getLocation(t);
                    i !== W.BOUNDARY && (i = n);
                  }
                  return i;
                },
              },
              {
                key: "setLabel",
                value: function () {
                  if (
                    2 !== arguments.length ||
                    !Number.isInteger(arguments[1]) ||
                    !Number.isInteger(arguments[0])
                  )
                    return d(s(a.prototype), "setLabel", this).apply(
                      this,
                      arguments
                    );
                  var e = arguments[0],
                    t = arguments[1];
                  null === this._label
                    ? (this._label = new Ft(e, t))
                    : this._label.setLocation(e, t);
                },
              },
              {
                key: "getEdges",
                value: function () {
                  return this._edges;
                },
              },
              {
                key: "mergeLabel",
                value: function () {
                  if (arguments[0] instanceof a) {
                    var e = arguments[0];
                    this.mergeLabel(e._label);
                  } else if (arguments[0] instanceof Ft)
                    for (var t = arguments[0], i = 0; i < 2; i++) {
                      var n = this.computeMergedLocation(t, i);
                      this._label.getLocation(i) === W.NONE &&
                        this._label.setLocation(i, n);
                    }
                },
              },
              {
                key: "add",
                value: function (e) {
                  this._edges.insert(e), e.setNode(this);
                },
              },
              {
                key: "setLabelBoundary",
                value: function (e) {
                  if (null === this._label) return null;
                  var t = W.NONE;
                  null !== this._label && (t = this._label.getLocation(e));
                  var i = null;
                  switch (t) {
                    case W.BOUNDARY:
                      i = W.INTERIOR;
                      break;
                    case W.INTERIOR:
                    default:
                      i = W.BOUNDARY;
                  }
                  this._label.setLocation(e, i);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._coord = null), (this._edges = null);
                  var e = arguments[0],
                    t = arguments[1];
                  (this._coord = e),
                    (this._edges = t),
                    (this._label = new Ft(0, W.NONE));
                },
              },
            ]
          ),
          a
        );
      })(Ot),
      zt = (function (t) {
        n(s, t);
        var i = u(s);
        function s() {
          return e(this, s), i.apply(this, arguments);
        }
        return s;
      })(tt);
    function Gt(e) {
      return null == e ? 0 : e.color;
    }
    function Vt(e) {
      return null == e ? null : e.parent;
    }
    function Qt(e, t) {
      null !== e && (e.color = t);
    }
    function Ht(e) {
      return null == e ? null : e.left;
    }
    function jt(e) {
      return null == e ? null : e.right;
    }
    var Wt = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return (
            e(this, r), ((t = s.call(this)).root_ = null), (t.size_ = 0), t
          );
        }
        return (
          i(
            r,
            [
              {
                key: "get",
                value: function (e) {
                  for (var t = this.root_; null !== t; ) {
                    var i = e.compareTo(t.key);
                    if (i < 0) t = t.left;
                    else {
                      if (!(i > 0)) return t.value;
                      t = t.right;
                    }
                  }
                  return null;
                },
              },
              {
                key: "put",
                value: function (e, t) {
                  if (null === this.root_)
                    return (
                      (this.root_ = {
                        key: e,
                        value: t,
                        left: null,
                        right: null,
                        parent: null,
                        color: 0,
                        getValue: function () {
                          return this.value;
                        },
                        getKey: function () {
                          return this.key;
                        },
                      }),
                      (this.size_ = 1),
                      null
                    );
                  var i,
                    n,
                    s = this.root_;
                  do {
                    if (((i = s), (n = e.compareTo(s.key)) < 0)) s = s.left;
                    else {
                      if (!(n > 0)) {
                        var r = s.value;
                        return (s.value = t), r;
                      }
                      s = s.right;
                    }
                  } while (null !== s);
                  var a = {
                    key: e,
                    left: null,
                    right: null,
                    value: t,
                    parent: i,
                    color: 0,
                    getValue: function () {
                      return this.value;
                    },
                    getKey: function () {
                      return this.key;
                    },
                  };
                  return (
                    n < 0 ? (i.left = a) : (i.right = a),
                    this.fixAfterInsertion(a),
                    this.size_++,
                    null
                  );
                },
              },
              {
                key: "fixAfterInsertion",
                value: function (e) {
                  var t;
                  for (
                    e.color = 1;
                    null != e && e !== this.root_ && 1 === e.parent.color;

                  )
                    Vt(e) === Ht(Vt(Vt(e)))
                      ? 1 === Gt((t = jt(Vt(Vt(e)))))
                        ? (Qt(Vt(e), 0),
                          Qt(t, 0),
                          Qt(Vt(Vt(e)), 1),
                          (e = Vt(Vt(e))))
                        : (e === jt(Vt(e)) && ((e = Vt(e)), this.rotateLeft(e)),
                          Qt(Vt(e), 0),
                          Qt(Vt(Vt(e)), 1),
                          this.rotateRight(Vt(Vt(e))))
                      : 1 === Gt((t = Ht(Vt(Vt(e)))))
                      ? (Qt(Vt(e), 0),
                        Qt(t, 0),
                        Qt(Vt(Vt(e)), 1),
                        (e = Vt(Vt(e))))
                      : (e === Ht(Vt(e)) && ((e = Vt(e)), this.rotateRight(e)),
                        Qt(Vt(e), 0),
                        Qt(Vt(Vt(e)), 1),
                        this.rotateLeft(Vt(Vt(e))));
                  this.root_.color = 0;
                },
              },
              {
                key: "values",
                value: function () {
                  var e = new me(),
                    t = this.getFirstEntry();
                  if (null !== t)
                    for (e.add(t.value); null !== (t = r.successor(t)); )
                      e.add(t.value);
                  return e;
                },
              },
              {
                key: "entrySet",
                value: function () {
                  var e = new Z(),
                    t = this.getFirstEntry();
                  if (null !== t)
                    for (e.add(t); null !== (t = r.successor(t)); ) e.add(t);
                  return e;
                },
              },
              {
                key: "rotateLeft",
                value: function (e) {
                  if (null != e) {
                    var t = e.right;
                    (e.right = t.left),
                      null != t.left && (t.left.parent = e),
                      (t.parent = e.parent),
                      null == e.parent
                        ? (this.root_ = t)
                        : e.parent.left === e
                        ? (e.parent.left = t)
                        : (e.parent.right = t),
                      (t.left = e),
                      (e.parent = t);
                  }
                },
              },
              {
                key: "rotateRight",
                value: function (e) {
                  if (null != e) {
                    var t = e.left;
                    (e.left = t.right),
                      null != t.right && (t.right.parent = e),
                      (t.parent = e.parent),
                      null == e.parent
                        ? (this.root_ = t)
                        : e.parent.right === e
                        ? (e.parent.right = t)
                        : (e.parent.left = t),
                      (t.right = e),
                      (e.parent = t);
                  }
                },
              },
              {
                key: "getFirstEntry",
                value: function () {
                  var e = this.root_;
                  if (null != e) for (; null != e.left; ) e = e.left;
                  return e;
                },
              },
              {
                key: "size",
                value: function () {
                  return this.size_;
                },
              },
              {
                key: "containsKey",
                value: function (e) {
                  for (var t = this.root_; null !== t; ) {
                    var i = e.compareTo(t.key);
                    if (i < 0) t = t.left;
                    else {
                      if (!(i > 0)) return !0;
                      t = t.right;
                    }
                  }
                  return !1;
                },
              },
            ],
            [
              {
                key: "successor",
                value: function (e) {
                  var t;
                  if (null === e) return null;
                  if (null !== e.right) {
                    for (t = e.right; null !== t.left; ) t = t.left;
                    return t;
                  }
                  t = e.parent;
                  for (var i = e; null !== t && i === t.right; )
                    (i = t), (t = t.parent);
                  return t;
                },
              },
            ]
          ),
          r
        );
      })(zt),
      qt = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "find",
                value: function (e) {
                  return this.nodeMap.get(e);
                },
              },
              {
                key: "addNode",
                value: function () {
                  if (arguments[0] instanceof V) {
                    var e = arguments[0],
                      t = this.nodeMap.get(e);
                    return (
                      null === t &&
                        ((t = this.nodeFact.createNode(e)),
                        this.nodeMap.put(e, t)),
                      t
                    );
                  }
                  if (arguments[0] instanceof Ut) {
                    var i = arguments[0],
                      n = this.nodeMap.get(i.getCoordinate());
                    return null === n
                      ? (this.nodeMap.put(i.getCoordinate(), i), i)
                      : (n.mergeLabel(i), n);
                  }
                },
              },
              {
                key: "print",
                value: function (e) {
                  for (var t = this.iterator(); t.hasNext(); )
                    t.next().print(e);
                },
              },
              {
                key: "iterator",
                value: function () {
                  return this.nodeMap.values().iterator();
                },
              },
              {
                key: "values",
                value: function () {
                  return this.nodeMap.values();
                },
              },
              {
                key: "getBoundaryNodes",
                value: function (e) {
                  for (var t = new me(), i = this.iterator(); i.hasNext(); ) {
                    var n = i.next();
                    n.getLabel().getLocation(e) === W.BOUNDARY && t.add(n);
                  }
                  return t;
                },
              },
              {
                key: "add",
                value: function (e) {
                  var t = e.getCoordinate();
                  this.addNode(t).add(e);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this.nodeMap = new Wt()), (this.nodeFact = null);
                  var e = arguments[0];
                  this.nodeFact = e;
                },
              },
            ]
          ),
          t
        );
      })(),
      Xt = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "isNorthern",
              value: function (e) {
                return e === t.NE || e === t.NW;
              },
            },
            {
              key: "isOpposite",
              value: function (e, t) {
                return e !== t && 2 == (e - t + 4) % 4;
              },
            },
            {
              key: "commonHalfPlane",
              value: function (e, t) {
                if (e === t) return e;
                if (2 == (e - t + 4) % 4) return -1;
                var i = e < t ? e : t;
                return 0 === i && 3 === (e > t ? e : t) ? 3 : i;
              },
            },
            {
              key: "isInHalfPlane",
              value: function (e, i) {
                return i === t.SE
                  ? e === t.SE || e === t.SW
                  : e === i || e === i + 1;
              },
            },
            {
              key: "quadrant",
              value: function () {
                if (
                  "number" == typeof arguments[0] &&
                  "number" == typeof arguments[1]
                ) {
                  var e = arguments[0],
                    i = arguments[1];
                  if (0 === e && 0 === i)
                    throw new A(
                      "Cannot compute the quadrant for point ( " +
                        e +
                        ", " +
                        i +
                        " )"
                    );
                  return e >= 0 ? (i >= 0 ? t.NE : t.SE) : i >= 0 ? t.NW : t.SW;
                }
                if (arguments[0] instanceof V && arguments[1] instanceof V) {
                  var n = arguments[0],
                    s = arguments[1];
                  if (s.x === n.x && s.y === n.y)
                    throw new A(
                      "Cannot compute the quadrant for two identical points " +
                        n
                    );
                  return s.x >= n.x
                    ? s.y >= n.y
                      ? t.NE
                      : t.SE
                    : s.y >= n.y
                    ? t.NW
                    : t.SW;
                }
              },
            },
          ]),
          t
        );
      })();
    (Xt.NE = 0), (Xt.NW = 1), (Xt.SW = 2), (Xt.SE = 3);
    var Yt = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "compareDirection",
                value: function (e) {
                  return this._dx === e._dx && this._dy === e._dy
                    ? 0
                    : this._quadrant > e._quadrant
                    ? 1
                    : this._quadrant < e._quadrant
                    ? -1
                    : ue.index(e._p0, e._p1, this._p1);
                },
              },
              {
                key: "getDy",
                value: function () {
                  return this._dy;
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  return this._p0;
                },
              },
              {
                key: "setNode",
                value: function (e) {
                  this._node = e;
                },
              },
              {
                key: "print",
                value: function (e) {
                  var t = Math.atan2(this._dy, this._dx),
                    i = this.getClass().getName(),
                    n = i.lastIndexOf("."),
                    s = i.substring(n + 1);
                  e.print(
                    "  " +
                      s +
                      ": " +
                      this._p0 +
                      " - " +
                      this._p1 +
                      " " +
                      this._quadrant +
                      ":" +
                      t +
                      "   " +
                      this._label
                  );
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e;
                  return this.compareDirection(t);
                },
              },
              {
                key: "getDirectedCoordinate",
                value: function () {
                  return this._p1;
                },
              },
              {
                key: "getDx",
                value: function () {
                  return this._dx;
                },
              },
              {
                key: "getLabel",
                value: function () {
                  return this._label;
                },
              },
              {
                key: "getEdge",
                value: function () {
                  return this._edge;
                },
              },
              {
                key: "getQuadrant",
                value: function () {
                  return this._quadrant;
                },
              },
              {
                key: "getNode",
                value: function () {
                  return this._node;
                },
              },
              {
                key: "toString",
                value: function () {
                  var e = Math.atan2(this._dy, this._dx),
                    t = this.getClass().getName(),
                    i = t.lastIndexOf(".");
                  return (
                    "  " +
                    t.substring(i + 1) +
                    ": " +
                    this._p0 +
                    " - " +
                    this._p1 +
                    " " +
                    this._quadrant +
                    ":" +
                    e +
                    "   " +
                    this._label
                  );
                },
              },
              { key: "computeLabel", value: function (e) {} },
              {
                key: "init",
                value: function (e, t) {
                  (this._p0 = e),
                    (this._p1 = t),
                    (this._dx = t.x - e.x),
                    (this._dy = t.y - e.y),
                    (this._quadrant = Xt.quadrant(this._dx, this._dy)),
                    O.isTrue(
                      !(0 === this._dx && 0 === this._dy),
                      "EdgeEnd with identical endpoints found"
                    );
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._edge = null),
                    (this._label = null),
                    (this._node = null),
                    (this._p0 = null),
                    (this._p1 = null),
                    (this._dx = null),
                    (this._dy = null),
                    (this._quadrant = null),
                    1 === arguments.length)
                  ) {
                    var e = arguments[0];
                    this._edge = e;
                  } else if (3 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1],
                      s = arguments[2];
                    t.constructor_.call(this, i, n, s, null);
                  } else if (4 === arguments.length) {
                    var r = arguments[0],
                      a = arguments[1],
                      o = arguments[2],
                      l = arguments[3];
                    t.constructor_.call(this, r),
                      this.init(a, o),
                      (this._label = l);
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      Kt = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "getNextMin",
                value: function () {
                  return this._nextMin;
                },
              },
              {
                key: "getDepth",
                value: function (e) {
                  return this._depth[e];
                },
              },
              {
                key: "setVisited",
                value: function (e) {
                  this._isVisited = e;
                },
              },
              {
                key: "computeDirectedLabel",
                value: function () {
                  (this._label = new Ft(this._edge.getLabel())),
                    this._isForward || this._label.flip();
                },
              },
              {
                key: "getNext",
                value: function () {
                  return this._next;
                },
              },
              {
                key: "setDepth",
                value: function (e, t) {
                  if (-999 !== this._depth[e] && this._depth[e] !== t)
                    throw new pe(
                      "assigned depths do not match",
                      this.getCoordinate()
                    );
                  this._depth[e] = t;
                },
              },
              {
                key: "isInteriorAreaEdge",
                value: function () {
                  for (var e = !0, t = 0; t < 2; t++)
                    (this._label.isArea(t) &&
                      this._label.getLocation(t, $.LEFT) === W.INTERIOR &&
                      this._label.getLocation(t, $.RIGHT) === W.INTERIOR) ||
                      (e = !1);
                  return e;
                },
              },
              {
                key: "setNextMin",
                value: function (e) {
                  this._nextMin = e;
                },
              },
              {
                key: "print",
                value: function (e) {
                  d(s(a.prototype), "print", this).call(this, e),
                    e.print(
                      " " + this._depth[$.LEFT] + "/" + this._depth[$.RIGHT]
                    ),
                    e.print(" (" + this.getDepthDelta() + ")"),
                    this._isInResult && e.print(" inResult");
                },
              },
              {
                key: "setMinEdgeRing",
                value: function (e) {
                  this._minEdgeRing = e;
                },
              },
              {
                key: "isLineEdge",
                value: function () {
                  var e = this._label.isLine(0) || this._label.isLine(1),
                    t =
                      !this._label.isArea(0) ||
                      this._label.allPositionsEqual(0, W.EXTERIOR),
                    i =
                      !this._label.isArea(1) ||
                      this._label.allPositionsEqual(1, W.EXTERIOR);
                  return e && t && i;
                },
              },
              {
                key: "setEdgeRing",
                value: function (e) {
                  this._edgeRing = e;
                },
              },
              {
                key: "getMinEdgeRing",
                value: function () {
                  return this._minEdgeRing;
                },
              },
              {
                key: "getDepthDelta",
                value: function () {
                  var e = this._edge.getDepthDelta();
                  return this._isForward || (e = -e), e;
                },
              },
              {
                key: "setInResult",
                value: function (e) {
                  this._isInResult = e;
                },
              },
              {
                key: "getSym",
                value: function () {
                  return this._sym;
                },
              },
              {
                key: "isForward",
                value: function () {
                  return this._isForward;
                },
              },
              {
                key: "getEdge",
                value: function () {
                  return this._edge;
                },
              },
              {
                key: "printEdge",
                value: function (e) {
                  this.print(e),
                    e.print(" "),
                    this._isForward
                      ? this._edge.print(e)
                      : this._edge.printReverse(e);
                },
              },
              {
                key: "setSym",
                value: function (e) {
                  this._sym = e;
                },
              },
              {
                key: "setVisitedEdge",
                value: function (e) {
                  this.setVisited(e), this._sym.setVisited(e);
                },
              },
              {
                key: "setEdgeDepths",
                value: function (e, t) {
                  var i = this.getEdge().getDepthDelta();
                  this._isForward || (i = -i);
                  var n = 1;
                  e === $.LEFT && (n = -1);
                  var s = $.opposite(e),
                    r = t + i * n;
                  this.setDepth(e, t), this.setDepth(s, r);
                },
              },
              {
                key: "getEdgeRing",
                value: function () {
                  return this._edgeRing;
                },
              },
              {
                key: "isInResult",
                value: function () {
                  return this._isInResult;
                },
              },
              {
                key: "setNext",
                value: function (e) {
                  this._next = e;
                },
              },
              {
                key: "isVisited",
                value: function () {
                  return this._isVisited;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._isForward = null),
                    (this._isInResult = !1),
                    (this._isVisited = !1),
                    (this._sym = null),
                    (this._next = null),
                    (this._nextMin = null),
                    (this._edgeRing = null),
                    (this._minEdgeRing = null),
                    (this._depth = [0, -999, -999]);
                  var e = arguments[0],
                    t = arguments[1];
                  if ((Yt.constructor_.call(this, e), (this._isForward = t), t))
                    this.init(e.getCoordinate(0), e.getCoordinate(1));
                  else {
                    var i = e.getNumPoints() - 1;
                    this.init(e.getCoordinate(i), e.getCoordinate(i - 1));
                  }
                  this.computeDirectedLabel();
                },
              },
              {
                key: "depthFactor",
                value: function (e, t) {
                  return e === W.EXTERIOR && t === W.INTERIOR
                    ? 1
                    : e === W.INTERIOR && t === W.EXTERIOR
                    ? -1
                    : 0;
                },
              },
            ]
          ),
          a
        );
      })(Yt),
      Zt = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            {
              key: "createNode",
              value: function (e) {
                return new Ut(e, null);
              },
            },
          ]),
          t
        );
      })(),
      Jt = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "printEdges",
                value: function (e) {
                  e.println("Edges:");
                  for (var t = 0; t < this._edges.size(); t++) {
                    e.println("edge " + t + ":");
                    var i = this._edges.get(t);
                    i.print(e), i.eiList.print(e);
                  }
                },
              },
              {
                key: "find",
                value: function (e) {
                  return this._nodes.find(e);
                },
              },
              {
                key: "addNode",
                value: function () {
                  if (arguments[0] instanceof Ut) {
                    var e = arguments[0];
                    return this._nodes.addNode(e);
                  }
                  if (arguments[0] instanceof V) {
                    var t = arguments[0];
                    return this._nodes.addNode(t);
                  }
                },
              },
              {
                key: "getNodeIterator",
                value: function () {
                  return this._nodes.iterator();
                },
              },
              {
                key: "linkResultDirectedEdges",
                value: function () {
                  for (var e = this._nodes.iterator(); e.hasNext(); )
                    e.next().getEdges().linkResultDirectedEdges();
                },
              },
              {
                key: "debugPrintln",
                value: function (e) {
                  Ae.out.println(e);
                },
              },
              {
                key: "isBoundaryNode",
                value: function (e, t) {
                  var i = this._nodes.find(t);
                  if (null === i) return !1;
                  var n = i.getLabel();
                  return null !== n && n.getLocation(e) === W.BOUNDARY;
                },
              },
              {
                key: "linkAllDirectedEdges",
                value: function () {
                  for (var e = this._nodes.iterator(); e.hasNext(); )
                    e.next().getEdges().linkAllDirectedEdges();
                },
              },
              {
                key: "matchInSameDirection",
                value: function (e, t, i, n) {
                  return (
                    !!e.equals(i) &&
                    ue.index(e, t, n) === ue.COLLINEAR &&
                    Xt.quadrant(e, t) === Xt.quadrant(i, n)
                  );
                },
              },
              {
                key: "getEdgeEnds",
                value: function () {
                  return this._edgeEndList;
                },
              },
              {
                key: "debugPrint",
                value: function (e) {
                  Ae.out.print(e);
                },
              },
              {
                key: "getEdgeIterator",
                value: function () {
                  return this._edges.iterator();
                },
              },
              {
                key: "findEdgeInSameDirection",
                value: function (e, t) {
                  for (var i = 0; i < this._edges.size(); i++) {
                    var n = this._edges.get(i),
                      s = n.getCoordinates();
                    if (this.matchInSameDirection(e, t, s[0], s[1])) return n;
                    if (
                      this.matchInSameDirection(
                        e,
                        t,
                        s[s.length - 1],
                        s[s.length - 2]
                      )
                    )
                      return n;
                  }
                  return null;
                },
              },
              {
                key: "insertEdge",
                value: function (e) {
                  this._edges.add(e);
                },
              },
              {
                key: "findEdgeEnd",
                value: function (e) {
                  for (var t = this.getEdgeEnds().iterator(); t.hasNext(); ) {
                    var i = t.next();
                    if (i.getEdge() === e) return i;
                  }
                  return null;
                },
              },
              {
                key: "addEdges",
                value: function (e) {
                  for (var t = e.iterator(); t.hasNext(); ) {
                    var i = t.next();
                    this._edges.add(i);
                    var n = new Kt(i, !0),
                      s = new Kt(i, !1);
                    n.setSym(s), s.setSym(n), this.add(n), this.add(s);
                  }
                },
              },
              {
                key: "add",
                value: function (e) {
                  this._nodes.add(e), this._edgeEndList.add(e);
                },
              },
              {
                key: "getNodes",
                value: function () {
                  return this._nodes.values();
                },
              },
              {
                key: "findEdge",
                value: function (e, t) {
                  for (var i = 0; i < this._edges.size(); i++) {
                    var n = this._edges.get(i),
                      s = n.getCoordinates();
                    if (e.equals(s[0]) && t.equals(s[1])) return n;
                  }
                  return null;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._edges = new me()),
                    (this._nodes = null),
                    (this._edgeEndList = new me()),
                    0 === arguments.length)
                  )
                    this._nodes = new qt(new Zt());
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    this._nodes = new qt(e);
                  }
                },
              },
              {
                key: "linkResultDirectedEdges",
                value: function (e) {
                  for (var t = e.iterator(); t.hasNext(); )
                    t.next().getEdges().linkResultDirectedEdges();
                },
              },
            ]
          ),
          t
        );
      })(),
      $t = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "sortShellsAndHoles",
                value: function (e, t, i) {
                  for (var n = e.iterator(); n.hasNext(); ) {
                    var s = n.next();
                    s.isHole() ? i.add(s) : t.add(s);
                  }
                },
              },
              {
                key: "computePolygons",
                value: function (e) {
                  for (var t = new me(), i = e.iterator(); i.hasNext(); ) {
                    var n = i.next().toPolygon(this._geometryFactory);
                    t.add(n);
                  }
                  return t;
                },
              },
              {
                key: "placeFreeHoles",
                value: function (e, i) {
                  for (var n = i.iterator(); n.hasNext(); ) {
                    var s = n.next();
                    if (null === s.getShell()) {
                      var r = t.findEdgeRingContaining(s, e);
                      if (null === r)
                        throw new pe(
                          "unable to assign hole to a shell",
                          s.getCoordinate(0)
                        );
                      s.setShell(r);
                    }
                  }
                },
              },
              {
                key: "buildMinimalEdgeRings",
                value: function (e, t, i) {
                  for (var n = new me(), s = e.iterator(); s.hasNext(); ) {
                    var r = s.next();
                    if (r.getMaxNodeDegree() > 2) {
                      r.linkDirectedEdgesForMinimalEdgeRings();
                      var a = r.buildMinimalRings(),
                        o = this.findShell(a);
                      null !== o
                        ? (this.placePolygonHoles(o, a), t.add(o))
                        : i.addAll(a);
                    } else n.add(r);
                  }
                  return n;
                },
              },
              {
                key: "buildMaximalEdgeRings",
                value: function (e) {
                  for (var t = new me(), i = e.iterator(); i.hasNext(); ) {
                    var n = i.next();
                    if (
                      n.isInResult() &&
                      n.getLabel().isArea() &&
                      null === n.getEdgeRing()
                    ) {
                      var s = new kt(n, this._geometryFactory);
                      t.add(s), s.setInResult();
                    }
                  }
                  return t;
                },
              },
              {
                key: "placePolygonHoles",
                value: function (e, t) {
                  for (var i = t.iterator(); i.hasNext(); ) {
                    var n = i.next();
                    n.isHole() && n.setShell(e);
                  }
                },
              },
              {
                key: "getPolygons",
                value: function () {
                  return this.computePolygons(this._shellList);
                },
              },
              {
                key: "findShell",
                value: function (e) {
                  for (var t = 0, i = null, n = e.iterator(); n.hasNext(); ) {
                    var s = n.next();
                    s.isHole() || ((i = s), t++);
                  }
                  return (
                    O.isTrue(
                      t <= 1,
                      "found two shells in MinimalEdgeRing list"
                    ),
                    i
                  );
                },
              },
              {
                key: "add",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    this.add(e.getEdgeEnds(), e.getNodes());
                  } else if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    Jt.linkResultDirectedEdges(i);
                    var n = this.buildMaximalEdgeRings(t),
                      s = new me(),
                      r = this.buildMinimalEdgeRings(n, this._shellList, s);
                    this.sortShellsAndHoles(r, this._shellList, s),
                      this.placeFreeHoles(this._shellList, s);
                  }
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._geometryFactory = null), (this._shellList = new me());
                  var e = arguments[0];
                  this._geometryFactory = e;
                },
              },
              {
                key: "findEdgeRingContaining",
                value: function (e, t) {
                  for (
                    var i = e.getLinearRing(),
                      n = i.getEnvelopeInternal(),
                      s = i.getCoordinateN(0),
                      r = null,
                      a = null,
                      o = t.iterator();
                    o.hasNext();

                  ) {
                    var l = o.next(),
                      h = l.getLinearRing(),
                      c = h.getEnvelopeInternal();
                    if (!c.equals(n) && c.contains(n)) {
                      s = Xe.ptNotInList(
                        i.getCoordinates(),
                        h.getCoordinates()
                      );
                      var u = !1;
                      Dt.isInRing(s, h.getCoordinates()) && (u = !0),
                        u &&
                          (null === r || a.contains(c)) &&
                          (a = (r = l).getLinearRing().getEnvelopeInternal());
                    }
                  }
                  return r;
                },
              },
            ]
          ),
          t
        );
      })(),
      ei = (function () {
        function t() {
          e(this, t);
        }
        return i(t, [{ key: "getBounds", value: function () {} }]), t;
      })(),
      ti = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getItem",
                value: function () {
                  return this._item;
                },
              },
              {
                key: "getBounds",
                value: function () {
                  return this._bounds;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [ei, E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._bounds = null), (this._item = null);
                  var e = arguments[0],
                    t = arguments[1];
                  (this._bounds = e), (this._item = t);
                },
              },
            ]
          ),
          t
        );
      })(),
      ii = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "poll",
                value: function () {
                  if (this.isEmpty()) return null;
                  var e = this._items.get(1);
                  return (
                    this._items.set(1, this._items.get(this._size)),
                    (this._size -= 1),
                    this.reorder(1),
                    e
                  );
                },
              },
              {
                key: "size",
                value: function () {
                  return this._size;
                },
              },
              {
                key: "reorder",
                value: function (e) {
                  for (
                    var t = null, i = this._items.get(e);
                    2 * e <= this._size &&
                    ((t = 2 * e) !== this._size &&
                      this._items.get(t + 1).compareTo(this._items.get(t)) <
                        0 &&
                      t++,
                    this._items.get(t).compareTo(i) < 0);
                    e = t
                  )
                    this._items.set(e, this._items.get(t));
                  this._items.set(e, i);
                },
              },
              {
                key: "clear",
                value: function () {
                  (this._size = 0), this._items.clear();
                },
              },
              {
                key: "peek",
                value: function () {
                  return this.isEmpty() ? null : this._items.get(1);
                },
              },
              {
                key: "isEmpty",
                value: function () {
                  return 0 === this._size;
                },
              },
              {
                key: "add",
                value: function (e) {
                  this._items.add(null), (this._size += 1);
                  var t = this._size;
                  for (
                    this._items.set(0, e);
                    e.compareTo(this._items.get(Math.trunc(t / 2))) < 0;
                    t /= 2
                  )
                    this._items.set(t, this._items.get(Math.trunc(t / 2)));
                  this._items.set(t, e);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._size = null),
                    (this._items = null),
                    (this._size = 0),
                    (this._items = new me()),
                    this._items.add(null);
                },
              },
            ]
          ),
          t
        );
      })(),
      ni = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            { key: "insert", value: function (e, t) {} },
            { key: "remove", value: function (e, t) {} },
            { key: "query", value: function () {} },
          ]),
          t
        );
      })(),
      si = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getLevel",
                value: function () {
                  return this._level;
                },
              },
              {
                key: "size",
                value: function () {
                  return this._childBoundables.size();
                },
              },
              {
                key: "getChildBoundables",
                value: function () {
                  return this._childBoundables;
                },
              },
              {
                key: "addChildBoundable",
                value: function (e) {
                  O.isTrue(null === this._bounds), this._childBoundables.add(e);
                },
              },
              {
                key: "isEmpty",
                value: function () {
                  return this._childBoundables.isEmpty();
                },
              },
              {
                key: "getBounds",
                value: function () {
                  return (
                    null === this._bounds &&
                      (this._bounds = this.computeBounds()),
                    this._bounds
                  );
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [ei, E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._childBoundables = new me()),
                    (this._bounds = null),
                    (this._level = null),
                    0 === arguments.length)
                  );
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    this._level = e;
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      ri = {
        reverseOrder: function () {
          return {
            compare: function (e, t) {
              return t.compareTo(e);
            },
          };
        },
        min: function (e) {
          return ri.sort(e), e.get(0);
        },
        sort: function (e, t) {
          var i = e.toArray();
          t ? Fe.sort(i, t) : Fe.sort(i);
          for (var n = e.iterator(), s = 0, r = i.length; s < r; s++)
            n.next(), n.set(i[s]);
        },
        singletonList: function (e) {
          var t = new me();
          return t.add(e), t;
        },
      },
      ai = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "maxDistance",
              value: function (e, i, n, s, r, a, o, l) {
                var h = t.distance(e, i, r, a);
                return (
                  (h = Math.max(h, t.distance(e, i, o, l))),
                  (h = Math.max(h, t.distance(n, s, r, a))),
                  Math.max(h, t.distance(n, s, o, l))
                );
              },
            },
            {
              key: "distance",
              value: function (e, t, i, n) {
                var s = i - e,
                  r = n - t;
                return Math.sqrt(s * s + r * r);
              },
            },
            {
              key: "maximumDistance",
              value: function (e, i) {
                var n = Math.min(e.getMinX(), i.getMinX()),
                  s = Math.min(e.getMinY(), i.getMinY()),
                  r = Math.max(e.getMaxX(), i.getMaxX()),
                  a = Math.max(e.getMaxY(), i.getMaxY());
                return t.distance(n, s, r, a);
              },
            },
            {
              key: "minMaxDistance",
              value: function (e, i) {
                var n = e.getMinX(),
                  s = e.getMinY(),
                  r = e.getMaxX(),
                  a = e.getMaxY(),
                  o = i.getMinX(),
                  l = i.getMinY(),
                  h = i.getMaxX(),
                  c = i.getMaxY(),
                  u = t.maxDistance(n, s, n, a, o, l, o, c);
                return (
                  (u = Math.min(u, t.maxDistance(n, s, n, a, o, l, h, l))),
                  (u = Math.min(u, t.maxDistance(n, s, n, a, h, c, o, c))),
                  (u = Math.min(u, t.maxDistance(n, s, n, a, h, c, h, l))),
                  (u = Math.min(u, t.maxDistance(n, s, r, s, o, l, o, c))),
                  (u = Math.min(u, t.maxDistance(n, s, r, s, o, l, h, l))),
                  (u = Math.min(u, t.maxDistance(n, s, r, s, h, c, o, c))),
                  (u = Math.min(u, t.maxDistance(n, s, r, s, h, c, h, l))),
                  (u = Math.min(u, t.maxDistance(r, a, n, a, o, l, o, c))),
                  (u = Math.min(u, t.maxDistance(r, a, n, a, o, l, h, l))),
                  (u = Math.min(u, t.maxDistance(r, a, n, a, h, c, o, c))),
                  (u = Math.min(u, t.maxDistance(r, a, n, a, h, c, h, l))),
                  (u = Math.min(u, t.maxDistance(r, a, r, s, o, l, o, c))),
                  (u = Math.min(u, t.maxDistance(r, a, r, s, o, l, h, l))),
                  (u = Math.min(u, t.maxDistance(r, a, r, s, h, c, o, c))),
                  Math.min(u, t.maxDistance(r, a, r, s, h, c, h, l))
                );
              },
            },
          ]),
          t
        );
      })(),
      oi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "maximumDistance",
                value: function () {
                  return ai.maximumDistance(
                    this._boundable1.getBounds(),
                    this._boundable2.getBounds()
                  );
                },
              },
              {
                key: "expandToQueue",
                value: function (e, i) {
                  var n = t.isComposite(this._boundable1),
                    s = t.isComposite(this._boundable2);
                  if (n && s)
                    return t.area(this._boundable1) > t.area(this._boundable2)
                      ? (this.expand(
                          this._boundable1,
                          this._boundable2,
                          !1,
                          e,
                          i
                        ),
                        null)
                      : (this.expand(
                          this._boundable2,
                          this._boundable1,
                          !0,
                          e,
                          i
                        ),
                        null);
                  if (n)
                    return (
                      this.expand(this._boundable1, this._boundable2, !1, e, i),
                      null
                    );
                  if (s)
                    return (
                      this.expand(this._boundable2, this._boundable1, !0, e, i),
                      null
                    );
                  throw new A("neither boundable is composite");
                },
              },
              {
                key: "isLeaves",
                value: function () {
                  return !(
                    t.isComposite(this._boundable1) ||
                    t.isComposite(this._boundable2)
                  );
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e;
                  return this._distance < t._distance
                    ? -1
                    : this._distance > t._distance
                    ? 1
                    : 0;
                },
              },
              {
                key: "expand",
                value: function (e, i, n, s, r) {
                  for (
                    var a = e.getChildBoundables().iterator();
                    a.hasNext();

                  ) {
                    var o = a.next(),
                      l = null;
                    (l = n
                      ? new t(i, o, this._itemDistance)
                      : new t(o, i, this._itemDistance)).getDistance() < r &&
                      s.add(l);
                  }
                },
              },
              {
                key: "getBoundable",
                value: function (e) {
                  return 0 === e ? this._boundable1 : this._boundable2;
                },
              },
              {
                key: "getDistance",
                value: function () {
                  return this._distance;
                },
              },
              {
                key: "distance",
                value: function () {
                  return this.isLeaves()
                    ? this._itemDistance.distance(
                        this._boundable1,
                        this._boundable2
                      )
                    : this._boundable1
                        .getBounds()
                        .distance(this._boundable2.getBounds());
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._boundable1 = null),
                    (this._boundable2 = null),
                    (this._distance = null),
                    (this._itemDistance = null);
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2];
                  (this._boundable1 = e),
                    (this._boundable2 = t),
                    (this._itemDistance = i),
                    (this._distance = this.distance());
                },
              },
              {
                key: "area",
                value: function (e) {
                  return e.getBounds().getArea();
                },
              },
              {
                key: "isComposite",
                value: function (e) {
                  return e instanceof si;
                },
              },
            ]
          ),
          t
        );
      })(),
      li = (function () {
        function t() {
          e(this, t);
        }
        return i(t, [{ key: "visitItem", value: function (e) {} }]), t;
      })(),
      hi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "queryInternal",
                value: function () {
                  if (
                    se(arguments[2], li) &&
                    arguments[0] instanceof Object &&
                    arguments[1] instanceof si
                  )
                    for (
                      var e = arguments[0],
                        t = arguments[2],
                        i = arguments[1].getChildBoundables(),
                        n = 0;
                      n < i.size();
                      n++
                    ) {
                      var s = i.get(n);
                      this.getIntersectsOp().intersects(s.getBounds(), e) &&
                        (s instanceof si
                          ? this.queryInternal(e, s, t)
                          : s instanceof ti
                          ? t.visitItem(s.getItem())
                          : O.shouldNeverReachHere());
                    }
                  else if (
                    se(arguments[2], ie) &&
                    arguments[0] instanceof Object &&
                    arguments[1] instanceof si
                  )
                    for (
                      var r = arguments[0],
                        a = arguments[2],
                        o = arguments[1].getChildBoundables(),
                        l = 0;
                      l < o.size();
                      l++
                    ) {
                      var h = o.get(l);
                      this.getIntersectsOp().intersects(h.getBounds(), r) &&
                        (h instanceof si
                          ? this.queryInternal(r, h, a)
                          : h instanceof ti
                          ? a.add(h.getItem())
                          : O.shouldNeverReachHere());
                    }
                },
              },
              {
                key: "getNodeCapacity",
                value: function () {
                  return this._nodeCapacity;
                },
              },
              {
                key: "lastNode",
                value: function (e) {
                  return e.get(e.size() - 1);
                },
              },
              {
                key: "size",
                value: function () {
                  if (0 === arguments.length)
                    return this.isEmpty()
                      ? 0
                      : (this.build(), this.size(this._root));
                  if (1 === arguments.length) {
                    for (
                      var e = 0,
                        t = arguments[0].getChildBoundables().iterator();
                      t.hasNext();

                    ) {
                      var i = t.next();
                      i instanceof si
                        ? (e += this.size(i))
                        : i instanceof ti && (e += 1);
                    }
                    return e;
                  }
                },
              },
              {
                key: "removeItem",
                value: function (e, t) {
                  for (
                    var i = null, n = e.getChildBoundables().iterator();
                    n.hasNext();

                  ) {
                    var s = n.next();
                    s instanceof ti && s.getItem() === t && (i = s);
                  }
                  return null !== i && (e.getChildBoundables().remove(i), !0);
                },
              },
              {
                key: "itemsTree",
                value: function () {
                  if (0 === arguments.length) {
                    this.build();
                    var e = this.itemsTree(this._root);
                    return null === e ? new me() : e;
                  }
                  if (1 === arguments.length) {
                    for (
                      var t = arguments[0],
                        i = new me(),
                        n = t.getChildBoundables().iterator();
                      n.hasNext();

                    ) {
                      var s = n.next();
                      if (s instanceof si) {
                        var r = this.itemsTree(s);
                        null !== r && i.add(r);
                      } else
                        s instanceof ti
                          ? i.add(s.getItem())
                          : O.shouldNeverReachHere();
                    }
                    return i.size() <= 0 ? null : i;
                  }
                },
              },
              {
                key: "insert",
                value: function (e, t) {
                  O.isTrue(
                    !this._built,
                    "Cannot insert items into an STR packed R-tree after it has been built."
                  ),
                    this._itemBoundables.add(new ti(e, t));
                },
              },
              {
                key: "boundablesAtLevel",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0],
                      t = new me();
                    return this.boundablesAtLevel(e, this._root, t), t;
                  }
                  if (3 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1],
                      s = arguments[2];
                    if ((O.isTrue(i > -2), n.getLevel() === i))
                      return s.add(n), null;
                    for (
                      var r = n.getChildBoundables().iterator();
                      r.hasNext();

                    ) {
                      var a = r.next();
                      a instanceof si
                        ? this.boundablesAtLevel(i, a, s)
                        : (O.isTrue(a instanceof ti), -1 === i && s.add(a));
                    }
                    return null;
                  }
                },
              },
              {
                key: "query",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    this.build();
                    var t = new me();
                    return (
                      this.isEmpty() ||
                        (this.getIntersectsOp().intersects(
                          this._root.getBounds(),
                          e
                        ) &&
                          this.queryInternal(e, this._root, t)),
                      t
                    );
                  }
                  if (2 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1];
                    if ((this.build(), this.isEmpty())) return null;
                    this.getIntersectsOp().intersects(
                      this._root.getBounds(),
                      i
                    ) && this.queryInternal(i, this._root, n);
                  }
                },
              },
              {
                key: "build",
                value: function () {
                  if (this._built) return null;
                  (this._root = this._itemBoundables.isEmpty()
                    ? this.createNode(0)
                    : this.createHigherLevels(this._itemBoundables, -1)),
                    (this._itemBoundables = null),
                    (this._built = !0);
                },
              },
              {
                key: "getRoot",
                value: function () {
                  return this.build(), this._root;
                },
              },
              {
                key: "remove",
                value: function () {
                  if (2 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1];
                    return (
                      this.build(),
                      !!this.getIntersectsOp().intersects(
                        this._root.getBounds(),
                        e
                      ) && this.remove(e, this._root, t)
                    );
                  }
                  if (3 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1],
                      s = arguments[2],
                      r = this.removeItem(n, s);
                    if (r) return !0;
                    for (
                      var a = null, o = n.getChildBoundables().iterator();
                      o.hasNext();

                    ) {
                      var l = o.next();
                      if (
                        this.getIntersectsOp().intersects(l.getBounds(), i) &&
                        l instanceof si &&
                        (r = this.remove(i, l, s))
                      ) {
                        a = l;
                        break;
                      }
                    }
                    return (
                      null !== a &&
                        a.getChildBoundables().isEmpty() &&
                        n.getChildBoundables().remove(a),
                      r
                    );
                  }
                },
              },
              {
                key: "createHigherLevels",
                value: function (e, t) {
                  O.isTrue(!e.isEmpty());
                  var i = this.createParentBoundables(e, t + 1);
                  return 1 === i.size()
                    ? i.get(0)
                    : this.createHigherLevels(i, t + 1);
                },
              },
              {
                key: "depth",
                value: function () {
                  if (0 === arguments.length)
                    return this.isEmpty()
                      ? 0
                      : (this.build(), this.depth(this._root));
                  if (1 === arguments.length) {
                    for (
                      var e = 0,
                        t = arguments[0].getChildBoundables().iterator();
                      t.hasNext();

                    ) {
                      var i = t.next();
                      if (i instanceof si) {
                        var n = this.depth(i);
                        n > e && (e = n);
                      }
                    }
                    return e + 1;
                  }
                },
              },
              {
                key: "createParentBoundables",
                value: function (e, t) {
                  O.isTrue(!e.isEmpty());
                  var i = new me();
                  i.add(this.createNode(t));
                  var n = new me(e);
                  ri.sort(n, this.getComparator());
                  for (var s = n.iterator(); s.hasNext(); ) {
                    var r = s.next();
                    this.lastNode(i).getChildBoundables().size() ===
                      this.getNodeCapacity() && i.add(this.createNode(t)),
                      this.lastNode(i).addChildBoundable(r);
                  }
                  return i;
                },
              },
              {
                key: "isEmpty",
                value: function () {
                  return this._built
                    ? this._root.isEmpty()
                    : this._itemBoundables.isEmpty();
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._root = null),
                    (this._built = !1),
                    (this._itemBoundables = new me()),
                    (this._nodeCapacity = null),
                    0 === arguments.length)
                  )
                    t.constructor_.call(this, t.DEFAULT_NODE_CAPACITY);
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    O.isTrue(e > 1, "Node capacity must be greater than 1"),
                      (this._nodeCapacity = e);
                  }
                },
              },
              {
                key: "compareDoubles",
                value: function (e, t) {
                  return e > t ? 1 : e < t ? -1 : 0;
                },
              },
            ]
          ),
          t
        );
      })();
    (hi.IntersectsOp = function () {}), (hi.DEFAULT_NODE_CAPACITY = 10);
    var ci = (function () {
        function t() {
          e(this, t);
        }
        return i(t, [{ key: "distance", value: function (e, t) {} }]), t;
      })(),
      ui = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "createParentBoundablesFromVerticalSlices",
                value: function (e, t) {
                  O.isTrue(e.length > 0);
                  for (var i = new me(), n = 0; n < e.length; n++)
                    i.addAll(
                      this.createParentBoundablesFromVerticalSlice(e[n], t)
                    );
                  return i;
                },
              },
              {
                key: "nearestNeighbourK",
                value: function () {
                  if (2 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1];
                    return this.nearestNeighbourK(e, F.POSITIVE_INFINITY, t);
                  }
                  if (3 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[2],
                      s = arguments[1],
                      r = new ii();
                    r.add(i);
                    for (var o = new ii(); !r.isEmpty() && s >= 0; ) {
                      var l = r.poll(),
                        h = l.getDistance();
                      if (h >= s) break;
                      l.isLeaves()
                        ? o.size() < n
                          ? o.add(l)
                          : (o.peek().getDistance() > h && (o.poll(), o.add(l)),
                            (s = o.peek().getDistance()))
                        : l.expandToQueue(r, s);
                    }
                    return a.getItems(o);
                  }
                },
              },
              {
                key: "createNode",
                value: function (e) {
                  return new di(e);
                },
              },
              {
                key: "size",
                value: function () {
                  return 0 === arguments.length
                    ? d(s(a.prototype), "size", this).call(this)
                    : d(s(a.prototype), "size", this).apply(this, arguments);
                },
              },
              {
                key: "insert",
                value: function () {
                  if (
                    !(
                      2 === arguments.length &&
                      arguments[1] instanceof Object &&
                      arguments[0] instanceof H
                    )
                  )
                    return d(s(a.prototype), "insert", this).apply(
                      this,
                      arguments
                    );
                  var e = arguments[0],
                    t = arguments[1];
                  if (e.isNull()) return null;
                  d(s(a.prototype), "insert", this).call(this, e, t);
                },
              },
              {
                key: "getIntersectsOp",
                value: function () {
                  return a.intersectsOp;
                },
              },
              {
                key: "verticalSlices",
                value: function (e, t) {
                  for (
                    var i = Math.trunc(Math.ceil(e.size() / t)),
                      n = new Array(t).fill(null),
                      s = e.iterator(),
                      r = 0;
                    r < t;
                    r++
                  ) {
                    n[r] = new me();
                    for (var a = 0; s.hasNext() && a < i; ) {
                      var o = s.next();
                      n[r].add(o), a++;
                    }
                  }
                  return n;
                },
              },
              {
                key: "query",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    return d(s(a.prototype), "query", this).call(this, e);
                  }
                  if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    d(s(a.prototype), "query", this).call(this, t, i);
                  }
                },
              },
              {
                key: "getComparator",
                value: function () {
                  return a.yComparator;
                },
              },
              {
                key: "createParentBoundablesFromVerticalSlice",
                value: function (e, t) {
                  return d(s(a.prototype), "createParentBoundables", this).call(
                    this,
                    e,
                    t
                  );
                },
              },
              {
                key: "remove",
                value: function () {
                  if (
                    2 === arguments.length &&
                    arguments[1] instanceof Object &&
                    arguments[0] instanceof H
                  ) {
                    var e = arguments[0],
                      t = arguments[1];
                    return d(s(a.prototype), "remove", this).call(this, e, t);
                  }
                  return d(s(a.prototype), "remove", this).apply(
                    this,
                    arguments
                  );
                },
              },
              {
                key: "depth",
                value: function () {
                  return 0 === arguments.length
                    ? d(s(a.prototype), "depth", this).call(this)
                    : d(s(a.prototype), "depth", this).apply(this, arguments);
                },
              },
              {
                key: "createParentBoundables",
                value: function (e, t) {
                  O.isTrue(!e.isEmpty());
                  var i = Math.trunc(
                      Math.ceil(e.size() / this.getNodeCapacity())
                    ),
                    n = new me(e);
                  ri.sort(n, a.xComparator);
                  var s = this.verticalSlices(
                    n,
                    Math.trunc(Math.ceil(Math.sqrt(i)))
                  );
                  return this.createParentBoundablesFromVerticalSlices(s, t);
                },
              },
              {
                key: "nearestNeighbour",
                value: function () {
                  if (1 === arguments.length) {
                    if (se(arguments[0], ci)) {
                      var e = arguments[0];
                      if (this.isEmpty()) return null;
                      var t = new oi(this.getRoot(), this.getRoot(), e);
                      return this.nearestNeighbour(t);
                    }
                    if (arguments[0] instanceof oi) {
                      var i = arguments[0],
                        n = F.POSITIVE_INFINITY,
                        s = null,
                        r = new ii();
                      for (r.add(i); !r.isEmpty() && n > 0; ) {
                        var a = r.poll(),
                          o = a.getDistance();
                        if (o >= n) break;
                        a.isLeaves()
                          ? ((n = o), (s = a))
                          : a.expandToQueue(r, n);
                      }
                      return null === s
                        ? null
                        : [
                            s.getBoundable(0).getItem(),
                            s.getBoundable(1).getItem(),
                          ];
                    }
                  } else {
                    if (2 === arguments.length) {
                      var l = arguments[0],
                        h = arguments[1];
                      if (this.isEmpty() || l.isEmpty()) return null;
                      var c = new oi(this.getRoot(), l.getRoot(), h);
                      return this.nearestNeighbour(c);
                    }
                    if (3 === arguments.length) {
                      var u = arguments[2],
                        d = new ti(arguments[0], arguments[1]),
                        p = new oi(this.getRoot(), d, u);
                      return this.nearestNeighbour(p)[0];
                    }
                    if (4 === arguments.length) {
                      var f = arguments[2],
                        m = arguments[3],
                        g = new ti(arguments[0], arguments[1]),
                        _ = new oi(this.getRoot(), g, f);
                      return this.nearestNeighbourK(_, m);
                    }
                  }
                },
              },
              {
                key: "isWithinDistance",
                value: function () {
                  if (2 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1],
                      i = F.POSITIVE_INFINITY,
                      n = new ii();
                    for (n.add(e); !n.isEmpty(); ) {
                      var s = n.poll(),
                        r = s.getDistance();
                      if (r > t) return !1;
                      if (s.maximumDistance() <= t) return !0;
                      if (s.isLeaves()) {
                        if ((i = r) <= t) return !0;
                      } else s.expandToQueue(n, i);
                    }
                    return !1;
                  }
                  if (3 === arguments.length) {
                    var a = arguments[0],
                      o = arguments[1],
                      l = arguments[2],
                      h = new oi(this.getRoot(), a.getRoot(), o);
                    return this.isWithinDistance(h, l);
                  }
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [ni, E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (0 === arguments.length)
                    a.constructor_.call(this, a.DEFAULT_NODE_CAPACITY);
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    hi.constructor_.call(this, e);
                  }
                },
              },
              {
                key: "centreX",
                value: function (e) {
                  return a.avg(e.getMinX(), e.getMaxX());
                },
              },
              {
                key: "avg",
                value: function (e, t) {
                  return (e + t) / 2;
                },
              },
              {
                key: "getItems",
                value: function (e) {
                  for (
                    var t = new Array(e.size()).fill(null), i = 0;
                    !e.isEmpty();

                  ) {
                    var n = e.poll();
                    (t[i] = n.getBoundable(0).getItem()), i++;
                  }
                  return t;
                },
              },
              {
                key: "centreY",
                value: function (e) {
                  return a.avg(e.getMinY(), e.getMaxY());
                },
              },
            ]
          ),
          a
        );
      })(hi),
      di = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return (
            e(this, r),
            (t = s.call(this)),
            r.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            r,
            [
              {
                key: "computeBounds",
                value: function () {
                  for (
                    var e = null, t = this.getChildBoundables().iterator();
                    t.hasNext();

                  ) {
                    var i = t.next();
                    null === e
                      ? (e = new H(i.getBounds()))
                      : e.expandToInclude(i.getBounds());
                  }
                  return e;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  var e = arguments[0];
                  si.constructor_.call(this, e);
                },
              },
            ]
          ),
          r
        );
      })(si);
    (ui.STRtreeNode = di),
      (ui.xComparator = new ((function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            {
              key: "interfaces_",
              get: function () {
                return [N];
              },
            },
            {
              key: "compare",
              value: function (e, t) {
                return hi.compareDoubles(
                  ui.centreX(e.getBounds()),
                  ui.centreX(t.getBounds())
                );
              },
            },
          ]),
          t
        );
      })())()),
      (ui.yComparator = new ((function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            {
              key: "interfaces_",
              get: function () {
                return [N];
              },
            },
            {
              key: "compare",
              value: function (e, t) {
                return hi.compareDoubles(
                  ui.centreY(e.getBounds()),
                  ui.centreY(t.getBounds())
                );
              },
            },
          ]),
          t
        );
      })())()),
      (ui.intersectsOp = new ((function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            {
              key: "interfaces_",
              get: function () {
                return [IntersectsOp];
              },
            },
            {
              key: "intersects",
              value: function (e, t) {
                return e.intersects(t);
              },
            },
          ]),
          t
        );
      })())()),
      (ui.DEFAULT_NODE_CAPACITY = 10);
    var pi = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "relativeSign",
              value: function (e, t) {
                return e < t ? -1 : e > t ? 1 : 0;
              },
            },
            {
              key: "compare",
              value: function (e, i, n) {
                if (i.equals2D(n)) return 0;
                var s = t.relativeSign(i.x, n.x),
                  r = t.relativeSign(i.y, n.y);
                switch (e) {
                  case 0:
                    return t.compareValue(s, r);
                  case 1:
                    return t.compareValue(r, s);
                  case 2:
                    return t.compareValue(r, -s);
                  case 3:
                    return t.compareValue(-s, r);
                  case 4:
                    return t.compareValue(-s, -r);
                  case 5:
                    return t.compareValue(-r, -s);
                  case 6:
                    return t.compareValue(-r, s);
                  case 7:
                    return t.compareValue(s, -r);
                }
                return O.shouldNeverReachHere("invalid octant value"), 0;
              },
            },
            {
              key: "compareValue",
              value: function (e, t) {
                return e < 0 ? -1 : e > 0 ? 1 : t < 0 ? -1 : t > 0 ? 1 : 0;
              },
            },
          ]),
          t
        );
      })(),
      fi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getCoordinate",
                value: function () {
                  return this.coord;
                },
              },
              {
                key: "print",
                value: function (e) {
                  e.print(this.coord), e.print(" seg # = " + this.segmentIndex);
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e;
                  return this.segmentIndex < t.segmentIndex
                    ? -1
                    : this.segmentIndex > t.segmentIndex
                    ? 1
                    : this.coord.equals2D(t.coord)
                    ? 0
                    : this._isInterior
                    ? t._isInterior
                      ? pi.compare(this._segmentOctant, this.coord, t.coord)
                      : 1
                    : -1;
                },
              },
              {
                key: "isEndPoint",
                value: function (e) {
                  return (
                    (0 === this.segmentIndex && !this._isInterior) ||
                    this.segmentIndex === e
                  );
                },
              },
              {
                key: "toString",
                value: function () {
                  return this.segmentIndex + ":" + this.coord.toString();
                },
              },
              {
                key: "isInterior",
                value: function () {
                  return this._isInterior;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._segString = null),
                    (this.coord = null),
                    (this.segmentIndex = null),
                    (this._segmentOctant = null),
                    (this._isInterior = null);
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2],
                    n = arguments[3];
                  (this._segString = e),
                    (this.coord = new V(t)),
                    (this.segmentIndex = i),
                    (this._segmentOctant = n),
                    (this._isInterior = !t.equals2D(e.getCoordinate(i)));
                },
              },
            ]
          ),
          t
        );
      })(),
      mi = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            { key: "hasNext", value: function () {} },
            { key: "next", value: function () {} },
            { key: "remove", value: function () {} },
          ]),
          t
        );
      })(),
      gi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getSplitCoordinates",
                value: function () {
                  var e = new qe();
                  this.addEndpoints();
                  for (var t = this.iterator(), i = t.next(); t.hasNext(); ) {
                    var n = t.next();
                    this.addEdgeCoordinates(i, n, e), (i = n);
                  }
                  return e.toCoordinateArray();
                },
              },
              {
                key: "addCollapsedNodes",
                value: function () {
                  var e = new me();
                  this.findCollapsesFromInsertedNodes(e),
                    this.findCollapsesFromExistingVertices(e);
                  for (var t = e.iterator(); t.hasNext(); ) {
                    var i = t.next().intValue();
                    this.add(this._edge.getCoordinate(i), i);
                  }
                },
              },
              {
                key: "createSplitEdgePts",
                value: function (e, t) {
                  var i = t.segmentIndex - e.segmentIndex + 2;
                  if (2 === i) return [new V(e.coord), new V(t.coord)];
                  var n = this._edge.getCoordinate(t.segmentIndex),
                    s = t.isInterior() || !t.coord.equals2D(n);
                  s || i--;
                  var r = new Array(i).fill(null),
                    a = 0;
                  r[a++] = new V(e.coord);
                  for (var o = e.segmentIndex + 1; o <= t.segmentIndex; o++)
                    r[a++] = this._edge.getCoordinate(o);
                  return s && (r[a] = new V(t.coord)), r;
                },
              },
              {
                key: "print",
                value: function (e) {
                  e.println("Intersections:");
                  for (var t = this.iterator(); t.hasNext(); )
                    t.next().print(e);
                },
              },
              {
                key: "findCollapsesFromExistingVertices",
                value: function (e) {
                  for (var t = 0; t < this._edge.size() - 2; t++) {
                    var i = this._edge.getCoordinate(t);
                    this._edge.getCoordinate(t + 1);
                    var n = this._edge.getCoordinate(t + 2);
                    i.equals2D(n) && e.add(ae.valueOf(t + 1));
                  }
                },
              },
              {
                key: "addEdgeCoordinates",
                value: function (e, t, i) {
                  var n = this.createSplitEdgePts(e, t);
                  i.add(n, !1);
                },
              },
              {
                key: "iterator",
                value: function () {
                  return this._nodeMap.values().iterator();
                },
              },
              {
                key: "addSplitEdges",
                value: function (e) {
                  this.addEndpoints(), this.addCollapsedNodes();
                  for (var t = this.iterator(), i = t.next(); t.hasNext(); ) {
                    var n = t.next(),
                      s = this.createSplitEdge(i, n);
                    e.add(s), (i = n);
                  }
                },
              },
              {
                key: "findCollapseIndex",
                value: function (e, t, i) {
                  if (!e.coord.equals2D(t.coord)) return !1;
                  var n = t.segmentIndex - e.segmentIndex;
                  return (
                    t.isInterior() || n--,
                    1 === n && ((i[0] = e.segmentIndex + 1), !0)
                  );
                },
              },
              {
                key: "findCollapsesFromInsertedNodes",
                value: function (e) {
                  for (
                    var t = new Array(1).fill(null),
                      i = this.iterator(),
                      n = i.next();
                    i.hasNext();

                  ) {
                    var s = i.next();
                    this.findCollapseIndex(n, s, t) && e.add(ae.valueOf(t[0])),
                      (n = s);
                  }
                },
              },
              {
                key: "getEdge",
                value: function () {
                  return this._edge;
                },
              },
              {
                key: "addEndpoints",
                value: function () {
                  var e = this._edge.size() - 1;
                  this.add(this._edge.getCoordinate(0), 0),
                    this.add(this._edge.getCoordinate(e), e);
                },
              },
              {
                key: "createSplitEdge",
                value: function (e, t) {
                  var i = this.createSplitEdgePts(e, t);
                  return new yi(i, this._edge.getData());
                },
              },
              {
                key: "add",
                value: function (e, t) {
                  var i = new fi(
                      this._edge,
                      e,
                      t,
                      this._edge.getSegmentOctant(t)
                    ),
                    n = this._nodeMap.get(i);
                  return null !== n
                    ? (O.isTrue(
                        n.coord.equals2D(e),
                        "Found equal nodes with different coordinates"
                      ),
                      n)
                    : (this._nodeMap.put(i, i), i);
                },
              },
              {
                key: "checkSplitEdgesCorrectness",
                value: function (e) {
                  var t = this._edge.getCoordinates(),
                    i = e.get(0).getCoordinate(0);
                  if (!i.equals2D(t[0]))
                    throw new B("bad split edge start point at " + i);
                  var n = e.get(e.size() - 1).getCoordinates(),
                    s = n[n.length - 1];
                  if (!s.equals2D(t[t.length - 1]))
                    throw new B("bad split edge end point at " + s);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._nodeMap = new Wt()), (this._edge = null);
                  var e = arguments[0];
                  this._edge = e;
                },
              },
            ]
          ),
          t
        );
      })(),
      _i = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "octant",
              value: function () {
                if (
                  "number" == typeof arguments[0] &&
                  "number" == typeof arguments[1]
                ) {
                  var e = arguments[0],
                    i = arguments[1];
                  if (0 === e && 0 === i)
                    throw new A(
                      "Cannot compute the octant for point ( " +
                        e +
                        ", " +
                        i +
                        " )"
                    );
                  var n = Math.abs(e),
                    s = Math.abs(i);
                  return e >= 0
                    ? i >= 0
                      ? n >= s
                        ? 0
                        : 1
                      : n >= s
                      ? 7
                      : 6
                    : i >= 0
                    ? n >= s
                      ? 3
                      : 2
                    : n >= s
                    ? 4
                    : 5;
                }
                if (arguments[0] instanceof V && arguments[1] instanceof V) {
                  var r = arguments[0],
                    a = arguments[1],
                    o = a.x - r.x,
                    l = a.y - r.y;
                  if (0 === o && 0 === l)
                    throw new A(
                      "Cannot compute the octant for two identical points " + r
                    );
                  return t.octant(o, l);
                }
              },
            },
          ]),
          t
        );
      })(),
      vi = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            { key: "getCoordinates", value: function () {} },
            { key: "size", value: function () {} },
            { key: "getCoordinate", value: function (e) {} },
            { key: "isClosed", value: function () {} },
            { key: "setData", value: function (e) {} },
            { key: "getData", value: function () {} },
          ]),
          t
        );
      })(),
      Ai = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            { key: "addIntersection", value: function (e, t) {} },
            {
              key: "interfaces_",
              get: function () {
                return [vi];
              },
            },
          ]),
          t
        );
      })(),
      yi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getCoordinates",
                value: function () {
                  return this._pts;
                },
              },
              {
                key: "size",
                value: function () {
                  return this._pts.length;
                },
              },
              {
                key: "getCoordinate",
                value: function (e) {
                  return this._pts[e];
                },
              },
              {
                key: "isClosed",
                value: function () {
                  return this._pts[0].equals(this._pts[this._pts.length - 1]);
                },
              },
              {
                key: "getSegmentOctant",
                value: function (e) {
                  return e === this._pts.length - 1
                    ? -1
                    : this.safeOctant(
                        this.getCoordinate(e),
                        this.getCoordinate(e + 1)
                      );
                },
              },
              {
                key: "setData",
                value: function (e) {
                  this._data = e;
                },
              },
              {
                key: "safeOctant",
                value: function (e, t) {
                  return e.equals2D(t) ? 0 : _i.octant(e, t);
                },
              },
              {
                key: "getData",
                value: function () {
                  return this._data;
                },
              },
              {
                key: "addIntersection",
                value: function () {
                  if (2 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1];
                    this.addIntersectionNode(e, t);
                  } else if (4 === arguments.length) {
                    var i = arguments[1],
                      n = arguments[3],
                      s = new V(arguments[0].getIntersection(n));
                    this.addIntersection(s, i);
                  }
                },
              },
              {
                key: "toString",
                value: function () {
                  return Tt.toLineString(new Je(this._pts));
                },
              },
              {
                key: "getNodeList",
                value: function () {
                  return this._nodeList;
                },
              },
              {
                key: "addIntersectionNode",
                value: function (e, t) {
                  var i = t,
                    n = i + 1;
                  if (n < this._pts.length) {
                    var s = this._pts[n];
                    e.equals2D(s) && (i = n);
                  }
                  return this._nodeList.add(e, i);
                },
              },
              {
                key: "addIntersections",
                value: function (e, t, i) {
                  for (var n = 0; n < e.getIntersectionNum(); n++)
                    this.addIntersection(e, t, i, n);
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Ai];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._nodeList = new gi(this)),
                    (this._pts = null),
                    (this._data = null);
                  var e = arguments[0],
                    t = arguments[1];
                  (this._pts = e), (this._data = t);
                },
              },
              {
                key: "getNodedSubstrings",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0],
                      i = new me();
                    return t.getNodedSubstrings(e, i), i;
                  }
                  if (2 === arguments.length)
                    for (
                      var n = arguments[1], s = arguments[0].iterator();
                      s.hasNext();

                    )
                      s.next().getNodeList().addSplitEdges(n);
                },
              },
            ]
          ),
          t
        );
      })(),
      xi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "minX",
                value: function () {
                  return Math.min(this.p0.x, this.p1.x);
                },
              },
              {
                key: "orientationIndex",
                value: function () {
                  if (arguments[0] instanceof t) {
                    var e = arguments[0],
                      i = ue.index(this.p0, this.p1, e.p0),
                      n = ue.index(this.p0, this.p1, e.p1);
                    return (i >= 0 && n >= 0) || (i <= 0 && n <= 0)
                      ? Math.max(i, n)
                      : 0;
                  }
                  if (arguments[0] instanceof V) {
                    var s = arguments[0];
                    return ue.index(this.p0, this.p1, s);
                  }
                },
              },
              {
                key: "toGeometry",
                value: function (e) {
                  return e.createLineString([this.p0, this.p1]);
                },
              },
              {
                key: "isVertical",
                value: function () {
                  return this.p0.x === this.p1.x;
                },
              },
              {
                key: "equals",
                value: function (e) {
                  if (!(e instanceof t)) return !1;
                  var i = e;
                  return this.p0.equals(i.p0) && this.p1.equals(i.p1);
                },
              },
              {
                key: "intersection",
                value: function (e) {
                  var t = new Rt();
                  return (
                    t.computeIntersection(this.p0, this.p1, e.p0, e.p1),
                    t.hasIntersection() ? t.getIntersection(0) : null
                  );
                },
              },
              {
                key: "project",
                value: function () {
                  if (arguments[0] instanceof V) {
                    var e = arguments[0];
                    if (e.equals(this.p0) || e.equals(this.p1)) return new V(e);
                    var i = this.projectionFactor(e),
                      n = new V();
                    return (
                      (n.x = this.p0.x + i * (this.p1.x - this.p0.x)),
                      (n.y = this.p0.y + i * (this.p1.y - this.p0.y)),
                      n
                    );
                  }
                  if (arguments[0] instanceof t) {
                    var s = arguments[0],
                      r = this.projectionFactor(s.p0),
                      a = this.projectionFactor(s.p1);
                    if (r >= 1 && a >= 1) return null;
                    if (r <= 0 && a <= 0) return null;
                    var o = this.project(s.p0);
                    r < 0 && (o = this.p0), r > 1 && (o = this.p1);
                    var l = this.project(s.p1);
                    return (
                      a < 0 && (l = this.p0),
                      a > 1 && (l = this.p1),
                      new t(o, l)
                    );
                  }
                },
              },
              {
                key: "normalize",
                value: function () {
                  this.p1.compareTo(this.p0) < 0 && this.reverse();
                },
              },
              {
                key: "angle",
                value: function () {
                  return Math.atan2(
                    this.p1.y - this.p0.y,
                    this.p1.x - this.p0.x
                  );
                },
              },
              {
                key: "getCoordinate",
                value: function (e) {
                  return 0 === e ? this.p0 : this.p1;
                },
              },
              {
                key: "distancePerpendicular",
                value: function (e) {
                  return xe.pointToLinePerpendicular(e, this.p0, this.p1);
                },
              },
              {
                key: "minY",
                value: function () {
                  return Math.min(this.p0.y, this.p1.y);
                },
              },
              {
                key: "midPoint",
                value: function () {
                  return t.midPoint(this.p0, this.p1);
                },
              },
              {
                key: "projectionFactor",
                value: function (e) {
                  if (e.equals(this.p0)) return 0;
                  if (e.equals(this.p1)) return 1;
                  var t = this.p1.x - this.p0.x,
                    i = this.p1.y - this.p0.y,
                    n = t * t + i * i;
                  return n <= 0
                    ? F.NaN
                    : ((e.x - this.p0.x) * t + (e.y - this.p0.y) * i) / n;
                },
              },
              {
                key: "closestPoints",
                value: function (e) {
                  var t = this.intersection(e);
                  if (null !== t) return [t, t];
                  var i = new Array(2).fill(null),
                    n = F.MAX_VALUE,
                    s = null,
                    r = this.closestPoint(e.p0);
                  (n = r.distance(e.p0)), (i[0] = r), (i[1] = e.p0);
                  var a = this.closestPoint(e.p1);
                  (s = a.distance(e.p1)) < n &&
                    ((n = s), (i[0] = a), (i[1] = e.p1));
                  var o = e.closestPoint(this.p0);
                  (s = o.distance(this.p0)) < n &&
                    ((n = s), (i[0] = this.p0), (i[1] = o));
                  var l = e.closestPoint(this.p1);
                  return (
                    (s = l.distance(this.p1)) < n &&
                      ((n = s), (i[0] = this.p1), (i[1] = l)),
                    i
                  );
                },
              },
              {
                key: "closestPoint",
                value: function (e) {
                  var t = this.projectionFactor(e);
                  return t > 0 && t < 1
                    ? this.project(e)
                    : this.p0.distance(e) < this.p1.distance(e)
                    ? this.p0
                    : this.p1;
                },
              },
              {
                key: "maxX",
                value: function () {
                  return Math.max(this.p0.x, this.p1.x);
                },
              },
              {
                key: "getLength",
                value: function () {
                  return this.p0.distance(this.p1);
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e,
                    i = this.p0.compareTo(t.p0);
                  return 0 !== i ? i : this.p1.compareTo(t.p1);
                },
              },
              {
                key: "reverse",
                value: function () {
                  var e = this.p0;
                  (this.p0 = this.p1), (this.p1 = e);
                },
              },
              {
                key: "equalsTopo",
                value: function (e) {
                  return (
                    (this.p0.equals(e.p0) && this.p1.equals(e.p1)) ||
                    (this.p0.equals(e.p1) && this.p1.equals(e.p0))
                  );
                },
              },
              {
                key: "lineIntersection",
                value: function (e) {
                  return ve.intersection(this.p0, this.p1, e.p0, e.p1);
                },
              },
              {
                key: "maxY",
                value: function () {
                  return Math.max(this.p0.y, this.p1.y);
                },
              },
              {
                key: "pointAlongOffset",
                value: function (e, t) {
                  var i = this.p0.x + e * (this.p1.x - this.p0.x),
                    n = this.p0.y + e * (this.p1.y - this.p0.y),
                    s = this.p1.x - this.p0.x,
                    r = this.p1.y - this.p0.y,
                    a = Math.sqrt(s * s + r * r),
                    o = 0,
                    l = 0;
                  if (0 !== t) {
                    if (a <= 0)
                      throw new IllegalStateException(
                        "Cannot compute offset from zero-length line segment"
                      );
                    (o = (t * s) / a), (l = (t * r) / a);
                  }
                  return new V(i - l, n + o);
                },
              },
              {
                key: "setCoordinates",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    this.setCoordinates(e.p0, e.p1);
                  } else if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    (this.p0.x = t.x),
                      (this.p0.y = t.y),
                      (this.p1.x = i.x),
                      (this.p1.y = i.y);
                  }
                },
              },
              {
                key: "segmentFraction",
                value: function (e) {
                  var t = this.projectionFactor(e);
                  return t < 0 ? (t = 0) : (t > 1 || F.isNaN(t)) && (t = 1), t;
                },
              },
              {
                key: "toString",
                value: function () {
                  return (
                    "LINESTRING( " +
                    this.p0.x +
                    " " +
                    this.p0.y +
                    ", " +
                    this.p1.x +
                    " " +
                    this.p1.y +
                    ")"
                  );
                },
              },
              {
                key: "isHorizontal",
                value: function () {
                  return this.p0.y === this.p1.y;
                },
              },
              {
                key: "reflect",
                value: function (e) {
                  var t = this.p1.getY() - this.p0.getY(),
                    i = this.p0.getX() - this.p1.getX(),
                    n =
                      this.p0.getY() * (this.p1.getX() - this.p0.getX()) -
                      this.p0.getX() * (this.p1.getY() - this.p0.getY()),
                    s = t * t + i * i,
                    r = t * t - i * i,
                    a = e.getX(),
                    o = e.getY();
                  return new V(
                    (-r * a - 2 * t * i * o - 2 * t * n) / s,
                    (r * o - 2 * t * i * a - 2 * i * n) / s
                  );
                },
              },
              {
                key: "distance",
                value: function () {
                  if (arguments[0] instanceof t) {
                    var e = arguments[0];
                    return xe.segmentToSegment(this.p0, this.p1, e.p0, e.p1);
                  }
                  if (arguments[0] instanceof V) {
                    var i = arguments[0];
                    return xe.pointToSegment(i, this.p0, this.p1);
                  }
                },
              },
              {
                key: "pointAlong",
                value: function (e) {
                  var t = new V();
                  return (
                    (t.x = this.p0.x + e * (this.p1.x - this.p0.x)),
                    (t.y = this.p0.y + e * (this.p1.y - this.p0.y)),
                    t
                  );
                },
              },
              {
                key: "hashCode",
                value: function () {
                  var e = F.doubleToLongBits(this.p0.x);
                  e ^= 31 * F.doubleToLongBits(this.p0.y);
                  var t = Math.trunc(e) ^ Math.trunc(e >> 32),
                    i = F.doubleToLongBits(this.p1.x);
                  return (
                    (i ^= 31 * F.doubleToLongBits(this.p1.y)),
                    t ^ Math.trunc(i) ^ Math.trunc(i >> 32)
                  );
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x, E];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this.p0 = null), (this.p1 = null), 0 === arguments.length)
                  )
                    t.constructor_.call(this, new V(), new V());
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    t.constructor_.call(this, e.p0, e.p1);
                  } else if (2 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1];
                    (this.p0 = i), (this.p1 = n);
                  } else if (4 === arguments.length) {
                    var s = arguments[0],
                      r = arguments[1],
                      a = arguments[2],
                      o = arguments[3];
                    t.constructor_.call(this, new V(s, r), new V(a, o));
                  }
                },
              },
              {
                key: "midPoint",
                value: function (e, t) {
                  return new V((e.x + t.x) / 2, (e.y + t.y) / 2);
                },
              },
            ]
          ),
          t
        );
      })(),
      bi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "overlap",
                value: function () {
                  if (2 === arguments.length);
                  else if (4 === arguments.length) {
                    var e = arguments[1],
                      t = arguments[2],
                      i = arguments[3];
                    arguments[0].getLineSegment(e, this._overlapSeg1),
                      t.getLineSegment(i, this._overlapSeg2),
                      this.overlap(this._overlapSeg1, this._overlapSeg2);
                  }
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._overlapSeg1 = new xi()),
                    (this._overlapSeg2 = new xi());
                },
              },
            ]
          ),
          t
        );
      })(),
      Ei = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getLineSegment",
                value: function (e, t) {
                  (t.p0 = this._pts[e]), (t.p1 = this._pts[e + 1]);
                },
              },
              {
                key: "computeSelect",
                value: function (e, t, i, n) {
                  var s = this._pts[t],
                    r = this._pts[i];
                  if (i - t == 1) return n.select(this, t), null;
                  if (!e.intersects(s, r)) return null;
                  var a = Math.trunc((t + i) / 2);
                  t < a && this.computeSelect(e, t, a, n),
                    a < i && this.computeSelect(e, a, i, n);
                },
              },
              {
                key: "getCoordinates",
                value: function () {
                  for (
                    var e = new Array(this._end - this._start + 1).fill(null),
                      t = 0,
                      i = this._start;
                    i <= this._end;
                    i++
                  )
                    e[t++] = this._pts[i];
                  return e;
                },
              },
              {
                key: "computeOverlaps",
                value: function () {
                  if (2 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1];
                    this.computeOverlaps(
                      this._start,
                      this._end,
                      e,
                      e._start,
                      e._end,
                      t
                    );
                  } else if (6 === arguments.length) {
                    var i = arguments[0],
                      n = arguments[1],
                      s = arguments[2],
                      r = arguments[3],
                      a = arguments[4],
                      o = arguments[5];
                    if (n - i == 1 && a - r == 1)
                      return o.overlap(this, i, s, r), null;
                    if (!this.overlaps(i, n, s, r, a)) return null;
                    var l = Math.trunc((i + n) / 2),
                      h = Math.trunc((r + a) / 2);
                    i < l &&
                      (r < h && this.computeOverlaps(i, l, s, r, h, o),
                      h < a && this.computeOverlaps(i, l, s, h, a, o)),
                      l < n &&
                        (r < h && this.computeOverlaps(l, n, s, r, h, o),
                        h < a && this.computeOverlaps(l, n, s, h, a, o));
                  }
                },
              },
              {
                key: "setId",
                value: function (e) {
                  this._id = e;
                },
              },
              {
                key: "select",
                value: function (e, t) {
                  this.computeSelect(e, this._start, this._end, t);
                },
              },
              {
                key: "getEnvelope",
                value: function () {
                  if (null === this._env) {
                    var e = this._pts[this._start],
                      t = this._pts[this._end];
                    this._env = new H(e, t);
                  }
                  return this._env;
                },
              },
              {
                key: "overlaps",
                value: function (e, t, i, n, s) {
                  return H.intersects(
                    this._pts[e],
                    this._pts[t],
                    i._pts[n],
                    i._pts[s]
                  );
                },
              },
              {
                key: "getEndIndex",
                value: function () {
                  return this._end;
                },
              },
              {
                key: "getStartIndex",
                value: function () {
                  return this._start;
                },
              },
              {
                key: "getContext",
                value: function () {
                  return this._context;
                },
              },
              {
                key: "getId",
                value: function () {
                  return this._id;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._pts = null),
                    (this._start = null),
                    (this._end = null),
                    (this._env = null),
                    (this._context = null),
                    (this._id = null);
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2],
                    n = arguments[3];
                  (this._pts = e),
                    (this._start = t),
                    (this._end = i),
                    (this._context = n);
                },
              },
            ]
          ),
          t
        );
      })(),
      Si = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, null, [
            {
              key: "findChainEnd",
              value: function (e, t) {
                for (var i = t; i < e.length - 1 && e[i].equals2D(e[i + 1]); )
                  i++;
                if (i >= e.length - 1) return e.length - 1;
                for (
                  var n = Xt.quadrant(e[i], e[i + 1]), s = t + 1;
                  s < e.length &&
                  (e[s - 1].equals2D(e[s]) ||
                    Xt.quadrant(e[s - 1], e[s]) === n);

                )
                  s++;
                return s - 1;
              },
            },
            {
              key: "getChains",
              value: function () {
                if (1 === arguments.length) {
                  var e = arguments[0];
                  return t.getChains(e, null);
                }
                if (2 === arguments.length) {
                  var i = arguments[0],
                    n = arguments[1],
                    s = new me(),
                    r = 0;
                  do {
                    var a = t.findChainEnd(i, r),
                      o = new Ei(i, r, a, n);
                    s.add(o), (r = a);
                  } while (r < i.length - 1);
                  return s;
                }
              },
            },
          ]),
          t
        );
      })(),
      Ci = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            { key: "computeNodes", value: function (e) {} },
            { key: "getNodedSubstrings", value: function () {} },
          ]),
          t
        );
      })(),
      Mi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "setSegmentIntersector",
                value: function (e) {
                  this._segInt = e;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Ci];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (((this._segInt = null), 0 === arguments.length));
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    this.setSegmentIntersector(e);
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      wi = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return (
            e(this, r),
            (t = s.call(this)),
            r.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            r,
            [
              {
                key: "getMonotoneChains",
                value: function () {
                  return this._monoChains;
                },
              },
              {
                key: "getNodedSubstrings",
                value: function () {
                  return yi.getNodedSubstrings(this._nodedSegStrings);
                },
              },
              {
                key: "getIndex",
                value: function () {
                  return this._index;
                },
              },
              {
                key: "add",
                value: function (e) {
                  for (
                    var t = Si.getChains(e.getCoordinates(), e).iterator();
                    t.hasNext();

                  ) {
                    var i = t.next();
                    i.setId(this._idCounter++),
                      this._index.insert(i.getEnvelope(), i),
                      this._monoChains.add(i);
                  }
                },
              },
              {
                key: "computeNodes",
                value: function (e) {
                  this._nodedSegStrings = e;
                  for (var t = e.iterator(); t.hasNext(); ) this.add(t.next());
                  this.intersectChains();
                },
              },
              {
                key: "intersectChains",
                value: function () {
                  for (
                    var e = new Ti(this._segInt),
                      t = this._monoChains.iterator();
                    t.hasNext();

                  )
                    for (
                      var i = t.next(),
                        n = this._index.query(i.getEnvelope()).iterator();
                      n.hasNext();

                    ) {
                      var s = n.next();
                      if (
                        (s.getId() > i.getId() &&
                          (i.computeOverlaps(s, e), this._nOverlaps++),
                        this._segInt.isDone())
                      )
                        return null;
                    }
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._monoChains = new me()),
                    (this._index = new ui()),
                    (this._idCounter = 0),
                    (this._nodedSegStrings = null),
                    (this._nOverlaps = 0),
                    0 === arguments.length)
                  );
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    Mi.constructor_.call(this, e);
                  }
                },
              },
            ]
          ),
          r
        );
      })(Mi),
      Ti = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "overlap",
                value: function () {
                  if (4 !== arguments.length)
                    return d(s(a.prototype), "overlap", this).apply(
                      this,
                      arguments
                    );
                  var e = arguments[1],
                    t = arguments[2],
                    i = arguments[3],
                    n = arguments[0].getContext(),
                    r = t.getContext();
                  this._si.processIntersections(n, e, r, i);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  this._si = null;
                  var e = arguments[0];
                  this._si = e;
                },
              },
            ]
          ),
          a
        );
      })(bi);
    wi.SegmentOverlapAction = Ti;
    var Ii = (function () {
      function t() {
        e(this, t), t.constructor_.apply(this, arguments);
      }
      return (
        i(
          t,
          [
            {
              key: "isDeletable",
              value: function (e, t, i, n) {
                var s = this._inputLine[e],
                  r = this._inputLine[t],
                  a = this._inputLine[i];
                return (
                  !!this.isConcave(s, r, a) &&
                  !!this.isShallow(s, r, a, n) &&
                  this.isShallowSampled(s, r, e, i, n)
                );
              },
            },
            {
              key: "deleteShallowConcavities",
              value: function () {
                for (
                  var e = 1,
                    i = this.findNextNonDeletedIndex(e),
                    n = this.findNextNonDeletedIndex(i),
                    s = !1;
                  n < this._inputLine.length;

                ) {
                  var r = !1;
                  this.isDeletable(e, i, n, this._distanceTol) &&
                    ((this._isDeleted[i] = t.DELETE), (r = !0), (s = !0)),
                    (e = r ? n : i),
                    (i = this.findNextNonDeletedIndex(e)),
                    (n = this.findNextNonDeletedIndex(i));
                }
                return s;
              },
            },
            {
              key: "isShallowConcavity",
              value: function (e, t, i, n) {
                return (
                  ue.index(e, t, i) === this._angleOrientation &&
                  xe.pointToSegment(t, e, i) < n
                );
              },
            },
            {
              key: "isShallowSampled",
              value: function (e, i, n, s, r) {
                var a = Math.trunc((s - n) / t.NUM_PTS_TO_CHECK);
                a <= 0 && (a = 1);
                for (var o = n; o < s; o += a)
                  if (!this.isShallow(e, i, this._inputLine[o], r)) return !1;
                return !0;
              },
            },
            {
              key: "isConcave",
              value: function (e, t, i) {
                return ue.index(e, t, i) === this._angleOrientation;
              },
            },
            {
              key: "simplify",
              value: function (e) {
                (this._distanceTol = Math.abs(e)),
                  e < 0 && (this._angleOrientation = ue.CLOCKWISE),
                  (this._isDeleted = new Array(this._inputLine.length).fill(
                    null
                  ));
                var t = !1;
                do {
                  t = this.deleteShallowConcavities();
                } while (t);
                return this.collapseLine();
              },
            },
            {
              key: "findNextNonDeletedIndex",
              value: function (e) {
                for (
                  var i = e + 1;
                  i < this._inputLine.length && this._isDeleted[i] === t.DELETE;

                )
                  i++;
                return i;
              },
            },
            {
              key: "isShallow",
              value: function (e, t, i, n) {
                return xe.pointToSegment(t, e, i) < n;
              },
            },
            {
              key: "collapseLine",
              value: function () {
                for (var e = new qe(), i = 0; i < this._inputLine.length; i++)
                  this._isDeleted[i] !== t.DELETE && e.add(this._inputLine[i]);
                return e.toCoordinateArray();
              },
            },
          ],
          [
            {
              key: "constructor_",
              value: function () {
                (this._inputLine = null),
                  (this._distanceTol = null),
                  (this._isDeleted = null),
                  (this._angleOrientation = ue.COUNTERCLOCKWISE);
                var e = arguments[0];
                this._inputLine = e;
              },
            },
            {
              key: "simplify",
              value: function (e, i) {
                return new t(e).simplify(i);
              },
            },
          ]
        ),
        t
      );
    })();
    (Ii.INIT = 0), (Ii.DELETE = 1), (Ii.KEEP = 1), (Ii.NUM_PTS_TO_CHECK = 10);
    var Ri = (function () {
      function t() {
        e(this, t), t.constructor_.apply(this, arguments);
      }
      return (
        i(
          t,
          [
            {
              key: "getCoordinates",
              value: function () {
                return this._ptList.toArray(t.COORDINATE_ARRAY_TYPE);
              },
            },
            {
              key: "setPrecisionModel",
              value: function (e) {
                this._precisionModel = e;
              },
            },
            {
              key: "addPt",
              value: function (e) {
                var t = new V(e);
                if ((this._precisionModel.makePrecise(t), this.isRedundant(t)))
                  return null;
                this._ptList.add(t);
              },
            },
            { key: "reverse", value: function () {} },
            {
              key: "addPts",
              value: function (e, t) {
                if (t) for (var i = 0; i < e.length; i++) this.addPt(e[i]);
                else for (var n = e.length - 1; n >= 0; n--) this.addPt(e[n]);
              },
            },
            {
              key: "isRedundant",
              value: function (e) {
                if (this._ptList.size() < 1) return !1;
                var t = this._ptList.get(this._ptList.size() - 1);
                return e.distance(t) < this._minimimVertexDistance;
              },
            },
            {
              key: "toString",
              value: function () {
                return new at()
                  .createLineString(this.getCoordinates())
                  .toString();
              },
            },
            {
              key: "closeRing",
              value: function () {
                if (this._ptList.size() < 1) return null;
                var e = new V(this._ptList.get(0)),
                  t = this._ptList.get(this._ptList.size() - 1);
                if (e.equals(t)) return null;
                this._ptList.add(e);
              },
            },
            {
              key: "setMinimumVertexDistance",
              value: function (e) {
                this._minimimVertexDistance = e;
              },
            },
          ],
          [
            {
              key: "constructor_",
              value: function () {
                (this._ptList = null),
                  (this._precisionModel = null),
                  (this._minimimVertexDistance = 0),
                  (this._ptList = new me());
              },
            },
          ]
        ),
        t
      );
    })();
    Ri.COORDINATE_ARRAY_TYPE = new Array(0).fill(null);
    var Pi = (function () {
      function t() {
        e(this, t);
      }
      return (
        i(t, null, [
          {
            key: "toDegrees",
            value: function (e) {
              return (180 * e) / Math.PI;
            },
          },
          {
            key: "normalize",
            value: function (e) {
              for (; e > Math.PI; ) e -= t.PI_TIMES_2;
              for (; e <= -Math.PI; ) e += t.PI_TIMES_2;
              return e;
            },
          },
          {
            key: "angle",
            value: function () {
              if (1 === arguments.length) {
                var e = arguments[0];
                return Math.atan2(e.y, e.x);
              }
              if (2 === arguments.length) {
                var t = arguments[0],
                  i = arguments[1],
                  n = i.x - t.x,
                  s = i.y - t.y;
                return Math.atan2(s, n);
              }
            },
          },
          {
            key: "isAcute",
            value: function (e, t, i) {
              var n = e.x - t.x,
                s = e.y - t.y;
              return n * (i.x - t.x) + s * (i.y - t.y) > 0;
            },
          },
          {
            key: "isObtuse",
            value: function (e, t, i) {
              var n = e.x - t.x,
                s = e.y - t.y;
              return n * (i.x - t.x) + s * (i.y - t.y) < 0;
            },
          },
          {
            key: "interiorAngle",
            value: function (e, i, n) {
              var s = t.angle(i, e),
                r = t.angle(i, n);
              return Math.abs(r - s);
            },
          },
          {
            key: "normalizePositive",
            value: function (e) {
              if (e < 0) {
                for (; e < 0; ) e += t.PI_TIMES_2;
                e >= t.PI_TIMES_2 && (e = 0);
              } else {
                for (; e >= t.PI_TIMES_2; ) e -= t.PI_TIMES_2;
                e < 0 && (e = 0);
              }
              return e;
            },
          },
          {
            key: "angleBetween",
            value: function (e, i, n) {
              var s = t.angle(i, e),
                r = t.angle(i, n);
              return t.diff(s, r);
            },
          },
          {
            key: "diff",
            value: function (e, t) {
              var i = null;
              return (
                (i = e < t ? t - e : e - t) > Math.PI && (i = 2 * Math.PI - i),
                i
              );
            },
          },
          {
            key: "toRadians",
            value: function (e) {
              return (e * Math.PI) / 180;
            },
          },
          {
            key: "getTurn",
            value: function (e, i) {
              var n = Math.sin(i - e);
              return n > 0 ? t.COUNTERCLOCKWISE : n < 0 ? t.CLOCKWISE : t.NONE;
            },
          },
          {
            key: "angleBetweenOriented",
            value: function (e, i, n) {
              var s = t.angle(i, e),
                r = t.angle(i, n) - s;
              return r <= -Math.PI
                ? r + t.PI_TIMES_2
                : r > Math.PI
                ? r - t.PI_TIMES_2
                : r;
            },
          },
        ]),
        t
      );
    })();
    (Pi.PI_TIMES_2 = 2 * Math.PI),
      (Pi.PI_OVER_2 = Math.PI / 2),
      (Pi.PI_OVER_4 = Math.PI / 4),
      (Pi.COUNTERCLOCKWISE = ue.COUNTERCLOCKWISE),
      (Pi.CLOCKWISE = ue.CLOCKWISE),
      (Pi.NONE = ue.COLLINEAR);
    var Di = (function () {
      function t() {
        e(this, t), t.constructor_.apply(this, arguments);
      }
      return (
        i(
          t,
          [
            {
              key: "addNextSegment",
              value: function (e, t) {
                if (
                  ((this._s0 = this._s1),
                  (this._s1 = this._s2),
                  (this._s2 = e),
                  this._seg0.setCoordinates(this._s0, this._s1),
                  this.computeOffsetSegment(
                    this._seg0,
                    this._side,
                    this._distance,
                    this._offset0
                  ),
                  this._seg1.setCoordinates(this._s1, this._s2),
                  this.computeOffsetSegment(
                    this._seg1,
                    this._side,
                    this._distance,
                    this._offset1
                  ),
                  this._s1.equals(this._s2))
                )
                  return null;
                var i = ue.index(this._s0, this._s1, this._s2),
                  n =
                    (i === ue.CLOCKWISE && this._side === $.LEFT) ||
                    (i === ue.COUNTERCLOCKWISE && this._side === $.RIGHT);
                0 === i
                  ? this.addCollinear(t)
                  : n
                  ? this.addOutsideTurn(i, t)
                  : this.addInsideTurn(i, t);
              },
            },
            {
              key: "addLineEndCap",
              value: function (e, t) {
                var i = new xi(e, t),
                  n = new xi();
                this.computeOffsetSegment(i, $.LEFT, this._distance, n);
                var s = new xi();
                this.computeOffsetSegment(i, $.RIGHT, this._distance, s);
                var r = t.x - e.x,
                  a = t.y - e.y,
                  o = Math.atan2(a, r);
                switch (this._bufParams.getEndCapStyle()) {
                  case _.CAP_ROUND:
                    this._segList.addPt(n.p1),
                      this.addDirectedFillet(
                        t,
                        o + Math.PI / 2,
                        o - Math.PI / 2,
                        ue.CLOCKWISE,
                        this._distance
                      ),
                      this._segList.addPt(s.p1);
                    break;
                  case _.CAP_FLAT:
                    this._segList.addPt(n.p1), this._segList.addPt(s.p1);
                    break;
                  case _.CAP_SQUARE:
                    var l = new V();
                    (l.x = Math.abs(this._distance) * Math.cos(o)),
                      (l.y = Math.abs(this._distance) * Math.sin(o));
                    var h = new V(n.p1.x + l.x, n.p1.y + l.y),
                      c = new V(s.p1.x + l.x, s.p1.y + l.y);
                    this._segList.addPt(h), this._segList.addPt(c);
                }
              },
            },
            {
              key: "getCoordinates",
              value: function () {
                return this._segList.getCoordinates();
              },
            },
            {
              key: "addMitreJoin",
              value: function (e, t, i, n) {
                var s = ve.intersection(t.p0, t.p1, i.p0, i.p1);
                if (
                  null !== s &&
                  (n <= 0 ? 1 : s.distance(e) / Math.abs(n)) <=
                    this._bufParams.getMitreLimit()
                )
                  return this._segList.addPt(s), null;
                this.addLimitedMitreJoin(
                  t,
                  i,
                  n,
                  this._bufParams.getMitreLimit()
                );
              },
            },
            {
              key: "addOutsideTurn",
              value: function (e, i) {
                if (
                  this._offset0.p1.distance(this._offset1.p0) <
                  this._distance * t.OFFSET_SEGMENT_SEPARATION_FACTOR
                )
                  return this._segList.addPt(this._offset0.p1), null;
                this._bufParams.getJoinStyle() === _.JOIN_MITRE
                  ? this.addMitreJoin(
                      this._s1,
                      this._offset0,
                      this._offset1,
                      this._distance
                    )
                  : this._bufParams.getJoinStyle() === _.JOIN_BEVEL
                  ? this.addBevelJoin(this._offset0, this._offset1)
                  : (i && this._segList.addPt(this._offset0.p1),
                    this.addCornerFillet(
                      this._s1,
                      this._offset0.p1,
                      this._offset1.p0,
                      e,
                      this._distance
                    ),
                    this._segList.addPt(this._offset1.p0));
              },
            },
            {
              key: "createSquare",
              value: function (e) {
                this._segList.addPt(
                  new V(e.x + this._distance, e.y + this._distance)
                ),
                  this._segList.addPt(
                    new V(e.x + this._distance, e.y - this._distance)
                  ),
                  this._segList.addPt(
                    new V(e.x - this._distance, e.y - this._distance)
                  ),
                  this._segList.addPt(
                    new V(e.x - this._distance, e.y + this._distance)
                  ),
                  this._segList.closeRing();
              },
            },
            {
              key: "addSegments",
              value: function (e, t) {
                this._segList.addPts(e, t);
              },
            },
            {
              key: "addFirstSegment",
              value: function () {
                this._segList.addPt(this._offset1.p0);
              },
            },
            {
              key: "addCornerFillet",
              value: function (e, t, i, n, s) {
                var r = t.x - e.x,
                  a = t.y - e.y,
                  o = Math.atan2(a, r),
                  l = i.x - e.x,
                  h = i.y - e.y,
                  c = Math.atan2(h, l);
                n === ue.CLOCKWISE
                  ? o <= c && (o += 2 * Math.PI)
                  : o >= c && (o -= 2 * Math.PI),
                  this._segList.addPt(t),
                  this.addDirectedFillet(e, o, c, n, s),
                  this._segList.addPt(i);
              },
            },
            {
              key: "addLastSegment",
              value: function () {
                this._segList.addPt(this._offset1.p1);
              },
            },
            {
              key: "initSideSegments",
              value: function (e, t, i) {
                (this._s1 = e),
                  (this._s2 = t),
                  (this._side = i),
                  this._seg1.setCoordinates(e, t),
                  this.computeOffsetSegment(
                    this._seg1,
                    i,
                    this._distance,
                    this._offset1
                  );
              },
            },
            {
              key: "addLimitedMitreJoin",
              value: function (e, t, i, n) {
                var s = this._seg0.p1,
                  r = Pi.angle(s, this._seg0.p0),
                  a =
                    Pi.angleBetweenOriented(this._seg0.p0, s, this._seg1.p1) /
                    2,
                  o = Pi.normalize(r + a),
                  l = Pi.normalize(o + Math.PI),
                  h = n * i,
                  c = i - h * Math.abs(Math.sin(a)),
                  u = s.x + h * Math.cos(l),
                  d = s.y + h * Math.sin(l),
                  p = new V(u, d),
                  f = new xi(s, p),
                  m = f.pointAlongOffset(1, c),
                  g = f.pointAlongOffset(1, -c);
                this._side === $.LEFT
                  ? (this._segList.addPt(m), this._segList.addPt(g))
                  : (this._segList.addPt(g), this._segList.addPt(m));
              },
            },
            {
              key: "addDirectedFillet",
              value: function (e, t, i, n, s) {
                var r = n === ue.CLOCKWISE ? -1 : 1,
                  a = Math.abs(t - i),
                  o = Math.trunc(a / this._filletAngleQuantum + 0.5);
                if (o < 1) return null;
                for (var l = a / o, h = new V(), c = 0; c < o; c++) {
                  var u = t + r * c * l;
                  (h.x = e.x + s * Math.cos(u)),
                    (h.y = e.y + s * Math.sin(u)),
                    this._segList.addPt(h);
                }
              },
            },
            {
              key: "computeOffsetSegment",
              value: function (e, t, i, n) {
                var s = t === $.LEFT ? 1 : -1,
                  r = e.p1.x - e.p0.x,
                  a = e.p1.y - e.p0.y,
                  o = Math.sqrt(r * r + a * a),
                  l = (s * i * r) / o,
                  h = (s * i * a) / o;
                (n.p0.x = e.p0.x - h),
                  (n.p0.y = e.p0.y + l),
                  (n.p1.x = e.p1.x - h),
                  (n.p1.y = e.p1.y + l);
              },
            },
            {
              key: "addInsideTurn",
              value: function (e, i) {
                if (
                  (this._li.computeIntersection(
                    this._offset0.p0,
                    this._offset0.p1,
                    this._offset1.p0,
                    this._offset1.p1
                  ),
                  this._li.hasIntersection())
                )
                  this._segList.addPt(this._li.getIntersection(0));
                else if (
                  ((this._hasNarrowConcaveAngle = !0),
                  this._offset0.p1.distance(this._offset1.p0) <
                    this._distance * t.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)
                )
                  this._segList.addPt(this._offset0.p1);
                else {
                  if (
                    (this._segList.addPt(this._offset0.p1),
                    this._closingSegLengthFactor > 0)
                  ) {
                    var n = new V(
                      (this._closingSegLengthFactor * this._offset0.p1.x +
                        this._s1.x) /
                        (this._closingSegLengthFactor + 1),
                      (this._closingSegLengthFactor * this._offset0.p1.y +
                        this._s1.y) /
                        (this._closingSegLengthFactor + 1)
                    );
                    this._segList.addPt(n);
                    var s = new V(
                      (this._closingSegLengthFactor * this._offset1.p0.x +
                        this._s1.x) /
                        (this._closingSegLengthFactor + 1),
                      (this._closingSegLengthFactor * this._offset1.p0.y +
                        this._s1.y) /
                        (this._closingSegLengthFactor + 1)
                    );
                    this._segList.addPt(s);
                  } else this._segList.addPt(this._s1);
                  this._segList.addPt(this._offset1.p0);
                }
              },
            },
            {
              key: "createCircle",
              value: function (e) {
                var t = new V(e.x + this._distance, e.y);
                this._segList.addPt(t),
                  this.addDirectedFillet(e, 0, 2 * Math.PI, -1, this._distance),
                  this._segList.closeRing();
              },
            },
            {
              key: "addBevelJoin",
              value: function (e, t) {
                this._segList.addPt(e.p1), this._segList.addPt(t.p0);
              },
            },
            {
              key: "init",
              value: function (e) {
                (this._distance = e),
                  (this._maxCurveSegmentError =
                    e * (1 - Math.cos(this._filletAngleQuantum / 2))),
                  (this._segList = new Ri()),
                  this._segList.setPrecisionModel(this._precisionModel),
                  this._segList.setMinimumVertexDistance(
                    e * t.CURVE_VERTEX_SNAP_DISTANCE_FACTOR
                  );
              },
            },
            {
              key: "addCollinear",
              value: function (e) {
                this._li.computeIntersection(
                  this._s0,
                  this._s1,
                  this._s1,
                  this._s2
                ),
                  this._li.getIntersectionNum() >= 2 &&
                    (this._bufParams.getJoinStyle() === _.JOIN_BEVEL ||
                    this._bufParams.getJoinStyle() === _.JOIN_MITRE
                      ? (e && this._segList.addPt(this._offset0.p1),
                        this._segList.addPt(this._offset1.p0))
                      : this.addCornerFillet(
                          this._s1,
                          this._offset0.p1,
                          this._offset1.p0,
                          ue.CLOCKWISE,
                          this._distance
                        ));
              },
            },
            {
              key: "closeRing",
              value: function () {
                this._segList.closeRing();
              },
            },
            {
              key: "hasNarrowConcaveAngle",
              value: function () {
                return this._hasNarrowConcaveAngle;
              },
            },
          ],
          [
            {
              key: "constructor_",
              value: function () {
                (this._maxCurveSegmentError = 0),
                  (this._filletAngleQuantum = null),
                  (this._closingSegLengthFactor = 1),
                  (this._segList = null),
                  (this._distance = 0),
                  (this._precisionModel = null),
                  (this._bufParams = null),
                  (this._li = null),
                  (this._s0 = null),
                  (this._s1 = null),
                  (this._s2 = null),
                  (this._seg0 = new xi()),
                  (this._seg1 = new xi()),
                  (this._offset0 = new xi()),
                  (this._offset1 = new xi()),
                  (this._side = 0),
                  (this._hasNarrowConcaveAngle = !1);
                var e = arguments[0],
                  i = arguments[1],
                  n = arguments[2];
                (this._precisionModel = e),
                  (this._bufParams = i),
                  (this._li = new Rt()),
                  (this._filletAngleQuantum =
                    Math.PI / 2 / i.getQuadrantSegments()),
                  i.getQuadrantSegments() >= 8 &&
                    i.getJoinStyle() === _.JOIN_ROUND &&
                    (this._closingSegLengthFactor =
                      t.MAX_CLOSING_SEG_LEN_FACTOR),
                  this.init(n);
              },
            },
          ]
        ),
        t
      );
    })();
    (Di.OFFSET_SEGMENT_SEPARATION_FACTOR = 0.001),
      (Di.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR = 0.001),
      (Di.CURVE_VERTEX_SNAP_DISTANCE_FACTOR = 1e-6),
      (Di.MAX_CLOSING_SEG_LEN_FACTOR = 80);
    var Li = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getOffsetCurve",
                value: function (e, t) {
                  if (((this._distance = t), 0 === t)) return null;
                  var i = t < 0,
                    n = Math.abs(t),
                    s = this.getSegGen(n);
                  e.length <= 1
                    ? this.computePointCurve(e[0], s)
                    : this.computeOffsetCurve(e, i, s);
                  var r = s.getCoordinates();
                  return i && Xe.reverse(r), r;
                },
              },
              {
                key: "computeSingleSidedBufferCurve",
                value: function (e, t, i) {
                  var n = this.simplifyTolerance(this._distance);
                  if (t) {
                    i.addSegments(e, !0);
                    var s = Ii.simplify(e, -n),
                      r = s.length - 1;
                    i.initSideSegments(s[r], s[r - 1], $.LEFT),
                      i.addFirstSegment();
                    for (var a = r - 2; a >= 0; a--) i.addNextSegment(s[a], !0);
                  } else {
                    i.addSegments(e, !1);
                    var o = Ii.simplify(e, n),
                      l = o.length - 1;
                    i.initSideSegments(o[0], o[1], $.LEFT), i.addFirstSegment();
                    for (var h = 2; h <= l; h++) i.addNextSegment(o[h], !0);
                  }
                  i.addLastSegment(), i.closeRing();
                },
              },
              {
                key: "computeRingBufferCurve",
                value: function (e, t, i) {
                  var n = this.simplifyTolerance(this._distance);
                  t === $.RIGHT && (n = -n);
                  var s = Ii.simplify(e, n),
                    r = s.length - 1;
                  i.initSideSegments(s[r - 1], s[0], t);
                  for (var a = 1; a <= r; a++) {
                    var o = 1 !== a;
                    i.addNextSegment(s[a], o);
                  }
                  i.closeRing();
                },
              },
              {
                key: "computeLineBufferCurve",
                value: function (e, t) {
                  var i = this.simplifyTolerance(this._distance),
                    n = Ii.simplify(e, i),
                    s = n.length - 1;
                  t.initSideSegments(n[0], n[1], $.LEFT);
                  for (var r = 2; r <= s; r++) t.addNextSegment(n[r], !0);
                  t.addLastSegment(), t.addLineEndCap(n[s - 1], n[s]);
                  var a = Ii.simplify(e, -i),
                    o = a.length - 1;
                  t.initSideSegments(a[o], a[o - 1], $.LEFT);
                  for (var l = o - 2; l >= 0; l--) t.addNextSegment(a[l], !0);
                  t.addLastSegment(),
                    t.addLineEndCap(a[1], a[0]),
                    t.closeRing();
                },
              },
              {
                key: "computePointCurve",
                value: function (e, t) {
                  switch (this._bufParams.getEndCapStyle()) {
                    case _.CAP_ROUND:
                      t.createCircle(e);
                      break;
                    case _.CAP_SQUARE:
                      t.createSquare(e);
                  }
                },
              },
              {
                key: "getLineCurve",
                value: function (e, t) {
                  if (((this._distance = t), this.isLineOffsetEmpty(t)))
                    return null;
                  var i = Math.abs(t),
                    n = this.getSegGen(i);
                  if (e.length <= 1) this.computePointCurve(e[0], n);
                  else if (this._bufParams.isSingleSided()) {
                    var s = t < 0;
                    this.computeSingleSidedBufferCurve(e, s, n);
                  } else this.computeLineBufferCurve(e, n);
                  return n.getCoordinates();
                },
              },
              {
                key: "getBufferParameters",
                value: function () {
                  return this._bufParams;
                },
              },
              {
                key: "simplifyTolerance",
                value: function (e) {
                  return e * this._bufParams.getSimplifyFactor();
                },
              },
              {
                key: "getRingCurve",
                value: function (e, i, n) {
                  if (((this._distance = n), e.length <= 2))
                    return this.getLineCurve(e, n);
                  if (0 === n) return t.copyCoordinates(e);
                  var s = this.getSegGen(n);
                  return (
                    this.computeRingBufferCurve(e, i, s), s.getCoordinates()
                  );
                },
              },
              {
                key: "computeOffsetCurve",
                value: function (e, t, i) {
                  var n = this.simplifyTolerance(this._distance);
                  if (t) {
                    var s = Ii.simplify(e, -n),
                      r = s.length - 1;
                    i.initSideSegments(s[r], s[r - 1], $.LEFT),
                      i.addFirstSegment();
                    for (var a = r - 2; a >= 0; a--) i.addNextSegment(s[a], !0);
                  } else {
                    var o = Ii.simplify(e, n),
                      l = o.length - 1;
                    i.initSideSegments(o[0], o[1], $.LEFT), i.addFirstSegment();
                    for (var h = 2; h <= l; h++) i.addNextSegment(o[h], !0);
                  }
                  i.addLastSegment();
                },
              },
              {
                key: "isLineOffsetEmpty",
                value: function (e) {
                  return 0 === e || (e < 0 && !this._bufParams.isSingleSided());
                },
              },
              {
                key: "getSegGen",
                value: function (e) {
                  return new Di(this._precisionModel, this._bufParams, e);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._distance = 0),
                    (this._precisionModel = null),
                    (this._bufParams = null);
                  var e = arguments[0],
                    t = arguments[1];
                  (this._precisionModel = e), (this._bufParams = t);
                },
              },
              {
                key: "copyCoordinates",
                value: function (e) {
                  for (
                    var t = new Array(e.length).fill(null), i = 0;
                    i < t.length;
                    i++
                  )
                    t[i] = new V(e[i]);
                  return t;
                },
              },
            ]
          ),
          t
        );
      })(),
      Fi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "findStabbedSegments",
                value: function () {
                  if (1 === arguments.length) {
                    for (
                      var e = arguments[0],
                        t = new me(),
                        i = this._subgraphs.iterator();
                      i.hasNext();

                    ) {
                      var n = i.next(),
                        s = n.getEnvelope();
                      e.y < s.getMinY() ||
                        e.y > s.getMaxY() ||
                        this.findStabbedSegments(e, n.getDirectedEdges(), t);
                    }
                    return t;
                  }
                  if (3 === arguments.length)
                    if (
                      se(arguments[2], ie) &&
                      arguments[0] instanceof V &&
                      arguments[1] instanceof Kt
                    ) {
                      for (
                        var r = arguments[0],
                          a = arguments[1],
                          o = arguments[2],
                          l = a.getEdge().getCoordinates(),
                          h = 0;
                        h < l.length - 1;
                        h++
                      )
                        if (
                          ((this._seg.p0 = l[h]),
                          (this._seg.p1 = l[h + 1]),
                          this._seg.p0.y > this._seg.p1.y &&
                            this._seg.reverse(),
                          !(
                            Math.max(this._seg.p0.x, this._seg.p1.x) < r.x ||
                            this._seg.isHorizontal() ||
                            r.y < this._seg.p0.y ||
                            r.y > this._seg.p1.y ||
                            ue.index(this._seg.p0, this._seg.p1, r) === ue.RIGHT
                          ))
                        ) {
                          var c = a.getDepth($.LEFT);
                          this._seg.p0.equals(l[h]) ||
                            (c = a.getDepth($.RIGHT));
                          var u = new Ni(this._seg, c);
                          o.add(u);
                        }
                    } else if (
                      se(arguments[2], ie) &&
                      arguments[0] instanceof V &&
                      se(arguments[1], ie)
                    )
                      for (
                        var d = arguments[0],
                          p = arguments[2],
                          f = arguments[1].iterator();
                        f.hasNext();

                      ) {
                        var m = f.next();
                        m.isForward() && this.findStabbedSegments(d, m, p);
                      }
                },
              },
              {
                key: "getDepth",
                value: function (e) {
                  var t = this.findStabbedSegments(e);
                  return 0 === t.size() ? 0 : ri.min(t)._leftDepth;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._subgraphs = null), (this._seg = new xi());
                  var e = arguments[0];
                  this._subgraphs = e;
                },
              },
            ]
          ),
          t
        );
      })(),
      Ni = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "compareTo",
                value: function (e) {
                  var t = e;
                  if (this._upwardSeg.minX() >= t._upwardSeg.maxX()) return 1;
                  if (this._upwardSeg.maxX() <= t._upwardSeg.minX()) return -1;
                  var i = this._upwardSeg.orientationIndex(t._upwardSeg);
                  return 0 !== i ||
                    0 !=
                      (i = -1 * t._upwardSeg.orientationIndex(this._upwardSeg))
                    ? i
                    : this._upwardSeg.compareTo(t._upwardSeg);
                },
              },
              {
                key: "compareX",
                value: function (e, t) {
                  var i = e.p0.compareTo(t.p0);
                  return 0 !== i ? i : e.p1.compareTo(t.p1);
                },
              },
              {
                key: "toString",
                value: function () {
                  return this._upwardSeg.toString();
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._upwardSeg = null), (this._leftDepth = null);
                  var e = arguments[0],
                    t = arguments[1];
                  (this._upwardSeg = new xi(e)), (this._leftDepth = t);
                },
              },
            ]
          ),
          t
        );
      })();
    Fi.DepthSegment = Ni;
    var Bi = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          var t;
          return (
            e(this, r),
            (t = s.call(this)),
            r.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(r, null, [
            {
              key: "constructor_",
              value: function () {
                v.constructor_.call(
                  this,
                  "Projective point not representable on the Cartesian plane."
                );
              },
            },
          ]),
          r
        );
      })(v),
      ki = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getY",
                value: function () {
                  var e = this.y / this.w;
                  if (F.isNaN(e) || F.isInfinite(e)) throw new Bi();
                  return e;
                },
              },
              {
                key: "getX",
                value: function () {
                  var e = this.x / this.w;
                  if (F.isNaN(e) || F.isInfinite(e)) throw new Bi();
                  return e;
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  var e = new V();
                  return (e.x = this.getX()), (e.y = this.getY()), e;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this.x = null),
                    (this.y = null),
                    (this.w = null),
                    0 === arguments.length)
                  )
                    (this.x = 0), (this.y = 0), (this.w = 1);
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    (this.x = e.x), (this.y = e.y), (this.w = 1);
                  } else if (2 === arguments.length) {
                    if (
                      "number" == typeof arguments[0] &&
                      "number" == typeof arguments[1]
                    ) {
                      var i = arguments[0],
                        n = arguments[1];
                      (this.x = i), (this.y = n), (this.w = 1);
                    } else if (
                      arguments[0] instanceof t &&
                      arguments[1] instanceof t
                    ) {
                      var s = arguments[0],
                        r = arguments[1];
                      (this.x = s.y * r.w - r.y * s.w),
                        (this.y = r.x * s.w - s.x * r.w),
                        (this.w = s.x * r.y - r.x * s.y);
                    } else if (
                      arguments[0] instanceof V &&
                      arguments[1] instanceof V
                    ) {
                      var a = arguments[0],
                        o = arguments[1];
                      (this.x = a.y - o.y),
                        (this.y = o.x - a.x),
                        (this.w = a.x * o.y - o.x * a.y);
                    }
                  } else if (3 === arguments.length) {
                    var l = arguments[0],
                      h = arguments[1],
                      c = arguments[2];
                    (this.x = l), (this.y = h), (this.w = c);
                  } else if (4 === arguments.length) {
                    var u = arguments[0],
                      d = arguments[1],
                      p = arguments[2],
                      f = arguments[3],
                      m = u.y - d.y,
                      g = d.x - u.x,
                      _ = u.x * d.y - d.x * u.y,
                      v = p.y - f.y,
                      A = f.x - p.x,
                      y = p.x * f.y - f.x * p.y;
                    (this.x = g * y - A * _),
                      (this.y = v * _ - m * y),
                      (this.w = m * A - v * g);
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      Oi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "area",
                value: function () {
                  return t.area(this.p0, this.p1, this.p2);
                },
              },
              {
                key: "signedArea",
                value: function () {
                  return t.signedArea(this.p0, this.p1, this.p2);
                },
              },
              {
                key: "interpolateZ",
                value: function (e) {
                  if (null === e) throw new A("Supplied point is null.");
                  return t.interpolateZ(e, this.p0, this.p1, this.p2);
                },
              },
              {
                key: "longestSideLength",
                value: function () {
                  return t.longestSideLength(this.p0, this.p1, this.p2);
                },
              },
              {
                key: "isAcute",
                value: function () {
                  return t.isAcute(this.p0, this.p1, this.p2);
                },
              },
              {
                key: "circumcentre",
                value: function () {
                  return t.circumcentre(this.p0, this.p1, this.p2);
                },
              },
              {
                key: "area3D",
                value: function () {
                  return t.area3D(this.p0, this.p1, this.p2);
                },
              },
              {
                key: "centroid",
                value: function () {
                  return t.centroid(this.p0, this.p1, this.p2);
                },
              },
              {
                key: "inCentre",
                value: function () {
                  return t.inCentre(this.p0, this.p1, this.p2);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this.p0 = null), (this.p1 = null), (this.p2 = null);
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2];
                  (this.p0 = e), (this.p1 = t), (this.p2 = i);
                },
              },
              {
                key: "area",
                value: function (e, t, i) {
                  return Math.abs(
                    ((i.x - e.x) * (t.y - e.y) - (t.x - e.x) * (i.y - e.y)) / 2
                  );
                },
              },
              {
                key: "signedArea",
                value: function (e, t, i) {
                  return (
                    ((i.x - e.x) * (t.y - e.y) - (t.x - e.x) * (i.y - e.y)) / 2
                  );
                },
              },
              {
                key: "det",
                value: function (e, t, i, n) {
                  return e * n - t * i;
                },
              },
              {
                key: "interpolateZ",
                value: function (e, t, i, n) {
                  var s = t.x,
                    r = t.y,
                    a = i.x - s,
                    o = n.x - s,
                    l = i.y - r,
                    h = n.y - r,
                    c = a * h - o * l,
                    u = e.x - s,
                    d = e.y - r,
                    p = (h * u - o * d) / c,
                    f = (-l * u + a * d) / c;
                  return (
                    t.getZ() +
                    p * (i.getZ() - t.getZ()) +
                    f * (n.getZ() - t.getZ())
                  );
                },
              },
              {
                key: "longestSideLength",
                value: function (e, t, i) {
                  var n = e.distance(t),
                    s = t.distance(i),
                    r = i.distance(e),
                    a = n;
                  return s > a && (a = s), r > a && (a = r), a;
                },
              },
              {
                key: "circumcentreDD",
                value: function (e, t, i) {
                  var n = le.valueOf(e.x).subtract(i.x),
                    s = le.valueOf(e.y).subtract(i.y),
                    r = le.valueOf(t.x).subtract(i.x),
                    a = le.valueOf(t.y).subtract(i.y),
                    o = le.determinant(n, s, r, a).multiply(2),
                    l = n.sqr().add(s.sqr()),
                    h = r.sqr().add(a.sqr()),
                    c = le.determinant(s, l, a, h),
                    u = le.determinant(n, l, r, h),
                    d = le.valueOf(i.x).subtract(c.divide(o)).doubleValue(),
                    p = le.valueOf(i.y).add(u.divide(o)).doubleValue();
                  return new V(d, p);
                },
              },
              {
                key: "isAcute",
                value: function (e, t, i) {
                  return (
                    !!Pi.isAcute(e, t, i) &&
                    !!Pi.isAcute(t, i, e) &&
                    !!Pi.isAcute(i, e, t)
                  );
                },
              },
              {
                key: "circumcentre",
                value: function (e, i, n) {
                  var s = n.x,
                    r = n.y,
                    a = e.x - s,
                    o = e.y - r,
                    l = i.x - s,
                    h = i.y - r,
                    c = 2 * t.det(a, o, l, h),
                    u = t.det(o, a * a + o * o, h, l * l + h * h),
                    d = t.det(a, a * a + o * o, l, l * l + h * h);
                  return new V(s - u / c, r + d / c);
                },
              },
              {
                key: "perpendicularBisector",
                value: function (e, t) {
                  var i = t.x - e.x,
                    n = t.y - e.y,
                    s = new ki(e.x + i / 2, e.y + n / 2, 1),
                    r = new ki(e.x - n + i / 2, e.y + i + n / 2, 1);
                  return new ki(s, r);
                },
              },
              {
                key: "angleBisector",
                value: function (e, t, i) {
                  var n = t.distance(e),
                    s = n / (n + t.distance(i)),
                    r = i.x - e.x,
                    a = i.y - e.y;
                  return new V(e.x + s * r, e.y + s * a);
                },
              },
              {
                key: "area3D",
                value: function (e, t, i) {
                  var n = t.x - e.x,
                    s = t.y - e.y,
                    r = t.getZ() - e.getZ(),
                    a = i.x - e.x,
                    o = i.y - e.y,
                    l = i.getZ() - e.getZ(),
                    h = s * l - r * o,
                    c = r * a - n * l,
                    u = n * o - s * a,
                    d = h * h + c * c + u * u;
                  return Math.sqrt(d) / 2;
                },
              },
              {
                key: "centroid",
                value: function (e, t, i) {
                  var n = (e.x + t.x + i.x) / 3,
                    s = (e.y + t.y + i.y) / 3;
                  return new V(n, s);
                },
              },
              {
                key: "inCentre",
                value: function (e, t, i) {
                  var n = t.distance(i),
                    s = e.distance(i),
                    r = e.distance(t),
                    a = n + s + r,
                    o = (n * e.x + s * t.x + r * i.x) / a,
                    l = (n * e.y + s * t.y + r * i.y) / a;
                  return new V(o, l);
                },
              },
            ]
          ),
          t
        );
      })(),
      Ui = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "addRingSide",
                value: function (e, t, i, n, s) {
                  if (0 === t && e.length < Ve.MINIMUM_VALID_SIZE) return null;
                  var r = n,
                    a = s;
                  e.length >= Ve.MINIMUM_VALID_SIZE &&
                    ue.isCCW(e) &&
                    ((r = s), (a = n), (i = $.opposite(i)));
                  var o = this._curveBuilder.getRingCurve(e, i, t);
                  this.addCurve(o, r, a);
                },
              },
              {
                key: "addRingBothSides",
                value: function (e, t) {
                  this.addRingSide(e, t, $.LEFT, W.EXTERIOR, W.INTERIOR),
                    this.addRingSide(e, t, $.RIGHT, W.INTERIOR, W.EXTERIOR);
                },
              },
              {
                key: "addPoint",
                value: function (e) {
                  if (this._distance <= 0) return null;
                  var t = e.getCoordinates(),
                    i = this._curveBuilder.getLineCurve(t, this._distance);
                  this.addCurve(i, W.EXTERIOR, W.INTERIOR);
                },
              },
              {
                key: "addPolygon",
                value: function (e) {
                  var t = this._distance,
                    i = $.LEFT;
                  this._distance < 0 && ((t = -this._distance), (i = $.RIGHT));
                  var n = e.getExteriorRing(),
                    s = Xe.removeRepeatedPoints(n.getCoordinates());
                  if (
                    this._distance < 0 &&
                    this.isErodedCompletely(n, this._distance)
                  )
                    return null;
                  if (this._distance <= 0 && s.length < 3) return null;
                  this.addRingSide(s, t, i, W.EXTERIOR, W.INTERIOR);
                  for (var r = 0; r < e.getNumInteriorRing(); r++) {
                    var a = e.getInteriorRingN(r),
                      o = Xe.removeRepeatedPoints(a.getCoordinates());
                    (this._distance > 0 &&
                      this.isErodedCompletely(a, -this._distance)) ||
                      this.addRingSide(
                        o,
                        t,
                        $.opposite(i),
                        W.INTERIOR,
                        W.EXTERIOR
                      );
                  }
                },
              },
              {
                key: "isTriangleErodedCompletely",
                value: function (e, t) {
                  var i = new Oi(e[0], e[1], e[2]),
                    n = i.inCentre();
                  return xe.pointToSegment(n, i.p0, i.p1) < Math.abs(t);
                },
              },
              {
                key: "addLineString",
                value: function (e) {
                  if (this._curveBuilder.isLineOffsetEmpty(this._distance))
                    return null;
                  var t = Xe.removeRepeatedPoints(e.getCoordinates());
                  if (
                    Xe.isRing(t) &&
                    !this._curveBuilder.getBufferParameters().isSingleSided()
                  )
                    this.addRingBothSides(t, this._distance);
                  else {
                    var i = this._curveBuilder.getLineCurve(t, this._distance);
                    this.addCurve(i, W.EXTERIOR, W.INTERIOR);
                  }
                },
              },
              {
                key: "addCurve",
                value: function (e, t, i) {
                  if (null === e || e.length < 2) return null;
                  var n = new yi(e, new Ft(0, W.BOUNDARY, t, i));
                  this._curveList.add(n);
                },
              },
              {
                key: "getCurves",
                value: function () {
                  return this.add(this._inputGeom), this._curveList;
                },
              },
              {
                key: "add",
                value: function (e) {
                  if (e.isEmpty()) return null;
                  if (e instanceof Be) this.addPolygon(e);
                  else if (e instanceof Re) this.addLineString(e);
                  else if (e instanceof De) this.addPoint(e);
                  else if (e instanceof Ge) this.addCollection(e);
                  else if (e instanceof rt) this.addCollection(e);
                  else if (e instanceof et) this.addCollection(e);
                  else {
                    if (!(e instanceof ze)) throw new Y(e.getGeometryType());
                    this.addCollection(e);
                  }
                },
              },
              {
                key: "isErodedCompletely",
                value: function (e, t) {
                  var i = e.getCoordinates();
                  if (i.length < 4) return t < 0;
                  if (4 === i.length)
                    return this.isTriangleErodedCompletely(i, t);
                  var n = e.getEnvelopeInternal(),
                    s = Math.min(n.getHeight(), n.getWidth());
                  return t < 0 && 2 * Math.abs(t) > s;
                },
              },
              {
                key: "addCollection",
                value: function (e) {
                  for (var t = 0; t < e.getNumGeometries(); t++) {
                    var i = e.getGeometryN(t);
                    this.add(i);
                  }
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._inputGeom = null),
                    (this._distance = null),
                    (this._curveBuilder = null),
                    (this._curveList = new me());
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2];
                  (this._inputGeom = e),
                    (this._distance = t),
                    (this._curveBuilder = i);
                },
              },
            ]
          ),
          t
        );
      })(),
      zi = (function () {
        function t() {
          e(this, t);
        }
        return i(t, [{ key: "locate", value: function (e) {} }]), t;
      })(),
      Gi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "next",
                value: function () {
                  if (this._atStart)
                    return (
                      (this._atStart = !1),
                      t.isAtomic(this._parent) && this._index++,
                      this._parent
                    );
                  if (null !== this._subcollectionIterator) {
                    if (this._subcollectionIterator.hasNext())
                      return this._subcollectionIterator.next();
                    this._subcollectionIterator = null;
                  }
                  if (this._index >= this._max) throw new X();
                  var e = this._parent.getGeometryN(this._index++);
                  return e instanceof ze
                    ? ((this._subcollectionIterator = new t(e)),
                      this._subcollectionIterator.next())
                    : e;
                },
              },
              {
                key: "remove",
                value: function () {
                  throw new Y(this.getClass().getName());
                },
              },
              {
                key: "hasNext",
                value: function () {
                  if (this._atStart) return !0;
                  if (null !== this._subcollectionIterator) {
                    if (this._subcollectionIterator.hasNext()) return !0;
                    this._subcollectionIterator = null;
                  }
                  return !(this._index >= this._max);
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [mi];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._parent = null),
                    (this._atStart = null),
                    (this._max = null),
                    (this._index = null),
                    (this._subcollectionIterator = null);
                  var e = arguments[0];
                  (this._parent = e),
                    (this._atStart = !0),
                    (this._index = 0),
                    (this._max = e.getNumGeometries());
                },
              },
              {
                key: "isAtomic",
                value: function (e) {
                  return !(e instanceof ze);
                },
              },
            ]
          ),
          t
        );
      })(),
      Vi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "locate",
                value: function (e) {
                  return t.locate(e, this._geom);
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [zi];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  this._geom = null;
                  var e = arguments[0];
                  this._geom = e;
                },
              },
              {
                key: "locatePointInPolygon",
                value: function (e, i) {
                  if (i.isEmpty()) return W.EXTERIOR;
                  var n = i.getExteriorRing(),
                    s = t.locatePointInRing(e, n);
                  if (s !== W.INTERIOR) return s;
                  for (var r = 0; r < i.getNumInteriorRing(); r++) {
                    var a = i.getInteriorRingN(r),
                      o = t.locatePointInRing(e, a);
                    if (o === W.BOUNDARY) return W.BOUNDARY;
                    if (o === W.INTERIOR) return W.EXTERIOR;
                  }
                  return W.INTERIOR;
                },
              },
              {
                key: "locatePointInRing",
                value: function (e, t) {
                  return t.getEnvelopeInternal().intersects(e)
                    ? Dt.locateInRing(e, t.getCoordinates())
                    : W.EXTERIOR;
                },
              },
              {
                key: "containsPointInPolygon",
                value: function (e, i) {
                  return W.EXTERIOR !== t.locatePointInPolygon(e, i);
                },
              },
              {
                key: "locateInGeometry",
                value: function (e, i) {
                  if (i instanceof Be) return t.locatePointInPolygon(e, i);
                  if (i instanceof ze)
                    for (var n = new Gi(i); n.hasNext(); ) {
                      var s = n.next();
                      if (s !== i) {
                        var r = t.locateInGeometry(e, s);
                        if (r !== W.EXTERIOR) return r;
                      }
                    }
                  return W.EXTERIOR;
                },
              },
              {
                key: "isContained",
                value: function (e, i) {
                  return W.EXTERIOR !== t.locate(e, i);
                },
              },
              {
                key: "locate",
                value: function (e, i) {
                  return i.isEmpty()
                    ? W.EXTERIOR
                    : i.getEnvelopeInternal().intersects(e)
                    ? t.locateInGeometry(e, i)
                    : W.EXTERIOR;
                },
              },
            ]
          ),
          t
        );
      })(),
      Qi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getNextCW",
                value: function (e) {
                  this.getEdges();
                  var t = this._edgeList.indexOf(e),
                    i = t - 1;
                  return (
                    0 === t && (i = this._edgeList.size() - 1),
                    this._edgeList.get(i)
                  );
                },
              },
              {
                key: "propagateSideLabels",
                value: function (e) {
                  for (var t = W.NONE, i = this.iterator(); i.hasNext(); ) {
                    var n = i.next().getLabel();
                    n.isArea(e) &&
                      n.getLocation(e, $.LEFT) !== W.NONE &&
                      (t = n.getLocation(e, $.LEFT));
                  }
                  if (t === W.NONE) return null;
                  for (var s = t, r = this.iterator(); r.hasNext(); ) {
                    var a = r.next(),
                      o = a.getLabel();
                    if (
                      (o.getLocation(e, $.ON) === W.NONE &&
                        o.setLocation(e, $.ON, s),
                      o.isArea(e))
                    ) {
                      var l = o.getLocation(e, $.LEFT),
                        h = o.getLocation(e, $.RIGHT);
                      if (h !== W.NONE) {
                        if (h !== s)
                          throw new pe(
                            "side location conflict",
                            a.getCoordinate()
                          );
                        l === W.NONE &&
                          O.shouldNeverReachHere(
                            "found single null side (at " +
                              a.getCoordinate() +
                              ")"
                          ),
                          (s = l);
                      } else
                        O.isTrue(
                          o.getLocation(e, $.LEFT) === W.NONE,
                          "found single null side"
                        ),
                          o.setLocation(e, $.RIGHT, s),
                          o.setLocation(e, $.LEFT, s);
                    }
                  }
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  var e = this.iterator();
                  return e.hasNext() ? e.next().getCoordinate() : null;
                },
              },
              {
                key: "print",
                value: function (e) {
                  Ae.out.println("EdgeEndStar:   " + this.getCoordinate());
                  for (var t = this.iterator(); t.hasNext(); )
                    t.next().print(e);
                },
              },
              {
                key: "isAreaLabelsConsistent",
                value: function (e) {
                  return (
                    this.computeEdgeEndLabels(e.getBoundaryNodeRule()),
                    this.checkAreaLabelsConsistent(0)
                  );
                },
              },
              {
                key: "checkAreaLabelsConsistent",
                value: function (e) {
                  var t = this.getEdges();
                  if (t.size() <= 0) return !0;
                  var i = t.size() - 1,
                    n = t.get(i).getLabel().getLocation(e, $.LEFT);
                  O.isTrue(n !== W.NONE, "Found unlabelled area edge");
                  for (var s = n, r = this.iterator(); r.hasNext(); ) {
                    var a = r.next().getLabel();
                    O.isTrue(a.isArea(e), "Found non-area edge");
                    var o = a.getLocation(e, $.LEFT),
                      l = a.getLocation(e, $.RIGHT);
                    if (o === l) return !1;
                    if (l !== s) return !1;
                    s = o;
                  }
                  return !0;
                },
              },
              {
                key: "findIndex",
                value: function (e) {
                  this.iterator();
                  for (var t = 0; t < this._edgeList.size(); t++)
                    if (this._edgeList.get(t) === e) return t;
                  return -1;
                },
              },
              {
                key: "iterator",
                value: function () {
                  return this.getEdges().iterator();
                },
              },
              {
                key: "getEdges",
                value: function () {
                  return (
                    null === this._edgeList &&
                      (this._edgeList = new me(this._edgeMap.values())),
                    this._edgeList
                  );
                },
              },
              {
                key: "getLocation",
                value: function (e, t, i) {
                  return (
                    this._ptInAreaLocation[e] === W.NONE &&
                      (this._ptInAreaLocation[e] = Vi.locate(
                        t,
                        i[e].getGeometry()
                      )),
                    this._ptInAreaLocation[e]
                  );
                },
              },
              {
                key: "toString",
                value: function () {
                  var e = new re();
                  e.append("EdgeEndStar:   " + this.getCoordinate()),
                    e.append("\n");
                  for (var t = this.iterator(); t.hasNext(); ) {
                    var i = t.next();
                    e.append(i), e.append("\n");
                  }
                  return e.toString();
                },
              },
              {
                key: "computeEdgeEndLabels",
                value: function (e) {
                  for (var t = this.iterator(); t.hasNext(); )
                    t.next().computeLabel(e);
                },
              },
              {
                key: "computeLabelling",
                value: function (e) {
                  this.computeEdgeEndLabels(e[0].getBoundaryNodeRule()),
                    this.propagateSideLabels(0),
                    this.propagateSideLabels(1);
                  for (var t = [!1, !1], i = this.iterator(); i.hasNext(); )
                    for (var n = i.next().getLabel(), s = 0; s < 2; s++)
                      n.isLine(s) &&
                        n.getLocation(s) === W.BOUNDARY &&
                        (t[s] = !0);
                  for (var r = this.iterator(); r.hasNext(); )
                    for (var a = r.next(), o = a.getLabel(), l = 0; l < 2; l++)
                      if (o.isAnyNull(l)) {
                        var h = W.NONE;
                        if (t[l]) h = W.EXTERIOR;
                        else {
                          var c = a.getCoordinate();
                          h = this.getLocation(l, c, e);
                        }
                        o.setAllLocationsIfNull(l, h);
                      }
                },
              },
              {
                key: "getDegree",
                value: function () {
                  return this._edgeMap.size();
                },
              },
              {
                key: "insertEdgeEnd",
                value: function (e, t) {
                  this._edgeMap.put(e, t), (this._edgeList = null);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._edgeMap = new Wt()),
                    (this._edgeList = null),
                    (this._ptInAreaLocation = [W.NONE, W.NONE]);
                },
              },
            ]
          ),
          t
        );
      })(),
      Hi = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "linkResultDirectedEdges",
                value: function () {
                  this.getResultAreaEdges();
                  for (
                    var e = null,
                      t = null,
                      i = this._SCANNING_FOR_INCOMING,
                      n = 0;
                    n < this._resultAreaEdgeList.size();
                    n++
                  ) {
                    var s = this._resultAreaEdgeList.get(n),
                      r = s.getSym();
                    if (s.getLabel().isArea())
                      switch ((null === e && s.isInResult() && (e = s), i)) {
                        case this._SCANNING_FOR_INCOMING:
                          if (!r.isInResult()) continue;
                          (t = r), (i = this._LINKING_TO_OUTGOING);
                          break;
                        case this._LINKING_TO_OUTGOING:
                          if (!s.isInResult()) continue;
                          t.setNext(s), (i = this._SCANNING_FOR_INCOMING);
                      }
                  }
                  if (i === this._LINKING_TO_OUTGOING) {
                    if (null === e)
                      throw new pe(
                        "no outgoing dirEdge found",
                        this.getCoordinate()
                      );
                    O.isTrue(
                      e.isInResult(),
                      "unable to link last incoming dirEdge"
                    ),
                      t.setNext(e);
                  }
                },
              },
              {
                key: "insert",
                value: function (e) {
                  var t = e;
                  this.insertEdgeEnd(t, t);
                },
              },
              {
                key: "getRightmostEdge",
                value: function () {
                  var e = this.getEdges(),
                    t = e.size();
                  if (t < 1) return null;
                  var i = e.get(0);
                  if (1 === t) return i;
                  var n = e.get(t - 1),
                    s = i.getQuadrant(),
                    r = n.getQuadrant();
                  return Xt.isNorthern(s) && Xt.isNorthern(r)
                    ? i
                    : Xt.isNorthern(s) || Xt.isNorthern(r)
                    ? 0 !== i.getDy()
                      ? i
                      : 0 !== n.getDy()
                      ? n
                      : (O.shouldNeverReachHere(
                          "found two horizontal edges incident on node"
                        ),
                        null)
                    : n;
                },
              },
              {
                key: "print",
                value: function (e) {
                  Ae.out.println("DirectedEdgeStar: " + this.getCoordinate());
                  for (var t = this.iterator(); t.hasNext(); ) {
                    var i = t.next();
                    e.print("out "),
                      i.print(e),
                      e.println(),
                      e.print("in "),
                      i.getSym().print(e),
                      e.println();
                  }
                },
              },
              {
                key: "getResultAreaEdges",
                value: function () {
                  if (null !== this._resultAreaEdgeList)
                    return this._resultAreaEdgeList;
                  this._resultAreaEdgeList = new me();
                  for (var e = this.iterator(); e.hasNext(); ) {
                    var t = e.next();
                    (t.isInResult() || t.getSym().isInResult()) &&
                      this._resultAreaEdgeList.add(t);
                  }
                  return this._resultAreaEdgeList;
                },
              },
              {
                key: "updateLabelling",
                value: function (e) {
                  for (var t = this.iterator(); t.hasNext(); ) {
                    var i = t.next().getLabel();
                    i.setAllLocationsIfNull(0, e.getLocation(0)),
                      i.setAllLocationsIfNull(1, e.getLocation(1));
                  }
                },
              },
              {
                key: "linkAllDirectedEdges",
                value: function () {
                  this.getEdges();
                  for (
                    var e = null, t = null, i = this._edgeList.size() - 1;
                    i >= 0;
                    i--
                  ) {
                    var n = this._edgeList.get(i),
                      s = n.getSym();
                    null === t && (t = s), null !== e && s.setNext(e), (e = n);
                  }
                  t.setNext(e);
                },
              },
              {
                key: "computeDepths",
                value: function () {
                  if (1 === arguments.length) {
                    var e = arguments[0],
                      t = this.findIndex(e),
                      i = e.getDepth($.LEFT),
                      n = e.getDepth($.RIGHT),
                      s = this.computeDepths(t + 1, this._edgeList.size(), i);
                    if (this.computeDepths(0, t, s) !== n)
                      throw new pe("depth mismatch at " + e.getCoordinate());
                  } else if (3 === arguments.length) {
                    for (
                      var r = arguments[1], a = arguments[2], o = arguments[0];
                      o < r;
                      o++
                    ) {
                      var l = this._edgeList.get(o);
                      l.setEdgeDepths($.RIGHT, a), (a = l.getDepth($.LEFT));
                    }
                    return a;
                  }
                },
              },
              {
                key: "mergeSymLabels",
                value: function () {
                  for (var e = this.iterator(); e.hasNext(); ) {
                    var t = e.next();
                    t.getLabel().merge(t.getSym().getLabel());
                  }
                },
              },
              {
                key: "linkMinimalDirectedEdges",
                value: function (e) {
                  for (
                    var t = null,
                      i = null,
                      n = this._SCANNING_FOR_INCOMING,
                      s = this._resultAreaEdgeList.size() - 1;
                    s >= 0;
                    s--
                  ) {
                    var r = this._resultAreaEdgeList.get(s),
                      a = r.getSym();
                    switch (
                      (null === t && r.getEdgeRing() === e && (t = r), n)
                    ) {
                      case this._SCANNING_FOR_INCOMING:
                        if (a.getEdgeRing() !== e) continue;
                        (i = a), (n = this._LINKING_TO_OUTGOING);
                        break;
                      case this._LINKING_TO_OUTGOING:
                        if (r.getEdgeRing() !== e) continue;
                        i.setNextMin(r), (n = this._SCANNING_FOR_INCOMING);
                    }
                  }
                  n === this._LINKING_TO_OUTGOING &&
                    (O.isTrue(
                      null !== t,
                      "found null for first outgoing dirEdge"
                    ),
                    O.isTrue(
                      t.getEdgeRing() === e,
                      "unable to link last incoming dirEdge"
                    ),
                    i.setNextMin(t));
                },
              },
              {
                key: "getOutgoingDegree",
                value: function () {
                  if (0 === arguments.length) {
                    for (var e = 0, t = this.iterator(); t.hasNext(); )
                      t.next().isInResult() && e++;
                    return e;
                  }
                  if (1 === arguments.length) {
                    for (
                      var i = arguments[0], n = 0, s = this.iterator();
                      s.hasNext();

                    )
                      s.next().getEdgeRing() === i && n++;
                    return n;
                  }
                },
              },
              {
                key: "getLabel",
                value: function () {
                  return this._label;
                },
              },
              {
                key: "findCoveredLineEdges",
                value: function () {
                  for (var e = W.NONE, t = this.iterator(); t.hasNext(); ) {
                    var i = t.next(),
                      n = i.getSym();
                    if (!i.isLineEdge()) {
                      if (i.isInResult()) {
                        e = W.INTERIOR;
                        break;
                      }
                      if (n.isInResult()) {
                        e = W.EXTERIOR;
                        break;
                      }
                    }
                  }
                  if (e === W.NONE) return null;
                  for (var s = e, r = this.iterator(); r.hasNext(); ) {
                    var a = r.next(),
                      o = a.getSym();
                    a.isLineEdge()
                      ? a.getEdge().setCovered(s === W.INTERIOR)
                      : (a.isInResult() && (s = W.EXTERIOR),
                        o.isInResult() && (s = W.INTERIOR));
                  }
                },
              },
              {
                key: "computeLabelling",
                value: function (e) {
                  d(s(a.prototype), "computeLabelling", this).call(this, e),
                    (this._label = new Ft(W.NONE));
                  for (var t = this.iterator(); t.hasNext(); )
                    for (
                      var i = t.next().getEdge().getLabel(), n = 0;
                      n < 2;
                      n++
                    ) {
                      var r = i.getLocation(n);
                      (r !== W.INTERIOR && r !== W.BOUNDARY) ||
                        this._label.setLocation(n, W.INTERIOR);
                    }
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._resultAreaEdgeList = null),
                    (this._label = null),
                    (this._SCANNING_FOR_INCOMING = 1),
                    (this._LINKING_TO_OUTGOING = 2);
                },
              },
            ]
          ),
          a
        );
      })(Qi),
      ji = (function (t) {
        n(r, t);
        var s = u(r);
        function r() {
          return e(this, r), s.call(this);
        }
        return (
          i(r, [
            {
              key: "createNode",
              value: function (e) {
                return new Ut(e, new Hi());
              },
            },
          ]),
          r
        );
      })(Zt),
      Wi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "compareTo",
                value: function (e) {
                  var i = e;
                  return t.compareOriented(
                    this._pts,
                    this._orientation,
                    i._pts,
                    i._orientation
                  );
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._pts = null), (this._orientation = null);
                  var e = arguments[0];
                  (this._pts = e), (this._orientation = t.orientation(e));
                },
              },
              {
                key: "orientation",
                value: function (e) {
                  return 1 === Xe.increasingDirection(e);
                },
              },
              {
                key: "compareOriented",
                value: function (e, t, i, n) {
                  for (
                    var s = t ? 1 : -1,
                      r = n ? 1 : -1,
                      a = t ? e.length : -1,
                      o = n ? i.length : -1,
                      l = t ? 0 : e.length - 1,
                      h = n ? 0 : i.length - 1;
                    ;

                  ) {
                    var c = e[l].compareTo(i[h]);
                    if (0 !== c) return c;
                    var u = (l += s) === a,
                      d = (h += r) === o;
                    if (u && !d) return -1;
                    if (!u && d) return 1;
                    if (u && d) return 0;
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      qi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "print",
                value: function (e) {
                  e.print("MULTILINESTRING ( ");
                  for (var t = 0; t < this._edges.size(); t++) {
                    var i = this._edges.get(t);
                    t > 0 && e.print(","), e.print("(");
                    for (var n = i.getCoordinates(), s = 0; s < n.length; s++)
                      s > 0 && e.print(","), e.print(n[s].x + " " + n[s].y);
                    e.println(")");
                  }
                  e.print(")  ");
                },
              },
              {
                key: "addAll",
                value: function (e) {
                  for (var t = e.iterator(); t.hasNext(); ) this.add(t.next());
                },
              },
              {
                key: "findEdgeIndex",
                value: function (e) {
                  for (var t = 0; t < this._edges.size(); t++)
                    if (this._edges.get(t).equals(e)) return t;
                  return -1;
                },
              },
              {
                key: "iterator",
                value: function () {
                  return this._edges.iterator();
                },
              },
              {
                key: "getEdges",
                value: function () {
                  return this._edges;
                },
              },
              {
                key: "get",
                value: function (e) {
                  return this._edges.get(e);
                },
              },
              {
                key: "findEqualEdge",
                value: function (e) {
                  var t = new Wi(e.getCoordinates());
                  return this._ocaMap.get(t);
                },
              },
              {
                key: "add",
                value: function (e) {
                  this._edges.add(e);
                  var t = new Wi(e.getCoordinates());
                  this._ocaMap.put(t, e);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._edges = new me()), (this._ocaMap = new Wt());
                },
              },
            ]
          ),
          t
        );
      })(),
      Xi = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(t, [
            { key: "processIntersections", value: function (e, t, i, n) {} },
            { key: "isDone", value: function () {} },
          ]),
          t
        );
      })(),
      Yi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "isTrivialIntersection",
                value: function (e, i, n, s) {
                  if (e === n && 1 === this._li.getIntersectionNum()) {
                    if (t.isAdjacentSegments(i, s)) return !0;
                    if (e.isClosed()) {
                      var r = e.size() - 1;
                      if ((0 === i && s === r) || (0 === s && i === r))
                        return !0;
                    }
                  }
                  return !1;
                },
              },
              {
                key: "getProperIntersectionPoint",
                value: function () {
                  return this._properIntersectionPoint;
                },
              },
              {
                key: "hasProperInteriorIntersection",
                value: function () {
                  return this._hasProperInterior;
                },
              },
              {
                key: "getLineIntersector",
                value: function () {
                  return this._li;
                },
              },
              {
                key: "hasProperIntersection",
                value: function () {
                  return this._hasProper;
                },
              },
              {
                key: "processIntersections",
                value: function (e, t, i, n) {
                  if (e === i && t === n) return null;
                  this.numTests++;
                  var s = e.getCoordinates()[t],
                    r = e.getCoordinates()[t + 1],
                    a = i.getCoordinates()[n],
                    o = i.getCoordinates()[n + 1];
                  this._li.computeIntersection(s, r, a, o),
                    this._li.hasIntersection() &&
                      (this.numIntersections++,
                      this._li.isInteriorIntersection() &&
                        (this.numInteriorIntersections++,
                        (this._hasInterior = !0)),
                      this.isTrivialIntersection(e, t, i, n) ||
                        ((this._hasIntersection = !0),
                        e.addIntersections(this._li, t, 0),
                        i.addIntersections(this._li, n, 1),
                        this._li.isProper() &&
                          (this.numProperIntersections++,
                          (this._hasProper = !0),
                          (this._hasProperInterior = !0))));
                },
              },
              {
                key: "hasIntersection",
                value: function () {
                  return this._hasIntersection;
                },
              },
              {
                key: "isDone",
                value: function () {
                  return !1;
                },
              },
              {
                key: "hasInteriorIntersection",
                value: function () {
                  return this._hasInterior;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Xi];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._hasIntersection = !1),
                    (this._hasProper = !1),
                    (this._hasProperInterior = !1),
                    (this._hasInterior = !1),
                    (this._properIntersectionPoint = null),
                    (this._li = null),
                    (this._isSelfIntersection = null),
                    (this.numIntersections = 0),
                    (this.numInteriorIntersections = 0),
                    (this.numProperIntersections = 0),
                    (this.numTests = 0);
                  var e = arguments[0];
                  this._li = e;
                },
              },
              {
                key: "isAdjacentSegments",
                value: function (e, t) {
                  return 1 === Math.abs(e - t);
                },
              },
            ]
          ),
          t
        );
      })(),
      Ki = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getSegmentIndex",
                value: function () {
                  return this.segmentIndex;
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  return this.coord;
                },
              },
              {
                key: "print",
                value: function (e) {
                  e.print(this.coord),
                    e.print(" seg # = " + this.segmentIndex),
                    e.println(" dist = " + this.dist);
                },
              },
              {
                key: "compareTo",
                value: function (e) {
                  var t = e;
                  return this.compare(t.segmentIndex, t.dist);
                },
              },
              {
                key: "isEndPoint",
                value: function (e) {
                  return (
                    (0 === this.segmentIndex && 0 === this.dist) ||
                    this.segmentIndex === e
                  );
                },
              },
              {
                key: "toString",
                value: function () {
                  return (
                    this.coord +
                    " seg # = " +
                    this.segmentIndex +
                    " dist = " +
                    this.dist
                  );
                },
              },
              {
                key: "getDistance",
                value: function () {
                  return this.dist;
                },
              },
              {
                key: "compare",
                value: function (e, t) {
                  return this.segmentIndex < e
                    ? -1
                    : this.segmentIndex > e
                    ? 1
                    : this.dist < t
                    ? -1
                    : this.dist > t
                    ? 1
                    : 0;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [x];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this.coord = null),
                    (this.segmentIndex = null),
                    (this.dist = null);
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2];
                  (this.coord = new V(e)),
                    (this.segmentIndex = t),
                    (this.dist = i);
                },
              },
            ]
          ),
          t
        );
      })(),
      Zi = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "print",
                value: function (e) {
                  e.println("Intersections:");
                  for (var t = this.iterator(); t.hasNext(); )
                    t.next().print(e);
                },
              },
              {
                key: "iterator",
                value: function () {
                  return this._nodeMap.values().iterator();
                },
              },
              {
                key: "addSplitEdges",
                value: function (e) {
                  this.addEndpoints();
                  for (var t = this.iterator(), i = t.next(); t.hasNext(); ) {
                    var n = t.next(),
                      s = this.createSplitEdge(i, n);
                    e.add(s), (i = n);
                  }
                },
              },
              {
                key: "addEndpoints",
                value: function () {
                  var e = this.edge.pts.length - 1;
                  this.add(this.edge.pts[0], 0, 0),
                    this.add(this.edge.pts[e], e, 0);
                },
              },
              {
                key: "createSplitEdge",
                value: function (e, t) {
                  var i = t.segmentIndex - e.segmentIndex + 2,
                    n = this.edge.pts[t.segmentIndex],
                    s = t.dist > 0 || !t.coord.equals2D(n);
                  s || i--;
                  var r = new Array(i).fill(null),
                    a = 0;
                  r[a++] = new V(e.coord);
                  for (var o = e.segmentIndex + 1; o <= t.segmentIndex; o++)
                    r[a++] = this.edge.pts[o];
                  return (
                    s && (r[a] = t.coord), new sn(r, new Ft(this.edge._label))
                  );
                },
              },
              {
                key: "add",
                value: function (e, t, i) {
                  var n = new Ki(e, t, i),
                    s = this._nodeMap.get(n);
                  return null !== s ? s : (this._nodeMap.put(n, n), n);
                },
              },
              {
                key: "isIntersection",
                value: function (e) {
                  for (var t = this.iterator(); t.hasNext(); )
                    if (t.next().coord.equals(e)) return !0;
                  return !1;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._nodeMap = new Wt()), (this.edge = null);
                  var e = arguments[0];
                  this.edge = e;
                },
              },
            ]
          ),
          t
        );
      })(),
      Ji = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "isIntersects",
                value: function () {
                  return !this.isDisjoint();
                },
              },
              {
                key: "isCovers",
                value: function () {
                  return (
                    (t.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) ||
                      t.isTrue(this._matrix[W.INTERIOR][W.BOUNDARY]) ||
                      t.isTrue(this._matrix[W.BOUNDARY][W.INTERIOR]) ||
                      t.isTrue(this._matrix[W.BOUNDARY][W.BOUNDARY])) &&
                    this._matrix[W.EXTERIOR][W.INTERIOR] === we.FALSE &&
                    this._matrix[W.EXTERIOR][W.BOUNDARY] === we.FALSE
                  );
                },
              },
              {
                key: "isCoveredBy",
                value: function () {
                  return (
                    (t.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) ||
                      t.isTrue(this._matrix[W.INTERIOR][W.BOUNDARY]) ||
                      t.isTrue(this._matrix[W.BOUNDARY][W.INTERIOR]) ||
                      t.isTrue(this._matrix[W.BOUNDARY][W.BOUNDARY])) &&
                    this._matrix[W.INTERIOR][W.EXTERIOR] === we.FALSE &&
                    this._matrix[W.BOUNDARY][W.EXTERIOR] === we.FALSE
                  );
                },
              },
              {
                key: "set",
                value: function () {
                  if (1 === arguments.length)
                    for (var e = arguments[0], t = 0; t < e.length; t++) {
                      var i = Math.trunc(t / 3),
                        n = t % 3;
                      this._matrix[i][n] = we.toDimensionValue(e.charAt(t));
                    }
                  else if (3 === arguments.length) {
                    var s = arguments[0],
                      r = arguments[1],
                      a = arguments[2];
                    this._matrix[s][r] = a;
                  }
                },
              },
              {
                key: "isContains",
                value: function () {
                  return (
                    t.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                    this._matrix[W.EXTERIOR][W.INTERIOR] === we.FALSE &&
                    this._matrix[W.EXTERIOR][W.BOUNDARY] === we.FALSE
                  );
                },
              },
              {
                key: "setAtLeast",
                value: function () {
                  if (1 === arguments.length)
                    for (var e = arguments[0], t = 0; t < e.length; t++) {
                      var i = Math.trunc(t / 3),
                        n = t % 3;
                      this.setAtLeast(i, n, we.toDimensionValue(e.charAt(t)));
                    }
                  else if (3 === arguments.length) {
                    var s = arguments[0],
                      r = arguments[1],
                      a = arguments[2];
                    this._matrix[s][r] < a && (this._matrix[s][r] = a);
                  }
                },
              },
              {
                key: "setAtLeastIfValid",
                value: function (e, t, i) {
                  e >= 0 && t >= 0 && this.setAtLeast(e, t, i);
                },
              },
              {
                key: "isWithin",
                value: function () {
                  return (
                    t.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                    this._matrix[W.INTERIOR][W.EXTERIOR] === we.FALSE &&
                    this._matrix[W.BOUNDARY][W.EXTERIOR] === we.FALSE
                  );
                },
              },
              {
                key: "isTouches",
                value: function (e, i) {
                  return e > i
                    ? this.isTouches(i, e)
                    : ((e === we.A && i === we.A) ||
                        (e === we.L && i === we.L) ||
                        (e === we.L && i === we.A) ||
                        (e === we.P && i === we.A) ||
                        (e === we.P && i === we.L)) &&
                        this._matrix[W.INTERIOR][W.INTERIOR] === we.FALSE &&
                        (t.isTrue(this._matrix[W.INTERIOR][W.BOUNDARY]) ||
                          t.isTrue(this._matrix[W.BOUNDARY][W.INTERIOR]) ||
                          t.isTrue(this._matrix[W.BOUNDARY][W.BOUNDARY]));
                },
              },
              {
                key: "isOverlaps",
                value: function (e, i) {
                  return (e === we.P && i === we.P) ||
                    (e === we.A && i === we.A)
                    ? t.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                        t.isTrue(this._matrix[W.INTERIOR][W.EXTERIOR]) &&
                        t.isTrue(this._matrix[W.EXTERIOR][W.INTERIOR])
                    : e === we.L &&
                        i === we.L &&
                        1 === this._matrix[W.INTERIOR][W.INTERIOR] &&
                        t.isTrue(this._matrix[W.INTERIOR][W.EXTERIOR]) &&
                        t.isTrue(this._matrix[W.EXTERIOR][W.INTERIOR]);
                },
              },
              {
                key: "isEquals",
                value: function (e, i) {
                  return (
                    e === i &&
                    t.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                    this._matrix[W.INTERIOR][W.EXTERIOR] === we.FALSE &&
                    this._matrix[W.BOUNDARY][W.EXTERIOR] === we.FALSE &&
                    this._matrix[W.EXTERIOR][W.INTERIOR] === we.FALSE &&
                    this._matrix[W.EXTERIOR][W.BOUNDARY] === we.FALSE
                  );
                },
              },
              {
                key: "toString",
                value: function () {
                  for (var e = new Ze("123456789"), t = 0; t < 3; t++)
                    for (var i = 0; i < 3; i++)
                      e.setCharAt(
                        3 * t + i,
                        we.toDimensionSymbol(this._matrix[t][i])
                      );
                  return e.toString();
                },
              },
              {
                key: "setAll",
                value: function (e) {
                  for (var t = 0; t < 3; t++)
                    for (var i = 0; i < 3; i++) this._matrix[t][i] = e;
                },
              },
              {
                key: "get",
                value: function (e, t) {
                  return this._matrix[e][t];
                },
              },
              {
                key: "transpose",
                value: function () {
                  var e = this._matrix[1][0];
                  return (
                    (this._matrix[1][0] = this._matrix[0][1]),
                    (this._matrix[0][1] = e),
                    (e = this._matrix[2][0]),
                    (this._matrix[2][0] = this._matrix[0][2]),
                    (this._matrix[0][2] = e),
                    (e = this._matrix[2][1]),
                    (this._matrix[2][1] = this._matrix[1][2]),
                    (this._matrix[1][2] = e),
                    this
                  );
                },
              },
              {
                key: "matches",
                value: function (e) {
                  if (9 !== e.length) throw new A("Should be length 9: " + e);
                  for (var i = 0; i < 3; i++)
                    for (var n = 0; n < 3; n++)
                      if (!t.matches(this._matrix[i][n], e.charAt(3 * i + n)))
                        return !1;
                  return !0;
                },
              },
              {
                key: "add",
                value: function (e) {
                  for (var t = 0; t < 3; t++)
                    for (var i = 0; i < 3; i++)
                      this.setAtLeast(t, i, e.get(t, i));
                },
              },
              {
                key: "isDisjoint",
                value: function () {
                  return (
                    this._matrix[W.INTERIOR][W.INTERIOR] === we.FALSE &&
                    this._matrix[W.INTERIOR][W.BOUNDARY] === we.FALSE &&
                    this._matrix[W.BOUNDARY][W.INTERIOR] === we.FALSE &&
                    this._matrix[W.BOUNDARY][W.BOUNDARY] === we.FALSE
                  );
                },
              },
              {
                key: "isCrosses",
                value: function (e, i) {
                  return (e === we.P && i === we.L) ||
                    (e === we.P && i === we.A) ||
                    (e === we.L && i === we.A)
                    ? t.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                        t.isTrue(this._matrix[W.INTERIOR][W.EXTERIOR])
                    : (e === we.L && i === we.P) ||
                      (e === we.A && i === we.P) ||
                      (e === we.A && i === we.L)
                    ? t.isTrue(this._matrix[W.INTERIOR][W.INTERIOR]) &&
                      t.isTrue(this._matrix[W.EXTERIOR][W.INTERIOR])
                    : e === we.L &&
                      i === we.L &&
                      0 === this._matrix[W.INTERIOR][W.INTERIOR];
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [b];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (((this._matrix = null), 0 === arguments.length))
                    (this._matrix = Array(3)
                      .fill()
                      .map(function () {
                        return Array(3);
                      })),
                      this.setAll(we.FALSE);
                  else if (1 === arguments.length)
                    if ("string" == typeof arguments[0]) {
                      var e = arguments[0];
                      t.constructor_.call(this), this.set(e);
                    } else if (arguments[0] instanceof t) {
                      var i = arguments[0];
                      t.constructor_.call(this),
                        (this._matrix[W.INTERIOR][W.INTERIOR] =
                          i._matrix[W.INTERIOR][W.INTERIOR]),
                        (this._matrix[W.INTERIOR][W.BOUNDARY] =
                          i._matrix[W.INTERIOR][W.BOUNDARY]),
                        (this._matrix[W.INTERIOR][W.EXTERIOR] =
                          i._matrix[W.INTERIOR][W.EXTERIOR]),
                        (this._matrix[W.BOUNDARY][W.INTERIOR] =
                          i._matrix[W.BOUNDARY][W.INTERIOR]),
                        (this._matrix[W.BOUNDARY][W.BOUNDARY] =
                          i._matrix[W.BOUNDARY][W.BOUNDARY]),
                        (this._matrix[W.BOUNDARY][W.EXTERIOR] =
                          i._matrix[W.BOUNDARY][W.EXTERIOR]),
                        (this._matrix[W.EXTERIOR][W.INTERIOR] =
                          i._matrix[W.EXTERIOR][W.INTERIOR]),
                        (this._matrix[W.EXTERIOR][W.BOUNDARY] =
                          i._matrix[W.EXTERIOR][W.BOUNDARY]),
                        (this._matrix[W.EXTERIOR][W.EXTERIOR] =
                          i._matrix[W.EXTERIOR][W.EXTERIOR]);
                    }
                },
              },
              {
                key: "matches",
                value: function () {
                  if (
                    Number.isInteger(arguments[0]) &&
                    "string" == typeof arguments[1]
                  ) {
                    var e = arguments[0],
                      i = arguments[1];
                    return (
                      i === we.SYM_DONTCARE ||
                      (i === we.SYM_TRUE && (e >= 0 || e === we.TRUE)) ||
                      (i === we.SYM_FALSE && e === we.FALSE) ||
                      (i === we.SYM_P && e === we.P) ||
                      (i === we.SYM_L && e === we.L) ||
                      (i === we.SYM_A && e === we.A)
                    );
                  }
                  if (
                    "string" == typeof arguments[0] &&
                    "string" == typeof arguments[1]
                  ) {
                    var n = arguments[1];
                    return new t(arguments[0]).matches(n);
                  }
                },
              },
              {
                key: "isTrue",
                value: function (e) {
                  return e >= 0 || e === we.TRUE;
                },
              },
            ]
          ),
          t
        );
      })(),
      $i = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "size",
                value: function () {
                  return this._size;
                },
              },
              {
                key: "addAll",
                value: function (e) {
                  return null === e || 0 === e.length
                    ? null
                    : (this.ensureCapacity(this._size + e.length),
                      Ae.arraycopy(e, 0, this._data, this._size, e.length),
                      void (this._size += e.length));
                },
              },
              {
                key: "ensureCapacity",
                value: function (e) {
                  if (e <= this._data.length) return null;
                  var t = Math.max(e, 2 * this._data.length);
                  this._data = Fe.copyOf(this._data, t);
                },
              },
              {
                key: "toArray",
                value: function () {
                  var e = new Array(this._size).fill(null);
                  return Ae.arraycopy(this._data, 0, e, 0, this._size), e;
                },
              },
              {
                key: "add",
                value: function (e) {
                  this.ensureCapacity(this._size + 1),
                    (this._data[this._size] = e),
                    ++this._size;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._data = null),
                    (this._size = 0),
                    0 === arguments.length)
                  )
                    t.constructor_.call(this, 10);
                  else if (1 === arguments.length) {
                    var e = arguments[0];
                    this._data = new Array(e).fill(null);
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      en = (function () {
        function t() {
          e(this, t);
        }
        return (
          i(
            t,
            [
              {
                key: "getChainStartIndices",
                value: function (e) {
                  var t = 0,
                    i = new $i(Math.trunc(e.length / 2));
                  i.add(t);
                  do {
                    var n = this.findChainEnd(e, t);
                    i.add(n), (t = n);
                  } while (t < e.length - 1);
                  return i.toArray();
                },
              },
              {
                key: "findChainEnd",
                value: function (e, t) {
                  for (
                    var i = Xt.quadrant(e[t], e[t + 1]), n = t + 1;
                    n < e.length && Xt.quadrant(e[n - 1], e[n]) === i;

                  )
                    n++;
                  return n - 1;
                },
              },
              {
                key: "OLDgetChainStartIndices",
                value: function (e) {
                  var i = 0,
                    n = new me();
                  n.add(i);
                  do {
                    var s = this.findChainEnd(e, i);
                    n.add(s), (i = s);
                  } while (i < e.length - 1);
                  return t.toIntArray(n);
                },
              },
            ],
            [
              {
                key: "toIntArray",
                value: function (e) {
                  for (
                    var t = new Array(e.size()).fill(null), i = 0;
                    i < t.length;
                    i++
                  )
                    t[i] = e.get(i).intValue();
                  return t;
                },
              },
            ]
          ),
          t
        );
      })(),
      tn = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getCoordinates",
                value: function () {
                  return this.pts;
                },
              },
              {
                key: "getMaxX",
                value: function (e) {
                  var t = this.pts[this.startIndex[e]].x,
                    i = this.pts[this.startIndex[e + 1]].x;
                  return t > i ? t : i;
                },
              },
              {
                key: "getMinX",
                value: function (e) {
                  var t = this.pts[this.startIndex[e]].x,
                    i = this.pts[this.startIndex[e + 1]].x;
                  return t < i ? t : i;
                },
              },
              {
                key: "computeIntersectsForChain",
                value: function () {
                  if (4 === arguments.length) {
                    var e = arguments[0],
                      t = arguments[1],
                      i = arguments[2],
                      n = arguments[3];
                    this.computeIntersectsForChain(
                      this.startIndex[e],
                      this.startIndex[e + 1],
                      t,
                      t.startIndex[i],
                      t.startIndex[i + 1],
                      n
                    );
                  } else if (6 === arguments.length) {
                    var s = arguments[0],
                      r = arguments[1],
                      a = arguments[2],
                      o = arguments[3],
                      l = arguments[4],
                      h = arguments[5];
                    if (r - s == 1 && l - o == 1)
                      return h.addIntersections(this.e, s, a.e, o), null;
                    if (!this.overlaps(s, r, a, o, l)) return null;
                    var c = Math.trunc((s + r) / 2),
                      u = Math.trunc((o + l) / 2);
                    s < c &&
                      (o < u &&
                        this.computeIntersectsForChain(s, c, a, o, u, h),
                      u < l &&
                        this.computeIntersectsForChain(s, c, a, u, l, h)),
                      c < r &&
                        (o < u &&
                          this.computeIntersectsForChain(c, r, a, o, u, h),
                        u < l &&
                          this.computeIntersectsForChain(c, r, a, u, l, h));
                  }
                },
              },
              {
                key: "overlaps",
                value: function (e, t, i, n, s) {
                  return H.intersects(
                    this.pts[e],
                    this.pts[t],
                    i.pts[n],
                    i.pts[s]
                  );
                },
              },
              {
                key: "getStartIndexes",
                value: function () {
                  return this.startIndex;
                },
              },
              {
                key: "computeIntersects",
                value: function (e, t) {
                  for (var i = 0; i < this.startIndex.length - 1; i++)
                    for (var n = 0; n < e.startIndex.length - 1; n++)
                      this.computeIntersectsForChain(i, e, n, t);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this.e = null), (this.pts = null), (this.startIndex = null);
                  var e = arguments[0];
                  (this.e = e), (this.pts = e.getCoordinates());
                  var t = new en();
                  this.startIndex = t.getChainStartIndices(this.pts);
                },
              },
            ]
          ),
          t
        );
      })(),
      nn = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "getDepth",
                value: function (e, t) {
                  return this._depth[e][t];
                },
              },
              {
                key: "setDepth",
                value: function (e, t, i) {
                  this._depth[e][t] = i;
                },
              },
              {
                key: "isNull",
                value: function () {
                  if (0 === arguments.length) {
                    for (var e = 0; e < 2; e++)
                      for (var i = 0; i < 3; i++)
                        if (this._depth[e][i] !== t.NULL_VALUE) return !1;
                    return !0;
                  }
                  if (1 === arguments.length) {
                    var n = arguments[0];
                    return this._depth[n][1] === t.NULL_VALUE;
                  }
                  if (2 === arguments.length) {
                    var s = arguments[0],
                      r = arguments[1];
                    return this._depth[s][r] === t.NULL_VALUE;
                  }
                },
              },
              {
                key: "normalize",
                value: function () {
                  for (var e = 0; e < 2; e++)
                    if (!this.isNull(e)) {
                      var t = this._depth[e][1];
                      this._depth[e][2] < t && (t = this._depth[e][2]),
                        t < 0 && (t = 0);
                      for (var i = 1; i < 3; i++) {
                        var n = 0;
                        this._depth[e][i] > t && (n = 1),
                          (this._depth[e][i] = n);
                      }
                    }
                },
              },
              {
                key: "getDelta",
                value: function (e) {
                  return this._depth[e][$.RIGHT] - this._depth[e][$.LEFT];
                },
              },
              {
                key: "getLocation",
                value: function (e, t) {
                  return this._depth[e][t] <= 0 ? W.EXTERIOR : W.INTERIOR;
                },
              },
              {
                key: "toString",
                value: function () {
                  return (
                    "A: " +
                    this._depth[0][1] +
                    "," +
                    this._depth[0][2] +
                    " B: " +
                    this._depth[1][1] +
                    "," +
                    this._depth[1][2]
                  );
                },
              },
              {
                key: "add",
                value: function () {
                  if (1 === arguments.length)
                    for (var e = arguments[0], i = 0; i < 2; i++)
                      for (var n = 1; n < 3; n++) {
                        var s = e.getLocation(i, n);
                        (s !== W.EXTERIOR && s !== W.INTERIOR) ||
                          (this.isNull(i, n)
                            ? (this._depth[i][n] = t.depthAtLocation(s))
                            : (this._depth[i][n] += t.depthAtLocation(s)));
                      }
                  else if (3 === arguments.length) {
                    var r = arguments[0],
                      a = arguments[1];
                    arguments[2] === W.INTERIOR && this._depth[r][a]++;
                  }
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  this._depth = Array(2)
                    .fill()
                    .map(function () {
                      return Array(3);
                    });
                  for (var e = 0; e < 2; e++)
                    for (var i = 0; i < 3; i++)
                      this._depth[e][i] = t.NULL_VALUE;
                },
              },
              {
                key: "depthAtLocation",
                value: function (e) {
                  return e === W.EXTERIOR
                    ? 0
                    : e === W.INTERIOR
                    ? 1
                    : t.NULL_VALUE;
                },
              },
            ]
          ),
          t
        );
      })();
    nn.NULL_VALUE = -1;
    var sn = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "getDepth",
                value: function () {
                  return this._depth;
                },
              },
              {
                key: "getCollapsedEdge",
                value: function () {
                  var e = new Array(2).fill(null);
                  return (
                    (e[0] = this.pts[0]),
                    (e[1] = this.pts[1]),
                    new a(e, Ft.toLineLabel(this._label))
                  );
                },
              },
              {
                key: "isIsolated",
                value: function () {
                  return this._isIsolated;
                },
              },
              {
                key: "getCoordinates",
                value: function () {
                  return this.pts;
                },
              },
              {
                key: "setIsolated",
                value: function (e) {
                  this._isIsolated = e;
                },
              },
              {
                key: "setName",
                value: function (e) {
                  this._name = e;
                },
              },
              {
                key: "equals",
                value: function (e) {
                  if (!(e instanceof a)) return !1;
                  var t = e;
                  if (this.pts.length !== t.pts.length) return !1;
                  for (
                    var i = !0, n = !0, s = this.pts.length, r = 0;
                    r < this.pts.length;
                    r++
                  )
                    if (
                      (this.pts[r].equals2D(t.pts[r]) || (i = !1),
                      this.pts[r].equals2D(t.pts[--s]) || (n = !1),
                      !i && !n)
                    )
                      return !1;
                  return !0;
                },
              },
              {
                key: "getCoordinate",
                value: function () {
                  if (0 === arguments.length)
                    return this.pts.length > 0 ? this.pts[0] : null;
                  if (1 === arguments.length) {
                    var e = arguments[0];
                    return this.pts[e];
                  }
                },
              },
              {
                key: "print",
                value: function (e) {
                  e.print("edge " + this._name + ": "), e.print("LINESTRING (");
                  for (var t = 0; t < this.pts.length; t++)
                    t > 0 && e.print(","),
                      e.print(this.pts[t].x + " " + this.pts[t].y);
                  e.print(")  " + this._label + " " + this._depthDelta);
                },
              },
              {
                key: "computeIM",
                value: function (e) {
                  a.updateIM(this._label, e);
                },
              },
              {
                key: "isCollapsed",
                value: function () {
                  return (
                    !!this._label.isArea() &&
                    3 === this.pts.length &&
                    !!this.pts[0].equals(this.pts[2])
                  );
                },
              },
              {
                key: "isClosed",
                value: function () {
                  return this.pts[0].equals(this.pts[this.pts.length - 1]);
                },
              },
              {
                key: "getMaximumSegmentIndex",
                value: function () {
                  return this.pts.length - 1;
                },
              },
              {
                key: "getDepthDelta",
                value: function () {
                  return this._depthDelta;
                },
              },
              {
                key: "getNumPoints",
                value: function () {
                  return this.pts.length;
                },
              },
              {
                key: "printReverse",
                value: function (e) {
                  e.print("edge " + this._name + ": ");
                  for (var t = this.pts.length - 1; t >= 0; t--)
                    e.print(this.pts[t] + " ");
                  e.println("");
                },
              },
              {
                key: "getMonotoneChainEdge",
                value: function () {
                  return (
                    null === this._mce && (this._mce = new tn(this)), this._mce
                  );
                },
              },
              {
                key: "getEnvelope",
                value: function () {
                  if (null === this._env) {
                    this._env = new H();
                    for (var e = 0; e < this.pts.length; e++)
                      this._env.expandToInclude(this.pts[e]);
                  }
                  return this._env;
                },
              },
              {
                key: "addIntersection",
                value: function (e, t, i, n) {
                  var s = new V(e.getIntersection(n)),
                    r = t,
                    a = e.getEdgeDistance(i, n),
                    o = r + 1;
                  if (o < this.pts.length) {
                    var l = this.pts[o];
                    s.equals2D(l) && ((r = o), (a = 0));
                  }
                  this.eiList.add(s, r, a);
                },
              },
              {
                key: "toString",
                value: function () {
                  var e = new Ze();
                  e.append("edge " + this._name + ": "),
                    e.append("LINESTRING (");
                  for (var t = 0; t < this.pts.length; t++)
                    t > 0 && e.append(","),
                      e.append(this.pts[t].x + " " + this.pts[t].y);
                  return (
                    e.append(")  " + this._label + " " + this._depthDelta),
                    e.toString()
                  );
                },
              },
              {
                key: "isPointwiseEqual",
                value: function (e) {
                  if (this.pts.length !== e.pts.length) return !1;
                  for (var t = 0; t < this.pts.length; t++)
                    if (!this.pts[t].equals2D(e.pts[t])) return !1;
                  return !0;
                },
              },
              {
                key: "setDepthDelta",
                value: function (e) {
                  this._depthDelta = e;
                },
              },
              {
                key: "getEdgeIntersectionList",
                value: function () {
                  return this.eiList;
                },
              },
              {
                key: "addIntersections",
                value: function (e, t, i) {
                  for (var n = 0; n < e.getIntersectionNum(); n++)
                    this.addIntersection(e, t, i, n);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this.pts = null),
                    (this._env = null),
                    (this.eiList = new Zi(this)),
                    (this._name = null),
                    (this._mce = null),
                    (this._isIsolated = !0),
                    (this._depth = new nn()),
                    (this._depthDelta = 0),
                    1 === arguments.length)
                  ) {
                    var e = arguments[0];
                    a.constructor_.call(this, e, null);
                  } else if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    (this.pts = t), (this._label = i);
                  }
                },
              },
              {
                key: "updateIM",
                value: function () {
                  if (
                    !(
                      2 === arguments.length &&
                      arguments[1] instanceof Ji &&
                      arguments[0] instanceof Ft
                    )
                  )
                    return d(s(a), "updateIM", this).apply(this, arguments);
                  var e = arguments[0],
                    t = arguments[1];
                  t.setAtLeastIfValid(
                    e.getLocation(0, $.ON),
                    e.getLocation(1, $.ON),
                    1
                  ),
                    e.isArea() &&
                      (t.setAtLeastIfValid(
                        e.getLocation(0, $.LEFT),
                        e.getLocation(1, $.LEFT),
                        2
                      ),
                      t.setAtLeastIfValid(
                        e.getLocation(0, $.RIGHT),
                        e.getLocation(1, $.RIGHT),
                        2
                      ));
                },
              },
            ]
          ),
          a
        );
      })(Ot),
      rn = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "setWorkingPrecisionModel",
                value: function (e) {
                  this._workingPrecisionModel = e;
                },
              },
              {
                key: "insertUniqueEdge",
                value: function (e) {
                  var i = this._edgeList.findEqualEdge(e);
                  if (null !== i) {
                    var n = i.getLabel(),
                      s = e.getLabel();
                    i.isPointwiseEqual(e) || (s = new Ft(e.getLabel())).flip(),
                      n.merge(s);
                    var r = t.depthDelta(s),
                      a = i.getDepthDelta() + r;
                    i.setDepthDelta(a);
                  } else
                    this._edgeList.add(e),
                      e.setDepthDelta(t.depthDelta(e.getLabel()));
                },
              },
              {
                key: "buildSubgraphs",
                value: function (e, t) {
                  for (var i = new me(), n = e.iterator(); n.hasNext(); ) {
                    var s = n.next(),
                      r = s.getRightmostCoordinate(),
                      a = new Fi(i).getDepth(r);
                    s.computeDepth(a),
                      s.findResultEdges(),
                      i.add(s),
                      t.add(s.getDirectedEdges(), s.getNodes());
                  }
                },
              },
              {
                key: "createSubgraphs",
                value: function (e) {
                  for (
                    var t = new me(), i = e.getNodes().iterator();
                    i.hasNext();

                  ) {
                    var n = i.next();
                    if (!n.isVisited()) {
                      var s = new _e();
                      s.create(n), t.add(s);
                    }
                  }
                  return ri.sort(t, ri.reverseOrder()), t;
                },
              },
              {
                key: "createEmptyResultGeometry",
                value: function () {
                  return this._geomFact.createPolygon();
                },
              },
              {
                key: "getNoder",
                value: function (e) {
                  if (null !== this._workingNoder) return this._workingNoder;
                  var t = new wi(),
                    i = new Rt();
                  return (
                    i.setPrecisionModel(e),
                    t.setSegmentIntersector(new Yi(i)),
                    t
                  );
                },
              },
              {
                key: "buffer",
                value: function (e, t) {
                  var i = this._workingPrecisionModel;
                  null === i && (i = e.getPrecisionModel()),
                    (this._geomFact = e.getFactory());
                  var n = new Li(i, this._bufParams),
                    s = new Ui(e, t, n).getCurves();
                  if (s.size() <= 0) return this.createEmptyResultGeometry();
                  this.computeNodedEdges(s, i),
                    (this._graph = new Jt(new ji())),
                    this._graph.addEdges(this._edgeList.getEdges());
                  var r = this.createSubgraphs(this._graph),
                    a = new $t(this._geomFact);
                  this.buildSubgraphs(r, a);
                  var o = a.getPolygons();
                  return o.size() <= 0
                    ? this.createEmptyResultGeometry()
                    : this._geomFact.buildGeometry(o);
                },
              },
              {
                key: "computeNodedEdges",
                value: function (e, t) {
                  var i = this.getNoder(t);
                  i.computeNodes(e);
                  for (
                    var n = i.getNodedSubstrings().iterator();
                    n.hasNext();

                  ) {
                    var s = n.next(),
                      r = s.getCoordinates();
                    if (2 !== r.length || !r[0].equals2D(r[1])) {
                      var a = s.getData(),
                        o = new sn(s.getCoordinates(), new Ft(a));
                      this.insertUniqueEdge(o);
                    }
                  }
                },
              },
              {
                key: "setNoder",
                value: function (e) {
                  this._workingNoder = e;
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._bufParams = null),
                    (this._workingPrecisionModel = null),
                    (this._workingNoder = null),
                    (this._geomFact = null),
                    (this._graph = null),
                    (this._edgeList = new qi());
                  var e = arguments[0];
                  this._bufParams = e;
                },
              },
              {
                key: "depthDelta",
                value: function (e) {
                  var t = e.getLocation(0, $.LEFT),
                    i = e.getLocation(0, $.RIGHT);
                  return t === W.INTERIOR && i === W.EXTERIOR
                    ? 1
                    : t === W.EXTERIOR && i === W.INTERIOR
                    ? -1
                    : 0;
                },
              },
              {
                key: "convertSegStrings",
                value: function (e) {
                  for (var t = new at(), i = new me(); e.hasNext(); ) {
                    var n = e.next(),
                      s = t.createLineString(n.getCoordinates());
                    i.add(s);
                  }
                  return t.buildGeometry(i);
                },
              },
            ]
          ),
          t
        );
      })(),
      an = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "rescale",
                value: function () {
                  if (se(arguments[0], q))
                    for (var e = arguments[0].iterator(); e.hasNext(); ) {
                      var t = e.next();
                      this.rescale(t.getCoordinates());
                    }
                  else if (arguments[0] instanceof Array) {
                    for (var i = arguments[0], n = 0; n < i.length; n++)
                      (i[n].x = i[n].x / this._scaleFactor + this._offsetX),
                        (i[n].y = i[n].y / this._scaleFactor + this._offsetY);
                    2 === i.length && i[0].equals2D(i[1]) && Ae.out.println(i);
                  }
                },
              },
              {
                key: "scale",
                value: function () {
                  if (se(arguments[0], q)) {
                    for (
                      var e = arguments[0],
                        t = new me(e.size()),
                        i = e.iterator();
                      i.hasNext();

                    ) {
                      var n = i.next();
                      t.add(
                        new yi(this.scale(n.getCoordinates()), n.getData())
                      );
                    }
                    return t;
                  }
                  if (arguments[0] instanceof Array) {
                    for (
                      var s = arguments[0],
                        r = new Array(s.length).fill(null),
                        a = 0;
                      a < s.length;
                      a++
                    )
                      r[a] = new V(
                        Math.round(
                          (s[a].x - this._offsetX) * this._scaleFactor
                        ),
                        Math.round(
                          (s[a].y - this._offsetY) * this._scaleFactor
                        ),
                        s[a].getZ()
                      );
                    return Xe.removeRepeatedPoints(r);
                  }
                },
              },
              {
                key: "isIntegerPrecision",
                value: function () {
                  return 1 === this._scaleFactor;
                },
              },
              {
                key: "getNodedSubstrings",
                value: function () {
                  var e = this._noder.getNodedSubstrings();
                  return this._isScaled && this.rescale(e), e;
                },
              },
              {
                key: "computeNodes",
                value: function (e) {
                  var t = e;
                  this._isScaled && (t = this.scale(e)),
                    this._noder.computeNodes(t);
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Ci];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._noder = null),
                    (this._scaleFactor = null),
                    (this._offsetX = null),
                    (this._offsetY = null),
                    (this._isScaled = !1),
                    2 === arguments.length)
                  ) {
                    var e = arguments[0],
                      i = arguments[1];
                    t.constructor_.call(this, e, i, 0, 0);
                  } else if (4 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1];
                    (this._noder = n),
                      (this._scaleFactor = s),
                      (this._isScaled = !this.isIntegerPrecision());
                  }
                },
              },
            ]
          ),
          t
        );
      })(),
      on = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "checkEndPtVertexIntersections",
                value: function () {
                  if (0 === arguments.length)
                    for (var e = this._segStrings.iterator(); e.hasNext(); ) {
                      var t = e.next().getCoordinates();
                      this.checkEndPtVertexIntersections(
                        t[0],
                        this._segStrings
                      ),
                        this.checkEndPtVertexIntersections(
                          t[t.length - 1],
                          this._segStrings
                        );
                    }
                  else if (2 === arguments.length)
                    for (
                      var i = arguments[0], n = arguments[1].iterator();
                      n.hasNext();

                    )
                      for (
                        var s = n.next().getCoordinates(), r = 1;
                        r < s.length - 1;
                        r++
                      )
                        if (s[r].equals(i))
                          throw new B(
                            "found endpt/interior pt intersection at index " +
                              r +
                              " :pt " +
                              i
                          );
                },
              },
              {
                key: "checkInteriorIntersections",
                value: function () {
                  if (0 === arguments.length)
                    for (var e = this._segStrings.iterator(); e.hasNext(); )
                      for (
                        var t = e.next(), i = this._segStrings.iterator();
                        i.hasNext();

                      ) {
                        var n = i.next();
                        this.checkInteriorIntersections(t, n);
                      }
                  else if (2 === arguments.length)
                    for (
                      var s = arguments[0],
                        r = arguments[1],
                        a = s.getCoordinates(),
                        o = r.getCoordinates(),
                        l = 0;
                      l < a.length - 1;
                      l++
                    )
                      for (var h = 0; h < o.length - 1; h++)
                        this.checkInteriorIntersections(s, l, r, h);
                  else if (4 === arguments.length) {
                    var c = arguments[0],
                      u = arguments[1],
                      d = arguments[2],
                      p = arguments[3];
                    if (c === d && u === p) return null;
                    var f = c.getCoordinates()[u],
                      m = c.getCoordinates()[u + 1],
                      g = d.getCoordinates()[p],
                      _ = d.getCoordinates()[p + 1];
                    if (
                      (this._li.computeIntersection(f, m, g, _),
                      this._li.hasIntersection() &&
                        (this._li.isProper() ||
                          this.hasInteriorIntersection(this._li, f, m) ||
                          this.hasInteriorIntersection(this._li, g, _)))
                    )
                      throw new B(
                        "found non-noded intersection at " +
                          f +
                          "-" +
                          m +
                          " and " +
                          g +
                          "-" +
                          _
                      );
                  }
                },
              },
              {
                key: "checkValid",
                value: function () {
                  this.checkEndPtVertexIntersections(),
                    this.checkInteriorIntersections(),
                    this.checkCollapses();
                },
              },
              {
                key: "checkCollapses",
                value: function () {
                  if (0 === arguments.length)
                    for (var e = this._segStrings.iterator(); e.hasNext(); ) {
                      var t = e.next();
                      this.checkCollapses(t);
                    }
                  else if (1 === arguments.length)
                    for (
                      var i = arguments[0].getCoordinates(), n = 0;
                      n < i.length - 2;
                      n++
                    )
                      this.checkCollapse(i[n], i[n + 1], i[n + 2]);
                },
              },
              {
                key: "hasInteriorIntersection",
                value: function (e, t, i) {
                  for (var n = 0; n < e.getIntersectionNum(); n++) {
                    var s = e.getIntersection(n);
                    if (!s.equals(t) && !s.equals(i)) return !0;
                  }
                  return !1;
                },
              },
              {
                key: "checkCollapse",
                value: function (e, i, n) {
                  if (e.equals(n))
                    throw new B(
                      "found non-noded collapse at " +
                        t.fact.createLineString([e, i, n])
                    );
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._li = new Rt()), (this._segStrings = null);
                  var e = arguments[0];
                  this._segStrings = e;
                },
              },
            ]
          ),
          t
        );
      })();
    on.fact = new at();
    var ln = (function () {
      function t() {
        e(this, t), t.constructor_.apply(this, arguments);
      }
      return (
        i(
          t,
          [
            {
              key: "intersectsScaled",
              value: function (e, t) {
                var i = Math.min(e.x, t.x),
                  n = Math.max(e.x, t.x),
                  s = Math.min(e.y, t.y),
                  r = Math.max(e.y, t.y),
                  a =
                    this._maxx < i ||
                    this._minx > n ||
                    this._maxy < s ||
                    this._miny > r;
                if (a) return !1;
                var o = this.intersectsToleranceSquare(e, t);
                return O.isTrue(!(a && o), "Found bad envelope test"), o;
              },
            },
            {
              key: "initCorners",
              value: function (e) {
                var t = 0.5;
                (this._minx = e.x - t),
                  (this._maxx = e.x + t),
                  (this._miny = e.y - t),
                  (this._maxy = e.y + t),
                  (this._corner[0] = new V(this._maxx, this._maxy)),
                  (this._corner[1] = new V(this._minx, this._maxy)),
                  (this._corner[2] = new V(this._minx, this._miny)),
                  (this._corner[3] = new V(this._maxx, this._miny));
              },
            },
            {
              key: "intersects",
              value: function (e, t) {
                return 1 === this._scaleFactor
                  ? this.intersectsScaled(e, t)
                  : (this.copyScaled(e, this._p0Scaled),
                    this.copyScaled(t, this._p1Scaled),
                    this.intersectsScaled(this._p0Scaled, this._p1Scaled));
              },
            },
            {
              key: "scale",
              value: function (e) {
                return Math.round(e * this._scaleFactor);
              },
            },
            {
              key: "getCoordinate",
              value: function () {
                return this._originalPt;
              },
            },
            {
              key: "copyScaled",
              value: function (e, t) {
                (t.x = this.scale(e.x)), (t.y = this.scale(e.y));
              },
            },
            {
              key: "getSafeEnvelope",
              value: function () {
                if (null === this._safeEnv) {
                  var e = t.SAFE_ENV_EXPANSION_FACTOR / this._scaleFactor;
                  this._safeEnv = new H(
                    this._originalPt.x - e,
                    this._originalPt.x + e,
                    this._originalPt.y - e,
                    this._originalPt.y + e
                  );
                }
                return this._safeEnv;
              },
            },
            {
              key: "intersectsPixelClosure",
              value: function (e, t) {
                return (
                  this._li.computeIntersection(
                    e,
                    t,
                    this._corner[0],
                    this._corner[1]
                  ),
                  !!(
                    this._li.hasIntersection() ||
                    (this._li.computeIntersection(
                      e,
                      t,
                      this._corner[1],
                      this._corner[2]
                    ),
                    this._li.hasIntersection() ||
                      (this._li.computeIntersection(
                        e,
                        t,
                        this._corner[2],
                        this._corner[3]
                      ),
                      this._li.hasIntersection() ||
                        (this._li.computeIntersection(
                          e,
                          t,
                          this._corner[3],
                          this._corner[0]
                        ),
                        this._li.hasIntersection())))
                  )
                );
              },
            },
            {
              key: "intersectsToleranceSquare",
              value: function (e, t) {
                var i = !1,
                  n = !1;
                return (
                  this._li.computeIntersection(
                    e,
                    t,
                    this._corner[0],
                    this._corner[1]
                  ),
                  !!(
                    this._li.isProper() ||
                    (this._li.computeIntersection(
                      e,
                      t,
                      this._corner[1],
                      this._corner[2]
                    ),
                    this._li.isProper() ||
                      (this._li.hasIntersection() && (i = !0),
                      this._li.computeIntersection(
                        e,
                        t,
                        this._corner[2],
                        this._corner[3]
                      ),
                      this._li.isProper() ||
                        (this._li.hasIntersection() && (n = !0),
                        this._li.computeIntersection(
                          e,
                          t,
                          this._corner[3],
                          this._corner[0]
                        ),
                        this._li.isProper() ||
                          (i && n) ||
                          e.equals(this._pt) ||
                          t.equals(this._pt))))
                  )
                );
              },
            },
            {
              key: "addSnappedNode",
              value: function (e, t) {
                var i = e.getCoordinate(t),
                  n = e.getCoordinate(t + 1);
                return (
                  !!this.intersects(i, n) &&
                  (e.addIntersection(this.getCoordinate(), t), !0)
                );
              },
            },
          ],
          [
            {
              key: "constructor_",
              value: function () {
                (this._li = null),
                  (this._pt = null),
                  (this._originalPt = null),
                  (this._ptScaled = null),
                  (this._p0Scaled = null),
                  (this._p1Scaled = null),
                  (this._scaleFactor = null),
                  (this._minx = null),
                  (this._maxx = null),
                  (this._miny = null),
                  (this._maxy = null),
                  (this._corner = new Array(4).fill(null)),
                  (this._safeEnv = null);
                var e = arguments[0],
                  t = arguments[1],
                  i = arguments[2];
                if (
                  ((this._originalPt = e),
                  (this._pt = e),
                  (this._scaleFactor = t),
                  (this._li = i),
                  t <= 0)
                )
                  throw new A("Scale factor must be non-zero");
                1 !== t &&
                  ((this._pt = new V(this.scale(e.x), this.scale(e.y))),
                  (this._p0Scaled = new V()),
                  (this._p1Scaled = new V())),
                  this.initCorners(this._pt);
              },
            },
          ]
        ),
        t
      );
    })();
    ln.SAFE_ENV_EXPANSION_FACTOR = 0.75;
    var hn = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "select",
                value: function () {
                  if (1 === arguments.length);
                  else if (2 === arguments.length) {
                    var e = arguments[1];
                    arguments[0].getLineSegment(e, this.selectedSegment),
                      this.select(this.selectedSegment);
                  }
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  this.selectedSegment = new xi();
                },
              },
            ]
          ),
          t
        );
      })(),
      cn = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "snap",
                value: function () {
                  if (1 === arguments.length) {
                    var t = arguments[0];
                    return this.snap(t, null, -1);
                  }
                  if (3 === arguments.length) {
                    var n = arguments[0],
                      s = arguments[1],
                      r = arguments[2],
                      a = n.getSafeEnvelope(),
                      o = new un(n, s, r);
                    return (
                      this._index.query(
                        a,
                        new ((function () {
                          function t() {
                            e(this, t);
                          }
                          return (
                            i(t, [
                              {
                                key: "interfaces_",
                                get: function () {
                                  return [li];
                                },
                              },
                              {
                                key: "visitItem",
                                value: function (e) {
                                  e.select(a, o);
                                },
                              },
                            ]),
                            t
                          );
                        })())()
                      ),
                      o.isNodeAdded()
                    );
                  }
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  this._index = null;
                  var e = arguments[0];
                  this._index = e;
                },
              },
            ]
          ),
          t
        );
      })(),
      un = (function (t) {
        n(a, t);
        var r = u(a);
        function a() {
          var t;
          return (
            e(this, a),
            (t = r.call(this)),
            a.constructor_.apply(h(t), arguments),
            t
          );
        }
        return (
          i(
            a,
            [
              {
                key: "isNodeAdded",
                value: function () {
                  return this._isNodeAdded;
                },
              },
              {
                key: "select",
                value: function () {
                  if (
                    !(
                      2 === arguments.length &&
                      Number.isInteger(arguments[1]) &&
                      arguments[0] instanceof Ei
                    )
                  )
                    return d(s(a.prototype), "select", this).apply(
                      this,
                      arguments
                    );
                  var e = arguments[1],
                    t = arguments[0].getContext();
                  if (
                    this._parentEdge === t &&
                    (e === this._hotPixelVertexIndex ||
                      e + 1 === this._hotPixelVertexIndex)
                  )
                    return null;
                  this._isNodeAdded |= this._hotPixel.addSnappedNode(t, e);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._hotPixel = null),
                    (this._parentEdge = null),
                    (this._hotPixelVertexIndex = null),
                    (this._isNodeAdded = !1);
                  var e = arguments[0],
                    t = arguments[1],
                    i = arguments[2];
                  (this._hotPixel = e),
                    (this._parentEdge = t),
                    (this._hotPixelVertexIndex = i);
                },
              },
            ]
          ),
          a
        );
      })(hn);
    cn.HotPixelSnapAction = un;
    var dn = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "processIntersections",
                value: function (e, t, i, n) {
                  if (e === i && t === n) return null;
                  var s = e.getCoordinates()[t],
                    r = e.getCoordinates()[t + 1],
                    a = i.getCoordinates()[n],
                    o = i.getCoordinates()[n + 1];
                  if (
                    (this._li.computeIntersection(s, r, a, o),
                    this._li.hasIntersection() &&
                      this._li.isInteriorIntersection())
                  ) {
                    for (var l = 0; l < this._li.getIntersectionNum(); l++)
                      this._interiorIntersections.add(
                        this._li.getIntersection(l)
                      );
                    e.addIntersections(this._li, t, 0),
                      i.addIntersections(this._li, n, 1);
                  }
                },
              },
              {
                key: "isDone",
                value: function () {
                  return !1;
                },
              },
              {
                key: "getInteriorIntersections",
                value: function () {
                  return this._interiorIntersections;
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Xi];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._li = null), (this._interiorIntersections = null);
                  var e = arguments[0];
                  (this._li = e), (this._interiorIntersections = new me());
                },
              },
            ]
          ),
          t
        );
      })(),
      pn = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "checkCorrectness",
                value: function (e) {
                  var t = yi.getNodedSubstrings(e),
                    i = new on(t);
                  try {
                    i.checkValid();
                  } catch (n) {
                    if (!(n instanceof v)) throw n;
                    n.printStackTrace();
                  }
                },
              },
              {
                key: "getNodedSubstrings",
                value: function () {
                  return yi.getNodedSubstrings(this._nodedSegStrings);
                },
              },
              {
                key: "snapRound",
                value: function (e, t) {
                  var i = this.findInteriorIntersections(e, t);
                  this.computeIntersectionSnaps(i), this.computeVertexSnaps(e);
                },
              },
              {
                key: "findInteriorIntersections",
                value: function (e, t) {
                  var i = new dn(t);
                  return (
                    this._noder.setSegmentIntersector(i),
                    this._noder.computeNodes(e),
                    i.getInteriorIntersections()
                  );
                },
              },
              {
                key: "computeVertexSnaps",
                value: function () {
                  if (se(arguments[0], q))
                    for (var e = arguments[0].iterator(); e.hasNext(); ) {
                      var t = e.next();
                      this.computeVertexSnaps(t);
                    }
                  else if (arguments[0] instanceof yi)
                    for (
                      var i = arguments[0], n = i.getCoordinates(), s = 0;
                      s < n.length;
                      s++
                    ) {
                      var r = new ln(n[s], this._scaleFactor, this._li);
                      this._pointSnapper.snap(r, i, s) &&
                        i.addIntersection(n[s], s);
                    }
                },
              },
              {
                key: "computeNodes",
                value: function (e) {
                  (this._nodedSegStrings = e),
                    (this._noder = new wi()),
                    (this._pointSnapper = new cn(this._noder.getIndex())),
                    this.snapRound(e, this._li);
                },
              },
              {
                key: "computeIntersectionSnaps",
                value: function (e) {
                  for (var t = e.iterator(); t.hasNext(); ) {
                    var i = t.next(),
                      n = new ln(i, this._scaleFactor, this._li);
                    this._pointSnapper.snap(n);
                  }
                },
              },
              {
                key: "interfaces_",
                get: function () {
                  return [Ci];
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  (this._pm = null),
                    (this._li = null),
                    (this._scaleFactor = null),
                    (this._noder = null),
                    (this._pointSnapper = null),
                    (this._nodedSegStrings = null);
                  var e = arguments[0];
                  (this._pm = e),
                    (this._li = new Rt()),
                    this._li.setPrecisionModel(e),
                    (this._scaleFactor = e.getScale());
                },
              },
            ]
          ),
          t
        );
      })(),
      fn = (function () {
        function t() {
          e(this, t), t.constructor_.apply(this, arguments);
        }
        return (
          i(
            t,
            [
              {
                key: "bufferFixedPrecision",
                value: function (e) {
                  var t = new an(new pn(new nt(1)), e.getScale()),
                    i = new rn(this._bufParams);
                  i.setWorkingPrecisionModel(e),
                    i.setNoder(t),
                    (this._resultGeometry = i.buffer(
                      this._argGeom,
                      this._distance
                    ));
                },
              },
              {
                key: "bufferReducedPrecision",
                value: function () {
                  if (0 === arguments.length) {
                    for (var e = t.MAX_PRECISION_DIGITS; e >= 0; e--) {
                      try {
                        this.bufferReducedPrecision(e);
                      } catch (r) {
                        if (!(r instanceof pe)) throw r;
                        this._saveException = r;
                      }
                      if (null !== this._resultGeometry) return null;
                    }
                    throw this._saveException;
                  }
                  if (1 === arguments.length) {
                    var i = arguments[0],
                      n = t.precisionScaleFactor(
                        this._argGeom,
                        this._distance,
                        i
                      ),
                      s = new nt(n);
                    this.bufferFixedPrecision(s);
                  }
                },
              },
              {
                key: "computeGeometry",
                value: function () {
                  if (
                    (this.bufferOriginalPrecision(),
                    null !== this._resultGeometry)
                  )
                    return null;
                  var e = this._argGeom.getFactory().getPrecisionModel();
                  e.getType() === nt.FIXED
                    ? this.bufferFixedPrecision(e)
                    : this.bufferReducedPrecision();
                },
              },
              {
                key: "setQuadrantSegments",
                value: function (e) {
                  this._bufParams.setQuadrantSegments(e);
                },
              },
              {
                key: "bufferOriginalPrecision",
                value: function () {
                  try {
                    var e = new rn(this._bufParams);
                    this._resultGeometry = e.buffer(
                      this._argGeom,
                      this._distance
                    );
                  } catch (t) {
                    if (!(t instanceof B)) throw t;
                    this._saveException = t;
                  }
                },
              },
              {
                key: "getResultGeometry",
                value: function (e) {
                  return (
                    (this._distance = e),
                    this.computeGeometry(),
                    this._resultGeometry
                  );
                },
              },
              {
                key: "setEndCapStyle",
                value: function (e) {
                  this._bufParams.setEndCapStyle(e);
                },
              },
            ],
            [
              {
                key: "constructor_",
                value: function () {
                  if (
                    ((this._argGeom = null),
                    (this._distance = null),
                    (this._bufParams = new _()),
                    (this._resultGeometry = null),
                    (this._saveException = null),
                    1 === arguments.length)
                  ) {
                    var e = arguments[0];
                    this._argGeom = e;
                  } else if (2 === arguments.length) {
                    var t = arguments[0],
                      i = arguments[1];
                    (this._argGeom = t), (this._bufParams = i);
                  }
                },
              },
              {
                key: "bufferOp",
                value: function () {
                  if (2 === arguments.length) {
                    var e = arguments[1];
                    return new t(arguments[0]).getResultGeometry(e);
                  }
                  if (3 === arguments.length) {
                    if (
                      Number.isInteger(arguments[2]) &&
                      arguments[0] instanceof j &&
                      "number" == typeof arguments[1]
                    ) {
                      var i = arguments[1],
                        n = arguments[2],
                        s = new t(arguments[0]);
                      return s.setQuadrantSegments(n), s.getResultGeometry(i);
                    }
                    if (
                      arguments[2] instanceof _ &&
                      arguments[0] instanceof j &&
                      "number" == typeof arguments[1]
                    ) {
                      var r = arguments[1];
                      return new t(
                        arguments[0],
                        arguments[2]
                      ).getResultGeometry(r);
                    }
                  } else if (4 === arguments.length) {
                    var a = arguments[1],
                      o = arguments[2],
                      l = arguments[3],
                      h = new t(arguments[0]);
                    return (
                      h.setQuadrantSegments(o),
                      h.setEndCapStyle(l),
                      h.getResultGeometry(a)
                    );
                  }
                },
              },
              {
                key: "precisionScaleFactor",
                value: function (e, t, i) {
                  var n = e.getEnvelopeInternal(),
                    s =
                      ye.max(
                        Math.abs(n.getMaxX()),
                        Math.abs(n.getMaxY()),
                        Math.abs(n.getMinX()),
                        Math.abs(n.getMinY())
                      ) +
                      2 * (t > 0 ? t : 0),
                    r = i - Math.trunc(Math.log(s) / Math.log(10) + 1);
                  return Math.pow(10, r);
                },
              },
            ]
          ),
          t
        );
      })();
    (fn.CAP_ROUND = _.CAP_ROUND),
      (fn.CAP_BUTT = _.CAP_FLAT),
      (fn.CAP_FLAT = _.CAP_FLAT),
      (fn.CAP_SQUARE = _.CAP_SQUARE),
      (fn.MAX_PRECISION_DIGITS = 12);
    var mn = [
        "Point",
        "MultiPoint",
        "LineString",
        "MultiLineString",
        "Polygon",
        "MultiPolygon",
      ],
      gn = (function () {
        function t(i) {
          e(this, t), (this.geometryFactory = i || new at());
        }
        return (
          i(t, [
            {
              key: "read",
              value: function (e) {
                var t,
                  i = (t = "string" == typeof e ? JSON.parse(e) : e).type;
                if (!_n[i]) throw new Error("Unknown GeoJSON type: " + t.type);
                return -1 !== mn.indexOf(i)
                  ? _n[i].call(this, t.coordinates)
                  : "GeometryCollection" === i
                  ? _n[i].call(this, t.geometries)
                  : _n[i].call(this, t);
              },
            },
            {
              key: "write",
              value: function (e) {
                var t = e.getGeometryType();
                if (!vn[t]) throw new Error("Geometry is not supported");
                return vn[t].call(this, e);
              },
            },
          ]),
          t
        );
      })(),
      _n = {
        Feature: function (e) {
          var t = {};
          for (var i in e) t[i] = e[i];
          if (e.geometry) {
            var n = e.geometry.type;
            if (!_n[n]) throw new Error("Unknown GeoJSON type: " + e.type);
            t.geometry = this.read(e.geometry);
          }
          return e.bbox && (t.bbox = _n.bbox.call(this, e.bbox)), t;
        },
        FeatureCollection: function (e) {
          var t = {};
          if (e.features) {
            t.features = [];
            for (var i = 0; i < e.features.length; ++i)
              t.features.push(this.read(e.features[i]));
          }
          return e.bbox && (t.bbox = this.parse.bbox.call(this, e.bbox)), t;
        },
        coordinates: function (e) {
          for (var t = [], i = 0; i < e.length; ++i) {
            var n = e[i];
            t.push(o(V, p(n)));
          }
          return t;
        },
        bbox: function (e) {
          return this.geometryFactory.createLinearRing([
            new V(e[0], e[1]),
            new V(e[2], e[1]),
            new V(e[2], e[3]),
            new V(e[0], e[3]),
            new V(e[0], e[1]),
          ]);
        },
        Point: function (e) {
          var t = o(V, p(e));
          return this.geometryFactory.createPoint(t);
        },
        MultiPoint: function (e) {
          for (var t = [], i = 0; i < e.length; ++i)
            t.push(_n.Point.call(this, e[i]));
          return this.geometryFactory.createMultiPoint(t);
        },
        LineString: function (e) {
          var t = _n.coordinates.call(this, e);
          return this.geometryFactory.createLineString(t);
        },
        MultiLineString: function (e) {
          for (var t = [], i = 0; i < e.length; ++i)
            t.push(_n.LineString.call(this, e[i]));
          return this.geometryFactory.createMultiLineString(t);
        },
        Polygon: function (e) {
          for (
            var t = _n.coordinates.call(this, e[0]),
              i = this.geometryFactory.createLinearRing(t),
              n = [],
              s = 1;
            s < e.length;
            ++s
          ) {
            var r = e[s],
              a = _n.coordinates.call(this, r),
              o = this.geometryFactory.createLinearRing(a);
            n.push(o);
          }
          return this.geometryFactory.createPolygon(i, n);
        },
        MultiPolygon: function (e) {
          for (var t = [], i = 0; i < e.length; ++i) {
            var n = e[i];
            t.push(_n.Polygon.call(this, n));
          }
          return this.geometryFactory.createMultiPolygon(t);
        },
        GeometryCollection: function (e) {
          for (var t = [], i = 0; i < e.length; ++i) {
            var n = e[i];
            t.push(this.read(n));
          }
          return this.geometryFactory.createGeometryCollection(t);
        },
      },
      vn = {
        coordinate: function (e) {
          var t = [e.x, e.y];
          return e.z && t.push(e.z), e.m && t.push(e.m), t;
        },
        Point: function (e) {
          return {
            type: "Point",
            coordinates: vn.coordinate.call(this, e.getCoordinate()),
          };
        },
        MultiPoint: function (e) {
          for (var t = [], i = 0; i < e._geometries.length; ++i) {
            var n = e._geometries[i],
              s = vn.Point.call(this, n);
            t.push(s.coordinates);
          }
          return { type: "MultiPoint", coordinates: t };
        },
        LineString: function (e) {
          for (var t = [], i = e.getCoordinates(), n = 0; n < i.length; ++n) {
            var s = i[n];
            t.push(vn.coordinate.call(this, s));
          }
          return { type: "LineString", coordinates: t };
        },
        MultiLineString: function (e) {
          for (var t = [], i = 0; i < e._geometries.length; ++i) {
            var n = e._geometries[i],
              s = vn.LineString.call(this, n);
            t.push(s.coordinates);
          }
          return { type: "MultiLineString", coordinates: t };
        },
        Polygon: function (e) {
          var t = [],
            i = vn.LineString.call(this, e._shell);
          t.push(i.coordinates);
          for (var n = 0; n < e._holes.length; ++n) {
            var s = e._holes[n],
              r = vn.LineString.call(this, s);
            t.push(r.coordinates);
          }
          return { type: "Polygon", coordinates: t };
        },
        MultiPolygon: function (e) {
          for (var t = [], i = 0; i < e._geometries.length; ++i) {
            var n = e._geometries[i],
              s = vn.Polygon.call(this, n);
            t.push(s.coordinates);
          }
          return { type: "MultiPolygon", coordinates: t };
        },
        GeometryCollection: function (e) {
          for (var t = [], i = 0; i < e._geometries.length; ++i) {
            var n = e._geometries[i],
              s = n.getGeometryType();
            t.push(vn[s].call(this, n));
          }
          return { type: "GeometryCollection", geometries: t };
        },
      };
    return {
      BufferOp: fn,
      GeoJSONReader: (function () {
        function t(i) {
          e(this, t), (this.parser = new gn(i || new at()));
        }
        return (
          i(t, [
            {
              key: "read",
              value: function (e) {
                return this.parser.read(e);
              },
            },
          ]),
          t
        );
      })(),
      GeoJSONWriter: (function () {
        function t() {
          e(this, t), (this.parser = new gn(this.geometryFactory));
        }
        return (
          i(t, [
            {
              key: "write",
              value: function (e) {
                return this.parser.write(e);
              },
            },
          ]),
          t
        );
      })(),
    };
  })();
})(KL),
  (JL.prototype = {
    constructor: JL,
    reset: function () {
      this.s = this.t = 0;
    },
    add: function (e) {
      eF($L, e, this.t),
        eF(this, $L.s, this.s),
        this.s ? (this.t += $L.t) : (this.s = $L.t);
    },
    valueOf: function () {
      return this.s;
    },
  });
var $L = new JL();
function eF(e, t, i) {
  var n = (e.s = t + i),
    s = n - t,
    r = n - s;
  e.t = t - r + (i - s);
}
var tF = 1e-6,
  iF = Math.PI,
  nF = iF / 2,
  sF = iF / 4,
  rF = 2 * iF,
  aF = 180 / iF,
  oF = iF / 180,
  lF = Math.abs,
  hF = Math.atan,
  cF = Math.atan2,
  uF = Math.cos,
  dF = Math.sin,
  pF = Math.sqrt;
function fF(e) {
  return e > 1 ? 0 : e < -1 ? iF : Math.acos(e);
}
function mF(e) {
  return e > 1 ? nF : e < -1 ? -nF : Math.asin(e);
}
function gF() {}
function _F(e, t) {
  e && xF.hasOwnProperty(e.type) && xF[e.type](e, t);
}
var vF,
  AF,
  yF = {
    Feature: function (e, t) {
      _F(e.geometry, t);
    },
    FeatureCollection: function (e, t) {
      for (var i = e.features, n = -1, s = i.length; ++n < s; )
        _F(i[n].geometry, t);
    },
  },
  xF = {
    Sphere: function (e, t) {
      t.sphere();
    },
    Point: function (e, t) {
      (e = e.coordinates), t.point(e[0], e[1], e[2]);
    },
    MultiPoint: function (e, t) {
      for (var i = e.coordinates, n = -1, s = i.length; ++n < s; )
        (e = i[n]), t.point(e[0], e[1], e[2]);
    },
    LineString: function (e, t) {
      bF(e.coordinates, t, 0);
    },
    MultiLineString: function (e, t) {
      for (var i = e.coordinates, n = -1, s = i.length; ++n < s; )
        bF(i[n], t, 0);
    },
    Polygon: function (e, t) {
      EF(e.coordinates, t);
    },
    MultiPolygon: function (e, t) {
      for (var i = e.coordinates, n = -1, s = i.length; ++n < s; ) EF(i[n], t);
    },
    GeometryCollection: function (e, t) {
      for (var i = e.geometries, n = -1, s = i.length; ++n < s; ) _F(i[n], t);
    },
  };
function bF(e, t, i) {
  var n,
    s = -1,
    r = e.length - i;
  for (t.lineStart(); ++s < r; ) (n = e[s]), t.point(n[0], n[1], n[2]);
  t.lineEnd();
}
function EF(e, t) {
  var i = -1,
    n = e.length;
  for (t.polygonStart(); ++i < n; ) bF(e[i], t, 1);
  t.polygonEnd();
}
function SF(e) {
  return [cF(e[1], e[0]), mF(e[2])];
}
function CF(e) {
  var t = e[0],
    i = e[1],
    n = uF(i);
  return [n * uF(t), n * dF(t), dF(i)];
}
function MF(e, t) {
  return e[0] * t[0] + e[1] * t[1] + e[2] * t[2];
}
function wF(e, t) {
  return [
    e[1] * t[2] - e[2] * t[1],
    e[2] * t[0] - e[0] * t[2],
    e[0] * t[1] - e[1] * t[0],
  ];
}
function TF(e, t) {
  (e[0] += t[0]), (e[1] += t[1]), (e[2] += t[2]);
}
function IF(e, t) {
  return [e[0] * t, e[1] * t, e[2] * t];
}
function RF(e) {
  var t = pF(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]);
  (e[0] /= t), (e[1] /= t), (e[2] /= t);
}
function PF(e, t) {
  function i(i, n) {
    return (i = e(i, n)), t(i[0], i[1]);
  }
  return (
    e.invert &&
      t.invert &&
      (i.invert = function (i, n) {
        return (i = t.invert(i, n)) && e.invert(i[0], i[1]);
      }),
    i
  );
}
function DF(e, t) {
  return [e > iF ? e - rF : e < -iF ? e + rF : e, t];
}
function LF(e) {
  return function (t, i) {
    return [(t += e) > iF ? t - rF : t < -iF ? t + rF : t, i];
  };
}
function FF(e) {
  var t = LF(e);
  return (t.invert = LF(-e)), t;
}
function NF(e, t) {
  var i = uF(e),
    n = dF(e),
    s = uF(t),
    r = dF(t);
  function a(e, t) {
    var a = uF(t),
      o = uF(e) * a,
      l = dF(e) * a,
      h = dF(t),
      c = h * i + o * n;
    return [cF(l * s - c * r, o * i - h * n), mF(c * s + l * r)];
  }
  return (
    (a.invert = function (e, t) {
      var a = uF(t),
        o = uF(e) * a,
        l = dF(e) * a,
        h = dF(t),
        c = h * s - l * r;
      return [cF(l * s + h * r, o * i + c * n), mF(c * i - o * n)];
    }),
    a
  );
}
function BF(e, t) {
  ((t = CF(t))[0] -= e), RF(t);
  var i = fF(-t[1]);
  return ((-t[2] < 0 ? -i : i) + rF - tF) % rF;
}
function kF() {
  var e,
    t = [];
  return {
    point: function (t, i) {
      e.push([t, i]);
    },
    lineStart: function () {
      t.push((e = []));
    },
    lineEnd: gF,
    rejoin: function () {
      t.length > 1 && t.push(t.pop().concat(t.shift()));
    },
    result: function () {
      var i = t;
      return (t = []), (e = null), i;
    },
  };
}
function OF(e, t) {
  return lF(e[0] - t[0]) < tF && lF(e[1] - t[1]) < tF;
}
function UF(e, t, i, n) {
  (this.x = e),
    (this.z = t),
    (this.o = i),
    (this.e = n),
    (this.v = !1),
    (this.n = this.p = null);
}
function zF(e, t, i, n, s) {
  var r,
    a,
    o = [],
    l = [];
  if (
    (e.forEach(function (e) {
      if (!((t = e.length - 1) <= 0)) {
        var t,
          i,
          n = e[0],
          a = e[t];
        if (OF(n, a)) {
          for (s.lineStart(), r = 0; r < t; ++r) s.point((n = e[r])[0], n[1]);
          s.lineEnd();
        } else
          o.push((i = new UF(n, e, null, !0))),
            l.push((i.o = new UF(n, null, i, !1))),
            o.push((i = new UF(a, e, null, !1))),
            l.push((i.o = new UF(a, null, i, !0)));
      }
    }),
    o.length)
  ) {
    for (l.sort(t), GF(o), GF(l), r = 0, a = l.length; r < a; ++r)
      l[r].e = i = !i;
    for (var h, c, u = o[0]; ; ) {
      for (var d = u, p = !0; d.v; ) if ((d = d.n) === u) return;
      (h = d.z), s.lineStart();
      do {
        if (((d.v = d.o.v = !0), d.e)) {
          if (p)
            for (r = 0, a = h.length; r < a; ++r) s.point((c = h[r])[0], c[1]);
          else n(d.x, d.n.x, 1, s);
          d = d.n;
        } else {
          if (p)
            for (h = d.p.z, r = h.length - 1; r >= 0; --r)
              s.point((c = h[r])[0], c[1]);
          else n(d.x, d.p.x, -1, s);
          d = d.p;
        }
        (h = (d = d.o).z), (p = !p);
      } while (!d.v);
      s.lineEnd();
    }
  }
}
function GF(e) {
  if ((t = e.length)) {
    for (var t, i, n = 0, s = e[0]; ++n < t; )
      (s.n = i = e[n]), (i.p = s), (s = i);
    (s.n = i = e[0]), (i.p = s);
  }
}
function VF(e, t) {
  return e < t ? -1 : e > t ? 1 : e >= t ? 0 : NaN;
}
function QF(e) {
  for (var t, i, n, s = e.length, r = -1, a = 0; ++r < s; ) a += e[r].length;
  for (i = new Array(a); --s >= 0; )
    for (t = (n = e[s]).length; --t >= 0; ) i[--a] = n[t];
  return i;
}
ZL(),
  ZL(),
  ZL(),
  (DF.invert = DF),
  1 === (vF = VF).length &&
    ((AF = vF),
    (vF = function (e, t) {
      return VF(AF(e), t);
    }));
var HF = 1e9,
  jF = -HF;
function WF(e, t, i, n) {
  function s(s, r) {
    return e <= s && s <= i && t <= r && r <= n;
  }
  function r(s, r, o, h) {
    var c = 0,
      u = 0;
    if (null == s || (c = a(s, o)) !== (u = a(r, o)) || (l(s, r) < 0) ^ (o > 0))
      do {
        h.point(0 === c || 3 === c ? e : i, c > 1 ? n : t);
      } while ((c = (c + o + 4) % 4) !== u);
    else h.point(r[0], r[1]);
  }
  function a(n, s) {
    return lF(n[0] - e) < tF
      ? s > 0
        ? 0
        : 3
      : lF(n[0] - i) < tF
      ? s > 0
        ? 2
        : 1
      : lF(n[1] - t) < tF
      ? s > 0
        ? 1
        : 0
      : s > 0
      ? 3
      : 2;
  }
  function o(e, t) {
    return l(e.x, t.x);
  }
  function l(e, t) {
    var i = a(e, 1),
      n = a(t, 1);
    return i !== n
      ? i - n
      : 0 === i
      ? t[1] - e[1]
      : 1 === i
      ? e[0] - t[0]
      : 2 === i
      ? e[1] - t[1]
      : t[0] - e[0];
  }
  return function (a) {
    var l,
      h,
      c,
      u,
      d,
      p,
      f,
      m,
      g,
      _,
      v,
      A = a,
      y = kF(),
      x = {
        point: b,
        lineStart: function () {
          (x.point = E), h && h.push((c = []));
          (_ = !0), (g = !1), (f = m = NaN);
        },
        lineEnd: function () {
          l && (E(u, d), p && g && y.rejoin(), l.push(y.result()));
          (x.point = b), g && A.lineEnd();
        },
        polygonStart: function () {
          (A = y), (l = []), (h = []), (v = !0);
        },
        polygonEnd: function () {
          var t = (function () {
              for (var t = 0, i = 0, s = h.length; i < s; ++i)
                for (
                  var r,
                    a,
                    o = h[i],
                    l = 1,
                    c = o.length,
                    u = o[0],
                    d = u[0],
                    p = u[1];
                  l < c;
                  ++l
                )
                  (r = d),
                    (a = p),
                    (d = (u = o[l])[0]),
                    (p = u[1]),
                    a <= n
                      ? p > n && (d - r) * (n - a) > (p - a) * (e - r) && ++t
                      : p <= n && (d - r) * (n - a) < (p - a) * (e - r) && --t;
              return t;
            })(),
            i = v && t,
            s = (l = QF(l)).length;
          (i || s) &&
            (a.polygonStart(),
            i && (a.lineStart(), r(null, null, 1, a), a.lineEnd()),
            s && zF(l, o, t, r, a),
            a.polygonEnd());
          (A = a), (l = h = c = null);
        },
      };
    function b(e, t) {
      s(e, t) && A.point(e, t);
    }
    function E(r, a) {
      var o = s(r, a);
      if ((h && c.push([r, a]), _))
        (u = r),
          (d = a),
          (p = o),
          (_ = !1),
          o && (A.lineStart(), A.point(r, a));
      else if (o && g) A.point(r, a);
      else {
        var l = [
            (f = Math.max(jF, Math.min(HF, f))),
            (m = Math.max(jF, Math.min(HF, m))),
          ],
          y = [
            (r = Math.max(jF, Math.min(HF, r))),
            (a = Math.max(jF, Math.min(HF, a))),
          ];
        !(function (e, t, i, n, s, r) {
          var a,
            o = e[0],
            l = e[1],
            h = 0,
            c = 1,
            u = t[0] - o,
            d = t[1] - l;
          if (((a = i - o), u || !(a > 0))) {
            if (((a /= u), u < 0)) {
              if (a < h) return;
              a < c && (c = a);
            } else if (u > 0) {
              if (a > c) return;
              a > h && (h = a);
            }
            if (((a = s - o), u || !(a < 0))) {
              if (((a /= u), u < 0)) {
                if (a > c) return;
                a > h && (h = a);
              } else if (u > 0) {
                if (a < h) return;
                a < c && (c = a);
              }
              if (((a = n - l), d || !(a > 0))) {
                if (((a /= d), d < 0)) {
                  if (a < h) return;
                  a < c && (c = a);
                } else if (d > 0) {
                  if (a > c) return;
                  a > h && (h = a);
                }
                if (((a = r - l), d || !(a < 0))) {
                  if (((a /= d), d < 0)) {
                    if (a > c) return;
                    a > h && (h = a);
                  } else if (d > 0) {
                    if (a < h) return;
                    a < c && (c = a);
                  }
                  return (
                    h > 0 && ((e[0] = o + h * u), (e[1] = l + h * d)),
                    c < 1 && ((t[0] = o + c * u), (t[1] = l + c * d)),
                    !0
                  );
                }
              }
            }
          }
        })(l, y, e, t, i, n)
          ? o && (A.lineStart(), A.point(r, a), (v = !1))
          : (g || (A.lineStart(), A.point(l[0], l[1])),
            A.point(y[0], y[1]),
            o || A.lineEnd(),
            (v = !1));
      }
      (f = r), (m = a), (g = o);
    }
    return x;
  };
}
var qF = ZL();
function XF(e) {
  return e;
}
ZL(), ZL(), ZL();
var YF = 1 / 0,
  KF = YF,
  ZF = -YF,
  JF = ZF,
  $F = {
    point: function (e, t) {
      e < YF && (YF = e);
      e > ZF && (ZF = e);
      t < KF && (KF = t);
      t > JF && (JF = t);
    },
    lineStart: gF,
    lineEnd: gF,
    polygonStart: gF,
    polygonEnd: gF,
    result: function () {
      var e = [
        [YF, KF],
        [ZF, JF],
      ];
      return (ZF = JF = -(KF = YF = 1 / 0)), e;
    },
  };
function eN(e, t, i, n) {
  return function (s, r) {
    var a,
      o,
      l,
      h = t(r),
      c = s.invert(n[0], n[1]),
      u = kF(),
      d = t(u),
      p = !1,
      f = {
        point: m,
        lineStart: _,
        lineEnd: v,
        polygonStart: function () {
          (f.point = A), (f.lineStart = y), (f.lineEnd = x), (o = []), (a = []);
        },
        polygonEnd: function () {
          (f.point = m), (f.lineStart = _), (f.lineEnd = v), (o = QF(o));
          var e = (function (e, t) {
            var i = t[0],
              n = t[1],
              s = [dF(i), -uF(i), 0],
              r = 0,
              a = 0;
            qF.reset();
            for (var o = 0, l = e.length; o < l; ++o)
              if ((c = (h = e[o]).length))
                for (
                  var h,
                    c,
                    u = h[c - 1],
                    d = u[0],
                    p = u[1] / 2 + sF,
                    f = dF(p),
                    m = uF(p),
                    g = 0;
                  g < c;
                  ++g, d = v, f = y, m = x, u = _
                ) {
                  var _ = h[g],
                    v = _[0],
                    A = _[1] / 2 + sF,
                    y = dF(A),
                    x = uF(A),
                    b = v - d,
                    E = b >= 0 ? 1 : -1,
                    S = E * b,
                    C = S > iF,
                    M = f * y;
                  if (
                    (qF.add(cF(M * E * dF(S), m * x + M * uF(S))),
                    (r += C ? b + E * rF : b),
                    C ^ (d >= i) ^ (v >= i))
                  ) {
                    var w = wF(CF(u), CF(_));
                    RF(w);
                    var T = wF(s, w);
                    RF(T);
                    var I = (C ^ (b >= 0) ? -1 : 1) * mF(T[2]);
                    (n > I || (n === I && (w[0] || w[1]))) &&
                      (a += C ^ (b >= 0) ? 1 : -1);
                  }
                }
            return (r < -tF || (r < tF && qF < -tF)) ^ (1 & a);
          })(a, c);
          o.length
            ? (p || (r.polygonStart(), (p = !0)), zF(o, iN, e, i, r))
            : e &&
              (p || (r.polygonStart(), (p = !0)),
              r.lineStart(),
              i(null, null, 1, r),
              r.lineEnd()),
            p && (r.polygonEnd(), (p = !1)),
            (o = a = null);
        },
        sphere: function () {
          r.polygonStart(),
            r.lineStart(),
            i(null, null, 1, r),
            r.lineEnd(),
            r.polygonEnd();
        },
      };
    function m(t, i) {
      var n = s(t, i);
      e((t = n[0]), (i = n[1])) && r.point(t, i);
    }
    function g(e, t) {
      var i = s(e, t);
      h.point(i[0], i[1]);
    }
    function _() {
      (f.point = g), h.lineStart();
    }
    function v() {
      (f.point = m), h.lineEnd();
    }
    function A(e, t) {
      l.push([e, t]);
      var i = s(e, t);
      d.point(i[0], i[1]);
    }
    function y() {
      d.lineStart(), (l = []);
    }
    function x() {
      A(l[0][0], l[0][1]), d.lineEnd();
      var e,
        t,
        i,
        n,
        s = d.clean(),
        h = u.result(),
        c = h.length;
      if ((l.pop(), a.push(l), (l = null), c))
        if (1 & s) {
          if ((t = (i = h[0]).length - 1) > 0) {
            for (
              p || (r.polygonStart(), (p = !0)), r.lineStart(), e = 0;
              e < t;
              ++e
            )
              r.point((n = i[e])[0], n[1]);
            r.lineEnd();
          }
        } else
          c > 1 && 2 & s && h.push(h.pop().concat(h.shift())),
            o.push(h.filter(tN));
    }
    return f;
  };
}

function tN(e) {
  return e.length > 1;
}

function iN(e, t) {
  return (
    ((e = e.x)[0] < 0 ? e[1] - nF - tF : nF - e[1]) -
    ((t = t.x)[0] < 0 ? t[1] - nF - tF : nF - t[1])
  );
}

ZL();

const nN = eN(
  function () {
    return !0;
  },
  function (e) {
    var t,
      i = NaN,
      n = NaN,
      s = NaN;
    return {
      lineStart: function () {
        e.lineStart(), (t = 1);
      },
      point: function (r, a) {
        var o = r > 0 ? iF : -iF,
          l = lF(r - i);
        lF(l - iF) < tF
          ? (e.point(i, (n = (n + a) / 2 > 0 ? nF : -nF)),
            e.point(s, n),
            e.lineEnd(),
            e.lineStart(),
            e.point(o, n),
            e.point(r, n),
            (t = 0))
          : s !== o &&
            l >= iF &&
            (lF(i - s) < tF && (i -= s * tF),
            lF(r - o) < tF && (r -= o * tF),
            (n = (function (e, t, i, n) {
              var s,
                r,
                a = dF(e - i);
              return lF(a) > tF
                ? hF(
                    (dF(t) * (r = uF(n)) * dF(i) -
                      dF(n) * (s = uF(t)) * dF(e)) /
                      (s * r * a)
                  )
                : (t + n) / 2;
            })(i, n, r, a)),
            e.point(s, n),
            e.lineEnd(),
            e.lineStart(),
            e.point(o, n),
            (t = 0)),
          e.point((i = r), (n = a)),
          (s = o);
      },
      lineEnd: function () {
        e.lineEnd(), (i = n = NaN);
      },
      clean: function () {
        return 2 - t;
      },
    };
  },
  function (e, t, i, n) {
    var s;
    if (null == e)
      (s = i * nF),
        n.point(-iF, s),
        n.point(0, s),
        n.point(iF, s),
        n.point(iF, 0),
        n.point(iF, -s),
        n.point(0, -s),
        n.point(-iF, -s),
        n.point(-iF, 0),
        n.point(-iF, s);
    else if (lF(e[0] - t[0]) > tF) {
      var r = e[0] < t[0] ? iF : -iF;
      (s = (i * r) / 2), n.point(-r, s), n.point(0, s), n.point(r, s);
    } else n.point(t[0], t[1]);
  },
  [-iF, -nF]
);

function sN(e, t) {
  var i = uF(e),
    n = i > 0,
    s = lF(i) > tF;
  function r(e, t) {
    return uF(e) * uF(t) > i;
  }
  function a(e, t, n) {
    var s = [1, 0, 0],
      r = wF(CF(e), CF(t)),
      a = MF(r, r),
      o = r[0],
      l = a - o * o;
    if (!l) return !n && e;
    var h = (i * a) / l,
      c = (-i * o) / l,
      u = wF(s, r),
      d = IF(s, h);
    TF(d, IF(r, c));
    var p = u,
      f = MF(d, p),
      m = MF(p, p),
      g = f * f - m * (MF(d, d) - 1);
    if (!(g < 0)) {
      var _ = pF(g),
        v = IF(p, (-f - _) / m);
      if ((TF(v, d), (v = SF(v)), !n)) return v;
      var A,
        y = e[0],
        x = t[0],
        b = e[1],
        E = t[1];
      x < y && ((A = y), (y = x), (x = A));
      var S = x - y,
        C = lF(S - iF) < tF;
      if (
        (!C && E < b && ((A = b), (b = E), (E = A)),
        C || S < tF
          ? C
            ? (b + E > 0) ^ (v[1] < (lF(v[0] - y) < tF ? b : E))
            : b <= v[1] && v[1] <= E
          : (S > iF) ^ (y <= v[0] && v[0] <= x))
      ) {
        var M = IF(p, (-f + _) / m);
        return TF(M, d), [v, SF(M)];
      }
    }
  }
  function o(t, i) {
    var s = n ? e : iF - e,
      r = 0;
    return (
      t < -s ? (r |= 1) : t > s && (r |= 2),
      i < -s ? (r |= 4) : i > s && (r |= 8),
      r
    );
  }
  return eN(
    r,
    function (e) {
      var t, i, l, h, c;
      return {
        lineStart: function () {
          (h = l = !1), (c = 1);
        },
        point: function (u, d) {
          var p,
            f = [u, d],
            m = r(u, d),
            g = n ? (m ? 0 : o(u, d)) : m ? o(u + (u < 0 ? iF : -iF), d) : 0;
          if (
            (!t && (h = l = m) && e.lineStart(),
            m !== l &&
              (!(p = a(t, f)) || OF(t, p) || OF(f, p)) &&
              ((f[0] += tF), (f[1] += tF), (m = r(f[0], f[1]))),
            m !== l)
          )
            (c = 0),
              m
                ? (e.lineStart(), (p = a(f, t)), e.point(p[0], p[1]))
                : ((p = a(t, f)), e.point(p[0], p[1]), e.lineEnd()),
              (t = p);
          else if (s && t && n ^ m) {
            var _;
            g & i ||
              !(_ = a(f, t, !0)) ||
              ((c = 0),
              n
                ? (e.lineStart(),
                  e.point(_[0][0], _[0][1]),
                  e.point(_[1][0], _[1][1]),
                  e.lineEnd())
                : (e.point(_[1][0], _[1][1]),
                  e.lineEnd(),
                  e.lineStart(),
                  e.point(_[0][0], _[0][1])));
          }
          !m || (t && OF(t, f)) || e.point(f[0], f[1]),
            (t = f),
            (l = m),
            (i = g);
        },
        lineEnd: function () {
          l && e.lineEnd(), (t = null);
        },
        clean: function () {
          return c | ((h && l) << 1);
        },
      };
    },
    function (i, n, s, r) {
      !(function (e, t, i, n, s, r) {
        if (i) {
          var a = uF(t),
            o = dF(t),
            l = n * i;
          null == s
            ? ((s = t + n * rF), (r = t - l / 2))
            : ((s = BF(a, s)),
              (r = BF(a, r)),
              (n > 0 ? s < r : s > r) && (s += n * rF));
          for (var h, c = s; n > 0 ? c > r : c < r; c -= l)
            (h = SF([a, -o * uF(c), -o * dF(c)])), e.point(h[0], h[1]);
        }
      })(r, e, t, s, i, n);
    },
    n ? [0, -e] : [-iF, e - iF]
  );
}

function rN(e) {
  return function (t) {
    var i = new aN();
    for (var n in e) i[n] = e[n];
    return (i.stream = t), i;
  };
}
function aN() {}

function oN(e, t, i) {
  var n = t[1][0] - t[0][0],
    s = t[1][1] - t[0][1],
    r = e.clipExtent && e.clipExtent();
  e.scale(150).translate([0, 0]),
    null != r && e.clipExtent(null),
    (function (e, t) {
      e && yF.hasOwnProperty(e.type) ? yF[e.type](e, t) : _F(e, t);
    })(i, e.stream($F));
  var a = $F.result(),
    o = Math.min(n / (a[1][0] - a[0][0]), s / (a[1][1] - a[0][1])),
    l = +t[0][0] + (n - o * (a[1][0] + a[0][0])) / 2,
    h = +t[0][1] + (s - o * (a[1][1] + a[0][1])) / 2;
  return null != r && e.clipExtent(r), e.scale(150 * o).translate([l, h]);
}

aN.prototype = {
  constructor: aN,
  point: function (e, t) {
    this.stream.point(e, t);
  },
  sphere: function () {
    this.stream.sphere();
  },
  lineStart: function () {
    this.stream.lineStart();
  },
  lineEnd: function () {
    this.stream.lineEnd();
  },
  polygonStart: function () {
    this.stream.polygonStart();
  },
  polygonEnd: function () {
    this.stream.polygonEnd();
  },
};
var lN = 16,
  hN = uF(30 * oF);
function cN(e, t) {
  return +t
    ? (function (e, t) {
        function i(n, s, r, a, o, l, h, c, u, d, p, f, m, g) {
          var _ = h - n,
            v = c - s,
            A = _ * _ + v * v;
          if (A > 4 * t && m--) {
            var y = a + d,
              x = o + p,
              b = l + f,
              E = pF(y * y + x * x + b * b),
              S = mF((b /= E)),
              C = lF(lF(b) - 1) < tF || lF(r - u) < tF ? (r + u) / 2 : cF(x, y),
              M = e(C, S),
              w = M[0],
              T = M[1],
              I = w - n,
              R = T - s,
              P = v * I - _ * R;
            ((P * P) / A > t ||
              lF((_ * I + v * R) / A - 0.5) > 0.3 ||
              a * d + o * p + l * f < hN) &&
              (i(n, s, r, a, o, l, w, T, C, (y /= E), (x /= E), b, m, g),
              g.point(w, T),
              i(w, T, C, y, x, b, h, c, u, d, p, f, m, g));
          }
        }
        return function (t) {
          var n,
            s,
            r,
            a,
            o,
            l,
            h,
            c,
            u,
            d,
            p,
            f,
            m = {
              point: g,
              lineStart: _,
              lineEnd: A,
              polygonStart: function () {
                t.polygonStart(), (m.lineStart = y);
              },
              polygonEnd: function () {
                t.polygonEnd(), (m.lineStart = _);
              },
            };
          function g(i, n) {
            (i = e(i, n)), t.point(i[0], i[1]);
          }
          function _() {
            (c = NaN), (m.point = v), t.lineStart();
          }
          function v(n, s) {
            var r = CF([n, s]),
              a = e(n, s);
            i(
              c,
              u,
              h,
              d,
              p,
              f,
              (c = a[0]),
              (u = a[1]),
              (h = n),
              (d = r[0]),
              (p = r[1]),
              (f = r[2]),
              lN,
              t
            ),
              t.point(c, u);
          }
          function A() {
            (m.point = g), t.lineEnd();
          }
          function y() {
            _(), (m.point = x), (m.lineEnd = b);
          }
          function x(e, t) {
            v((n = e), t),
              (s = c),
              (r = u),
              (a = d),
              (o = p),
              (l = f),
              (m.point = v);
          }
          function b() {
            i(c, u, h, d, p, f, s, r, n, a, o, l, lN, t), (m.lineEnd = A), A();
          }
          return m;
        };
      })(e, t)
    : (function (e) {
        return rN({
          point: function (t, i) {
            (t = e(t, i)), this.stream.point(t[0], t[1]);
          },
        });
      })(e);
}
var uN = rN({
  point: function (e, t) {
    this.stream.point(e * oF, t * oF);
  },
});

function dN(e) {
  return (function (e) {
    var t,
      i,
      n,
      s,
      r,
      a,
      o,
      l,
      h,
      c,
      u = 150,
      d = 480,
      p = 250,
      f = 0,
      m = 0,
      g = 0,
      _ = 0,
      v = 0,
      A = null,
      y = nN,
      x = null,
      b = XF,
      E = 0.5,
      S = cN(w, E);
    function C(e) {
      return [(e = r(e[0] * oF, e[1] * oF))[0] * u + i, n - e[1] * u];
    }
    function M(e) {
      return (
        (e = r.invert((e[0] - i) / u, (n - e[1]) / u)) && [e[0] * aF, e[1] * aF]
      );
    }
    function w(e, s) {
      return [(e = t(e, s))[0] * u + i, n - e[1] * u];
    }
    function T() {
      r = PF(
        (s = (function (e, t, i) {
          return (e %= rF)
            ? t || i
              ? PF(FF(e), NF(t, i))
              : FF(e)
            : t || i
            ? NF(t, i)
            : DF;
        })(g, _, v)),
        t
      );
      var e = t(f, m);
      return (i = d - e[0] * u), (n = p + e[1] * u), I();
    }
    function I() {
      return (h = c = null), C;
    }
    return (
      (C.stream = function (e) {
        return h && c === e ? h : (h = uN(y(s, S(b((c = e))))));
      }),
      (C.clipAngle = function (e) {
        return arguments.length
          ? ((y = +e ? sN((A = e * oF), 6 * oF) : ((A = null), nN)), I())
          : A * aF;
      }),
      (C.clipExtent = function (e) {
        return arguments.length
          ? ((b =
              null == e
                ? ((x = a = o = l = null), XF)
                : WF(
                    (x = +e[0][0]),
                    (a = +e[0][1]),
                    (o = +e[1][0]),
                    (l = +e[1][1])
                  )),
            I())
          : null == x
          ? null
          : [
              [x, a],
              [o, l],
            ];
      }),
      (C.scale = function (e) {
        return arguments.length ? ((u = +e), T()) : u;
      }),
      (C.translate = function (e) {
        return arguments.length ? ((d = +e[0]), (p = +e[1]), T()) : [d, p];
      }),
      (C.center = function (e) {
        return arguments.length
          ? ((f = (e[0] % 360) * oF), (m = (e[1] % 360) * oF), T())
          : [f * aF, m * aF];
      }),
      (C.rotate = function (e) {
        return arguments.length
          ? ((g = (e[0] % 360) * oF),
            (_ = (e[1] % 360) * oF),
            (v = e.length > 2 ? (e[2] % 360) * oF : 0),
            T())
          : [g * aF, _ * aF, v * aF];
      }),
      (C.precision = function (e) {
        return arguments.length ? ((S = cN(w, (E = e * e))), I()) : pF(E);
      }),
      (C.fitExtent = function (e, t) {
        return oN(C, e, t);
      }),
      (C.fitSize = function (e, t) {
        return (function (e, t, i) {
          return oN(e, [[0, 0], t], i);
        })(C, e, t);
      }),
      function () {
        return (t = e.apply(this, arguments)), (C.invert = t.invert && M), T();
      }
    );
  })(function () {
    return e;
  })();
}

function pN(e) {
  return function (t, i) {
    var n = uF(t),
      s = uF(i),
      r = e(n * s);
    return [r * s * dF(t), r * dF(i)];
  };
}

function fN(e) {
  return function (t, i) {
    var n = pF(t * t + i * i),
      s = e(n),
      r = dF(s),
      a = uF(s);
    return [cF(t * r, n * a), mF(n && (i * r) / n)];
  };
}

pN(function (e) {
  return pF(2 / (1 + e));
}).invert = fN(function (e) {
  return 2 * mF(e / 2);
});

var mN = pN(function (e) {
  return (e = fF(e)) && e / dF(e);
});

function gN(e, t) {
  return [e, t];
}

mN.invert = fN(function (e) {
  return e;
});

gN.invert = gN;

const _N = 6371008.8;
const vN = { kilometers: 6371.0088, meters: _N };

class AN extends ug {
  constructor(e, t) {
    super(),
      (this.needsSwap = !1),
      (this.clearColor = void 0 !== e ? e : 0),
      (this.clearAlpha = void 0 !== t ? t : 0),
      (this._oldClearColor = new Color());
  }
  render(e, t, i) {
    let n;
    this.clearColor &&
      (e.getClearColor(this._oldClearColor),
      (n = e.getClearAlpha()),
      e.setClearColor(this.clearColor, this.clearAlpha)),
      e.setRenderTarget(this.renderToScreen ? null : i),
      e.clear(),
      this.clearColor && e.setClearColor(this._oldClearColor, n);
  }
}

class yN extends ug {
  constructor(e, t, i, n, s) {
    super(),
      (this.scene = e),
      (this.camera = t),
      (this.overrideMaterial = i),
      (this.clearColor = n),
      (this.clearAlpha = void 0 !== s ? s : 0),
      (this.clear = !0),
      (this.clearDepth = !1),
      (this.needsSwap = !1),
      (this._oldClearColor = new Color()),
      (this._excludeElements = []),
      (this._includeElements = []);
  }
  render(e, t, i) {
    const n = e.autoClear;
    let s, r;
    (e.autoClear = !1),
      void 0 !== this.overrideMaterial &&
        ((r = this.scene.overrideMaterial),
        (this.scene.overrideMaterial = this.overrideMaterial)),
      this.clearColor &&
        (e.getClearColor(this._oldClearColor),
        (s = e.getClearAlpha()),
        e.setClearColor(this.clearColor, this.clearAlpha)),
      this.clearDepth && e.clearDepth(),
      e.setRenderTarget(this.renderToScreen ? null : i),
      this.clear &&
        e.clear(e.autoClearColor, e.autoClearDepth, e.autoClearStencil);
    const a = this._includeElements.length > 0,
      o = this._excludeElements.length > 0;
    o &&
      this.scene.traverse((e) => {
        this._excludeElements.includes(e) && (e.visible = !1);
      }),
      a &&
        this.scene.traverse((e) => {
          this._includeElements.includes(e) || (e.visible = !1);
        }),
      e.render(this.scene, this.camera),
      o &&
        this.scene.traverse((e) => {
          this._excludeElements.includes(e) && (e.visible = !0);
        }),
      a &&
        this.scene.traverse((e) => {
          this._includeElements.includes(e) || (e.visible = !0);
        }),
      this.clearColor && e.setClearColor(this._oldClearColor, s),
      void 0 !== this.overrideMaterial && (this.scene.overrideMaterial = r),
      (e.autoClear = n);
  }
}

function loadStyle(styleContent, root) {
  if (s[styleContent]) return;

  const i = root || document;

  const n = document.createElement("style");
  n.type = "text/css";
  n.innerHTML = styleContent;

  const r = i.getElementsByTagName("head")[0];

  try {
    r.appendChild(n), (s[e] = !0);
  } catch (Ym) {}
}

loadStyle(
  '.mapv-controls-pane{position:absolute;z-index:15;bottom:0;left:0;right:0}.mapv-controls-pane .bottom-right-anchor{position:absolute;width:52px;bottom:40px;right:20px}.mapv-controls-pane .bottom-left-anchor{position:absolute;bottom:60px;left:20px}.mapv-controls-pane .compass{width:52px;height:54px;margin-top:10px;visibility:visible;position:relative;background-size:266px;background-repeat:no-repeat;background-position:0 0}.mapv-controls-pane .compass .compass-up{position:absolute;left:20px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-controls-pane .compass .compass-up:hover{fill:#2c82ff}.mapv-controls-pane .compass .compass-down{position:absolute;left:20px;bottom:2px;margin:2px;width:8px;height:8px;fill:#000;cursor:pointer}.mapv-controls-pane .compass .compass-down:hover{fill:#2c82ff}.mapv-controls-pane .compass .compass-left{cursor:pointer;position:absolute;top:5px;left:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px}.mapv-controls-pane .compass .compass-left:hover{background-position:-89px -5px}.mapv-controls-pane .compass .compass-right{cursor:pointer;position:absolute;top:5px;right:2px;width:15px;height:42px;background-size:266px;background-repeat:no-repeat;background-position:-75px -5px;transform:rotateY(180deg);-ms-transform:rotateY(180deg);-webkit-transform:rotateY(180deg);-o-transform:rotateY(180deg);-moz-transform:rotateY(180deg)}.mapv-controls-pane .compass .compass-right:hover{background-position:-89px -5px}.mapv-controls-pane .compass .compass-center{cursor:pointer;position:absolute;top:11px;left:19px;width:14px;height:32px;background-size:266px;background-repeat:no-repeat;background-position:-56px -10px;transform:rotate(0)}.mapv-controls-pane .zoom{width:26px;height:54px;visibility:visible;margin-left:13px;margin-top:10px}.mapv-controls-pane .zoom .zoom-add{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:2px 2px 0 0;background-position:0 0}.mapv-controls-pane .zoom .zoom-add:hover .zoom-add-tag{background-position:20px 0}.mapv-controls-pane .zoom .zoom-add-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px}.mapv-controls-pane .zoom .zoom-sub{cursor:pointer;width:26px;height:26px;background-color:#fff;border-bottom:1px solid #ccc;border-radius:0 0 2px 2px}.mapv-controls-pane .zoom .zoom-sub:hover .zoom-sub-tag{background-position:10px 0}.mapv-controls-pane .zoom .zoom-sub-tag{position:absolute;width:10px;height:10px;margin:8px;background-size:40px 10px;background-position:-10px 0}.mapv-controls-pane .scale{position:absolute;bottom:10px;left:100px;visibility:visible;width:90px;height:26px}.mapv-controls-pane .scale .scale-text{width:100%;font-size:10px;text-align:center;user-select:none;transition:width .3s}.mapv-controls-pane .scale .scale-line{position:relative;width:100%;height:8px;user-select:none}.mapv-controls-pane .scale .scale-line-mid{position:absolute;left:2px;right:2px;top:3px;bottom:2px;background-color:#333;overflow:hidden}.mapv-controls-pane .scale .scale-line-left{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden}.mapv-controls-pane .scale .scale-line-right{position:absolute;width:2px;height:8px;background-color:#333;overflow:hidden;right:0}.mapv-controls-pane .drawer{position:absolute;right:31px;bottom:164px;margin:2px;cursor:pointer}.mapv-controls-pane .drawer .drawer-btn{background-color:#fff;padding:5px 5px 0;border-radius:2px}.mapv-controls-pane .drawer .drawer-btn:hover{background-color:#f3f3f3}.mapv-controls-pane .drawer .drawer-icon{height:16px;width:16px;fill:#797979}.mapv-controls-pane .drawer .drawer-list{position:absolute;right:32px;top:0;display:none;list-style:none;background-color:#fff;box-shadow:0 0 20px #00000026;white-space:nowrap;border-radius:2px}.mapv-controls-pane .drawer .drawer-item{display:flex;align-items:center;padding:0 16px;height:24px;line-height:24px}.mapv-controls-pane .drawer .drawer-item-check{margin:0}.mapv-controls-pane .drawer .drawer-item-name{margin-left:6px;font-size:12px}.mapv-controls-pane .drawer .drawer-arrow{width:0;height:0;border-width:4px;border-style:solid;border-color:transparent transparent transparent #fff;position:absolute;top:11px;right:-7px}.mapv-controls-pane .mouse-location{position:absolute;bottom:10px;right:20px;visibility:visible;padding:2px 6px;background-color:#fff;font-size:14px;border-radius:2px}.mapv-controls-pane .logo{position:absolute;width:81px;height:27px;bottom:10px;left:5px;visibility:visible}.mapv-controls-pane .geo-locate{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-controls-pane .fullscreen{background-color:#fff;height:26px;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc}.mapv-controls-pane .export-image{background-color:#fff;width:26px;visibility:visible;cursor:pointer;border-bottom:1px solid #ccc;height:26px}.mapv-controls-pane .geo-locate:hover .control-group-svg,.mapv-controls-pane .fullscreen:hover .control-group-svg,.mapv-controls-pane .export-image:hover .control-group-svg{fill:#2c82ff}.mapv-controls-pane .control-group-svg{margin:5px;height:16px;width:16px;fill:#999}.mapv-overlay-pane{position:absolute;z-index:10}.mapv-overlay-pane .mapv-popup{width:200px;height:110px}.mapv-overlay-pane .mapv-popup .frame{width:198px;height:98px;background:white;border-radius:4px;border:1px solid #e6e1e1}.mapv-overlay-pane .mapv-popup .title{height:30px;border-bottom:1px solid #e6e1e1;line-height:30px;padding-left:10px;font-size:18px;font-weight:500}.mapv-overlay-pane .mapv-popup .close{width:20px;height:31px;position:absolute;font-size:20px;text-align:center;right:5px;cursor:pointer}.mapv-overlay-pane .mapv-popup .triangle{width:0;height:0;border-top:10px solid white;border-left:12px solid transparent;border-right:12px solid transparent;margin-left:88px}.mapv-overlay-pane .mapv-popup .content{padding:5px}.mapv-dom-points{position:absolute;z-index:10;user-select:none}.mapv-measure-pane{display:inline-block;position:absolute;height:30px;border-radius:5px;padding:0 5px;line-height:30px;background-color:#797774;color:#fff;transform:translate(-50%,-130%);overflow:visible}.mapv-measure-pane:after{content:"";position:absolute;width:0;height:0;left:50%;bottom:0;border:6px solid transparent;border-top:6px solid #797774;background-color:transparent;transform:translate(-50%,10px)}.mapv-container{touch-action:none}.mapv-hidden{display:none!important}\n'
);

window.MAPVTHREE_VERSION = "1.0.18";

exports.AreaMeasure = class extends QL {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_area", 0),
      publicField(this, "_node", []),
      publicField(this, "_editor"),
      publicField(this, "_infoMarkers"),
      publicField(this, "_infoMarkersDataSource"),
      publicField(this, "_infoMarkersBuffer", {
        position: [],
        index: [],
        payload: [],
      }),
      publicField(this, "_addNode", (e) => {
        (this._node = e.value), e.value.length > 3 && this._adjustNode(e);
      }),
      publicField(this, "_movePolygonNode", (e) => {
        this._node = e.value;
        const t = this._node.map((e) => e.position);
        3 === this._options.dimensions
          ? (this._area = QL.getSpaceArea(t))
          : (this._area = QL.getArea(t)),
          this.setInfoMarkers(t);
      }),
      publicField(this, "_moveRectNode", (e) => {
        this._node = e.value;
        const t = this._node.map((e) => e.position);
        3 === this._options.dimensions
          ? (this._area = QL.getSpaceArea(t))
          : (this._area = QL.getArea(t)),
          this.setInfoMarkers(t);
      }),
      publicField(this, "_moveCircleNode", (e) => {
        this._node = e.value;
        const { size: t } = e.value[0],
          i = Math.PI * Math.pow(t / 2, 2);
        this._area = i;
        const n = this._node.map((e) => e.position);
        this.setInfoMarkers(n);
      }),
      publicField(this, "_moveNode", (e) => {
        this._adjustNode(e);
      }),
      publicField(this, "_changeNode", (e) => {
        this._adjustNode(e);
      }),
      publicField(this, "_adjustNode", (e) => {
        "rect" === this._options.type
          ? this._moveRectNode(e)
          : "circle" === this._options.type
          ? this._moveCircleNode(e)
          : this._movePolygonNode(e);
      }),
      (this._engine = e),
      (this._options = t);
  }
  initEditor() {
    let e;
    return (
      (e =
        "rect" === this._options.type
          ? (this._editor = this._engine.add(
              new zL(this._engine, {
                editingPolygonParameter: this._options.editingPolygonParameter,
                editedPolygonParameter: this._options.editedPolygonParameter,
              })
            ))
          : "circle" === this._options.type
          ? (this._editor = this._engine.add(
              new UL(this._engine, {
                editingPolygonParameter: this._options.editingPolygonParameter,
                editedPolygonParameter: this._options.editedPolygonParameter,
              })
            ))
          : (this._editor = this._engine.add(
              new GL(this._engine, {
                editingPolygonParameter: this._options.editingPolygonParameter,
                editedPolygonParameter: this._options.editedPolygonParameter,
                borderLineParameter: this._options.borderLineParameter,
              })
            ))),
      e
    );
  }
  initInfoMarkers() {
    let e = (this._infoMarkers = this._engine.add(
      new dP({ callback: this.createInfoMarkers, offset: [0, 0] })
    ));
    e.renderItem = this.createInfoMarkers;
    let t = (this._infoMarkersDataSource = new mA());
    this._infoMarkersDataSource.setAttribute("payload", "area"),
      (e.dataSource = t);
  }
  createInfoMarkers(e) {
    const n = document.createElement("div");
    return (
      (n.innerText =
        e > 1e4
          ? Math.round((e / 1e6) * 100) / 100 + " km²"
          : Math.round(100 * e) / 100 + " m²"),
      i(n, `${t}-measure-pane`),
      n
    );
  }
  setInfoMarkers(e) {
    let t;
    (t =
      -1 === this._editor.selectedIndex
        ? this._editor.drawedGraph.length
        : this._editor.selectedIndex),
      this._infoMarkersBuffer.position.splice(t, 1, e[0]),
      this._infoMarkersBuffer.index.splice(t, 1, t),
      this._infoMarkersBuffer.payload.splice(t, 1, { area: this._area }),
      this._infoMarkersDataSource.setData(this._infoMarkersBuffer);
  }
  clearBuffer() {
    this._infoMarkersBuffer = { position: [], index: [], payload: [] };
  }
  clearAll() {
    (this.enabled = !1),
      this._editor.clearAll(),
      this.clearBuffer(),
      this._infoMarkersDataSource.setData();
  }
  dispose() {
    this.clearAll(),
      this._infoMarkers && this._engine.remove(this._infoMarkers);
  }
  get area() {
    return this._area;
  }
};
exports.BubblePoint = class extends InstancedMesh {
  constructor(e) {
    super(e),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "color"),
      publicField(this, "size"),
      publicField(this, "duration"),
      publicField(this, "trail"),
      publicField(this, "type"),
      (this.parameters = e),
      this.defineMaterialProxyProperties([
        "color",
        "size",
        "duration",
        "trail",
        "size3",
        "height",
        "opacity",
      ]);
  }
  initObject() {
    (this.geometry = new wR()),
      (this.material = new UR(this.parameters)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
};
exports.BufferAnalysis = class extends Object3D {
  constructor(e = {}) {
    super(e),
      publicField(this, "_radius"),
      publicField(this, "_type"),
      publicField(this, "_bufferElement"),
      (this._options = e);
  }
  afterAddToEngine(e) {
    (this._engine = e),
      (this._bufferParameters = this._options.bufferParameters || {
        color: "#007be6",
        transparent: !0,
        opacity: 0.5,
      }),
      (this._lineParameters = this._options.lineParameters || {
        color: "#5c5dfd",
      }),
      (this._radius = this._options.radius || 10),
      (this.editorType = this._options.type || "line"),
      (this._line = this._engine.add(
        new eL({
          color: "#5c5dfd",
          keepSize: !0,
          lineWidth: 4,
          depthTest: !1,
          ...this._lineParameters,
        })
      )),
      (this._line.dataSource = UT.fromGeoJSONObject([])),
      (this._line.renderOrder = 100),
      (this._bufferElement = this._engine.add(
        new KD({ ...this._bufferParameters })
      )),
      (this._bufferElement.dataSource = UT.fromGeoJSONObject([]));
  }
  beforeRemoveFromEngine(e) {
    e.remove(this._line), e.remove(this._bufferElement);
  }
  clear() {
    this._line.dataSource.setData(), this._bufferElement.dataSource.setData();
  }
  build() {
    let e;
    (e = "polygon" === this._type ? Gv(this._data) : this._data),
      this._line.dataSource.setData(e),
      this._bufferElement.dataSource.setData(this.bufferData);
  }
  buffer(e, t, i) {
    let n = (i = i || {}).units || "kilometers",
      s = i.steps || 8;
    if (!e) throw new Error("geojson is required");
    if ("object" != typeof i) throw new Error("options must be an object");
    if ("number" != typeof s) throw new Error("steps must be an number");
    if (void 0 === t) throw new Error("radius is required");
    if (s <= 0) throw new Error("steps must be greater than 0");
    let r = [];
    switch (e.type) {
      case "GeometryCollection":
        return (
          Qv(e, (e) => {
            let i = this.bufferFeature(e, t, n, s);
            i && r.push(i);
          }),
          $v(r)
        );
      case "FeatureCollection":
        return (
          Hv(e, (e) => {
            let i = this.bufferFeature(e, t, n, s);
            i &&
              Hv(i, (e) => {
                e && r.push(e);
              });
          }),
          $v(r)
        );
    }
    return this.bufferFeature(e, t, n, s);
  }
  radiansToLength(e, t = "kilometers") {
    const i = vN[t];
    if (!i) throw new Error(t + " units is invalid");
    return e * i;
  }
  lengthToRadians(e, t = "kilometers") {
    const i = vN[t];
    if (!i) throw new Error(t + " units is invalid");
    return e / i;
  }
  bufferFeature(e, t, i, n) {
    let s = e.properties || {},
      r = "Feature" === e.type ? e.geometry : e;
    if ("GeometryCollection" === r.type) {
      let s = [];
      return (
        Qv(e, function (e) {
          let r = this.bufferFeature(e, t, i, n);
          r && s.push(r);
        }),
        $v(s)
      );
    }
    let a = this.defineProjection(r),
      o = { type: r.type, coordinates: this.projectCoords(r.coordinates, a) },
      l = new KL.exports.GeoJSONReader().read(o),
      h = this.radiansToLength(this.lengthToRadians(t, i), "meters"),
      c = KL.exports.BufferOp.bufferOp(l, h, n);
    if (
      ((c = new KL.exports.GeoJSONWriter().write(c)),
      !this.coordsIsNaN(c.coordinates))
    )
      return Jv(
        { type: c.type, coordinates: this.unprojectCoords(c.coordinates, a) },
        s
      );
  }
  coordsIsNaN(e) {
    return Array.isArray(e[0]) ? this.coordsIsNaN(e[0]) : isNaN(e[0]);
  }
  projectCoords(e, t) {
    return "object" != typeof e[0]
      ? t(e)
      : e.map((e) => this.projectCoords(e, t));
  }
  unprojectCoords(e, t) {
    return "object" != typeof e[0]
      ? t.invert(e)
      : e.map((e) => this.unprojectCoords(e, t));
  }
  defineProjection(e) {
    let t = rA(e).geometry.coordinates,
      i = [-t[0], -t[1]];
    return dN(mN).scale(79.4188).clipAngle(179.999).rotate(i).scale(6371008.8);
  }
  get bufferData() {
    return this.buffer(this._data, this._radius, { units: "meters" });
  }
  get data() {
    return this._data;
  }
  set data(e) {
    this._data = e;
  }
  get radius() {
    return this._radius;
  }
  set radius(e) {
    this._radius = e;
  }
  get bufferType() {
    return this._type;
  }
  set bufferType(e) {
    this._type !== e && (this._type = e);
  }
};
exports.CSVDataSource = $I;
exports.Circle = eD;
exports.CircleEditor = UL;
exports.ClippingPlane = ClippingPlane;
exports.ClippingPlaneCollection = ClippingPlaneCollection;
exports.ClusterPoint = class extends GP {
  constructor(e = {}) {
    super(e),
      publicField(this, "_ready"),
      publicField(this, "_cluster"),
      publicField(this, "_clusterDataSource"),
      publicField(this, "_icon"),
      publicField(this, "_label"),
      publicField(this, "_minUpdateInterval"),
      publicField(this, "isEventEntitySupported", !0),
      publicField(this, "_minUpdateInterval", 300),
      publicField(this, "_lastUpdateTime", 0),
      publicField(this, "_updateTimeoutHandler", null),
      publicField(this, "_updateRenderingData", () => {
        const { map: e } = this.engine,
          t = e.getBoundingBox(),
          i = Math.round(e.getZoom()),
          n = this.engine.map.unprojectPointArr(t.min.toArray()),
          s = this.engine.map.unprojectPointArr(t.max.toArray()),
          r = this._cluster.getClusters([...n, ...s], i);
        this._clusterDataSource.setData(r), this._clusterDataSource.update();
        for (const a of this.children) a.setData();
      }),
      (this.parameters = e),
      (this._ready = !1),
      (this._cluster = new RP(Object.assign({}, HP, e.cluster))),
      this._cluster.load([]);
    (this._clusterDataSource = new UT())
      .setAttribute("size")
      .setAttribute("icon")
      .setAttribute("text", (e) => (e && e.cluster ? e.point_count : 0) + "");
  }
  initObject() {}
  afterAddToEngine(e) {
    super.afterAddToEngine(e);
    const t = this.parameters;
    t.icon &&
      (this._icon = this.addComponent(new lP(Object.assign({}, VP, t.icon)))),
      t.label &&
        (this._label = this.addComponent(
          new yP(Object.assign({}, QP, t.label))
        )),
      (this._ready = !0);
  }
  setData() {
    let e = this.dataSource.data;
    (this.cachedData = e),
      this._cluster.load(this.dataSource._geoFeatures),
      (this.needsUpdate = !1);
  }
  onBeforeScenePrepareRender(e, t, i, n) {
    if (!this._ready || !this.dataSource) return;
    this._needsUpdate && this._updateRenderingData(),
      clearTimeout(this._updateTimeoutHandler);
    const s = n.time;
    if (s - this._lastUpdateTime > this._minUpdateInterval)
      return this._updateRenderingData(), void (this._lastUpdateTime = s);
    (this._updateTimeoutHandler = setTimeout(() => {
      this._updateRenderingData(), e.requestRender();
    }, this._minUpdateInterval)),
      super.onBeforeScenePrepareRender(e, t, i, n);
  }
  getChildDataSource() {
    return this._clusterDataSource;
  }
  getEntityByIndex(e) {
    const t = this._clusterDataSource;
    if (!t) return;
    const i = {
        index: e,
        value: t.getOriginData(e),
        itemIndex: t.getOriginDataIndex(e),
        pairs: {},
      },
      n = t.data;
    for (const s of Object.keys(n)) i.pairs[s] = n[s][e];
    return i;
  }
  get minUpdateInterval() {
    return this._minUpdateInterval;
  }
  set minUpdateInterval(e) {
    e < 16 && (e = 16), (this._minUpdateInterval = e);
  }
  get clusterDataSource() {
    return this._clusterDataSource;
  }
};
exports.Cone = class extends InstancedMesh {
  constructor(e) {
    super(e),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "opacity"),
      publicField(this, "height"),
      publicField(this, "size"),
      publicField(this, "getInstanceLocalMatrix", (e, t, i) => {
        const { vertexHeights: n, vertexSizes: s } = this.parameters,
          { height: r, size: a } = this.dataSource.data;
        let o = new Matrix4();
        if (n && r) {
          const e = new Matrix4();
          e.makeScale(1, 1, r[i]), o.multiply(e);
        }
        if (s && a) {
          const e = new Matrix4();
          e.makeScale(a[i], a[i], 1), o.multiply(e);
        }
        return o;
      }),
      publicField(this, "addCustomAttributes", () => {
        this.calcMaxHeight(), this.getSphereIndex();
      }),
      (this.parameters = e),
      this.defineMaterialProxyProperties(["opacity", "color", "size"]);
  }
  initObject() {
    (this.geometry = new gL(this.parameters)),
      (this.material = new vL(this.parameters)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  calcMaxHeight() {
    const { vertexHeights: e } = this.parameters,
      { height: t } = this.dataSource.data;
    let i = -1;
    if (!e || !t) return i;
    for (let n = 0; n < t.length; n++) i < t[n] && (i = t[n]);
    this.material.uniforms.maxHeight.value = i;
  }
  getSphereIndex() {
    const { sphereIndex: e } = this.geometry.parameters;
    this.material.uniforms.sphereIndex.value = e;
  }
};
exports.CustomStaticSky = Hb;
exports.DOMOverlay = bL;
exports.DataItem = oA;
exports.DataSource = fA;
exports.Default3DTiles = class extends Object3D {
  constructor(e) {
    super(),
      publicField(this, "options", null),
      publicField(this, "_tilesRenderer", null),
      publicField(this, "_elementsManager", null),
      publicField(this, "_elementsGroup", null),
      publicField(this, "_editableElementManager", null),
      publicField(this, "engine", null),
      publicField(this, "_tileMaxLevel", 19),
      publicField(this, "is3DTiles", !0),
      publicField(this, "_materialManager", null),
      publicField(this, "_debugTilesRenderer", null),
      publicField(this, "_freezeUpdate", !1),
      publicField(this, "_excludeCastShadowMaterials", {
        road: !0,
        green: !0,
        isolation: !0,
      }),
      publicField(this, "_instancedElementManager", null),
      publicField(this, "_identityType", 1),
      publicField(this, "_visibile", !0),
      publicField(this, "_loaders", []),
      publicField(this, "handleBeforeRender", (e, t) => {
        this._debugTilesRenderer ||
          (!this._freezeUpdate &&
            this._visibile &&
            (this._elementsManager && this._elementsManager.tick(t),
            this._tilesRenderer.update()),
          this._editableElementManager.refreshTiles());
      }),
      publicField(this, "handleLoadTileSet", (e, t, i) => {
        this.engine.requestRender();
      }),
      publicField(this, "handleUpdateModel", (e) => {
        this._materialManager
          ? e.traverse((e) => {
              if (e.originalMaterial) {
                const t = e.originalMaterialName,
                  i = this._materialManager.getMaterialByKey(t);
                e.material = i || e.originalMaterial;
              }
            })
          : e.traverse((e) => {
              e.originalMaterial && (e.material = e.originalMaterial);
            }),
          this.engine.requestRender();
      }),
      publicField(this, "parseTileInfo", (e) => {
        const t = e.content.uri,
          i = t.substring(t.lastIndexOf("/") + 1).split(".")[0],
          n = i.split("-");
        (e.__id = i),
          (e.__level = parseInt(n[0], 10)),
          (e.__lodLevel = this._tileMaxLevel - e.__level);
      }),
      publicField(this, "handleLoadModel", (e, t) => {
        this._materialManager &&
          e.traverse((e) => {
            if (e.material) {
              const t = e.material.name;
              (e.originalMaterial = e.material), (e.originalMaterialName = t);
              const i = this._materialManager.getMaterialByKey(t);
              i && (e.material = i),
                this._excludeCastShadowMaterials[t] || (e.castShadow = !0),
                (e.receiveShadow = !0);
            }
          }),
          (e._tileUri = t.content.uri),
          this.parseTileInfo(t),
          this._instancedElementManager.onTileLoad(t, e),
          this._elementsManager.onTileLoad(t, e),
          this._editableElementManager.onTileLoad(t, e),
          this.engine.requestRender();
      }),
      publicField(this, "handleDisposeModel", (e, t) => {
        this._instancedElementManager.onTileDispose(t, e),
          this._elementsManager.onTileDispose(t, e),
          this._editableElementManager.onTileDispose(t, e);
      }),
      publicField(this, "handleTileVisibleChanged", (e, t, i) => {
        i
          ? (this._editableElementManager.onTileShow(t),
            this._instancedElementManager.onTileShow(t),
            this._elementsManager.onTileShow(t))
          : (this._editableElementManager.onTileHide(t),
            this._instancedElementManager.onTileHide(t),
            this._elementsManager.onTileHide(t));
      }),
      publicField(this, "handleDebugBeforeengineRender", () => {
        this._freezeUpdate || this._debugTilesRenderer.update();
      }),
      publicField(this, "_updateTilesCustomLoaders", (e) => {
        for (const t of this._loaders) e.manager.addHandler(t[0], t[1]);
      }),
      publicField(this, "handleDebugLoadTileSet", () => {
        this.engine.requestRender();
      }),
      publicField(this, "handleDebugLoadModel", () => {
        this.engine.requestRender();
      }),
      publicField(this, "transformFromEcefToPlane", (e, t, i = 0) => {
        let n = Lw.eastNorthUpToFixedFrame(Lw.lnglatToEcef(e, t, i));
        n.invert();
        const s = new Matrix4(),
          r = uv([e, t]);
        s.makeTranslation(r[0], r[1], 0);
        const a = new Matrix4();
        a.multiplyMatrices(s, n),
          a.decompose(this.position, this.quaternion, this.scale);
      }),
      publicField(this, "lockCameraViewport", () => {
        const e = this.showDebug
            ? this._debugTilesRenderer
            : this._tilesRenderer,
          t = this._engine,
          i = t.camera,
          n = (this._lockedCamera = i.clone());
        e.hasCamera(i) && e.deleteCamera(i),
          e.setCamera(n),
          e.setResolutionFromRenderer(n, t.renderer),
          this._updateCameraHelper(n);
      }),
      publicField(this, "releaseCameraViewport", () => {
        const e = this.showDebug
            ? this._debugTilesRenderer
            : this._tilesRenderer,
          t = this._engine,
          i = t.camera,
          n = this._lockedCamera;
        this._lockedCamera &&
          e.hasCamera(n) &&
          (e.deleteCamera(n), (this._lockedCamera = null)),
          e.setCamera(i),
          e.setResolutionFromRenderer(i, t.renderer),
          this._destoryCameraHelper();
      }),
      publicField(this, "preloadView", (e) => {
        let t = this._tilesRenderer.preloadCamera;
        t ||
          ((t = this.engine.camera.clone()), this._tilesRenderer.setCamera(t));
        const { position: i } = e;
        this.engine.map._map._cameraLookAt(t, i, e),
          this.tilesRenderer.setResolutionFromRenderer(t, this.engine.renderer);
      }),
      publicField(this, "removePreloadView", () => {
        this._tilesRenderer.removePreloadCamera();
      }),
      publicField(this, "disposeTilesRender", (e) => {
        e.forEachLoadedModel((t, i) => {
          e.disposeTile(i);
        });
      }),
      (this.options = e);
    const t = (this._tilesRenderer = new rw(this.options.url));
    (t.lruCache.cacheList = []),
      (t.fetchOptions = e.fetchOptions || {}),
      (t.errorTarget = e.errorTarget || 64),
      (t.preprocessURL = e.preprocessURL || null),
      (t.errorThreshold = e.errorThreshold || 1 / 0),
      (t.maxDepth = e.maxDepth || 1 / 0),
      (t.loadSiblings = void 0 === e.loadSiblings || e.loadSiblings),
      (t.displayActiveTiles =
        void 0 !== e.displayActiveTiles && e.displayActiveTiles),
      (t.autoDisableRendererCulling =
        void 0 === e.autoDisableRendererCulling ||
        e.autoDisableRendererCulling),
      e.lruCache_maxSize &&
        ((t.lruCache.minSize = Math.max(0.25 * e.lruCache_maxSize, 100)),
        (t.lruCache.maxSize = e.lruCache_maxSize)),
      (t.downloadQueue.priorityCallback = _T),
      e.maxDownloadJobs && (t.downloadQueue.maxJobs = e.maxDownloadJobs),
      (t.parseQueue.priorityCallback = _T),
      e.maxParseJobs && (t.parseQueue.maxJobs = e.maxParseJobs),
      (t.enabledSchedule = e.enabledSchedule || !1),
      (t.deferOutSideFrustum = e.deferOutSideFrustum || !1),
      (t.deferLoadDepth = e.deferLoadDepth || 100),
      (t.cullWithChildrenBounds = e.cullWithChildrenBounds || !1),
      (t.cullRequestsWhileMoving = e.cullRequestsWhileMoving || !1),
      (t.cullRequestsWhileMovingMultiplier =
        e.cullRequestsWhileMovingMultiplier || 60),
      (t.dynamicScreenSpaceError = e.dynamicScreenSpaceError || !1),
      (t.dynamicScreenSpaceErrorFactor = e.dynamicScreenSpaceErrorFactor || 4),
      (t.dynamicScreenSpaceErrorHeightFalloff =
        e.dynamicScreenSpaceErrorHeightFalloff || 0.25),
      (t.dynamicScreenHeightScale = e.dynamicScreenHeightScale || 6),
      (t.dynamicScreenSpaceErrorDensity =
        e.dynamicScreenSpaceErrorDensity || 0.00278),
      (t.foveatedScreenSpaceError = e.foveatedScreenSpaceError || !1),
      (t.foveatedConeSize = e.foveatedConeSize || 0.3),
      (t.cacheDepth = e.cacheDepth || 5),
      (t.maxCacheChildren = e.maxCacheChildren = 100),
      this.add(t.group);
    const i = (this._elementsGroup = new va());
    this.add(i);
    (this._elementsManager = new vw(this._elementsGroup)).tilesRenderer = t;
    const n = (this._instancedElementManager = new Sw());
    (n.tilesRenderer = t), this.add(n.group);
    ((this._editableElementManager = new Dw()).tilesRenderer = t),
      Array.isArray(e.loaders)
        ? (this._loaders = e.loaders)
        : (this._loaders = []),
      this._updateTilesCustomLoaders(t);
  }
  afterAddToEngine(e) {
    this.engine = this._engine = e;
    const t = this._tilesRenderer;
    (t._engine = e),
      t.setCamera(e.camera),
      t.setResolutionFromRenderer(e.camera, e.renderer),
      (t.onLoadTileSet = this.handleLoadTileSet),
      (t.onLoadModel = this.handleLoadModel),
      (t.onDisposeModel = this.handleDisposeModel),
      (t.onTileVisibilityChange = this.handleTileVisibleChanged),
      e.addPrepareRenderListener(this.handleBeforeRender),
      (this._instancedElementManager.engine = e),
      (this._elementsManager.engine = e),
      (this._editableElementManager.engine = e);
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  getBounds() {
    const e = new Box3(),
      t = this._tilesRenderer.getBounds(e);
    return t && e.applyMatrix4(this.matrixWorld), t ? e : null;
  }
  createDebugTilesRenderer() {
    this._tilesRenderer.group.visible = !1;
    const e = (this._debugTilesRenderer = new _w(this.options.url)),
      t = this.engine;
    (e._engine = t),
      e.setCamera(t.camera),
      e.setResolutionFromRenderer(t.camera, t.renderer),
      (e.errorTarget = this._tilesRenderer.errorTarget),
      (e.loadSiblings = this._tilesRenderer.loadSiblings),
      (e.displayActiveTiles = this._tilesRenderer.displayActiveTiles),
      (e.autoDisableRendererCulling =
        this._tilesRenderer.autoDisableRendererCulling),
      (e.preprocessURL = this._tilesRenderer.preprocessURL),
      (e.errorThreshold = this._tilesRenderer.errorThreshold),
      (e.maxDepth = this._tilesRenderer.maxDepth),
      (e.displayBoxBounds = !0),
      (e.enabledSchedule = this._tilesRenderer.enabledSchedule),
      (e.deferOutSideFrustum = this._tilesRenderer.deferOutSideFrustum),
      (e.deferLoadDepth = this._tilesRenderer.deferLoadDepth),
      (e.cullWithChildrenBounds = this._tilesRenderer.cullWithChildrenBounds),
      (e.cullRequestsWhileMoving = this._tilesRenderer.cullRequestsWhileMoving),
      (e.cullRequestsWhileMovingMultiplier =
        this._tilesRenderer.cullRequestsWhileMovingMultiplier),
      (e.dynamicScreenSpaceError = this._tilesRenderer.dynamicScreenSpaceError),
      (e.dynamicScreenSpaceErrorFactor =
        this._tilesRenderer.dynamicScreenSpaceErrorFactor),
      (e.dynamicScreenSpaceErrorHeightFalloff =
        this._tilesRenderer.dynamicScreenSpaceErrorHeightFalloff),
      (e.dynamicScreenHeightScale =
        this._tilesRenderer.dynamicScreenHeightScale),
      (e.dynamicScreenSpaceErrorDensity =
        this._tilesRenderer.dynamicScreenSpaceErrorDensity),
      (e.foveatedScreenSpaceError =
        this._tilesRenderer.foveatedScreenSpaceError),
      (e.foveatedConeSize = this._tilesRenderer.foveatedConeSize),
      (e.cacheDepth = this._tilesRenderer.cacheDepth),
      (e.maxCacheChildren = this._tilesRenderer.maxCacheChildren),
      (e.onLoadTileSet = this.handleLoadTileSet),
      (e.onLoadModel = this.handleLoadModel),
      t.addPrepareRenderListener(this.handleDebugBeforeengineRender),
      this._updateTilesCustomLoaders(e),
      this.add(this._debugTilesRenderer.group);
  }
  isEntityVisible(e) {
    return !e.id || !this._editableElementManager.hasDeletedId(e.id);
  }
  _updateCameraHelper(e) {
    const t = this._engine;
    this._destoryCameraHelper();
    const i = (this._cameraHelper = new ah(e));
    t.add(i);
  }
  _destoryCameraHelper() {
    const e = this._engine;
    this._cameraHelper &&
      (e.remove(this._cameraHelper),
      this._cameraHelper.dispose(),
      (this._cameraHelper = null));
  }
  destoryDebugTilesRenderer() {
    this.remove(this._debugTilesRenderer.group),
      this.engine.removePrepareRenderListener(
        this.handleDebugBeforeengineRender
      ),
      this.disposeTilesRender(this._debugTilesRenderer),
      this._debugTilesRenderer.dispose(),
      (this._tilesRenderer.group.visible = !0);
  }
  dispose() {
    this.remove(this._tilesRenderer.group),
      this.engine.removePrepareRenderListener(this.handleBeforeRender),
      this.disposeTilesRender(this._tilesRenderer),
      this._tilesRenderer.dispose(),
      this._debugTilesRenderer &&
        (this.remove(this._debugTilesRenderer.group),
        this.engine.removePrepareRenderListener(
          this.handleDebugBeforeengineRender
        ),
        this.disposeTilesRender(this._debugTilesRenderer),
        this._debugTilesRenderer.dispose());
  }
  get checkIntersectByBox() {
    return (
      (this.showDebug ? this._debugTilesRenderer : this._tilesRenderer)
        .checkIntersectByBox || !1
    );
  }
  set checkIntersectByBox(e) {
    (this.showDebug
      ? this._debugTilesRenderer
      : this._tilesRenderer
    ).checkIntersectByBox = e;
  }
  set materialManager(e) {
    e &&
      ((e.engine = this.engine),
      (e.tiles = this),
      e.init(),
      e.Identity3DTilesMaterialManager && (e.type = this._identityType)),
      (this._materialManager = e),
      this._tilesRenderer.forEachLoadedModel(this.handleUpdateModel);
  }
  get materialManager() {
    return this._materialManager;
  }
  set showDebug(e) {
    e
      ? this._debugTilesRenderer || this.createDebugTilesRenderer()
      : this._debugTilesRenderer &&
        (this.destoryDebugTilesRenderer(), (this._debugTilesRenderer = null)),
      this.engine.requestRender();
  }
  get showDebug() {
    return !!this._debugTilesRenderer;
  }
  get debugTilesRenderer() {
    return this._debugTilesRenderer;
  }
  get elementsManager() {
    return this._elementsManager;
  }
  get freezeUpdate() {
    return this._freezeUpdate;
  }
  set freezeUpdate(e) {
    this._freezeUpdate = e;
  }
  get errorTarget() {
    return this._tilesRenderer.errorTarget;
  }
  set errorTarget(e) {
    (this._tilesRenderer.errorTarget = e),
      this._debugTilesRenderer && (this._debugTilesRenderer.errorTarget = e),
      this.engine.requestRender();
  }
  get tilesGroup() {
    return this._tilesRenderer.group;
  }
  get tilesRenderer() {
    return this._tilesRenderer;
  }
  get instancedElementManager() {
    return this._instancedElementManager;
  }
  get editableElementManager() {
    return this._editableElementManager;
  }
  get identityType() {
    return this._identityType;
  }
  set identityType(e) {
    (this._identityType = e),
      this._materialManager &&
        this._materialManager.isIdentity3DTilesMaterialManager &&
        (this._materialManager.type = e);
  }
  get loadSiblings() {
    return this._tilesRenderer.loadSiblings;
  }
  set loadSiblings(e) {
    (this._tilesRenderer.loadSiblings = e),
      this._debugTilesRenderer && (this._debugTilesRenderer.loadSiblings = e);
  }
  get displayActiveTiles() {
    return this._tilesRenderer.displayActiveTiles;
  }
  set displayActiveTiles(e) {
    (this._tilesRenderer.displayActiveTiles = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.displayActiveTiles = e);
  }
  get autoDisableRendererCulling() {
    return this._tilesRenderer.autoDisableRendererCulling;
  }
  set autoDisableRendererCulling(e) {
    (this._tilesRenderer.autoDisableRendererCulling = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.autoDisableRendererCulling = e);
  }
  get preprocessURL() {
    return this._tilesRenderer.preprocessURL;
  }
  set preprocessURL(e) {
    (this._tilesRenderer.preprocessURL = e),
      this._debugTilesRenderer && (this._debugTilesRenderer.preprocessURL = e);
  }
  get errorThreshold() {
    return this._tilesRenderer.errorThreshold;
  }
  set errorThreshold(e) {
    (this._tilesRenderer.errorThreshold = e),
      this._debugTilesRenderer && (this._debugTilesRenderer.errorThreshold = e);
  }
  get maxDepth() {
    return this._tilesRenderer.maxDepth;
  }
  set maxDepth(e) {
    (this._tilesRenderer.maxDepth = e),
      this._debugTilesRenderer && (this._debugTilesRenderer.maxDepth = e);
  }
  get enabledSchedule() {
    return this._tilesRenderer.enabledSchedule;
  }
  set enabledSchedule(e) {
    (this._tilesRenderer.enabledSchedule = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.enabledSchedule = e);
  }
  get cacheDepth() {
    return this._tilesRenderer.maxCacheChildren;
  }
  set cacheDepth(e) {
    (this._tilesRenderer.cacheDepth = e),
      this._debugTilesRenderer && (this._debugTilesRenderer.cacheDepth = e);
  }
  get maxCacheChildren() {
    return this._tilesRenderer.maxCacheChildren;
  }
  set maxCacheChildren(e) {
    (this._tilesRenderer.maxCacheChildren = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.maxCacheChildren = e);
  }
  get deferLoadDepth() {
    return this._tilesRenderer.deferLoadDepth;
  }
  set deferLoadDepth(e) {
    (this._tilesRenderer.deferLoadDepth = e),
      this._debugTilesRenderer && (this._debugTilesRenderer.deferLoadDepth = e);
  }
  get deferOutSideFrustum() {
    return this._tilesRenderer.deferOutSideFrustum;
  }
  set deferOutSideFrustum(e) {
    (this._tilesRenderer.deferOutSideFrustum = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.deferOutSideFrustum = e);
  }
  get cullWithChildrenBounds() {
    return this._tilesRenderer.cullWithChildrenBounds;
  }
  set cullWithChildrenBounds(e) {
    (this._tilesRenderer.cullWithChildrenBounds = e),
      this._debugTilesRenderer &&
        (this._tilesRenderer.cullWithChildrenBounds = e);
  }
  get cullRequestsWhileMoving() {
    return this._tilesRenderer.cullRequestsWhileMoving;
  }
  set cullRequestsWhileMoving(e) {
    (this._tilesRenderer.cullRequestsWhileMoving = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.cullRequestsWhileMoving = e);
  }
  get cullRequestsWhileMovingMultiplier() {
    return this._tilesRenderer.cullRequestsWhileMovingMultiplier;
  }
  set cullRequestsWhileMovingMultiplier(e) {
    (this._tilesRenderer.cullRequestsWhileMovingMultiplier = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.cullRequestsWhileMovingMultiplier = e);
  }
  get dynamicScreenSpaceError() {
    return this._tilesRenderer.dynamicScreenSpaceError;
  }
  set dynamicScreenSpaceError(e) {
    (this._tilesRenderer.dynamicScreenSpaceError = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.dynamicScreenSpaceError = e);
  }
  get dynamicScreenSpaceErrorFactor() {
    return this._tilesRenderer.dynamicScreenSpaceErrorFactor;
  }
  set dynamicScreenSpaceErrorFactor(e) {
    (this._tilesRenderer.dynamicScreenSpaceErrorFactor = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.dynamicScreenSpaceErrorFactor = e);
  }
  get dynamicScreenSpaceErrorHeightFalloff() {
    return this._tilesRenderer.dynamicScreenSpaceErrorHeightFalloff;
  }
  set dynamicScreenSpaceErrorHeightFalloff(e) {
    (this._tilesRenderer.dynamicScreenSpaceErrorHeightFalloff = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.dynamicScreenSpaceErrorHeightFalloff = e);
  }
  get dynamicScreenHeightScale() {
    return this._tilesRenderer.dynamicScreenHeightScale;
  }
  set dynamicScreenHeightScale(e) {
    (this._tilesRenderer.dynamicScreenHeightScale = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.dynamicScreenHeightScale = e);
  }
  get dynamicScreenSpaceErrorDensity() {
    return this._tilesRenderer.dynamicScreenSpaceErrorDensity;
  }
  set dynamicScreenSpaceErrorDensity(e) {
    (this._tilesRenderer.dynamicScreenSpaceErrorDensity = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.dynamicScreenSpaceErrorDensity = e);
  }
  get foveatedScreenSpaceError() {
    return this._tilesRenderer.foveatedScreenSpaceError;
  }
  set foveatedScreenSpaceError(e) {
    (this._tilesRenderer.foveatedScreenSpaceError = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.foveatedScreenSpaceError = e);
  }
  get foveatedConeSize() {
    return this._tilesRenderer.foveatedConeSize;
  }
  set foveatedConeSize(e) {
    (this._tilesRenderer.foveatedConeSize = e),
      this._debugTilesRenderer &&
        (this._debugTilesRenderer.foveatedConeSize = e);
  }
  set visible(e) {
    (this._visibile = e),
      this._tilesRenderer && (this._tilesRenderer.group.visible = e);
  }
  get visible() {
    return this._visibile;
  }
};
exports.Default3DTilesMaterialManager = yT;
exports.DomPoints = dP;
exports.DynamicInstancedMesh = Cw;
exports.DynamicSky = sE;
exports.DynamicWeather = og;
exports.EffectModelPoint = class extends GeoObject {
  constructor(e) {
    super(),
      publicField(this, "_model"),
      publicField(this, "_normalize"),
      publicField(this, "_rotateToZUp"),
      publicField(this, "_keepSize"),
      publicField(this, "_size"),
      publicField(this, "_size3"),
      publicField(this, "_useSize3"),
      publicField(this, "_height"),
      publicField(this, "_animationRotate"),
      publicField(this, "_animationRotatePeriod"),
      publicField(this, "_animationJump"),
      publicField(this, "_animationJumpPeriod"),
      publicField(this, "_animationJumpHeight"),
      publicField(this, "isEventEntitySupported", !0),
      publicField(this, "_model", null),
      publicField(this, "_normalize", !0),
      publicField(this, "_rotateToZUp", !0),
      publicField(this, "_keepSize", !0),
      publicField(this, "_size", 1),
      publicField(this, "_size3", [1, 1, 1]),
      publicField(this, "_useSize3", !1),
      publicField(this, "_height", 0),
      publicField(this, "_animationRotate", !1),
      publicField(this, "_animationRotatePeriod", 3e3),
      publicField(this, "_animationJump", !1),
      publicField(this, "_animationJumpPeriod", 3e3),
      publicField(this, "_animationJumpHeight", 30),
      publicField(this, "_updateModel", () => {
        this._cleanOldMesh();
        const e = bw(this._model, this._normalize, this._rotateToZUp);
        for (const t of e) {
          const e = t.material;
          let i = new WP();
          i.setCommonUniforms(this.engine.rendering.uniforms),
            (i.transparent = e.transparent),
            (i.opacity = e.opacity),
            (i.side = e.side),
            (i.depthWrite = e.depthWrite),
            (i.depthTest = e.depthTest),
            (i.depthFunc = e.depthFunc),
            (i.blendDst = e.blendDst),
            (i.blendDstAlpha = e.blendDstAlpha),
            (i.blendEquation = e.blendEquation),
            (i.blendEquationAlpha = e.blendEquationAlpha),
            (i.blending = e.blending),
            (i.blendSrc = e.blendSrc),
            (i.blendSrcAlpha = e.blendSrcAlpha),
            (i.premultipliedAlpha = e.premultipliedAlpha),
            (i.color = e.color),
            (i.colorWrite = e.colorWrite),
            (i.emissive = e.emissive),
            (i.map = e.map),
            (i.keepSize = this._keepSize),
            (i.size = this._size),
            (i.size3 = this._size3),
            (i.useSize3 = this._useSize3),
            (i.height = this._height),
            (i.animationRotate = this._animationRotate),
            (i.animationRotatePeriod = this._animationRotatePeriod),
            (i.animationJump = this._animationJump),
            (i.animationJumpPeriod = this._animationJumpPeriod),
            (i.animationJumpHeight = this._animationJumpHeight);
          const n = t.geometry,
            s = n.getAttribute("color");
          s &&
            (4 === s.itemSize
              ? (i.vertexColors4 = !0)
              : 3 === s.itemSize && (i.vertexColors3 = !0));
          const r = new InstancedMesh(n, i);
          (r.engine = this.engine),
            (r.receiveRaycast = this.receiveRaycast),
            (r.dataAutoUpdate = !1),
            (r.__eventProxyByParent = !0),
            this.dataSource && (r.dataSource = this.dataSource),
            this.add(r);
        }
        this.needsUpdate = !0;
      }),
      publicField(this, "_cleanOldMesh", () => {
        const e = this.children;
        for (const t of e)
          this.remove(t),
            t.geometry && t.geometry.dispose(),
            t.material &&
              (t.material.map && t.material.map.dispose(),
              t.material.dispose());
      }),
      publicField(this, "_defineChildrenMaterialProperty", (e) => {
        Object.defineProperty(this, e, {
          get: function () {
            return this["_" + e];
          },
          set: function (t) {
            this["_" + e] = t;
            for (const i of this.children) i.material[e] = t;
          },
        });
      }),
      (e = Object.assign({}, qP, e)),
      (this._normalize = e.normalize),
      (this._rotateToZUp = e.rotateToZUp),
      [
        "size",
        "size3",
        "useSize3",
        "height",
        "keepSize",
        "animationRotate",
        "animationRotatePeriod",
        "animationJump",
        "animationJumpPeriod",
        "animationJumpHeight",
      ].forEach((t) => {
        void 0 !== e[t] && (this["_" + t] = e[t]),
          this._defineChildrenMaterialProperty(t);
      });
  }
  setData() {
    const e = this.dataSource;
    for (const t of this.children) (t.dataSource = e), t.setData();
    this.needsUpdate = !1;
  }
  onDispose() {
    this._cleanOldMesh();
  }
  set model(e) {
    e !== this._model && ((this._model = e), this._updateModel());
  }
  get model() {
    return this._model;
  }
};
exports.EmptySky = Wm;
exports.Engine = class {
  constructor(e, t = {}) {
    publicField(this, "_container"),
      publicField(this, "_event"),
      publicField(this, "_map"),
      publicField(this, "_rendering"),
      publicField(this, "_selection"),
      publicField(this, "_controls"),
      publicField(this, "isEngine", !0),
      (this._container = e),
      (this._event = new sy(this, t.event)),
      (this._map = new Hx(this, t.map)),
      this._map.init();
    const i = this.map.getResolution();
    (this._rendering = new ey(this, { resolution: i, ...t.rendering })),
      this._rendering.init(),
      this._map.afterInit(),
      this._rendering.startRenderLoop(),
      (this._selection = new Mb(this, t.selection)),
      (this._controls = new Ub(this, t.controls)),
      this.trackingRequest();
  }
  add(e) {
    return this._rendering.add(e);
  }
  remove(e) {
    this._rendering.remove(e);
  }
  requestRender() {
    this._rendering.requestRender();
  }
  addPrepareRenderListener(e) {
    this._rendering.addPrepareRenderListener(e);
  }
  addBeforeRenderListener(e) {
    this._rendering.addBeforeRenderListener(e);
  }
  removeBeforeRenderListener(e) {
    this._rendering.removeBeforeRenderListener(e);
  }
  removePrepareRenderListener(e) {
    this._rendering.removePrepareRenderListener(e);
  }
  addBeforePrepareRenderObject(e) {
    this._rendering.addBeforePrepareRenderObject(e);
  }
  removeBeforePrepareRenderObject(e) {
    this._rendering.removeBeforePrepareRenderObject(e);
  }
  addBeforeRenderObject(e) {
    this._rendering.addBeforeRenderObject(e);
  }
  removeBeforeRenderObject(e) {
    this._rendering.removeBeforeRenderObject(e);
  }
  lockCamera() {
    this.camera._isLocked = !0;
  }
  unlockCamera() {
    this.camera._isLocked = !1;
  }
  get container() {
    return this._container;
  }
  get map() {
    return this._map;
  }
  get rendering() {
    return this._rendering;
  }
  get controls() {
    return this._controls;
  }
  get renderer() {
    return this._rendering.renderer;
  }
  get scene() {
    return this._rendering.scene;
  }
  get camera() {
    return this._rendering.camera;
  }
  get event() {
    return this._event;
  }
  get selection() {
    return this._selection;
  }
  dispose() {
    this._controls.dispose(),
      this._event.dispose(),
      this._selection.dispose(),
      this._rendering.dispose(),
      this._map.dispose();
  }
  trackingRequest() {
    var e, t;
    null == (t = null == (e = this._map._map) ? void 0 : e.map) ||
      t._printLog("mapvthree");
  }
};
exports.ExtendMeshStandardMaterial = Tw;
exports.FanPoint = class extends InstancedMesh {
  constructor(e) {
    super(e),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "color"),
      publicField(this, "opacity"),
      publicField(this, "size"),
      publicField(this, "height"),
      publicField(this, "speed"),
      publicField(this, "type"),
      publicField(this, "segmentAngle"),
      publicField(this, "sideColor"),
      (this.parameters = e),
      this.defineMaterialProxyProperties([
        "color",
        "size",
        "size3",
        "height",
        "opacity",
        "speed",
        "segmentAngle",
        "sideColor",
      ]);
  }
  initObject() {
    (this.geometry = new wR()),
      (this.material = new BR(this.parameters)),
      (this.material.animationRotate = !0),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
};
exports.FatLine = eL;
exports.FloodAnalysis = class extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_coverageArea", []),
      publicField(this, "_currentHeight", 0),
      publicField(this, "_floodSpeed", 50),
      publicField(this, "_maxVisibleValue", 0),
      publicField(this, "_minVisibleValue", 0),
      publicField(this, "_dataSource", null),
      publicField(this, "_enabled", !1),
      publicField(this, "_floodPolygon"),
      publicField(this, "_floodSpeed"),
      publicField(this, "_floodState"),
      publicField(this, "_color", "#007be6"),
      publicField(this, "_opacity", 0.5),
      publicField(this, "_startFlood", () => {
        2 !== this._floodState &&
          (this._currentHeight < this.maxVisibleValue
            ? ((this._currentHeight += this.floodSpeed), this.floodCallback())
            : (this._floodState = 2));
      });
  }
  afterAddToEngine(e) {
    this._engine = e;
  }
  floodCallback() {
    "ColorSetting" === this.type ||
      (this._floodPolygon
        ? (this._floodPolygon.extrudeValue = this._currentHeight)
        : ((this._floodPolygon = this._engine.add(
            new KD({
              transparent: !0,
              color: this._color,
              opacity: this._opacity,
              extrude: !0,
              extrudeValue: this._currentHeight,
            })
          )),
          (this._floodPolygon.dataSource = this._dataSource)));
  }
  destroy() {
    this._engine.remove(this._floodPolygon), (this._floodPolygon = null);
  }
  reset() {
    this.destroy(),
      (this._currentHeight = this._minVisibleValue),
      (this._floodState = 0);
  }
  get color() {
    return this._color;
  }
  set color(e) {
    (this._color = e), this._floodPolygon && (this._floodPolygon.color = e);
  }
  get opacity() {
    return this._opacity;
  }
  set opacity(e) {
    (this._opacity = e), this._floodPolygon && (this._floodPolygon.opacity = e);
  }
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(e) {
    e && e instanceof fA
      ? ((this._dataSource = e),
        this._floodPolygon && (this._floodPolygon.dataSource = e))
      : console.warn("DataSource is invalid");
  }
  get maxVisibleValue() {
    return this._maxVisibleValue;
  }
  set maxVisibleValue(e) {
    e <= this.minVisibleValue
      ? console.warn(
          "The maxVisibleValue must greater than the minVisibleValue"
        )
      : (this._maxVisibleValue = e);
  }
  get minVisibleValue() {
    return this._minVisibleValue;
  }
  set minVisibleValue(e) {
    e > this._maxVisibleValue
      ? console.warn("The maxVisibleValue must less than the minVisibleValue")
      : ((this._minVisibleValue = e), (this._currentHeight = e));
  }
  get floodSpeed() {
    return this._floodSpeed;
  }
  set floodSpeed(e) {
    if (e < 0) this._floodSpeed = 0;
    else {
      let t = 16;
      this._engine && (t = this._engine.rendering.animationLoopFrameTime),
        (this._floodSpeed = (e * t) / 1e3);
    }
  }
  get floodState() {
    return this._floodState;
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled !== e &&
      ((this._enabled = e),
      e
        ? 1 !== this._floodState &&
          ((this._floodState = 1),
          this._engine.rendering.addPrepareRenderListener(this._startFlood))
        : (this._engine.rendering.removePrepareRenderListener(this._startFlood),
          this.reset()));
  }
};
exports.FlyManager = class extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_engine"),
      publicField(this, "_isRunning", !1),
      publicField(this, "_animationStartTime", 0),
      publicField(this, "_animationDuration", 0),
      publicField(this, "_animationStartState", null),
      publicField(this, "_animationFinishState", null),
      publicField(this, "update", (e, t) => {
        if (!this._isRunning) return;
        const i = t.time - this._animationStartTime;
        let n = 1;
        this._animationDuration > 0 && (n = i / this._animationDuration),
          n > 1 && (n = 1);
        const s = this._animationStartState,
          r = this._animationFinishState,
          a = this._engine.map;
        let o = {};
        void 0 !== s.heading && (o.heading = xv(s.heading, r.heading, n)),
          void 0 !== s.pitch && (o.pitch = xv(s.pitch, r.pitch, n)),
          void 0 !== s.zoom && (o.zoom = xv(s.zoom, r.zoom, n)),
          void 0 !== s.range && (o.range = xv(s.range, r.range, n));
        let l = bv(s.center, r.center, n);
        a.lookAt(l, o),
          i >= this._animationDuration || n >= 1
            ? ((this._isRunning = !1), this.onFinish && this.onFinish())
            : this._engine.requestRender();
      }),
      publicField(this, "restrictHeading", (e, t) =>
        Math.abs(t - e + 360) < 180
          ? t + 360
          : Math.abs(t - e - 360) < 180
          ? t - 360
          : t
      );
  }
  afterAddToEngine(e) {
    (this._engine = e), e.addPrepareRenderListener(this.update);
  }
  flyTo(e, t = {}) {
    let { center: i, pitch: n, heading: s, zoom: r, range: a } = e;
    const { duration: o = 300 } = t,
      l = {},
      h = {},
      c = this._engine.map,
      u = c.getCenter(),
      d = i || c.getCenter();
    !u[2] && (u[2] = 0),
      !d[2] && (d[2] = 0),
      (l.center = u),
      (h.center = d),
      isNaN(n) || ((l.pitch = c.getPitch()), (h.pitch = n)),
      isNaN(s) ||
        ((s = this.restrictHeading(c.getHeading(), s)),
        (l.heading = c.getHeading()),
        (h.heading = s)),
      isNaN(r) || ((l.zoom = c.getZoom()), (h.zoom = r)),
      isNaN(a) || ((l.range = c.getCameraDistance()), (h.range = a)),
      (this._animationStartState = l),
      (this._animationFinishState = h),
      (this._animationDuration = o),
      (this._isRunning = !0),
      (this._animationStartTime = new Date().getTime()),
      this._engine.requestRender(),
      this.onStart && this.onStart();
  }
  beforeRemoveFromEngine() {
    this._engine.removePrepareRenderListener(this.update),
      this.removeFromParent();
  }
};
exports.FoliageLeafMaterial = Pw;
exports.GeoInstancedMesh = InstancedMesh;
exports.GeoJSONDataSource = UT;
exports.Grid = class extends InstancedMesh {
  constructor(e) {
    super(e),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "color"),
      publicField(this, "height"),
      publicField(this, "radialSegments"),
      publicField(this, "radiusTop"),
      publicField(this, "radiusBottom"),
      publicField(this, "openEnded"),
      publicField(this, "heightSegments"),
      publicField(this, "isMultiColor"),
      publicField(this, "multiColor"),
      publicField(this, "isLight"),
      publicField(this, "lightPos"),
      (this.parameters = e),
      this.defineGeometryProxyProperties([
        "height",
        "radiusTop",
        "radiusBottom",
        "height",
        "radialSegments",
        "heightSegments",
        "openEnded",
      ]),
      this.defineMaterialProxyProperties([
        "color",
        "multiColor",
        "isMultiColor",
        "lightPos",
      ]);
  }
  initObject() {
    (this.geometry = new cL(this.parameters)),
      (this.material = new dL(this.parameters)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
};

exports.Heatmap = makeHeatmapClass(
  Mesh,
  Wi,
  Wa,
  wa,
  ut,
  aD,
  oD,
  sD,
  iD,
  rn,
  InstancedMesh
);
exports.Heatmap3D = makeHeatmap3DClass(
  Mesh,
  PlaneGeometry,
  CommonShaderMaterial,
  In,
  Xn,
  N_,
  CanvasTexture
);

exports.Icon = lP;
exports.IconPoint = JR;
exports.Identity3DTilesMaterialManager = class extends yT {
  constructor() {
    super(),
      publicField(this, "_type", 1),
      publicField(this, "isIdentity3DTilesMaterialManager", !0),
      (this.material = new TT({ color: 35020 }));
  }
  onInit() {
    this.updateType();
  }
  updateType() {
    (this.tiles.instancedElementManager.idEnabled = 1 === this._type),
      (this.tiles.instancedElementManager.dataTypeEnabled = 2 === this._type),
      (this.material.type = this._type);
  }
  getMaterialByKey(e) {
    return this.material;
  }
  dispose() {
    this.material.dispose();
  }
  set type(e) {
    (this._type = e), this.updateType();
  }
  get type() {
    return this._type;
  }
};
exports.JSONDataSource = tR;
exports.LODDynamicInstancedMesh = class extends Object3D {
  constructor(e) {
    super(),
      publicField(this, "_lodMeshes", []),
      publicField(this, "_lodChildren", {}),
      (this._lodMeshes = e || []);
  }
  addInstances(e, t = 0) {
    let i = this._lodChildren[t];
    if (!i) {
      let e = this._lodMeshes[t];
      e || (e = this._lodMeshes[this._lodMeshes.length - 1]),
        (i = new Cw(e)),
        (this._lodChildren[t] = i),
        this.add(i);
    }
    i && i.addInstances(e);
  }
  removeInstances(e, t = 0) {
    const i = this._lodChildren[t];
    i && i.removeInstances(e);
  }
  setMeshesAt(e, t = 0) {
    this._lodMeshes[t] = e;
    const i = this._lodChildren;
    i[t] && (i[t].meshes = e);
  }
  setLODMeshes(e) {
    for (let t = 0; t < e.length; t++) {
      const i = e[t];
      this.setMeshesAt(i, t);
    }
  }
  set needsUpdate(e) {
    if (e) {
      const e = this.children;
      for (const t of e) t && (t.needsUpdate = !0);
    }
  }
};
exports.LODModel = class extends Object3D {
  constructor(e) {
    super(e),
      publicField(this, "_hysteresis", 0.1),
      publicField(this, "_levels", []),
      publicField(this, "_compressed", !1),
      publicField(this, "_currentLevel"),
      publicField(this, "_currentModel"),
      publicField(this, "_loader", PS),
      publicField(
        this,
        "_generateModelMesh",
        async (e) =>
          new Promise((t, i) => {
            this._loader.load(
              e,
              (e) => {
                t(e.scene);
              },
              null,
              i
            );
          })
      ),
      publicField(this, "update", async () => {
        if (!this.visible) return;
        const e = this._engine.camera,
          t = this.levels,
          i = this.position,
          n = t.length;
        if (n > 0) {
          const s = e.position.distanceTo(i),
            r = t[n - 1].hysteresis || this.hysteresis;
          if (s > t[n - 1].distance * (1 + r))
            return (
              this._modelMeshSingleton.keys.forEach(async (e) => {
                (await this._modelMeshSingleton.get(e)).visible = !1;
              }),
              (this._currentLevel = void 0),
              void (this._currentModel = void 0)
            );
          let a, o;
          for (let e = 0; e < n; e++) {
            const i = t[e];
            let n = i.distance;
            if (i.init) {
              if (!0 === (await this._modelMeshSingleton.get(i.file)).visible) {
                n += n * (i.hysteresis || this.hysteresis);
              }
            }
            if (void 0 === a && s <= n) a = e;
            else if (i.init) {
              (await this._modelMeshSingleton.get(i.file)).visible = !1;
            }
          }
          if (a >= 0) {
            let e = t[a],
              i = await this._modelMeshSingleton.get(e.file);
            e.init
              ? (i.visible = !0)
              : (this.add(i), (e.init = !0), this.handleLoaded(i)),
              (o = i);
          }
          (this._currentLevel = a), (this._currentModel = o);
        }
      }),
      e.hysteresis && (this.hysteresis = e.hysteresis),
      e.levels && (this.levels = e.levels),
      e.compressed && (this.compressed = e.compressed);
  }
  afterAddToEngine(e) {
    (this._engine = e),
      (this._modelMeshSingleton = new lE()),
      (this._modelMeshSingleton.generate = this._generateModelMesh),
      this._engine.rendering.addPrepareRenderListener(this.update);
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  addLevel(e, t = 0, i = 0) {
    t = Math.abs(t);
    const n = this.levels;
    let s;
    for (s = 0; s < n.length && !(t < n[s].distance); s++);
    return (
      n.splice(s, 0, { distance: t, hysteresis: i, file: e, init: !1 }), this
    );
  }
  removeLevel(e) {
    for (let t = 0; t < this.levels.length; t++) {
      if (e === this.levels[t].file) {
        this.levels.splice(t, 1);
        break;
      }
    }
    return this;
  }
  getCurrentLevel() {
    return this._currentLevel;
  }
  getCurrentModel() {
    return this._currentModel;
  }
  async getModel(e) {
    let t = this.levels[e];
    if (t) return await this._modelMeshSingleton.get(t.file);
  }
  handleLoaded(e) {
    this.dispatchEvent({ type: "loaded", value: e }),
      this._engine.event.markEventProxy(this),
      this.levels.every((e) => e.init) &&
        this.dispatchEvent({ type: "complete", value: this });
  }
  dispose() {
    if (this._loaded) {
      this._engine.rendering.removePrepareRenderListener(this.update),
        this._modelMeshSingleton.keys.forEach(async (e) => {
          let t = await this._modelMeshSingleton.get(e);
          this.remove(t);
        });
      for (let e = 0; e < this.levels.length; e++) {
        this.levels[e].init = !1;
      }
    }
  }
  set transform(e) {
    e.translate &&
      (e.translate instanceof Vector3
        ? this.position.copy(e.translate)
        : this.position.set(...e.translate)),
      e.rotation &&
        (e.rotation instanceof Vector3
          ? this.rotation.copy(e.rotation)
          : this.rotation.set(...e.rotation)),
      e.scale &&
        (e.scale instanceof Vector3
          ? this.scale.copy(e.scale)
          : "number" == typeof e.scale
          ? this.scale.setScalar(e.scale)
          : this.scale.set(...e.scale));
  }
  get transform() {
    return {
      translate: this.position,
      rotation: this.rotation,
      scale: this.scale,
    };
  }
  set levels(e) {
    this._levels = e.map((e) => ((e.init = !1), e));
  }
  get levels() {
    return this._levels;
  }
  set hysteresis(e) {
    this._hysteresis = e;
  }
  get hysteresis() {
    return this._hysteresis;
  }
  set compressed(e) {
    (this._compressed = e), (this._loader = e ? DS : PS);
  }
  get compressed() {
    return this._compressed;
  }
  set lodFactor(e) {
    this._lodFactor = e;
  }
  get lodFactor() {
    return this._lodFactor;
  }
};
exports.Label = yP;

exports.LengthMeasure = class extends QL {
  constructor(e, n = {}) {
    super(),
      publicField(this, "_editor", null),
      publicField(this, "_node"),
      publicField(this, "_infoMarkers"),
      publicField(this, "_infoMarkersDataSource"),
      publicField(this, "_totalMarker"),
      publicField(this, "_totalMarkerDataSource"),
      publicField(this, "_length", 0),
      publicField(this, "_segmentLengths", []),
      publicField(this, "_indexOffset", [0, 0]),
      publicField(this, "_infoMarkersBuffer", {
        position: [],
        index: [],
        payload: [],
      }),
      publicField(this, "_totalMarkerBuffer", {
        position: [],
        index: [],
        payload: [],
      }),
      publicField(this, "createInfoMarkers", (e) => {
        const n = document.createElement("div");
        return (
          (n.innerText = e.toFixed(this.fixedNum)), i(n, `${t}-measure-pane`), n
        );
      }),
      publicField(this, "createTotalMarker", (e) => {
        const n = document.createElement("div");
        return (
          (n.innerText = `总长度:${e.toFixed(this.fixedNum)}`),
          i(n, `${t}-measure-pane`),
          n
        );
      }),
      publicField(this, "_addNode", (e) => {
        this._node = e.value;
        const t = this._node.map((e) => e.position);
        if (t.length < 2) return;
        (this._segmentLengths = QL.getSegementLength(
          t,
          this._options.component
        )),
          (this._length = this._segmentLengths.reduce((e, t) => e + t, 0));
        const i = this._editor._helpersBuffer,
          { position: n } = i,
          s = [];
        for (let o = 0, l = n.length; o < l - 1; o++) {
          const e = n[o],
            t = n[o + 1];
          s.push([(e[0] + t[0]) / 2, (e[1] + t[1]) / 2, (e[2] + t[2]) / 2]);
        }
        let r = s.length;
        this._indexOffset[this.selectedIndex + 1] =
          this._indexOffset[this.selectedIndex] + s.length;
        let a = this._indexOffset[this.selectedIndex];
        this._infoMarkersBuffer.position.splice(a, r, ...s),
          this._infoMarkersBuffer.index.splice(
            a,
            r,
            ...new Array(r).fill(0).map((e, t) => t + a)
          ),
          this._infoMarkersBuffer.payload.splice(
            a,
            r,
            ...this._segmentLengths.map((e) => ({ length: e }))
          ),
          this._infoMarkersDataSource.setData(this._infoMarkersBuffer);
      }),
      publicField(this, "_moveNode", (e) => {}),
      publicField(this, "_changeNode", (e) => {
        this._node = e.value;
        const t = this._node.map((e) => e.position);
        t.length < 2 ||
          (this._addNode(e),
          this._totalMarkerBuffer.position.splice(
            this.selectedIndex,
            1,
            t[t.length - 1]
          ),
          this._totalMarkerBuffer.index.splice(
            this.selectedIndex,
            1,
            this.selectedIndex
          ),
          this._totalMarkerBuffer.payload.splice(this.selectedIndex, 1, {
            length: this._length,
          }),
          this._totalMarkerDataSource.setData(this._totalMarkerBuffer));
      }),
      (this._engine = e),
      (this._options = n),
      n.fixedNum && (this.fixedNum = n.fixedNum);
  }
  initEditor() {
    return (this._editor = this._engine.add(
      new OL(this._engine, {
        lineColor: this._options.lineColor,
        virtualLineParameter: this._options.virtualLineParameter,
        lineParameter: this._options.lineParameter,
      })
    ));
  }
  initInfoMarkers() {
    let e = (this._infoMarkers = this._engine.add(
        new dP({ callback: this.createInfoMarkers, offset: [0, 0] })
      )),
      t = (this._totalMarker = this._engine.add(
        new dP({ callback: this.createTotalMarker, offset: [0, 0] })
      ));
    (e.renderItem = this.createInfoMarkers),
      (t.renderItem = this.createTotalMarker);
    let i = (this._infoMarkersDataSource = new mA()),
      n = (this._totalMarkerDataSource = new mA());
    this._infoMarkersDataSource.setAttribute("payload", "length"),
      this._totalMarkerDataSource.setAttribute("payload", "length"),
      (e.dataSource = i),
      (t.dataSource = n);
  }
  clearBuffer() {
    (this._infoMarkersBuffer = { position: [], index: [], payload: [] }),
      (this._totalMarkerBuffer = { position: [], index: [], payload: [] });
  }
  clearAll() {
    (this._editor.enabled = !1),
      this._editor.clearAll(),
      this.clearBuffer(),
      this._infoMarkersDataSource.setData(),
      this._totalMarkerDataSource.setData();
  }
  dispose() {
    this.clearAll(),
      this._infoMarkers && this._engine.remove(this._infoMarkers),
      this._totalMarker && this._engine.remove(this._totalMarker);
  }
  get selectedIndex() {
    let e;
    return (
      (e =
        -1 === this._editor.selectedIndex
          ? this._editor.drawedGraph.length
          : this._editor.selectedIndex),
      e
    );
  }
  get length() {
    return this._length;
  }
  get segmentLengths() {
    return this._segmentLengths;
  }
};

exports.LightSphere = class extends InstancedMesh {
  constructor(e) {
    super(e),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "radius"),
      publicField(this, "color"),
      publicField(this, "widthSegments"),
      publicField(this, "heightSegments"),
      publicField(this, "phiStart"),
      publicField(this, "phiLength"),
      publicField(this, "thetaStart"),
      publicField(this, "thetaLength"),
      publicField(this, "animationEffect"),
      publicField(this, "animationEffectPeriod"),
      (this.parameters = e),
      this.defineMaterialProxyProperties([
        "radius",
        "color",
        "widthSegments",
        "heightSegments",
        "phiStart",
        "phiLength",
        "thetaStart",
        "thetaLength",
      ]);
  }
  initObject() {
    (this.geometry = new LightSphereGeometry(this.parameters)),
      (this.material = new lL(this.parameters)),
      (this.material.animationRotate = !0),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
};
exports.Marker = class extends bL {
  constructor(e = {}) {
    super(e),
      publicField(this, "_icon"),
      publicField(this, "_width"),
      publicField(this, "_height"),
      (this.isMarker = !0);
  }
  initDom() {
    let e = document.createElement("img");
    return i(e, `${t}-marker`), e;
  }
  afterInit() {
    (this.icon = this.parameters.icon || ""),
      (this.width = this.parameters.width || 20),
      (this.height = this.parameters.height || 20),
      (this.opacity = this.parameters.opacity || 1);
  }
  get icon() {
    return this._icon;
  }
  set icon(e) {
    this.dom && (this.dom.src = e), (this._icon = e);
  }
  get width() {
    return this._width;
  }
  set width(e) {
    this.dom && (this.dom.width = e), (this._width = e);
  }
  get height() {
    return this._height;
  }
  set height(e) {
    this.dom && (this.dom.height = e), (this._height = e);
  }
};

exports.MaskLayer = class extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_maskElements", []),
      publicField(this, "_isMasked", !1),
      publicField(this, "_enabled", !1);
  }
  afterAddToEngine(e) {
    (this._engine = e),
      (this._maskPolygon = e.add(new KD({ colorWrite: !1 }))),
      (this._clearPass = new AN()),
      (this._maskPass = new Ag(this._maskPolygon, e.camera)),
      (this._scenePass = new yN(e.scene, e.camera)),
      (this._scenePass.clear = !1),
      (this._skyElement = null),
      e.scene.traverse((e) => {
        e.isEmptySky && (this._skyElement = e);
      }),
      this._skyElement &&
        ((this._maskSkyPass = new Ag(this._maskPolygon, e.camera)),
        (this._maskSkyPass.inverse = !0),
        this._skyElement.isCustomStaticSky || this._skyElement.isSphereSky
          ? (this._renderPass = new yN(this._skyElement, e.camera))
          : (this._renderPass = new yN(e.scene.children[1], e.camera)),
        (this._renderPass.clear = !1)),
      (this._clearMaskPass = new yg()),
      (this._gammaCorrectionPass = new vg(cg)),
      (this._outputPass = new vg(hg)),
      (this._outputPass.renderToScreen = !0),
      (this._maskElementsPass = new yN(e.scene, e.camera)),
      (this._maskElementsPass.clear = !1);
  }
  beforeRemoveFromEngine(e) {
    this.dispose();
  }
  dispose() {
    this._engine.remove(this._maskPolygon),
      this._gammaCorrectionPass.dispose(),
      this._outputPass.dispose();
  }
  get dataSource() {
    return this._dataSource;
  }
  set dataSource(e) {
    e &&
      e instanceof fA &&
      ((this._maskPolygon.dataSource = e), (this._dataSource = e));
  }
  get maskLayers() {
    return this._maskElements;
  }
  set maskLayers(e) {
    e.length > 0 &&
      ((this._maskElementsPass._excludeElements = e), (this._maskElements = e));
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    if (this._enabled !== e)
      if (((this._enabled = e), this._enabled)) {
        if (!this._dataSource) return;
        if (this._isMasked) return;
        (this._isMasked = !0),
          this._engine.rendering.postprocessing.addPass(this._clearPass),
          this._engine.rendering.postprocessing.addPass(this._maskPass),
          this._engine.rendering.postprocessing.addPass(this._scenePass),
          this._engine.rendering.postprocessing.addPass(this._clearMaskPass),
          this._engine.rendering.postprocessing.addPass(this._maskSkyPass),
          this.maskLayers.length > 0
            ? this._engine.rendering.postprocessing.addPass(
                this._maskElementsPass
              )
            : this._skyElement &&
              this._engine.rendering.postprocessing.addPass(this._renderPass),
          this._engine.rendering.postprocessing.addPass(this._clearMaskPass),
          this._engine.rendering.postprocessing.addPass(
            this._gammaCorrectionPass
          ),
          this._engine.rendering.postprocessing.addPass(this._outputPass);
      } else
        this._engine.rendering.postprocessing.removePass(this._clearPass),
          this._engine.rendering.postprocessing.removePass(this._maskPass),
          this._engine.rendering.postprocessing.removePass(this._scenePass),
          this._engine.rendering.postprocessing.removePass(this._clearMaskPass),
          this._engine.rendering.postprocessing.removePass(this._maskSkyPass),
          this._engine.rendering.postprocessing.removePass(
            this._maskElementsPass
          ),
          this._renderPass &&
            this._engine.rendering.postprocessing.removePass(this._renderPass),
          this._engine.rendering.postprocessing.removePass(this._clearMaskPass),
          this._engine.rendering.postprocessing.removePass(
            this._gammaCorrectionPass
          ),
          this._engine.rendering.postprocessing.removePass(this._outputPass),
          (this._isMasked = !1);
  }
};
exports.MaskLayer3D = class extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_maskElements", []),
      publicField(this, "_enabled", !1),
      publicField(this, "_maskArea", []),
      publicField(this, "_maskPoint", []),
      publicField(this, "_maskRadius", 0),
      publicField(this, "_maskWidth", 0),
      publicField(this, "_maskHeight", 0),
      publicField(this, "_shaderVersion", 0),
      publicField(this, "_type", "polygon"),
      publicField(this, "traverseTile", (e, t = []) => {
        const i = e.children,
          n = i.length;
        if (!(n > 0)) return t.push(e), t;
        for (let s = 0; s < n; s++) this.traverseTile(i[s], t);
      }),
      publicField(this, "update", (e) => {
        this.addAndUpdateUniforms(e);
      }),
      publicField(this, "addAndUpdateUniforms", (e) => {
        if (!e) return;
        const t = e.material;
        if (t) {
          let e = !1;
          t.defines && t.defines.USE_CLIP !== this.enabled
            ? ((t.defines.USE_CLIP = this._enabled), (e = !0))
            : !t.defines &&
              this._enabled &&
              ((t.defines = { USE_CLIP: this.enabled }), (e = !0)),
            t.isCommonShaderMaterial ||
            t.hasAcquireMaskShader ||
            "ExtendMeshStandardMaterial" === t.type
              ? this._updateUniforms(t)
              : ((t.hasAcquireMaskShader = !0),
                (t.onBeforeCompile = (e) => {
                  this._updateUniformsInternal(e.uniforms),
                    (t.uniforms = e.uniforms);
                }),
                (e = !0)),
            e &&
              ((t.customProgramCacheKey = () => this._shaderVersion++),
              (t.needsUpdate = !0));
        }
      }),
      publicField(this, "updateMapTile", (e) => {
        const t = e.value;
        if (!t) return;
        const i = [];
        this.traverseTile(t, i);
        const n = i.length;
        for (let s = 0; s < n; s++) {
          const e = i[s];
          (e.hasModify = !0),
            (e.onBeforeRender = (...e) => {
              this._updateUniforms(...e);
            });
        }
      }),
      publicField(this, "clipMask", () => {
        this._engine &&
          this.traverseWithCondition(this._engine.scene, this.update);
      });
  }
  afterAddToEngine(e) {
    this._engine = e;
  }
  traverseWithCondition(e, t) {
    if (e.isEmptySky || e.__isEnvironment) return;
    if (this._maskElements.length > 0 && this._maskElements.includes(e))
      return void e.traverse((e) => {
        t && t(e);
      });
    0 === this._maskElements.length && t && t(e);
    const i = e.children;
    for (let n = 0; n < i.length; n++) this.traverseWithCondition(i[n], t);
  }
  _updateUniforms(e) {
    const t = e.uniforms;
    this._updateUniformsInternal(t);
  }
  _updateUniformsInternal(e) {
    if (!e) return;
    e.mvt_clipParameters ||
      (e.mvt_clipParameters = {
        value: {
          clip_type: 0,
          clip_point: new Vector2(),
          clip_radius: 0,
          clip_width: 0,
          clip_height: 0,
          clip_polygonCount: 20,
          u_polygon: new Array(20).fill(0).map(() => new Vector3()),
        },
      });
    const { cameraOffsetX: t, cameraOffsetY: i } =
        this._engine.rendering.renderState,
      n = "polygon" === this._type ? 0 : "circle" === this._type ? 1 : 2;
    if (((e.mvt_clipParameters.value.clip_type = n), "polygon" === this.type)) {
      const n = [],
        s = this._maskArea.length;
      for (let e = 0; e < 20; e++)
        if (e < s) {
          const s = this._maskArea[e];
          n.push(new Vector3(s[0] - t, s[1] - i, 0));
        } else n.push(new Vector3());
      (e.mvt_clipParameters.value.clip_polygonCount = s),
        (e.mvt_clipParameters.value.u_polygon = n);
    } else if ("circle" === this.type) {
      const n = new Vector2(this.maskPoint.x - t, this.maskPoint.y - i, 0);
      (e.mvt_clipParameters.value.clip_point = n),
        (e.mvt_clipParameters.value.clip_radius = this.maskRadius);
    } else if ("rect" === this.type) {
      const n = new Vector2(this.maskPoint.x - t, this.maskPoint.y - i, 0);
      (e.mvt_clipParameters.value.clip_point = n),
        (e.mvt_clipParameters.value.clip_width = this._maskWidth),
        (e.mvt_clipParameters.value.clip_height = this._maskHeight);
    }
  }
  get maskArea() {
    return this._maskArea;
  }
  set maskArea(e) {
    "polygon" !== this.type &&
      console.warn("type不为polygon，指定maskArea无效"),
      Array.isArray(e) && e.length > 2
        ? (this._maskArea = e)
        : console.warn("无效的掩膜裁剪区域");
  }
  get maskPoint() {
    return this._maskPoint;
  }
  set maskPoint(e) {
    const t = new Vector2(...e);
    this._maskPoint = t;
  }
  get maskRadius() {
    return this._maskRadius;
  }
  set maskRadius(e) {
    "circle" !== this.type && console.warn("type不为circle,指定maskCircle无效"),
      (this._maskRadius = e);
  }
  get maskWidth() {
    return this._maskWidth;
  }
  set maskWidth(e) {
    "rect" !== this.type && console.warn("type不为rect,指定maskWidth无效"),
      (this._maskWidth = e);
  }
  get maskHeight() {
    return this._maskHeight;
  }
  set maskHeight(e) {
    "rect" !== this.type && console.warn("type不为rect,指定maskHeight无效"),
      (this._maskHeight = e);
  }
  get maskElements() {
    return this._maskElements;
  }
  set maskElements(e) {
    e.length > 0 && (this._maskElements = e);
  }
  get type() {
    return this._type;
  }
  set type(e) {
    this._type !== e && (this._type = e);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled !== e &&
      ((this._enabled = e),
      (this._engine.rendering._useClip = e),
      this._enabled &&
        this._engine.rendering.addBeforeRenderListener(this.clipMask));
  }
};
exports.Measure = QL;
exports.MeshHeightMaterial = class extends Tw {
  constructor(e) {
    super({
      uniforms: {
        minAltitude: { value: 0 },
        maxAltitude: { value: 870 },
        noiseMap: { value: null },
        noiseUvScale: { value: 0.001 },
        noiseScale: { value: 0.21 },
        noiseBais: { value: -0.2 },
      },
    }),
      publicField(this, "_gradient", null),
      publicField(this, "_cachedGradientMap", null),
      publicField(this, "isMeshHeightMaterial", !0),
      this.defineMaterialNormalProperties(this, [
        "minAltitude",
        "maxAltitude",
        "noiseUvScale",
        "noiseScale",
        "noiseBais",
      ]),
      (this.vertexShaderChunks = EL),
      (this.fragmentShaderChunks = SL),
      this.createGradientMap(),
      this.setValues(e);
  }
  get gradient() {
    return this._gradient;
  }
  set gradient(e) {
    (this._gradient = e), this.updateGradientMap();
  }
  get noiseMap() {
    return this.uniforms.noiseMap.value;
  }
  set noiseMap(e) {
    (this.uniforms.noiseMap.value = e),
      e ? (this.defines.USE_NOISE_MAP = !0) : delete this.defines.USE_NOISE_MAP,
      (this.needsUpdate = !0);
  }
  createGradientMap() {
    let e = document.createElement("canvas");
    (e.width = 64), (e.height = 2);
    let t = e.getContext("2d"),
      i = t.createLinearGradient(0, 0, 64, 0);
    i.addColorStop(0, "#062516"),
      i.addColorStop(0.2, "#85765d"),
      i.addColorStop(0.6, "#032a21"),
      i.addColorStop(0.9, "#001323"),
      i.addColorStop(0.95, "#051420"),
      i.addColorStop(1, "#263241"),
      (t.fillStyle = i),
      t.fillRect(0, 0, 64, 2),
      (this._cachedGradientMap = new CanvasTexture(e)),
      (this.map = this._cachedGradientMap);
  }
  updateGradientMap() {
    let e = this._cachedGradient;
    if ("[object Object]" !== Object.prototype.toString.call(e)) return;
    let t = this._cachedGradientMap.image.getContext("2d");
    t.clearRect(0, 0, 64, 2);
    let i = t.createLinearGradient(0, 0, 64, 0);
    for (const n in e)
      Object.hasOwnProperty.call(e, n) && i.addColorStop(n, e[n]);
    (t.fillStyle = i),
      t.fillRect(0, 0, 64, 2),
      (this._cachedGradientMap.needsUpdate = !0);
  }
  dispose() {
    this.noiseMap && this.noiseMap.dispose(), super.dispose();
  }
};
exports.MultiClippingPlaneCollection = WL;
exports.ObjectTracker = rR;
exports.PathTracker = class extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_isRunning", !1),
      publicField(this, "_animationStartTime", 0),
      publicField(this, "_animationDuration", 0),
      publicField(this, "_animationTransform", {}),
      publicField(this, "_animationCurrenState", null),
      publicField(this, "_engine", null),
      publicField(this, "_track", null),
      publicField(this, "_frameInfo", null),
      publicField(this, "_sampledPath", []),
      publicField(this, "_isPause", !1),
      publicField(this, "_pauseTime", 0),
      publicField(this, "_pauseTimestamp", 0),
      publicField(this, "_object", null),
      publicField(this, "_interpolateDirectThreshold", 10),
      publicField(this, "_interpolateDirectThresholdPercent", 0.4),
      publicField(this, "_lockView", !1),
      publicField(this, "_viewFollow", !0),
      publicField(this, "_viewMode", DL),
      publicField(this, "_arcInfo", {}),
      publicField(this, "_pointHandle", "normal"),
      publicField(this, "_update", () => {
        if (!this._isRunning || this._isPause) return;
        const e =
          this._engine.rendering.renderState.time -
          this._pauseTime -
          this._animationStartTime;
        let t = 1;
        this._animationDuration > 0 && (t = e / this._animationDuration),
          t > 1 && (t = 1);
        const i = this._interpolatePath(t);
        this._animationCurrenState = i;
        const n = this._engine.map;
        if (
          void 0 !== i.position &&
          void 0 !== i.pitch &&
          void 0 !== i.direction
        ) {
          let e = i.direction;
          const t = this._engine._container.clientHeight;
          let s =
              (this._animationTransform.distance / (t / 2)) *
              Math.tan(((n.fov / 2) * Math.PI) / 180),
            r = this._engine.map.getZoomByZoomUnits(s);
          this.viewFollow &&
            this._updateCamera(
              this._engine.rendering.camera,
              i.position,
              r,
              s,
              e - Math.PI / 2,
              i.pitch
            ),
            this.object &&
              (this.object.position.set(...i.position),
              (this.object.rotation.y = e),
              (this.object.rotation.z = i.pitch));
        }
        e >= this._animationDuration || t >= 1
          ? this.stop()
          : this._engine.requestRender();
      });
  }
  afterAddToEngine(e) {
    (this._engine = e),
      "blank" !== e.map.mapType &&
        "blank_3dcontrol" !== e.map.mapType &&
        console.error(
          "PathTracker is not compatible with current type of Map."
        ),
      e.addPrepareRenderListener(this._update);
  }
  beforeRemoveFromEngine() {
    this._engine.removePrepareRenderListener(this._update);
  }
  _updateCamera(e, t, i, n, s, r) {
    let a = this._engine.map;
    "blank" === a.mapType
      ? this._computeCameraMatrixBlankMap(e, t, i, n, s, r)
      : "blank_3dcontrol" === a.mapType &&
        this._computeCameraMatrixBlankMap3D(e, t, i, n, s, r);
  }
  _computeCameraMatrixBlankMap(e, t, i, n, s, r) {
    const a = this._engine.map,
      { distance: o, heading: l, pitch: h } = this._animationTransform,
      c = this._engine._container.clientWidth,
      u = this._engine._container.clientHeight;
    if (
      (e.position.set(0, 0, 0),
      e.quaternion.set(0, 0, 0, 1),
      e.up.set(0, 0, 1),
      e.translateX(t[0]),
      e.translateY(t[1]),
      t[2] && e.translateZ(t[2]),
      this.lockView)
    )
      e.rotateOnAxis(new Vector3(0, 0, 1), (l * Math.PI) / 180 + s),
        e.rotateOnAxis(new Vector3(1, 0, 0), (h * Math.PI) / 180 + r),
        e.translateZ(o);
    else {
      e.rotateOnAxis(new Vector3(0, 0, 1), (a.getHeading() * Math.PI) / 180),
        e.rotateOnAxis(new Vector3(1, 0, 0), (a.getPitch() * Math.PI) / 180);
      const t =
        (u / 2 / Math.tan(((a.fov / 2) * Math.PI) / 180)) * a.getZoomUnits();
      e.translateZ(t);
    }
    e.updateMatrix(), e.updateMatrixWorld(), (e.aspect = c / u);
    let d = n;
    d < 1 && (d = 1),
      (e.near = Math.min(Math.max(e.position.z / 1e4, 0.1), 10)),
      (e.far = a.map._far * d),
      e.updateProjectionMatrix(),
      (a.map.center = t),
      this.lockView &&
        ((a.map.cameraDistance = o),
        (a.map.zoomUnits = n),
        (a.map.zoom = i),
        (a.map.heading = l + (s / Math.PI) * 180),
        (a.map.pitch = h + (r / Math.PI) * 180));
  }
  _computeCameraMatrixBlankMap3D(e, t, i, n, s, r) {
    const a = this._engine.map,
      { distance: o, heading: l, pitch: h } = this._animationTransform;
    let c = a.unprojectPointArr(t);
    this.lockView
      ? a.lookAt(c, {
          heading: l + ze.radToDeg(s),
          pitch: h + ze.radToDeg(r),
          range: o,
        })
      : a.lookAt(c, {
          heading: a.getHeading(),
          pitch: a.getPitch(),
          range: a.getCameraDistance(),
        });
    const u = e.position.z;
    let d = a.map.pitch + a.fov / 2,
      p = 1e6;
    (p = (u / Math.cos(ze.degToRad(Math.min(d, 89)))) * 1.25),
      (e.near = Math.min(Math.max(u / 1e4, 0.1), 10)),
      p < 2e4 && (p = 2e4),
      (e.far = p);
  }
  _interpolatePath(e) {
    const t = this._engine.map,
      i = this._sampledPath.length;
    for (let a = 1; a < i; a++) {
      const i = this._frameInfo[a],
        n = this._frameInfo[a - 1],
        s = this._sampledPath[a],
        r = this._sampledPath[a - 1],
        o = this._sampledPath[a + 1];
      if (e >= r.percent && e < s.percent) {
        const a = (e - r.percent) / (s.percent - r.percent);
        let l = bv(r.point, s.point, a);
        const [h, c] = s.position,
          [u, d] = r.position;
        let p = new Vector2(h - u, c - d).angle(),
          f = xv(r.pitch, s.pitch, a);
        const m = this._arcInfo.startRatio && a < this._arcInfo.startRatio;
        let g = 0;
        if (o) {
          const e = s.distance - r.distance,
            i = o.distance - s.distance,
            n = Math.min(e, i),
            h = this.interpolateDirectThreshold / n,
            c = h < 0.5 ? h : this._interpolateDirectThresholdPercent,
            u = e < i ? c : (i * c) / e,
            d = i < e ? c : (e * c) / i,
            f = a > 1 - u,
            _ = [r.position, s.position, u],
            v = [s.position, o.position, d];
          if (f || m) {
            f && (this._arcInfo.line1 = _),
              f && (this._arcInfo.line2 = v),
              f && (this._arcInfo.startRatio = d);
            const e = (a - (1 - u)) / u,
              i = a / this._arcInfo.startRatio,
              n = f ? e : i,
              { point: s, direction: r } = Mv(
                this._arcInfo.line1,
                this._arcInfo.line2,
                f ? n : 1 + n
              ),
              o = t.unprojectPointArr(s);
            s && (l[0] = o[0]) && (l[1] = o[1]),
              (p = new Vector2(...r).angle() + Math.PI / 2),
              (g = f ? n / 2 : (1 + n) / 2);
          }
        } else if (m) {
          const e = a / this._arcInfo.startRatio,
            { point: t, direction: i } = Mv(
              this._arcInfo.line1,
              this._arcInfo.line2,
              1 + e
            );
          t && (l[0] = t[0]) && (l[1] = t[1]),
            (p = new Vector2(...i).angle() + Math.PI / 2),
            (g = (1 + e) / 2);
        }
        let _ = t.projectPointArr(l);
        if (i && n)
          switch (this._viewMode) {
            case NL:
              if (
                ((p = n.yaw + (i.yaw - n.yaw) * g),
                (f = n.pitch + (i.pitch - n.pitch) * g),
                n.aim)
              ) {
                const { aim: e } = n,
                  i = t.projectPointArr(e),
                  [s, r, a] = i;
                p = new Vector2(s - _[0], r - _[1]).angle();
                const o = yv(_, i);
                f = Math.PI / 2 - Math.asin(Math.abs(a - _[2]) / o);
              }
              break;
            case BL:
              if (
                ((p = n.yaw + (i.yaw - n.yaw) * a),
                (f = n.pitch + (i.pitch - n.pitch) * a),
                "curve" === this._pointHandle)
              ) {
                let i;
                (i =
                  this._frameInfo &&
                  this._frameInfo.length &&
                  this._frameInfo.every((e) => e.speed)
                    ? this.curvePath.getPointAt(e)
                    : this.curvePath.getPoint(e)),
                  (l = this._engine.map.unprojectPointArr([i.x, i.y, i.z])),
                  (_ = t.projectPointArr(l));
              }
          }
        return {
          percent: e,
          point: l,
          position: _,
          distance: xv(r.distance, s.distance, a),
          direction: p,
          pitch: f,
        };
      }
    }
    const [n, s] = this._sampledPath[this._sampledPath.length - 1].direction;
    let r = {
      ...this._sampledPath[this._sampledPath.length - 1],
      direction: new Vector2(n, s).angle(),
    };
    if (this._frameInfo[this._sampledPath.length - 1])
      if (this._frameInfo[this._sampledPath.length - 1].aim) {
        const { aim: e } = this._frameInfo[this._sampledPath.length - 1],
          { position: i } = this._sampledPath[this._sampledPath.length - 1],
          n = t.projectPointArr(e),
          [s, a, o] = n;
        r.direction = new Vector2(s - i[0], a - i[1]).angle();
        const l = yv(i, n);
        r.pitch = Math.PI / 2 - Math.asin(Math.abs(o - i[2]) / l);
      } else
        (r.direction = this._frameInfo[this._sampledPath.length - 1].yaw),
          (r.pitch = this._frameInfo[this._sampledPath.length - 1].pitch);
    return r;
  }
  _createSampledPath(e) {
    const t = this._engine.map;
    if (!e) return;
    let i = 0,
      n = [0],
      s = [],
      r = [],
      a = 0,
      o = [0];
    for (let d = 1; d < e.length; d++) {
      const u = e[d],
        p = e[d - 1],
        f = e[d + 1],
        m = yv(t.projectPointArr(p), t.projectPointArr(u));
      if (
        ((n[d] = m + i),
        (i += m),
        this._frameInfo &&
          this._frameInfo.length &&
          this._frameInfo.every((e) => e.speed))
      ) {
        const e = (m / this._frameInfo[d - 1].speed) * 1e3;
        (this._frameInfo[d - 1].time = e),
          !f && (this._frameInfo[d].time = 0),
          (o[d] = e + a),
          (a += e);
      } else if (
        this._frameInfo &&
        this._frameInfo.length &&
        this._frameInfo.every((e) => e.time)
      ) {
        const e = this._frameInfo[d - 1];
        (o[d] = e.time + a), (a += e.time);
      }
      if (
        (1 === d &&
          ((s[0] = Ev(p, u).toArray()), (r[0] = this._getRadians(p, u))),
        f)
      ) {
        const e = Ev(p, u).toArray(),
          t = Ev(u, f).toArray(),
          i =
            ((h = t),
            (c = 0.5),
            [(l = e)[0] + (h[0] - l[0]) * c, l[1] + (h[1] - l[1]) * c]);
        s[d] = i;
        const n = this._getRadians(p, u),
          a = this._getRadians(u, f);
        r[d] = xv(n, a, 0.5);
      } else (s[d] = Ev(p, u).toArray()), (r[d] = this._getRadians(p, u));
    }
    var l, h, c;
    const u = [];
    for (let d = 0; d < e.length; d++) {
      const l = e[d][2] ? e[d] : [e[d][0], e[d][1], 0];
      n[d] - this.interpolateDirectThreshold > n[d - 1] && 0 !== d && e.length;
      const h = {
        percent: (n[d] / i).toFixed(6),
        point: l,
        position: t.projectPointArr(l),
        distance: n[d],
        direction: s[d],
        pitch: r[d],
      };
      a && o && (h.percent = (o[d] / a).toFixed(6)),
        u.push(h),
        n[d] + this.interpolateDirectThreshold < n[d + 1] &&
          0 !== d &&
          e.length;
    }
    return u.sort((e, t) => e.percent - t.percent), (this._sampledPath = u), u;
  }
  _getRadians(e, t) {
    const i = this._engine.map,
      n = yv(
        (e = i.projectPointArr([e[0], e[1], e[2] || 0])),
        (t = i.projectPointArr([t[0], t[1], t[2] || 0]))
      ),
      s =
        ((r = e),
        (a = t),
        Math.sqrt(Math.pow(r[0] - a[0], 2) + Math.pow(r[1] - a[1], 2)));
    var r, a;
    const o = Math.acos(s / n);
    return e[2] >= t[2] ? -o : o;
  }
  start(e = {}) {
    const {
      duration: t = 1e3,
      heading: i = 0,
      pitch: n = 60,
      distance: s = 100,
    } = e;
    if (this.track) {
      if ((this.lockView && this._engine.lockCamera(), this._isPause))
        return (
          (this._pauseTime += new Date().valueOf() - this._pauseTimestamp),
          (this._isPause = !1),
          void this._engine.requestRender()
        );
      if (!this._isRunning) {
        if (
          ((this._isRunning = !0),
          (this._animationTransform = { heading: i, pitch: n, distance: s }),
          (this._animationDuration = t),
          this._frameInfo &&
            this._frameInfo.length &&
            this._frameInfo.every((e) => e.time || 0 === e.time))
        ) {
          this._animationTransform = { heading: 0, pitch: 0, distance: s };
          let e = 0;
          this._frameInfo.forEach((t) => {
            const { time: i } = t;
            e += i;
          }),
            (this._animationDuration = e);
        }
        (this._animationStartTime = new Date().getTime()),
          this._engine.requestRender(),
          this.onStart && this.onStart();
      }
    }
  }
  pause(e) {
    return (
      (this._isPause = !0),
      (this._pauseTimestamp = new Date().valueOf()),
      e &&
        this.lockView &&
        (this._engine.unlockCamera(), this._engine.requestRender()),
      this._animationCurrenState
    );
  }
  stop() {
    this._isRunning &&
      ((this._isRunning = !1),
      this._engine.unlockCamera(),
      this._engine.requestRender(),
      (this._pauseTimestamp = 0),
      (this._pauseTime = 0),
      (this._animationCurrenState = null),
      (this._arcInfo = {}),
      this.onFinish && this.onFinish());
  }
  set track(e) {
    if (e) {
      if (
        e instanceof Array &&
        e[0] instanceof Array &&
        "number" == typeof e[0][0] &&
        e.length >= 2
      )
        (this._track = e), this._createSampledPath(e);
      else if (
        e.constructor === Object &&
        e.geometry &&
        "LineString" === e.geometry.type &&
        Array.isArray(e.geometry.coordinates)
      ) {
        const { properties: t = {} } = e;
        (this._track = e.geometry.coordinates),
          (this._frameInfo = t.frameInfo || []),
          this._createSampledPath(e.geometry.coordinates);
      } else if (e instanceof Array) {
        const t = [],
          i = [];
        e.forEach((e) => {
          const {
            x: n,
            y: s,
            z: r,
            pitch: a,
            yaw: o,
            aim: l,
            speed: h,
            time: c,
          } = e;
          t.push([n, s, r]),
            i.push({ pitch: a, yaw: o, aim: l, speed: h, time: c });
        }),
          (this._track = t),
          (this._frameInfo = i),
          this._createSampledPath(t);
      }
    } else this._track = null;
  }
  get track() {
    return this._track;
  }
  set interpolateDirectThreshold(e) {
    this._interpolateDirectThreshold !== e &&
      ((this._interpolateDirectThreshold = e),
      this._createSampledPath(this.track));
  }
  get interpolateDirectThreshold() {
    return this._interpolateDirectThreshold;
  }
  set interpolateDirectThresholdPercent(e) {
    this._interpolateDirectThresholdPercent !== e &&
      ((this._interpolateDirectThresholdPercent = e),
      this._createSampledPath(this.track));
  }
  get interpolateDirectThresholdPercent() {
    return this._interpolateDirectThresholdPercent;
  }
  set viewMode(e) {
    switch (((this._viewMode = e), e)) {
      case DL:
        (this.lockView = !1), (this.viewFollow = !0);
        break;
      case LL:
        (this.lockView = !0), (this.viewFollow = !0);
        break;
      case FL:
        (this.lockView = !1), (this.viewFollow = !1);
        break;
      default:
        (this.lockView = !0), (this.viewFollow = !0);
    }
  }
  get viewMode() {
    return this._viewMode;
  }
  set lockView(e) {
    (this._lockView = e),
      this._isRunning && !0 === e
        ? this._engine.lockCamera()
        : this._engine.unlockCamera();
  }
  get lockView() {
    return this._lockView;
  }
  set object(e) {
    this._object = e;
  }
  get object() {
    return this._object;
  }
  get viewFollow() {
    return this._viewFollow;
  }
  set viewFollow(e) {
    this._viewFollow !== e && (this._viewFollow = e);
  }
  set pointHandle(e) {
    if (((this._pointHandle = e), "curve" === e)) {
      const e = this._track.map((e) =>
        new Vector3().fromArray(this._engine.map.projectPointArr(e))
      );
      this.curvePath = new Ro(e);
    }
  }
};
exports.Pillar = class extends InstancedMesh {
  constructor(e) {
    super(e),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "opacity"),
      publicField(this, "height"),
      publicField(this, "radiusSegments"),
      publicField(this, "radius"),
      publicField(this, "gradient"),
      publicField(this, "vertexHeights"),
      publicField(this, "openEnded"),
      publicField(this, "getInstanceLocalMatrix", (e, t, i) => {
        const { vertexHeights: n } = this.parameters,
          { height: s } = this.dataSource.data;
        if (n && s) {
          const e = new Matrix4();
          return e.makeScale(1, 1, s[i]), e;
        }
        return null;
      }),
      publicField(this, "addCustomAttributes", () => {
        const { vertexHeights: e } = this.parameters,
          { height: t } = this.dataSource.data;
        let i = -1;
        if (!e || !t) return i;
        for (let n = 0; n < t.length; n++) i < t[n] && (i = t[n]);
        this.material.uniforms.maxHeight.value = i;
      }),
      (this.parameters = e);
  }
  initObject() {
    (this.geometry = new pL(this.parameters)),
      (this.material = new mL(this.parameters)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
};
exports.PointEditor = class extends kL {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_pointBuffer", {
        position: [],
        index: [],
        payload: [],
      }),
      publicField(this, "_hasBeenPush", !1),
      publicField(this, "_engine"),
      publicField(this, "_options"),
      publicField(this, "_point"),
      publicField(this, "_pointDataSource"),
      publicField(this, "_completedDataSource"),
      publicField(this, "_completedElement"),
      publicField(this, "_isAdd"),
      publicField(this, "_selectedIndex"),
      publicField(this, "_stage"),
      publicField(this, "_transformIndex"),
      publicField(this, "_lastDataItem"),
      publicField(this, "_handleAddClick", (e) => {
        (this._isAdd = !0),
          (0 !== this._stage && 1 !== this._stage) ||
            ((this._stage = 1),
            this.addNode(e.position, e.point),
            this._handleAddFinish()),
          this._engine.requestRender();
      }),
      publicField(this, "_handleCompleteClick", (e) => {
        if (1 !== this._stage) {
          this.complete(),
            (this._selectedIndex = e.entity.selectedIndex),
            this._engine.event.unbind("click", this._handleAddClick),
            (this._lastDataItem = this._drawedGraph.slice(
              this._selectedIndex,
              this._selectedIndex + 1
            )),
            (this._stage = 2),
            this._completedDataSource.setData();
          for (let e = 0; e < this._drawedGraph.length; e++)
            e !== this._selectedIndex &&
              this._completedDataSource.add(this._drawedGraph[e].dataItem);
          (this._pointBuffer = this._lastDataItem[0].pointBuffer),
            this._pointDataSource.setData(this._pointBuffer),
            this._engine.event.bind(
              this._point,
              "click",
              this._handleNodeClick
            ),
            this._engine.requestRender();
        }
      }),
      publicField(this, "_handleAddFinish", (e) => {
        1 === this._stage && (this._stage = 2),
          (this._hasBeenPush = !1),
          this.dispatchEvent({ type: "change", value: this.data }),
          this._engine.requestRender(),
          this._engine.event.unbind("click", this._handleAddClick),
          this._engine.event.bind(this._point, "click", this._handleNodeClick),
          this._engine.event.bind("click", this._handleCancelEdit);
      }),
      publicField(this, "_handleNodeClick", (e) => {
        e.domEvent
          ? e.event.domEvent.preventDefault()
          : e.event.preventDefault(),
          !e.entity ||
            (2 !== this._stage && 3 !== this._stage) ||
            ((this._transformIndex = e.entity.index),
            this.attachTransform(e.entity.position),
            (this._stage = 3),
            this._engine.selection.transformControl.addEventListener(
              "objectChange",
              this._handleTransformChanging
            ),
            this._engine.selection.transformControl.addEventListener(
              "mouseUp",
              this._handleTransformChanged
            ));
      }),
      publicField(this, "_handleTransformChanging", (e) => {
        let t = this._getTransformBoxState();
        (3 !== this._stage && 4 !== this._stage) ||
          (this.updateNode(this._transformIndex, t),
          this.dispatchEvent({ type: "change", value: this.data }),
          (this._stage = 4));
      }),
      publicField(this, "_handleTransformChanged", (e) => {
        let t = this._getTransformBoxState();
        4 === this._stage &&
          (this.updateNode(this._transformIndex, t),
          this.dispatchEvent({ type: "change", value: this.data }),
          (this._stage = 3));
      }),
      publicField(this, "_handleCancelEdit", (e) => {
        3 === this._stage && (this.detachTransform(), (this._stage = 2));
      }),
      (this._engine = e),
      t.pointColor || (t.pointColor = "rgb(200, 200, 50)"),
      t.pointSize || (t.pointSize = 10),
      (this._options = t);
  }
  initObjects() {
    this.initPoint(), this.initCompleteElement();
  }
  initPoint() {
    let e = (this._pointDataSource = new mA());
    (this._point = this._engine.add(
      new SimplePoint({
        color: this._options.pointColor,
        size: 1.1 * this._options.pointSize,
      })
    )).dataSource = e;
  }
  initCompleteElement() {
    let e = (this._completedDataSource = new mA()),
      t = (this._completedElement = this._engine.add(
        new SimplePoint({
          color: this._options.pointColor,
          size: this._options.pointSize,
        })
      ));
    e.setAttribute("selectedIndex"),
      (t.dataSource = e),
      (t.receiveRaycast = !0),
      this._engine.event.bind(t, "click", this._handleCompleteClick);
  }
  initEvents() {
    this._engine.event.bind("click", this._handleAddClick),
      this._drawedGraph.length > 0 &&
        this._engine.event.bind(
          this._completedElement,
          "click",
          this._handleCompleteClick
        );
  }
  graphInfo(e) {
    this._pointBuffer.payload[0].selectedIndex = e;
    const t = new oA(
      this._pointBuffer.position[0],
      this._pointBuffer.payload[0]
    );
    return { pointBuffer: this._pointBuffer, dataItem: t };
  }
  addNode(e, t) {
    this._pointBuffer.position.push(e),
      (this._pointBuffer.index = [0]),
      this._pointBuffer.payload.push({ point: t, position: e, scale: 2 }),
      this._pointDataSource.setData(this._pointBuffer);
  }
  updateNode(e, t) {
    const { point: i, position: n } = t;
    this._pointBuffer.position.splice(e, 1, n),
      this._pointBuffer.payload.splice(e, 1, {
        point: i,
        position: n,
        scale: t.width,
        angle: t.angle[2],
      }),
      this._pointDataSource.setData(this._pointBuffer);
  }
  unbindEvents() {
    this._engine.event.unbind("click", this._handleAddClick),
      this._engine.event.unbind("click", this._handleCancelEdit),
      this._engine.event.unbind("mousemove", this._handleAddMove),
      this._engine.event.unbind(this._point, "click", this._handleNodeClick),
      this._engine.event.unbind(
        this._completedElement,
        "click",
        this._handleCompleteClick
      ),
      this._engine.selection.transformControl.removeEventListener(
        "objectChange",
        this._handleTransformChanging
      ),
      this._engine.selection.transformControl.removeEventListener(
        "mouseUp",
        this._handleTransformChanged
      );
  }
  clearBuffers() {
    this._pointBuffer = { position: [], index: [], payload: [] };
  }
  clearObjects() {
    this._pointDataSource.setData(), this._engine.requestRender();
  }
  dispose() {
    (this.enabled = !1), this._engine.remove(this._point);
  }
  overwriteNodes(e) {
    this.clearBuffers(),
      (this._pointBuffer.position[0] = e[0].position),
      (this._pointBuffer.index = [0]),
      (this._pointBuffer.payload = e),
      this._pointDataSource.setData(this._pointBuffer);
  }
  _getProperties(e) {
    const { scale: t } = e;
    return { scale: t };
  }
  get data() {
    return this._pointBuffer.payload;
  }
  set data(e) {
    this.overwriteNodes(e),
      this._handleCancelEdit(),
      (this._stage = 2),
      (this._isAdd = !0),
      this.dispatchEvent({ type: "change", value: e }),
      this._engine.requestRender();
  }
};
exports.PointGroup = GP;
exports.PointerLockControl = class extends PL {
  constructor(e) {
    super(e.camera, e.map.container),
      publicField(this, "_enableKeyboardEvent", !1),
      publicField(this, "_moveForward", !1),
      publicField(this, "_moveBackward", !1),
      publicField(this, "_moveLeft", !1),
      publicField(this, "_moveRight", !1),
      publicField(this, "_moveTop", !1),
      publicField(this, "_moveBottom", !1),
      publicField(this, "_prevTime"),
      publicField(this, "_velocity", new Vector3()),
      publicField(this, "_direction", new Vector3()),
      publicField(this, "handleKeyDownEvent", (e) => {
        switch (e.keyCode) {
          case 87:
            this._moveForward = !0;
            break;
          case 83:
            this._moveBackward = !0;
            break;
          case 65:
            this._moveLeft = !0;
            break;
          case 68:
            this._moveRight = !0;
            break;
          case 81:
            this._moveTop = !0;
            break;
          case 69:
            this._moveBottom = !0;
            break;
          case 76:
            !this.isLocked && this.lock();
        }
      }),
      publicField(this, "animationMove", () => {
        if (!this._enableKeyboardEvent) return;
        const e = performance.now();
        requestAnimationFrame(this.animationMove);
        const t = (e - this._prevTime) / 1e3;
        (this._velocity.x -= 10 * this._velocity.x * t),
          (this._velocity.z -= 10 * this._velocity.z * t),
          (this._velocity.y -= 10 * this._velocity.y * t),
          (this._direction.z =
            Number(this._moveForward) - Number(this._moveBackward)),
          (this._direction.x =
            Number(this._moveRight) - Number(this._moveLeft)),
          (this._direction.y =
            Number(this._moveTop) - Number(this._moveBottom)),
          this._direction.normalize(),
          (this._moveForward || this._moveBackward) &&
            (this._velocity.z -= this._direction.z * this.forwardStepSize * t),
          (this._moveLeft || this._moveRight) &&
            (this._velocity.x -= this._direction.x * this.rightStepSize * t),
          (this._moveTop || this._moveBottom) &&
            (this._velocity.y -= this._direction.y * this.topStepSize * t),
          this.moveRight(-this._velocity.x),
          this.moveForward(-this._velocity.z),
          (this._engine.camera.position.z -= this._velocity.y),
          (this._prevTime = e);
      }),
      publicField(this, "handleKeyUpEvent", (e) => {
        switch (e.keyCode) {
          case 87:
            this._moveForward = !1;
            break;
          case 83:
            this._moveBackward = !1;
            break;
          case 65:
            this._moveLeft = !1;
            break;
          case 68:
            this._moveRight = !1;
            break;
          case 81:
            this._moveTop = !1;
            break;
          case 69:
            this._moveBottom = !1;
        }
      }),
      (this._engine = e),
      this._engine.camera.up.set(0, 0, 1),
      (this.stepSize = 10),
      this.addEventListener("change", (t) => {
        e.requestRender();
      });
  }
  dispose() {
    super.dispose(), (this.enableKeyboardEvent = !1);
  }
  get forwardStepSize() {
    return this._forwardStepSize;
  }
  set forwardStepSize(e) {
    this._forwardStepSize = e;
  }
  get rightStepSize() {
    return this._rightStepSize;
  }
  set rightStepSize(e) {
    this._rightStepSize = e;
  }
  get topStepSize() {
    return this._topStepSize;
  }
  set topStepSize(e) {
    this._topStepSize = e;
  }
  set stepSize(e) {
    (this.forwardStepSize = e),
      (this.rightStepSize = e),
      (this.topStepSize = e);
  }
  set enableKeyboardEvent(e) {
    e !== this._enableKeyboardEvent &&
      ((this._enableKeyboardEvent = e),
      e
        ? ((this._prevTime = performance.now()),
          requestAnimationFrame(this.animationMove),
          window.addEventListener("keydown", this.handleKeyDownEvent),
          window.addEventListener("keyup", this.handleKeyUpEvent))
        : (window.removeEventListener("keydown", this.handleKeyDownEvent),
          window.removeEventListener("keyup", this.handleKeyUpEvent)));
  }
};

exports.Polygon = KD;
exports.PolygonEditor = GL;

exports.Popup = class extends bL {
  constructor(e) {
    super(e),
      publicField(this, "_titleDiv"),
      publicField(this, "_contentDiv"),
      publicField(this, "_title"),
      publicField(this, "_content"),
      publicField(this, "_closePopup"),
      publicField(this, "click", () => {
        this.visible = !1;
      }),
      (this.isPopup = !0);
  }
  initDom() {
    const e = document.createElement("div");
    i(e, `${t}-popup`);
    const n = document.createElement("div");
    i(n, "frame");
    const s = (this._titleDiv = document.createElement("div"));
    i(s, "title"), (s.innerText = this.title);
    const r = (this._closePopup = document.createElement("div"));
    i(r, "close"), (r.innerText = "x"), r.addEventListener("click", this.click);
    const a = (this._contentDiv = document.createElement("div"));
    i(a, "content"),
      (a.innerText = this.content),
      n.appendChild(r),
      n.appendChild(s),
      n.appendChild(a);
    const o = document.createElement("div");
    return i(o, "triangle"), e.appendChild(n), e.appendChild(o), e;
  }
  afterInit() {
    (this.title = this.parameters.title || "title"),
      (this.content = this.parameters.content || "content");
  }
  onDispose() {
    this._closePopup.removeEventListener("click", this.click);
  }
  get title() {
    return this._title;
  }
  set title(e) {
    e && ((this._title = e), this._titleDiv && (this._titleDiv.innerText = e));
  }
  get content() {
    return this._content;
  }
  set content(e) {
    (this._content = e), this._contentDiv && (this._contentDiv.innerText = e);
  }
};

exports.Realistic3DTilesMaterialManager = class extends yT {
  constructor() {
    super(...arguments),
      publicField(this, "isRealistic3DTilesMaterialManager", !0),
      publicField(this, "_autoTimingLight", !0),
      publicField(this, "_nightLightDensity", 0),
      publicField(this, "getTexture", (e, t, i, n, s) => {
        const r = MT.load(
          Gm(
            Qm(),
            "assets/textures/realistic",
            `TexturesCom_${e}_${t}.${n.format || "jpg"}`
          ),
          s
        );
        return (r.wrapS = r.wrapT = w), (r.repeat = i), r;
      }),
      publicField(this, "createPbrMaterial", (e, t, i, n = {}, s = {}) => {
        i || (i = new Vector2(0.5, 0.5)),
          t || (t = { albedo: !0, normal: !0, roughness: !0, ao: !1 });
        const r = { ...n, envMapIntensity: 2 };
        t.albedo && (r.map = this.getTexture(e, "albedo", i, s)),
          t.normal && (r.normalMap = this.getTexture(e, "normal", i, s)),
          t.roughness &&
            (r.roughnessMap = this.getTexture(e, "roughness", i, s)),
          t.ao && (r.aoMap = this.getTexture(e, "ao", i, s)),
          t.emissive && (r.emissiveMap = this.getTexture(e, "emissive", i, s));
        return new Vo(r);
      }),
      publicField(this, "createBuildingMaterial", () => {
        const e = MT.load(
          Hm("assets/textures/building/building3_atlas_diffuse.jpg")
        );
        e.wrapS = e.wrapT = w;
        const t = MT.load(
          Hm("assets/textures/building/building3_atlas_normal.jpg")
        );
        t.wrapS = t.wrapT = w;
        const i = MT.load(
          Hm("assets/textures/building/building3_atlas_metallic_roughness.jpg")
        );
        i.wrapS = i.wrapT = w;
        const n = MT.load(
          Hm("assets/textures/building/building_atlas_emissive.jpg")
        );
        n.wrapS = n.wrapT = w;
        const s = MT.load(Hm("assets/textures/building/ac1.png"));
        s.flipY = !1;
        const r = new Tw({
          roughness: 0.5,
          metalness: 0.2,
          map: e,
          normalMap: t,
          roughnessMap: i,
          metalnessMap: i,
          emissiveMap: n,
          uniforms: { acMap: { value: s } },
          vertexShaderChunks: {
            pars: "\n                    attribute float _mt;\n                    varying float vMt;\n                ",
            main_before: "\n                    vMt = _mt;\n                ",
          },
          fragmentShaderChunks: {
            pars: "\n                    uniform sampler2D acMap;\n                    varying float vMt;\n                    #define USE_CUSTOM_MAP\n                ",
            main_before:
              "\n                    if (vMt < 100.0) {\n                        float row = floor(vMt / 4.0);\n                        float col = mod(vMt, 4.0);\n                        uv.x = col * 0.25 + mod(vUv.x / 36.0,  0.25);\n                        if (vUv.y < 3.0) {\n                            uv.y = 0.02;\n                            uv.x = 0.02;\n                        } else {\n                            // uv.y = vUv.y / 9.0;\n                            uv.y = 1.0 - (row * 0.25 + 0.25 - mod(vUv.y / 36.0,  0.25));\n                        }\n                    }\n                ",
            custom_map:
              "\n                    vec4 sampledDiffuseColor;\n                    if (vMt < 100.0) {\n                        sampledDiffuseColor = texture2D( map, uv );\n                    }\n                    else {\n                        sampledDiffuseColor = texture2D( acMap, vUv );\n                    }\n                ",
            color_after:
              "\n                    // diffuseColor.xyz = vec3(vMt / 15.0, 0, 0);\n                ",
          },
        });
        return (r.uniforms.acMap.value = s), r;
      }),
      publicField(this, "handleWeatherChanged", (e) => {
        let t = 0.8,
          i = 1,
          n = !1;
        "cloudy" === e || "partlyCloudy" === e
          ? ((t = 0.4), (i = 1))
          : "rainy" === e
          ? ((t = 0.2), (i = 1), (n = !0))
          : "snow" === e && ((t = 0.2), (i = 0.2));
        const s = this._materrialMap.get("road");
        if (((s.envMapIntensity = t), (s.roughness = i), n)) {
          const e = this.getTexture(
            "Ground_MudWet_512",
            "roughness",
            new Vector2(0.1, 0.1),
            {},
            () => {
              this.engine.requestRender();
            }
          );
          (s._roughnessMap = s.roughnessMap),
            (s.roughnessMap = e),
            (s.map.repeat = new Vector2(0.05, 0.05));
        } else
          s._roughnessMap &&
            ((s.roughnessMap = s._roughnessMap),
            (s._roughnessMap = null),
            (s.map.repeat = new Vector2(0.5, 0.5)));
        this._materrialMap.get("buildingSide").envMapIntensity = t;
      }),
      publicField(this, "handleTimeChanged", (e) => {
        if (!this._autoTimingLight) return;
        let t = 0;
        (t =
          e > 66600 || e < 19800
            ? 1
            : e > 63e3
            ? (e - 63e3) / 3600
            : e < 23400
            ? (23400 - e) / 3600
            : 0),
          this.updateLightDensity(t);
      });
  }
  onInit() {
    this.addMaterials();
    const e = this.engine,
      t = e.rendering.sky;
    t &&
      (t.addTimeChangedListener(this.handleTimeChanged),
      this.handleTimeChanged(t.time));
    const i = e.rendering.weather;
    i &&
      (i.addWeatherChangedListener(this.handleWeatherChanged),
      this.handleWeatherChanged(i.weather));
  }
  addMaterials() {
    this._materrialMap.set(
      "road",
      this.createPbrMaterial("Asphalt_Base10_2x2_512", null, null, {
        color: 11184810,
        roughness: 0.8,
        side: 2,
        emissiveIntensity: 0,
        emissive: new Color(920067),
      })
    ),
      this._materrialMap.set(
        "isolation",
        this.createPbrMaterial("Nature_Pebbles_512", null, null, {})
      ),
      this._materrialMap.set(
        "green",
        this.createPbrMaterial("Nature_Moss_512", null, null, {
          color: 13434828,
        })
      ),
      this._materrialMap.set("buildingSide", this.createBuildingMaterial()),
      this._materrialMap.set(
        "buildingRoof",
        this.createPbrMaterial(
          "Roofing_Bitumen_512",
          {},
          new Vector2(1, 1),
          { color: 5592405, metalness: 0.2, roughness: 0.8 },
          { format: "jpg" }
        )
      );
    const e = new CT();
    this._materrialMap.set("water", e);
    this.engine.addBeforeRenderObject(e);
  }
  updateLightDensity(e) {
    const t = this._materrialMap.get("buildingSide");
    this._materrialMap.get("road"),
      t.uniforms.emissive.value.copy(wT).multiplyScalar(0.3 * e);
  }
  get autoTimingLight() {
    return this._autoTimingLight;
  }
  set autoTimingLight(e) {
    if (((e = !!e), (this._autoTimingLight = e), e)) {
      const e = this.engine.sky;
      e && this.handleTimeChanged(e.time);
    } else this.updateLightDensity(this._nightLightDensity);
  }
  get nightLightDensity() {
    return this._nightLightDensity;
  }
  set nightLightDensity(e) {
    (this._nightLightDensity = e),
      this._autoTimingLight || this.updateLightDensity(e);
  }
};

exports.RectEditor = zL;
exports.RoadLight3DTilesElement = class extends IT {
  constructor() {
    super(...arguments),
      publicField(this, "subscribedDataTypeIds", [101]),
      publicField(this, "_tickInterval", 0),
      publicField(this, "_scaleSize", 0.04),
      publicField(this, "_powerStates", new Set()),
      publicField(this, "_colorStates", new Map()),
      publicField(this, "_allPowerOn", !1);
  }
  createMeshFromGeometry(e) {
    return new RT(e);
  }
  _refreshPowerViewState(e, t) {
    this._allPowerOn || this._powerStates.has(e)
      ? ((t.visible = !0),
        this._colorStates.has(e) && (t.color = this._colorStates.get(e)))
      : (t.visible = !1);
  }
  onEntityShow(e, t) {
    this._refreshPowerViewState(e, t);
  }
  setPowerState(e, t) {
    if (
      (t ? this._powerStates.add(e) : this._powerStates.delete(e),
      this._visibleIdMap.has(e))
    ) {
      const t = this._visibleIdMap.get(e);
      this._refreshPowerViewState(e, t), this.engine.requestRender();
    }
  }
  togglePowerState(e) {
    this.setPowerState(e, !this.isPowerOn(e)), this.engine.requestRender();
  }
  isPowerOn(e) {
    return this._powerStates.has(e);
  }
  setColor(e, t) {
    if ((this._colorStates.set(e, t), this._visibleIdMap.has(e))) {
      const t = this._visibleIdMap.get(e);
      this._refreshPowerViewState(e, t), this.engine.requestRender();
    }
  }
  set allPowerOn(e) {
    this._allPowerOn = e;
  }
  get allPowerOn() {
    return this._allPowerOn;
  }
};
exports.ShapePoint = class extends InstancedMesh {
  constructor(e) {
    super(e),
      (this.parameters = e),
      this.defineGeometryProxyProperties(["shapeType"]);
  }
  getDefaultParams() {
    return { shapeType: "cube" };
  }
  initObject() {
    const { shapeType: e, ...t } = this.parameters;
    (this.geometry = new VR(this.parameters)),
      (this.material = new HR(t)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
};
exports.SightLine = class extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_viewPoistion"),
      publicField(this, "_targetPositions", []),
      publicField(this, "_occlusionPoints", []),
      publicField(this, "_raycaster", new $l()),
      publicField(this, "_tempModelViewMatrix", new Matrix4()),
      publicField(this, "_visibleLine"),
      publicField(this, "_invisibleLine"),
      publicField(this, "_visibleDataSource", UT.fromGeoJSONObject()),
      publicField(this, "_invisibleDataSource", UT.fromGeoJSONObject()),
      publicField(this, "_distanceBias", 0.1),
      publicField(this, "_visibleColor", "green"),
      publicField(this, "_invisibleColor", "red");
  }
  afterAddToEngine(e) {
    this._engine = e;
  }
  destroy() {
    this._visibleLine && this._engine.remove(this._visibleLine),
      this._invisibleLine && this._engine.remove(this._invisibleLine);
  }
  addTargetPoint(e) {
    e.position &&
      this._targetPositions.push({
        name: "point" + this._targetPositions.length,
        ...e,
      });
  }
  removeTargetPoint(e) {
    "string" == typeof e
      ? (this._targetPositions = this._targetPositions.filters(
          (t) => t.name !== e
        ))
      : this._targetPositions.splice(e, 1),
      this.build();
  }
  removeAllTargetPoint() {
    (this._targetPositions = []), this.build();
  }
  buildGeoJSON(e) {
    let t = { type: "FeatureCollection", features: [] };
    if (e)
      for (let i = 0; i < e.length; i++) {
        const n = {
          type: "Feature",
          properties: {},
          geometry: { coordinates: e[i], type: "LineString" },
        };
        t.features.push(n);
      }
    return t;
  }
  convertToScreenCoord(e) {
    const t = new Vector4(...e, 1);
    let i = this._tempModelViewMatrix.copy(
        this._engine.rendering.renderState.viewMatrixWorldInverse
      ),
      n = this._engine.camera.projectionMatrix;
    return t.applyMatrix4(i).applyMatrix4(n), t.divideScalar(t.w), t;
  }
  build() {
    this._visibleLine && this._engine.remove(this._visibleLine),
      this._invisibleLine && this._engine.remove(this._invisibleLine);
    const e = [],
      t = [],
      i = new Vector3(...this.viewPosition);
    for (let r = 0; r < this._targetPositions.length; r++) {
      const n = this._targetPositions[r].position,
        s = new Vector3();
      s.set(n[0], n[1], n[2]).sub(i).normalize(),
        (this._raycaster = new $l()),
        this._raycaster.set(i, s);
      const a = this._raycaster.intersectObjects(this._engine.scene.children),
        o = a.length;
      if (o > 0) {
        let i = 0;
        for (; i < o; ) {
          const s = a[i];
          if ((i++, s.distance < this._distanceBias)) continue;
          const r = new Vector3(...this.viewPosition).distanceTo(
            new Vector3(...n)
          );
          if (s.distance > r) e.push([this.viewPosition, n]);
          else {
            const i = [s.point.x, s.point.y, s.point.z];
            this._occlusionPoints.push(i),
              e.push([this.viewPosition, i]),
              t.push([i, n]);
          }
          break;
        }
      } else e.push([this.viewPosition, n]);
    }
    const n = this.buildGeoJSON(e),
      s = this.buildGeoJSON(t);
    this._visibleDataSource.setData(n),
      this._invisibleDataSource.setData(s),
      (this._visibleLine = this._engine.add(
        new eL({ color: this._visibleColor, keepSize: !0 })
      )),
      (this._invisibleLine = this._engine.add(
        new eL({ color: this._invisibleColor, keepSize: !0 })
      )),
      (this._visibleLine.dataSource = this._visibleDataSource),
      (this._invisibleLine.dataSource = this._invisibleDataSource);
  }
  get viewPosition() {
    return this._viewPoistion;
  }
  set viewPosition(e) {
    e && (this._viewPoistion = e);
  }
  get visibleColor() {
    return this._visibleColor;
  }
  set visibleColor(e) {
    this._visibleColor = e;
  }
  get invisibleColor() {
    return this._invisibleColor;
  }
  set invisibleColor(e) {
    this._invisibleColor = e;
  }
};
exports.SimplePoint = SimplePoint;
exports.SkyLine = class extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_color", "red"),
      publicField(this, "_width", 10),
      publicField(this, "_enabled", !1),
      publicField(this, "_skylinePass"),
      publicField(this, "getSelectedObjects", () => {
        const e = this._engine.rendering.objectsScene.children.filter(
          (e) => !(e instanceof Wm)
        );
        this._skylinePass.selectedObjects = e;
      });
  }
  afterAddToEngine(e) {
    this._engine = e;
    const t = (this._skylinePass = new XL(
      new Vector2(
        window.innerWidth * window.devicePixelRatio,
        window.innerHeight * window.devicePixelRatio
      ),
      e.scene,
      e.camera
    ));
    (t.edgeGlow = 0),
      (t.edgeThickness = 0.5),
      (t.pulsePeriod = 0),
      (this.color = this._color),
      (this.width = this._width),
      (t.overlayMaterial.blending = 5),
      this._engine.rendering.postprocessings.add(this._skylinePass);
  }
  beforeRemoveFromEngine(e) {
    e.rendering.removePrepareRenderListener(this.getSelectedObjects),
      e.rendering.postprocessing.removePass(this._skylinePass);
  }
  get width() {
    return this._width;
  }
  set width(e) {
    (this._width = e), (this._skylinePass.edgeStrength = e);
  }
  get color() {
    return this._color;
  }
  set color(e) {
    (this._color = e),
      this._skylinePass.visibleEdgeColor.set(e),
      this._skylinePass.hiddenEdgeColor.set(e);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled !== e &&
      ((this._enabled = e),
      e
        ? (this._engine.rendering.useMrt ||
            console.warn("please set useMrt to true"),
          this._engine.rendering.addPrepareRenderListener(
            this.getSelectedObjects
          ),
          this._engine.rendering.addPrepareRenderListener(() => {
            this._skylinePass.material &&
              (this._skylinePass.material.uniforms.visibleEdgeColor.value.set(
                "#ff0000"
              ),
              this._skylinePass.material.uniforms.hiddenEdgeColor.value.set(
                "#ff0000"
              ));
          }))
        : (this._engine.rendering.removePrepareRenderListener(
            this.getSelectedObjects
          ),
          (this._skylinePass.selectedObjects = [])),
      this._engine.requestRender());
  }
};
exports.SlopeAnalysis = class extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_coverageArea", []),
      publicField(this, "_slopeMap"),
      publicField(this, "_maxSlope", 90),
      publicField(this, "_minSlope", 0),
      publicField(this, "_enabled", !1),
      publicField(this, "_terrain"),
      publicField(this, "_coverageClippingPlanes"),
      publicField(this, "_defaultColorStop", {
        0.5: "rgb(85,182,43",
        2: "rgb(135,211,43",
        5: "rgb(204,244,44",
        15: "rgb(245,233,44",
        35: "rgb(255,138,43",
        55: "rgb(255,84,43",
        90: "rgb(255,32,43",
      }),
      publicField(this, "bindTerrain", (e) => {
        this._terrain = e;
      }),
      publicField(this, "_update", () => {
        const e = this._terrain._tileGroup.children;
        for (let t = 0; t < e.length; t++) {
          const i = e[t].material;
          this._updateUniforms(i),
            i &&
              !i._hasAddSlopeShader &&
              ((i._hasAddSlopeShader = !0), this._updateShader(i));
        }
      }),
      publicField(this, "_updateShader", (e) => {
        let t, i;
        (e.onBeforeCompile = (e) => {
          (t = e.vertexShader),
            (i = e.fragmentShader),
            (e.vertexShader = e.vertexShader.replace(
              "#include <clipping_planes_pars_vertex>",
              "\n                #include <clipping_planes_pars_vertex>\n\n                varying vec3 vNor;\n                varying vec3 vUp;\n            "
            )),
            (e.vertexShader = e.vertexShader.replace(
              "#include <begin_vertex>",
              "\n                #include <begin_vertex>\n\n                vNor = normalMatrix * normal;\n                vUp = normalMatrix * vec3(0.0, 0.0, 1.0);\n            "
            )),
            (e.fragmentShader = e.fragmentShader.replace(
              "varying vec3 vViewPosition;",
              "\n                varying vec3 vViewPosition;\n                uniform sampler2D u_slopeMap;\n                uniform sampler2D u_slopePlanes;\n                uniform sampler2D u_slopeLengthTexture;\n                uniform mat4 u_slopePlanesMatrix;\n                uniform int u_slopePlanesWidth;\n                uniform int u_slopePlanesHeight;\n                uniform int u_slopeArrayLength;\n                uniform int u_slopeMaxLength;\n                uniform float u_minSlope;\n                uniform float u_maxSlope;\n                uniform bool u_slopeEnabled;\n                varying vec3 vNor;\n                varying vec3 vUp;\n                \n            "
            )),
            (e.fragmentShader = e.fragmentShader.replace(
              "void main() {",
              "\n\n                    bool isInPolygon(vec4 fragmentCoord, sampler2D clippingPlanes, mat4 clippingPlanesMatrix, \n                    sampler2D multiClippingPlanesLength) {\n                        vec4 position = windowToEyeCoordinate(fragmentCoord);\n                        vec3 clipNormal = vec3(0.0);\n                        vec3 clipPosition = vec3(0.0);\n                        float clipAmount = 0.0;\n                        bool isIn = false;\n                        float pixelSize = getPixelSize(position);\n                        int count = 0;\n                        for (int i = 0; i < u_slopeArrayLength; i++) {\n                            bool planeClipped = true;\n                            float collectionClipAmount = 0.0;\n                            int collectionLength = int(texture2D(multiClippingPlanesLength,\n                                vec2((float(i) + 0.5) / float(u_slopeArrayLength), 0.5)).w);\n                            for (int j = 0; j < u_slopeMaxLength; j++) {\n                                collectionLength--;\n                                vec4 clippingPlane = getClippingPlane(clippingPlanes, count,\n                                     clippingPlanesMatrix, u_slopePlanesWidth, u_slopePlanesWidth);\n                                clipNormal = clippingPlane.xyz;\n                                clipPosition = -clippingPlane.w * clipNormal;\n                                    float amount = dot(clipNormal, (position.xyz - clipPosition)) / pixelSize;\n                                \n                                collectionClipAmount = max(amount, collectionClipAmount);\n                                planeClipped = planeClipped && (amount <= 0.0);\n                                count++;\n                                if (collectionLength == 0) {\n                                    break;\n                                }\n                            }\n                            \n                            if (planeClipped) {\n                                isIn = true;\n                            }\n                        }\n                    return isIn;\n                }\n\n                void main() {\n            "
            )),
            (e.fragmentShader = e.fragmentShader.replace(
              "#include <opaque_fragment>",
              "\n                #include <opaque_fragment>\n    \n                if (u_slopeEnabled) {\n                    bool isIn = isInPolygon(gl_FragCoord, u_slopePlanes, \n                        u_slopePlanesMatrix,u_slopeLengthTexture);\n                    if (isIn) {\n                        float dirAlpha = dot(normalize(vNor),vUp);\n                        float coverageAlpha = clamp(0.0, 1.0, dirAlpha);\n                        float angle = acos(coverageAlpha);\n\n                        if (angle >= u_minSlope && angle <= u_maxSlope){\n                            float colorUV = angle / PI * 4.0;\n                            vec4 slopeColor = texture2D(u_slopeMap, vec2(colorUV));\n                            gl_FragColor = slopeColor;\n                        }\n                    }\n                }\n            "
            ));
        }),
          (e.onAfterCompile = (e) => {
            (e.vertexShader = t), (e.fragmentShader = i);
          }),
          (e.needsUpdate = !0);
      }),
      publicField(this, "_updateUniforms", (e) => {
        const t = e.uniforms;
        if (!t || !this._coverageClippingPlanes) return;
        const { width: i, height: n } = this._engine.rendering.canvas,
          s = this._engine.camera.projectionMatrixInverse;
        e.uniforms.u_resolution.value.set(i, n),
          e.uniforms.inverseProjection.value.copy(s);
        const {
          texture: r,
          lengthTexture: a,
          clippingPlanesMatrix: o,
          length: l,
          maxCollectionLength: h,
        } = this._coverageClippingPlanes;
        (t.u_slopeMap = { value: this._slopeMap }),
          (t.u_slopePlanes = { value: r }),
          (t.u_slopeLengthTexture = { value: a }),
          (t.u_slopePlanesMatrix = { value: o }),
          (t.u_slopeEnabled = { value: this.enabled });
        const { width: c, height: u } = r.image;
        (t.u_slopePlanesWidth = { value: c }),
          (t.u_slopePlanesHeight = { value: u }),
          (t.u_slopeArrayLength = { value: l }),
          (t.u_slopeMaxLength = { value: h }),
          (t.u_minSlope = { value: this.minSlope }),
          (t.u_maxSlope = { value: this.maxSlope });
      }),
      publicField(this, "isClockWise", (e) => {
        let t = e.length,
          i = 0;
        for (let n = t - 1, s = 0; s < t; n = s++)
          i += e[n][0] * e[s][1] - e[s][0] * e[n][1];
        return i < 0;
      });
  }
  afterAddToEngine(e) {
    (this._engine = e),
      (this.minSlope = this._minSlope),
      (this.maxSlope = this._maxSlope);
  }
  setColorStop(e) {
    const t = document.createElement("canvas");
    (t.width = 100), (t.height = 1);
    const i = t.getContext("2d"),
      n = i.createLinearGradient(0, 0, 100, 0);
    for (let s in e) e.hasOwnProperty(s) && n.addColorStop(s / 90, e[s]);
    (i.fillStyle = n),
      i.fillRect(0, 0, 100, 1),
      (this._slopeMap = new CanvasTexture(t));
  }
  build() {
    (this._terrain && this._terrain instanceof Object3D) ||
      console.warn("The terrain is invalid"),
      this.enabled &&
        (this._slopeMap || this.setColorStop(this._defaultColorStop),
        this._engine.rendering.addBeforeRenderListener(this._update));
  }
  isConcavePoly(e) {
    let t, i;
    for (let n = 1, s = e.length; n < s - 1; n++) {
      const s = new Vector2().fromArray(e[n - 1]),
        r = new Vector2().fromArray(e[n]),
        a = new Vector2().fromArray(e[n + 1]),
        o = new Vector2().subVectors(r, s),
        l = new Vector2().subVectors(a, r);
      if (((i = o.cross(l) >= 0 ? 1 : -1), void 0 !== t && t !== i)) return !0;
      t = i;
    }
    return !1;
  }
  close() {
    (this.enabled = !1),
      this._slopeMap && this._slopeMap.dispose(),
      setTimeout(() => {
        this._engine.rendering.removeBeforeRenderListener(this._update);
      }, 60);
  }
  get enabled() {
    return this._enabled;
  }
  set enabled(e) {
    this._enabled !== e && (this._enabled = e);
  }
  get minSlope() {
    return this._minSlope;
  }
  set minSlope(e) {
    e < 0 && (e = 0), (this._minSlope = (e / 180) * Math.PI);
  }
  get maxSlope() {
    return this._maxSlope;
  }
  set maxSlope(e) {
    e > 90 && (e = 90), (this._maxSlope = (e / 180) * Math.PI);
  }
  get coverageArea() {
    return this._coverageArea;
  }
  set coverageArea(e) {
    if (!(e && e.length > 2)) return;
    let t;
    t = this.isClockWise(e) ? [...e].reverse() : e;
    if (0 === t.length) return;
    const i = new WL(this._engine, { owner: !0 });
    if (this.isConcavePoly(t)) {
      const e = vD.exports.flatten([t]),
        n = e,
        s = vD.exports(e.vertices, e.holes, e.dimensions),
        r = n.vertices,
        a = s;
      for (let t = 0; t < s.length; ) {
        const e = a.slice(t, t + 3).map((e) => r.slice(3 * e, 3 * (e + 1))),
          n = ClippingPlaneCollection.fromPoints(this._engine, e, {});
        i.add(n), (t += 3);
      }
    } else {
      const e = ClippingPlaneCollection.fromPoints(this._engine, t, {});
      i.add(e);
    }
    i.update(), (this._coverageClippingPlanes = i), (this._coverageArea = t);
  }
};
exports.Spark = class extends XP {
  constructor(e) {
    super(e),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "color"),
      publicField(this, "vertexColors"),
      publicField(this, "height"),
      publicField(this, "vertexHeights"),
      publicField(this, "speed"),
      publicField(this, "tailLength"),
      publicField(this, "idle"),
      publicField(this, "emissive"),
      (this.parameters = e),
      this.defineMaterialProxyProperties([
        "color",
        "height",
        "tailLength",
        "speed",
        "idle",
        "emissive",
        "vertexColors",
        "vertexHeights",
      ]);
  }
  getDefaultParams() {
    return { height: 100 };
  }
  initObject() {
    (this.geometry = new YP(this.parameters)),
      (this.material = new ZP(this.parameters)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms);
  }
  setData() {
    const e = this.dataSource.data,
      t = [],
      i = [],
      n = [],
      s = [],
      r = [];
    for (let a = 0; a < e.position.length; a++) {
      let o = e.position[a];
      if (
        (t.push(o[0], o[1], o[2]),
        this.parameters.vertexHeights && e.height
          ? (t.push(o[0], o[1], o[2] + e.height[a]),
            n.push(e.height[a], e.height[a]),
            s.push(0, e.height[a]))
          : (t.push(o[0], o[1], o[2] + this.parameters.height),
            s.push(0, this.parameters.height)),
        this.parameters.vertexColors && e.color)
      ) {
        let t = colorToVec4(e.color[a]);
        i.push(...t.toArray(), ...t.toArray());
      }
      r.push(2 * a, 2 * a + 1);
    }
    this.geometry.setData({
      aPositions: t,
      aColors: i,
      aHeights: n,
      aLengths: s,
      indices: r,
    }),
      this.geometry.computeBoundingSphere(),
      this.makeGeometryOffsetPosition(this.geometry, t),
      (this.needsUpdate = !1);
  }
};
exports.SpecialPoint = class extends InstancedMesh {
  constructor(e) {
    super(e),
      publicField(this, "geometry"),
      publicField(this, "material"),
      publicField(this, "color"),
      publicField(this, "opacity"),
      publicField(this, "size"),
      publicField(this, "height"),
      (this.parameters = e),
      this.defineMaterialProxyProperties([
        "color",
        "size",
        "height",
        "opacity",
      ]);
  }
  initObject() {
    (this.geometry = new wR()),
      (this.material = new LR(this.parameters)),
      this.material.setCommonUniforms(this.engine.rendering.uniforms),
      (this.needsUpdate = !0);
  }
};
exports.SplineAreaEditor = class extends Object3D {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_fillBuffer", {
        position: [[[]]],
        index: [],
        payload: [],
      }),
      publicField(this, "_strokeBuffer", {
        position: [[]],
        index: [],
        payload: [],
      }),
      publicField(this, "_engine"),
      publicField(this, "_splineEditor"),
      publicField(this, "_options"),
      publicField(this, "_stroke"),
      publicField(this, "_strokeDataSource"),
      publicField(this, "_fill"),
      publicField(this, "_fillDataSource"),
      publicField(this, "_handleSplineChange", (e) => {
        let t = e.value;
        this.clearBuffers(),
          this._drawSplineArea(t),
          this.dispatchEvent({
            type: "change",
            value: { polygon: this.positions, spline: t },
          });
      }),
      publicField(this, "_drawSplineArea", (e) => {
        let t = this._parseSplineToArea(e);
        for (let i = 0; i < t.length; i++) {
          const e = t[i];
          this._strokeBuffer.position[0].push(e),
            this._strokeBuffer.index.push(i),
            this._fillBuffer.position[0][0].push(e),
            this._fillBuffer.index.push(i);
        }
        this._strokeDataSource.setData(this._strokeBuffer),
          this._fillDataSource.setData(this._fillBuffer),
          this._engine.requestRender();
      }),
      (this._engine = e),
      (this._splineEditor = e.add(new OL(e, t))),
      t.fillColor || (t.fillColor = "rgba(40, 70, 150)"),
      t.strokeColor || (t.strokeColor = "rgb(255, 255, 255)"),
      (this._options = t);
  }
  afterAddToEngine() {
    this.initObjects();
  }
  initStroke() {
    let e = (this._strokeDataSource = new mA()),
      t = (this._stroke = this._engine.add(
        new eL({
          lineWidth: 3,
          color: this._options.strokeColor,
          keepSize: !0,
          lineJoin: "round",
        })
      ));
    return (t.dataSource = e), t;
  }
  initFill() {
    let e = (this._fillDataSource = new mA()),
      t = (this._fill = this._engine.add(
        new KD({ color: this._options.fillColor, opacity: 0.2 })
      ));
    return (t.dataSource = e), t;
  }
  initObjects() {
    this.initFill(), this.initStroke();
  }
  _parseSplineToArea(e) {
    let t = [],
      i = new Vector2(0, 0);
    for (let n = 0; n < e.length; n++) {
      const s = e[n];
      let r = new Vector2(1, 0);
      (r = r.rotateAround(i, s.angle)), r.normalize();
      let a = [
        s.position[0] + r.x * s.scale,
        s.position[1] + r.y * s.scale,
        s.position[2],
      ];
      t.push(a);
    }
    for (let n = e.length - 1; n >= 0; n--) {
      const s = e[n];
      let r = new Vector2(1, 0);
      (r = r.rotateAround(i, s.angle)), r.normalize();
      let a = [
        s.position[0] - r.x * s.scale,
        s.position[1] - r.y * s.scale,
        s.position[2],
      ];
      t.push(a);
    }
    return t.push(t[0]), t;
  }
  clearBuffers() {
    (this._strokeBuffer = { position: [[]], index: [], payload: [] }),
      (this._fillBuffer = { position: [[[]]], index: [], payload: [] });
  }
  clearObjects() {
    this._strokeDataSource.setData(),
      this._fillDataSource.setData(),
      this._engine.requestRender();
  }
  dispose() {
    (this.enabled = !1),
      this._engine.remove(this._stroke),
      this._engine.remove(this._fill);
  }
  get spline() {
    return this._splineEditor;
  }
  set positions(e) {
    this._splineEditor.data = e;
  }
  get positions() {
    return this._fillBuffer.position[0][0];
  }
  get enabled() {
    return this._splineEditor.enabled;
  }
  set enabled(e) {
    e !== this._enabled &&
      ((this._splineEditor.enabled = e),
      this._splineEditor.clearAll(),
      e
        ? (this.clearBuffers(),
          this._splineEditor.addEventListener(
            "change",
            this._handleSplineChange
          ))
        : (this._splineEditor.removeEventListener(
            "change",
            this._handleSplineChange
          ),
          this.clearObjects()));
  }
};
exports.SplineEditor = OL;
exports.StaticSky = class extends Hb {
  constructor() {
    super(),
      publicField(this, "isStaticSky", !0),
      publicField(this, "_phase", "default"),
      publicField(this, "_lastPhase", null),
      publicField(this, "_lastWeather", null),
      publicField(this, "_nightStartTime", 64800),
      publicField(this, "_nightEndTime", 21600),
      publicField(this, "_afternoonTime", 55800),
      publicField(this, "_duskTime", 61200),
      publicField(this, "_engine", null),
      publicField(this, "_PMREMGenerator", null),
      (this.time = 43200);
  }
  afterAddToEngine(e) {
    super.afterAddToEngine(e),
      (this._engine = e),
      (this._PMREMGenerator = new ds(e.renderer)),
      this.loadSkyTexture();
  }
  onTimeChanged(e) {
    e >= this._nightStartTime || e <= this._nightEndTime
      ? (this._phase = "night")
      : e >= this._duskTime
      ? (this._phase = "dusk")
      : e >= this._afternoonTime
      ? (this._phase = "afternoon")
      : (this._phase = "default"),
      this.loadSkyTexture();
  }
  onWeatherChanged(e) {
    (this._weather = e), this.loadSkyTexture();
  }
  loadSkyTexture() {
    if (
      !this._engine ||
      (this._phase === this._lastPhase && this.weather === this._lastWeather)
    )
      return;
    let e = Gm(
      Qm(),
      "assets/textures/sky",
      this.weather,
      this._phase,
      "/" + this._phase + ".jpg"
    );
    (this.textureURL = e),
      (this._lastPhase = this._phase),
      (this._lastWeather = this._weather);
  }
};
exports.TerrainClipPlan = qL;
exports.TextMesh = EA;
exports.TrafficLight3DTilesElement = class extends IT {
  constructor(e) {
    super(e),
      publicField(this, "subscribedDataTypeIds", [110, 111, 112, 113]),
      publicField(this, "_tickInterval", 1e3),
      publicField(this, "_typeConfigMap", {
        110: { slots: [0, 0, 0], stateType: 1 },
        111: { slots: [1, 1, 1] },
        112: { slots: [4, 5] },
        113: { slots: [-1] },
        xxx: { slots: [0, 0, 0, -1] },
        xxx1: { slots: [0, 0, -1], stateType: 2 },
      }),
      publicField(this, "_scaleSize", 0.1),
      publicField(this, "_stateMap", new Map()),
      publicField(this, "_timeTableMap", new Map()),
      publicField(this, "_refreshObjectViewState", (e, t) => {
        if (this._timeTableMap.has(e)) t.timeTable = this._timeTableMap.get(e);
        else if (((t.timeTable = null), this._stateMap.has(e))) {
          const i = this._stateMap.get(e);
          (t.lightState = i.state),
            (t.number = i.number),
            (t.stateStartTime = i.startAt);
        } else t.lightState = null;
        t.updateState(Date.now() / 1e3);
      }),
      (kT = new BT());
  }
  createMeshFromGeometry(e, t) {
    const i = new BT(e);
    (i.lightStatus = -1), (i.dataType = t.dataType);
    const n = this._typeConfigMap[t.dataType];
    return (i.slots = n.slots), (i.stateType = n.stateType), i;
  }
  tickObject(e, t) {
    e.updateState(t);
  }
  onEntityShow(e, t) {
    this._refreshObjectViewState(e, t);
  }
  setLightState(e, t, i = 0) {
    if (
      (null != t
        ? this._stateMap.set(e, {
            state: t,
            number: i,
            startAt: Date.now() / 1e3,
          })
        : this._stateMap.delete(e),
      this._visibleIdMap.has(e))
    ) {
      const t = this._visibleIdMap.get(e);
      this._refreshObjectViewState(e, t), this.engine.requestRender();
    }
  }
  setTimeTable(e, t) {
    if (
      (t ? this._timeTableMap.set(e, t) : this._timeTableMap.delete(e),
      this._visibleIdMap.has(e))
    ) {
      const t = this._visibleIdMap.get(e);
      this._refreshObjectViewState(e, t), this.engine.requestRender();
    }
  }
  getTimeTable(e) {
    return this._timeTableMap.get(e);
  }
  getLightState(e) {
    return this._stateMap.get(e);
  }
  getRealtimeState(e) {
    let t = this._visibleIdMap.get(e);
    if (t) {
      const i = this._timeTableMap.get(e);
      if (i) (t = kT), (t.timeTable = i);
      else {
        const i = this.getLightState(e);
        i &&
          ((t = kT),
          (t.lightState = i.state),
          (t.number = i.number),
          (t.stateStartTime = i.startAt));
      }
    }
    return t
      ? (t.updateStatus(Date.now()),
        { lightState: t.lightState, number: t.number })
      : null;
  }
};
exports.TransformControl = Cb;
exports.Twin = aR;
exports.UltraDynamicSky = sE;
exports.VerticalGradientSky = class extends rE {
  createMaterial() {
    return new oE();
  }
  get gradients() {
    return this._material.gradients;
  }
  set gradients(e) {
    this._material.gradients = e;
  }
};

exports.ViewShedAnalysis = class extends Object3D {
  constructor() {
    super(...arguments),
      publicField(this, "_distance"),
      publicField(this, "_isAutoDistance", !0),
      publicField(this, "_viewPosition"),
      publicField(this, "_targetPosition"),
      publicField(this, "_visibleColor", 65280),
      publicField(this, "_invisibleColor", 16711680),
      publicField(this, "_camera"),
      publicField(this, "_fov", 45),
      publicField(this, "_updateUniforms", () => {
        this.createDepth();
        const e = this._viewshedPass.material.uniforms;
        (e.tDepth.value =
          this._engine.rendering.main.sceneRendering.depthTexture),
          (e.shadowMap.value = this._depthTarget.texture),
          (e.cameraNear.value = this._engine.camera.near),
          (e.cameraFar.value = this._engine.camera.far),
          e.mvt_projectionInverseMatrix.value.copy(
            this._engine.camera.projectionMatrixInverse
          ),
          e.mvt_viewInverseMatrix.value.copy(this._engine.camera.matrixWorld),
          (e.lightCameraNear.value = this._camera.near),
          (e.lightCameraFar.value = this._camera.far),
          e.lightPosition.value.copy(this._camera.position),
          e.lightViewMatrix.value.copy(this._camera.matrixWorldInverse),
          e.lightProjectionMatrix.value.copy(this._camera.projectionMatrix);
        const { width: t, height: i } = this._depthTarget.texture.source.data,
          n = new Vector2(
            (1 / t) * window.devicePixelRatio,
            (1 / i) * window.devicePixelRatio
          );
        e.texelStepSize.value.copy(n),
          e.visibleColor.value.copy(this._visibleColor),
          e.invisibleColor.value.copy(this._invisibleColor);
      });
  }
  afterAddToEngine(e) {
    (this._engine = e),
      (this._camera = new Dn()),
      (this.visibleColor = this._visibleColor),
      (this.invisibleColor = this._invisibleColor);
    const t = (this._depthTarget = new ut(
      window.innerWidth * window.devicePixelRatio * 3,
      window.innerHeight * window.devicePixelRatio * 3
    ));
    (t.texture.format = Q),
      (t.texture.generateMipmaps = !1),
      (t.depthBuffer = !0),
      (t.depthTexture = new xa()),
      (t.depthTexture.format = H),
      (t.depthTexture.type = G);
  }
  createDepth(e = this._camera) {
    let t = new ShaderMaterial({
      vertexShader:
        "\n            precision highp float;\n            uniform float cameraNear;\n            uniform float cameraFar;\n            varying float depth;\n            varying vec4 vPosition;\n            varying float dis;\n            uniform vec3 uLightPosition;\n\n            void main() {\n                gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                depth = gl_Position.z / cameraFar;\n                vPosition = modelViewMatrix * vec4(position, 1.0);\n\n                vec3 dir = (modelMatrix * vec4(position, 1.0)).xyz - uLightPosition.xyz;\n                dis = length(dir.xyz) / cameraFar;\n            }\n        ",
      fragmentShader:
        "\n            precision highp float;\n            varying float depth;\n            varying vec4 vPosition;\n            varying float dis;\n            #include <packing>\n\n            void main() {\n                gl_FragColor = vec4(vec3(dis), 1.0);\n            }\n        ",
      uniforms: {
        cameraNear: { value: e.near },
        cameraFar: { value: e.far },
        uLightPosition: { value: new Vector3().copy(e.position) },
      },
    });
    const i = this._engine.scene.overrideMaterial;
    (this._engine.scene.overrideMaterial = t),
      this._engine.rendering.renderer.setRenderTarget(this._depthTarget),
      this._engine.rendering.renderer.clear(),
      this._engine.rendering.renderer.render(this._engine.scene, e),
      (this._engine.scene.overrideMaterial = i),
      this._engine.rendering.renderer.setRenderTarget(null),
      t.dispose();
  }
  createOutlineFrustum() {
    if (!this._camera) return void console.warn("没有可绑定的相机");
    return new ah(this._camera);
  }
  createShadowMapGLSL() {
    return {
      uniforms: {
        tDiffuse: { value: null },
        tDepth: { value: null },
        shadowMap: { value: null },
        cameraNear: { value: null },
        cameraFar: { value: null },
        mvt_projectionInverseMatrix: { value: new Matrix4() },
        mvt_viewInverseMatrix: { value: new Matrix4() },
        lightPosition: { value: new Vector3() },
        lightCameraNear: { value: null },
        lightCameraFar: { value: null },
        lightViewMatrix: { value: new Matrix4() },
        lightProjectionMatrix: { value: new Matrix4() },
        texelStepSize: { value: new Vector2() },
        visibleColor: { value: new Vector3() },
        invisibleColor: { value: new Vector3() },
      },
      vertexShader:
        "\n                varying vec2 vUV;\n                varying vec3 vPosition;\n                uniform mat4 cameraMatrix;\n\n                void main() {\n                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n                    vPosition = position;\n                    vUV = uv;\n                }\n            ",
      fragmentShader:
        "\n                uniform sampler2D tDiffuse;\n                uniform sampler2D tDepth;\n                uniform sampler2D shadowMap;\n                varying vec3 vPosition;\n                uniform float cameraFar;\n                uniform float cameraNear;\n                uniform mat4 mvt_projectionInverseMatrix;\n                uniform mat4 mvt_viewInverseMatrix;\n                uniform vec3 centerPosition;\n                uniform vec3 lightPosition;\n                uniform float lightCameraFar;\n                uniform float lightCameraNear;\n                uniform mat4 lightViewMatrix;\n                uniform mat4 lightProjectionMatrix;\n                uniform vec2 texelStepSize;\n                uniform vec3 visibleColor;\n                uniform vec3 invisibleColor;\n                varying vec2 vUV;\n\n                float linearize_depth(in float depth){\n                    float a = cameraFar / (cameraFar - cameraNear);\n                    float b = cameraFar * cameraNear / (cameraNear - cameraFar);\n                    return a + b / depth;\n                }\n        \n                float reconstruct_depth(const in vec2 uv){\n                    float depth = texture2D(tDepth, uv).x;\n                    return pow(2.0, depth * log2(cameraFar + 1.0)) - 1.0;\n                }\n        \n                float getDepth(vec2 uv) {\n                    #if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n                        return linearize_depth(reconstruct_depth(uv));\n                    #else\n                        return texture2D(tDepth, uv).x;\n                    #endif\n                }\n        \n                vec3 getWorldPositionFromDepth(float depth) {\n                    float z = depth * 2.0 - 1.0;\n                    vec4 clipSpacePosition = vec4(vUV * 2.0 - 1.0, z, 1.0);\n                \n                    vec4 viewSpacePosition = mvt_projectionInverseMatrix * clipSpacePosition;\n                    \n                    vec4 worldSpacePosition = mvt_viewInverseMatrix * viewSpacePosition;\n                \n                    return worldSpacePosition.xyz / worldSpacePosition.w;\n                }\n\n                float sampleDepthMap(sampler2D depthMap, vec2 uv) {\n                    vec4 shadowDepth = texture2D(depthMap, uv);\n    \n                    return shadowDepth.r;\n                }\n\n                float shadowDepthCompare(sampler2D depthMap, vec2 uv, float depth) {\n                    return step(depth, sampleDepthMap(depthMap, uv));\n                }\n\n                vec3 getNormalEC() {\n                    return vec3(1.0);\n                }\n\n\n                float private_shadowVisibility(\n                    float visibility, float nDotL, \n                    float normalShadingSmooth, \n                    float darkness) \n                {\n                    float strength = step(0.0, nDotL);\n\n                    visibility *= strength;\n\n                    visibility = max(visibility, darkness);\n                    return visibility;\n                }\n\n                float shadowVisibility (\n                    sampler2D shadowMap,\n                    vec2 uv, float depth,\n                    float nDotL,\n                    float normalShadingSmooth,\n                    float darkness) \n                {\n                    float radius = 1.0;\n                    float dx0 = -texelStepSize.x * radius;\n                    float dy0 = -texelStepSize.y * radius;\n                    float dx1 = texelStepSize.x * radius;\n                    float dy1 = texelStepSize.y * radius;\n\n                    depth = depth - 0.0003;\n\n                    float visibility = (\n                        shadowDepthCompare(shadowMap, uv, depth) +\n                        shadowDepthCompare(shadowMap, uv + vec2(dx0, dy0), depth) +\n                        shadowDepthCompare(shadowMap, uv + vec2(0.0, dy0), depth) +\n                        shadowDepthCompare(shadowMap, uv + vec2(dx1, dy0), depth) +\n                        shadowDepthCompare(shadowMap, uv + vec2(dx0, 0.0), depth) +\n                        shadowDepthCompare(shadowMap, uv + vec2(dx1, 0.0), depth) +\n                        shadowDepthCompare(shadowMap, uv + vec2(dx0, dy1), depth) +\n                        shadowDepthCompare(shadowMap, uv + vec2(0.0, dy1), depth) +\n                        shadowDepthCompare(shadowMap, uv + vec2(dx1, dy1), depth)\n                    ) * (1.0 / 9.0);\n\n                    return private_shadowVisibility(visibility, nDotL, normalShadingSmooth, darkness);\n                }\n\n                bool visible(vec4 result) {\n                    result.x/=result.w;\n                    result.y/=result.w;\n                    result.z/=result.w;\n                    return result.x>=-1.&&result.x<=1.\n                    &&result.y>=-1.&&result.y<=1.\n                    &&result.z>=-1.&&result.z<=1.;\n                }\n\n                void main() {\n                    vec4 color = texture2D(tDiffuse, vUV);\n                    gl_FragColor = color;\n\n                    // vec3 visibleColor = vec3(0.0, 1.0, 0.0);\n                    // vec3 invisibleColor = vec3(1.0, 0.0, 0.0);\n\n                    // 计算当前片元的世界坐标\n                    float depth = getDepth(vUV);\n                    vec3 worldSpacePosition = getWorldPositionFromDepth(depth);\n\n                    // 当前片元到光源相机的方向和距离\n                    vec4 vcPos= lightViewMatrix * vec4(worldSpacePosition, 1.0);\n                    vec3 directionEC = worldSpacePosition - lightPosition.xyz;\n                    float dis = length(directionEC);\n\n                    if (dis > lightCameraNear && dis < lightCameraFar) {\n                        vec4 posInEye = lightProjectionMatrix * vcPos;\n\n                        directionEC = normalize(directionEC);\n\n                        vec3 normalEC = getNormalEC();\n                        float nDotL = clamp(dot(normalEC, -directionEC), 0.0, 1.0);\n                        float normalShadingSmooth = 0.1;\n                        float darkness = 0.3;\n                        float depthBias = 0.005;\n\n                        if (visible(posInEye)) {\n                            // 获取shadow map对应的uv\n                            vec4 gytyPosition = lightProjectionMatrix \n                                * lightViewMatrix * vec4(worldSpacePosition.xyz, 1.0);\n                            gytyPosition= gytyPosition / gytyPosition.w; \n                            float s = (gytyPosition.s + 1.0) / 2.0;\n                            float t = (gytyPosition.t + 1.0) / 2.0;\n                            vec2 uv_depth = vec2(s, t);\n\n                            float depth = dis / lightCameraFar - depthBias;\n                            float visibility = \n                                shadowVisibility(shadowMap, uv_depth, depth, nDotL, normalShadingSmooth, darkness);\n                            if (visibility > 0.3) {\n                                gl_FragColor = vec4(visibleColor, 1.0);\n                            }\n                            else {\n                                gl_FragColor = vec4(invisibleColor, 1.0);\n                            }    \n                        }\n                    }\n                }\n            ",
    };
  }
  build() {
    const e = this._distance,
      t = 0.001 * this._distance;
    (this._camera.fov = this._fov),
      (this._camera.near = t),
      (this._camera.far = e),
      this._camera.position.copy(this._viewPosition),
      this._camera.lookAt(this._targetPosition),
      this._camera.updateProjectionMatrix();
    const i = (this._outlineFrustum = this.createOutlineFrustum());
    this._engine.add(i), this._engine.add(this._camera);
    const n = this.createShadowMapGLSL(),
      s = (this._viewshedPass = new vg(n));
    this._engine.rendering.postprocessings.add(s),
      this._engine.rendering.addPrepareRenderListener(this._updateUniforms);
  }
  close() {
    this._engine.rendering.removePrepareRenderListener(this._updateUniforms),
      this._engine.remove(this._camera),
      this._engine.remove(this._outlineFrustum);
  }
  get viewPosition() {
    return this._viewPosition;
  }
  set viewPosition(e) {
    this._viewPosition = e;
  }
  get targetPosition() {
    return this._targetPosition;
  }
  set targetPosition(e) {
    if (((this._targetPosition = e), this._isAutoDistance)) {
      const t = this._viewPosition.distanceTo(e);
      this.distance = t;
    }
    this._camera &&
      (this._camera.lookAt(this._targetPosition),
      (this._camera.rotation.z = 0));
  }
  get distance() {
    return this._distance;
  }
  set distance(e) {
    (this._distance = e),
      this._camera &&
        this._outlineFrustum &&
        ((this._camera.far = e),
        this._camera.updateProjectionMatrix(),
        this._outlineFrustum.update(),
        this._engine.requestRender());
  }
  get fov() {
    return this._fov;
  }
  set fov(e) {
    (this._fov = e),
      this._camera &&
        ((this._camera.fov = e),
        this._camera.updateProjectionMatrix(),
        this._outlineFrustum.update(),
        this._engine.requestRender());
  }
  get visibleColor() {
    return this._visibleColor;
  }
  set visibleColor(e) {
    const t = new Color(e);
    this._visibleColor = new Vector3(t.r, t.g, t.b);
  }
  get invisibleColor() {
    return this._invisibleColor;
  }
  set invisibleColor(e) {
    const t = new Color(e);
    this._invisibleColor = new Vector3(t.r, t.g, t.b);
  }
};

exports.VolumeLandAnalysis = class extends Object3D {
  constructor(e, t = {}) {
    super(),
      publicField(this, "_coveragePosition", []),
      publicField(this, "_surfaceHeight", 0),
      publicField(this, "_interpolateNum", 50),
      publicField(this, "_polygonPosition", []),
      publicField(this, "_cutArea", 0),
      publicField(this, "_cutVolume", 0),
      publicField(this, "_fillArea", 0),
      publicField(this, "_fillVolume", 0),
      publicField(this, "_terrain"),
      publicField(this, "_terrainClipPlan"),
      publicField(this, "_terrainClipPlanOpts"),
      (this._engine = e),
      (this._terrain = t.terrain),
      (this._terrainClipPlanOpts = t.terrainClipPlanOpts);
    (this._terrainClipPlan = new qL({
      terrain: this._terrain,
      bottomImg:
        t.bottomImg ||
        Hm("assets/textures/excavation/excavationregion_top.jpeg"),
      wallImg:
        t.wallImg ||
        Hm("assets/textures/excavation/excavationregion_side.jpeg"),
      ...this._terrainClipPlanOpts,
    })).isTerrainHeight = !0;
  }
  afterAddToEngine(e) {
    (this._engine = e), this._engine.add(this._terrainClipPlan);
  }
  build() {
    const e = tA([this._polygonPosition]),
      t = Wv(e),
      i = new Vector2(t[0], t[1]),
      n = new Vector2(t[0], t[3]),
      s = new Vector2(t[2], t[1]),
      r = new Vector2(t[2], t[3]),
      a = this._calcInterpolatePoints(i, n, s, r);
    this._sampleGridHeights(a);
    const o = this.getGridIndex(),
      l = this._filterGridList(a, o, e);
    this.calcVolumeLand(l),
      (this._terrainClipPlan.terrainHeight = this._surfaceHeight),
      (this._terrainClipPlan.coveragePosition = this.coveragePosition),
      this._terrainClipPlan.updateData();
  }
  _calcInterpolatePoints(e, t, i, n) {
    const s = this.interpolateNum,
      r = [];
    (r[0] = []), (r[s - 1] = []);
    for (let a = 0; a < s; a++) {
      const o = new YL(new Vector2().lerpVectors(t, n, a / (s - 1)));
      (o.row = 0), (o.col = a), r[0].push(o);
      const l = new YL(new Vector2().lerpVectors(e, i, a / (s - 1)));
      (l.row = s - 1), (l.col = a), r[s - 1].push(l);
    }
    for (let a = 0; a < r[0].length; a++) {
      const e = r[0][a].lnglat,
        t = r[s - 1][a].lnglat;
      for (let i = 1; i < s; i++) {
        void 0 === r[i] && (r[i] = []);
        let n = new YL(new Vector2().lerpVectors(e, t, i / s));
        (n.row = i), (n.col = a), (r[i][a] = n);
      }
    }
    return r;
  }
  _sampleGridHeights(e) {
    const t = e.flat();
    for (let i = 0; i < t.length; i++) {
      const e = t[i],
        n = e.lnglat,
        s = this._terrain.getHeight([n.x, n.y]);
      e.h = s;
    }
  }
  _filterGridList(e, t, i) {
    const n = [],
      s = e.flat();
    for (let r = 0; r < t.length; r += 3) {
      const e = s[t[r]],
        a = s[t[r + 1]],
        o = s[t[r + 2]],
        l = this.isInPolygon(e, i),
        h = this.isInPolygon(a, i),
        c = this.isInPolygon(o, i);
      let u = [];
      l && u.push(l),
        h && u.push(h),
        c && u.push(c),
        u.length > 1 && n.push([e, a, o]);
    }
    return n;
  }
  calcVolumeLand(e) {
    let t = 0,
      i = 0,
      n = 0,
      s = 0;
    e.forEach((e) => {
      const r = e.map((e) =>
          this._engine.map.unprojectPointArr(e.lnglat.toArray())
        ),
        a = e.reduce((e, t) => (t.h || 0) + e, 0) / 3;
      r.push(r[0]);
      const o = iA(tA([r]));
      a > this._surfaceHeight
        ? ((n += o), (s += (a - this.surfaceHeight) * o))
        : ((t += o), (i += (this.surfaceHeight - a) * o));
    }),
      (this._cutArea = n),
      (this._cutVolume = s),
      (this._fillArea = t),
      (this._fillVolume = i);
  }
  getGridIndex() {
    const e = this.interpolateNum,
      t = [];
    for (let i = 0; i < e - 1; i++)
      for (let n = 0; n < e - 1; n++) {
        let s = n + e * i,
          r = s + 1,
          a = s + e;
        t.push(s, r, a, r, a, ++a);
      }
    return t;
  }
  isInPolygon(e, t) {
    if (void 0 !== e.isIn) return e.isIn;
    const { x: i, y: n } = e.lnglat;
    return Zv(eA([i, n]), t) ? (e.isIn = !0) : (e.isIn = !1), e.isIn;
  }
  clear() {
    (this._cutArea = 0),
      (this._cutVolume = 0),
      (this._fillArea = 0),
      (this._fillVolume = 0),
      this._terrainClipPlan.dispose();
  }
  get surfaceHeight() {
    return this._surfaceHeight;
  }
  set surfaceHeight(e) {
    this._surfaceHeight = e;
  }
  get coveragePosition() {
    return this._coveragePosition;
  }
  set coveragePosition(e) {
    Array.isArray(e) && e.length > 2
      ? ((this._coveragePosition = e), (this._polygonPosition = [...e, e[0]]))
      : (console.warn("coveragePosition is invalid"),
        (this._coveragePosition = []),
        (this._polygonPosition = []));
  }
  get interpolateNum() {
    return this._interpolateNum;
  }
  set interpolateNum(e) {
    e > 0 && (this.interpolateNum = e);
  }
  get cutArea() {
    return this._cutArea;
  }
  get cutVolume() {
    return this._cutVolume;
  }
  get fillArea() {
    return this._fillArea;
  }
  get fillVolume() {
    return this._fillVolume;
  }
};

exports.Wall = rL;

exports.WaterMaterial = CT;

exports.Wireframe3DTilesMaterialManager = class extends yT {
  constructor() {
    super(), (this.material = new Oi({ color: 35020, wireframe: !0 }));
  }
  getMaterialByKey(e) {
    return this.material;
  }
  dispose() {
    this.material.dispose();
  }
};

exports.colorUtils = P_;
exports.geojsonUtils = aA;
exports.modelUtils = Ew;
exports.urlUtils = jm;

Object.defineProperties(exports, {
  __esModule: { value: !0 },
  [Symbol.toStringTag]: { value: "Module" },
});

window.mapvThree = exports;
